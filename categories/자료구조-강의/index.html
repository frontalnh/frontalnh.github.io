<!DOCTYPE html>
<html class="has-navbar-fixed-top">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Category: 자료구조 강의 - Jake.Lee&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="google-site-verification" content="PgpnJMuvO-IqYWyFljnyr-tusLhJUz1VRMmECenJyHE">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">






<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="/css/style.css">
<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>

</head>

<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">Categories</a>
            
            <a class="navbar-item " href="/tags">Tags</a>
            
            <a class="navbar-item " href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" href="https://github.com/frontalnh">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

        <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5><i class="far fa-folder"></i>자료구조 강의</h5>
        </div>
    </div>
</section>
<section class="section">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6354931397950820",
    enable_page_level_ads: true
  });
</script>

    <div class="container">
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/24/자료구조-해시/" itemprop="url">
                자료구조 | 해시
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-24T09:53:21.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                4 minutes read (About 593 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="해시란">해시란?</span></h1><p>해시란 탐색, 삽입, 삭제를 모두 O(1) 기대 시간에 수행할 수 있도록 해 주는 기법입니다.<br>해시는 해시 테이블을 통해 구현되며 해시 테이블은 <strong>b개의 버킷</strong> 과 버킷 내에 s개의 사전쌍들로 이루어 집니다.<br>여기서 해시함수 h는 키 값을 특정 홈 주소로 사상 시키는 함수로써 주로 <strong>제산 함수</strong> 등이 사용됩니다.</p>
<p><strong>h(k) = 0 ~ (b-1)</strong></p>
<p>위 식에서 h(k)를 <strong>해시</strong> 혹은 <strong>홈 주소</strong> 라고 부릅니다.</p>
<p>이상적인 조건 하에서 모든 사전쌍들이 모두 홈 버킷에 저장됩니다.</p>
<p>이런 해시 테이블에 있는 쌍의 수를 n 개라 하고, 가능한 전체 키의 총 개수를 T라 할때</p>
<p><strong>키 밀도 = n/T</strong></p>
<p>위 식이 성립합니다.</p>
<p>이러한 해시 함수는 여러 개의 키를 하나의 버킷에 사상시키게 되기 때문에<br>h(k1) = h(k2) 가 되는 k1과 k2가 존재하게 되고 이 경우 k1과 k2를 h에 대한 동거자라고 부릅니다.</p>
<p><strong>오버플로우</strong> 란 어떤 쌍을 삽입 시 홈 버킷이 넘치는 경우를 말합니다.</p>
<h1><span id="정적-해싱">정적 해싱</span></h1><p>오버플로우 처리방법에는 <strong>개방 주소법과 체인법</strong> 이 있으며, <strong>개방 주소법</strong> 에는 <strong>선형 조사법</strong>, 이차 조사법, 재해싱, 임의 조사법이 있습니다.</p>
<h2><span id="오버플로우-처리법">오버플로우 처리법</span></h2><h3><span id="개방-주소법">개방 주소법</span></h3><p><strong>선형 조사법</strong></p>
<p><img src="\images\선형조사법개념도.png" alt="선형 조사법 개념도"></p>
<h3><span id="체인법">체인법</span></h3><p>선형 조사법을 비롯한 개방 주소법에서는 키를 탐색 할 때 서로 다른 해시 값을 가진 키들과 일일히 비교를 수행하기 때문에 효율이 매우 떨어집니다.<br>이와 달리 <strong>체인법</strong> 에서는 ht[i] 가 버킷 i에 연결된 체인들 중 첫번째 블록을 가리키고 있기 때문에, 연결된 체인 내에서만 탐색을 수행하면 되어 속도가 빠릅니다.</p>
<p><img src="\images\체인법개념도.png" alt="체인법 개념도"></p>
<h1><span id="동적-해싱">동적 해싱</span></h1><p>재조정을 한 번 할 때마다 오직 하나의 버킷만 재조정함</p>
<h2><span id="디렉터리-사용-동적-해싱">디렉터리 사용 동적 해싱</span></h2><h2><span id="디렉터리-미사용-동적-해싱">디렉터리 미사용 동적 해싱</span></h2>
                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/24/자료구조-스택과-큐/" itemprop="url">
                자료구조 | 스택과 큐
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-24T09:25:01.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                2 minutes read (About 271 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="스택을-활용한-수식의-계산">스택을 활용한 수식의 계산</span></h1><p>모든 프로그래밍 언어는 연산 순위를 결정해야한다.<br>일반적으로 실생활 에서는 x+y 와 같이 연산자를 피연산자 사이에 작성하는 <strong>중위 표기법(infix notation)</strong> 을 사용하지만, 컴퓨터의 컴파일러는 <strong>후위 표기법(postfix notation)</strong> 으로 코드를 변환하기에 컴퓨터의 연산과정을 이해하기 위해서 <strong>후기 표현법</strong> 에 대해 익숙해질 필요가 있습니다.</p>
<p><strong>후위 표기식 연산법</strong></p>
<ol>
<li>연산자를 만날때까지 피연산자를 스택에 저장</li>
<li>연산자를 만나면 연산에 필요한 만큼만 스택에서 가져와 실행하여 연산결과를 다시 스택에 저장</li>
</ol>
<p><img src="/images/후위표기식연산.png" alt="후위 표기식 연산"></p>
<p><strong>중위 표기식을 후위 표기식으로 고치는 법</strong></p>
<ol>
<li>식을 모두 괄호식으로 고침</li>
<li>연산자를 모두 해당하는 오른 괄호랑 대체</li>
<li>모들 괄호를 삭제</li>
</ol>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/24/자료구조-그래프/" itemprop="url">
                자료구조 | 그래프
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-24T07:55:15.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                7 minutes read (About 1108 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#그래프-추상-데이타-타입">그래프 추상 데이타 타입</a></li>
<li><a href="#그래프-표현법">그래프 표현법</a></li>
<li><a href="#그래프의-기본-연산">그래프의 기본 연산</a><ul>
<li><a href="#깊이-우선-탐색dfs">깊이 우선 탐색(DFS)</a></li>
<li><a href="#너비-우선-탐색bfs">너비 우선 탐색(BFS)</a></li>
<li><a href="#신장-트리spanning-tree">신장 트리(spanning tree)</a></li>
</ul>
</li>
<li><a href="#최소-비용-신장-트리">최소 비용 신장 트리</a><ul>
<li><a href="#kruskal-알고리즘">Kruskal 알고리즘</a></li>
<li><a href="#prim-알고리즘">Prim 알고리즘</a></li>
</ul>
</li>
<li><a href="#최단-경로와-이행적-폐쇄">최단 경로와 이행적 폐쇄</a><ul>
<li><a href="#dijkstra-알고리즘-하나의-출발점에서-모든-목표점-음이-아닌-간선-비용의-경우">Dijkstra 알고리즘, 하나의 출발점에서 모든 목표점: 음이 아닌 간선 비용의 경우</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="그래프-추상-데이타-타입">그래프 추상 데이타 타입</span></h1><p>가령 여러 지점과 그 지점들을 잊는 길들 처럼 현실 세계의 많은 문제들은 <strong>그래프</strong> 라는 개념을 통해 해결될 수 있습니다.</p>
<p>그래프 G 는 2개의 집합 V와 E로 구성됩니다. V는 공집합이 아닌 <strong>정점(Vertice)</strong> 들의 유한 집합이며, G는 정점 쌍들의 집합으로 이러한 쌍을 <strong>간선</strong> 이라 합니다. V(G) 와 E(G)는 각 각 정점과 간선들의 집합을 의미합니다. 그래프는 정점에서 특정 정점으로 가는데에 방향의 개념이 존재하는 경우와 존재하지 않는 경우로 나눌 수 있으며, 이렇게 정점에서 정점으로 이동시 방향이 있는 경우를 <strong>방향 그래프(directed graph)</strong> 라고 하며, 방향이 없는 경우 <strong>무방향 그래프(undirected graph)</strong> 라고 합니다.</p>
<p>여기서 정점에 연결된 간선의 수를 <strong>차수</strong> 라고 하며, Euler는 각 정점의 차수가 <strong>짝수</strong> 인 경우에만 임의의 정점에서 출발하여 각 간선을 단 한 번씩만 거치고 출발한 정점으로 되돌아오는 길이 있음을 보였으며, 이를 <strong>오일러 행로(Eulerian Walk)</strong> 라 부릅니다.</p>
<h1><span id="그래프-표현법">그래프 표현법</span></h1><p>무방향 그래프의 간선 <strong>(u, v)</strong><br>방향 그래프의 간선 <strong>&lt;u, v&gt;</strong></p>
<p><img src="\images\그래프의표현.png" alt="그래프의 표현"></p>
<p><img src="\images\인접리스트표현개념도.png" alt="인접 리스트 표현 개념도"></p>
<h1><span id="그래프의-기본-연산">그래프의 기본 연산</span></h1><p><img src="../images/dFS,BFS를적용하기위한그래프.png" alt="DFS, BFS 를 적용하기 위한 그래프"></p>
<h2><span id="깊이-우선-탐색dfs">깊이 우선 탐색(DFS)</span></h2><p><img src="../images/dFS개념도.png" alt="DFS 개념도"></p>
<p>위처럼 인접 리스트 표현법의 경우 간선의 횟수 만큼만 탐색이 진행되므로, O(e) 의 복잡도를 가진다.<br>하지만 인접 매트릭스 표현으로 표현한 경우 각 정점마다 다른 정점들과 비교해야 하므로 O(n^2) 의 복잡도를 가진다.</p>
<h2><span id="너비-우선-탐색bfs">너비 우선 탐색(BFS)</span></h2><p><img src="../images/bFS개념도.png" alt="BFS 개념도"></p>
<p><strong>시간 복잡도: O(n^2)</strong></p>
<h2><span id="신장-트리spanning-tree">신장 트리(spanning tree)</span></h2><p>신장 트리란 G의 간선들로만 구성되고 G의 모든 정점을 포함하는 트리를 말합니다.<br>신장 트리를 만들기 위해서는 DFS 혹은 BFS를 모두 이용할 수 있으며, DFS를 이용하여 만들어진 신장트리를 <strong>깊이 우선 신장 트리(depth first spanning tree)</strong> 라 하고, BFS를 이용하여 만들어진 신장 트리를 <strong>너비 우선 신장 트리(breath first spanning tree)</strong> 라 부릅니다.</p>
<h1><span id="최소-비용-신장-트리">최소 비용 신장 트리</span></h1><p>가중치가 부여된 무방향 그래프의 신장 트리의 비용은 신장 트리를 구성하는 간선들의 비용의 합이 됩니다. 여기서 <strong>최소 비용 신장 트리</strong> 란 최저의 비용을 갖는 신장트리를 의미합니다.</p>
<p>이 경우 다음의 조건을 만족해야 합니다.</p>
<ol>
<li>그래프 내에 있는 간선만을 사용해야 한다.</li>
<li>정확히 n-1개의 간선만을 사용해야 한다.</li>
<li>사이클을 생성하는 간선은 사용하면 안된다.</li>
</ol>
<h2><span id="kruskal-알고리즘">Kruskal 알고리즘</span></h2><p><img src="\images\kruskal알고리즘개념도.png" alt="kruskal 알고리즘 개념도"></p>
<h2><span id="prim-알고리즘">Prim 알고리즘</span></h2><p><img src="\images\prim알고리즘개념도.png" alt="prim 알고리즘 개념도"></p>
<h1><span id="최단-경로와-이행적-폐쇄">최단 경로와 이행적 폐쇄</span></h1><p>현대의 많은 지도 시스템들은 임의의 두 특정 지점 사이의 경로를 탐색하는 많은 시스템 중의 일부입니다. 경로 탐색 시스템은 일반적으로 주나 전국의 도로 시스템을 표현하기 위하여 그래프를 이용합니다. 이러한 문제에서 도시 A에서 도시 B로 가려는 운전자는 다음과 같은 사항들이 궁금할 것입니다.</p>
<ol>
<li>A로 부터 B로 가는 길이 있는가?</li>
<li>A로부터 B로 가는 길이 2갱 이상이라면, 어느 길이 최단으로 가는 길인가?</li>
</ol>
<h2><span id="dijkstra-알고리즘-하나의-출발점에서-모든-목표점-음이-아닌-간선-비용의-경우">Dijkstra 알고리즘, 하나의 출발점에서 모든 목표점: 음이 아닌 간선 비용의 경우</span></h2><p><strong>다이크스트라 알고리즘</strong></p>
<p><img src="\images\dijkstra알고리즘개념도.png" alt="dijkstra 알고리즘 개념도"></p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/07/자료구조-b-트리/" itemprop="url">
                자료구조 | B-트리
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-07T04:48:01.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                6 minutes read (About 964 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="m-원-탐색트리란-무엇인가">m-원 탐색트리란 무엇인가?</span></h1><p>B-트리를 배우기 전에 그 근본 개념이 되는 m-원 탐색트리에 대해 알아봅시다.<br>기존의 이진 탐색트리 에서 균형 이진 탐색트리인 AVL 트리의 경우 n 개의 노드에 대해서 깊이가 최소 logn에 가깝기 때문에, 실제 시스템에서 AVL 구조로 저장된 데이터에 접근하기 위해서는 만약 모든 노드가 다른 메모리 안에 들어 있다면 최악의 경우 logn번 만큼 메모리 혹은 디스크에 접근을 해야 했습니다.</p>
<p>이렇게 수 차례에 걸쳐 메모리 혹은 디스크에 접근하는 것은 치명적인 탐색 시간 상승을 야기했고, 이에 <strong>탐색 트리의 높이를 줄여 탐색시간을 줄이기</strong> 위한 많은 노력들이 있었고, 이를 위해서는 필수적으로 <strong>트리의 차수가 증가</strong> 해야 했습니다. m-원 탐색트리는 m개의 차수를 가지는 노드들로 구성된 트리이며, 실제로는 트리 노드들이 하나의 캐시 블록이나 디스크 블록을 체울 수 있는 가장 큰 차수를 사용하고 있습니다.</p>
<p>m-원 탐색트리의 정의는 다음과 같습니다.</p>
<p><strong>m-원 탐색트리의 정의</strong></p>
<p><img src="..\images\m-원탐색트리의정의.png" alt="m-원 탐색트리의 정의"></p>
<p><strong>m-원 탐색트리의 예시</strong></p>
<p><img src="..\images\m-원탐색트리예시.png" alt="m-원 탐색트리 예시"></p>
<h1><span id="b-트리란">B-트리란?</span></h1><p>B-트리는 이러한 m-원 탐색트리의 일종이며 다음과 같이 정의됩니다.</p>
<p><strong>차수가 m인 B-트리의 정의</strong></p>
<p><img src="..\images\b-트리의정의.png" alt="B-트리의 정의"></p>
<p><strong>B-트리의 예시</strong></p>
<p><img src="..\images\b-트리의예시.png" alt="B-트리의 예시"></p>
<h2><span id="b-트리의-삽입">B-트리의 삽입</span></h2><p><img src="..\images\b-트리의삽입.png" alt="b-트리의 삽입"></p>
<h2><span id="b-트리의-삭제">B-트리의 삭제</span></h2><p>키가 x인 노드를 삭제하려고 할 때, x가 리프가 아닌 노드 z에서 발견될 경우, z에서 x가 차지하던 자리는 B-트리의 리프 노드로 부터 적당한 키로 채워진다. 가령 x가 그의 i번째 키라고 하면, E_i는 서브트리 A_i 내의 가장 작은 원소 혹은 서브트리 A_(i-1)의 가장 큰 원소로 채워질 수 있습니다. 여기서 삭제되는 리프노드 p에 대해 다음의 4가지 경우가 존재합니다.</p>
<h3><span id="case1">CASE1</span></h3><p>p 또한 루트노드인 경우<br>삭제 후 리프에 적어도 키가 하나 남아있다면 삭제 후 저장하고, 없다면 공백트리가 됩니다.</p>
<h3><span id="case2">CASE2</span></h3><p>삭제 후 p가 적어도 [m/2]-1 개의 원소를 가지고 있는 경우 즉, 최소 원소 개수가 만족되는 경우<br>그대로 삭제를 진행</p>
<h3><span id="case3-회전">CASE3 회전</span></h3><p>p가 [m/2]-2개의 원소를 가지며, 인접한 형제노드 q가 적어도 [m/2]개 원소를 가지는 경우. 즉, p가 삭제 후 최소 키보다 적은 키를 가지고 있고 형제 노드는 최소 키 이상의 키를 가지고 있는 경우<br>다음과 같이 <strong>회전</strong> 을 진행합니다.</p>
<p><img src="..\images\b-트리삭제시회전.png" alt="B-트리 삭제 시 회전"></p>
<h3><span id="case4-병합">CASE4 병합</span></h3><p>p가 [m/2]-2개의 원소를 가지고 있고, 가장 가까운 형제노드 q가 [m/2]-1개의 원소를 가지고 있는 경우. 즉, p가 삭제 후 최소 키보다 적은 키를 가지고 있고 형제 노드도 딱 최소 키만을 가지고 있는 경우<br>p,q와 p,q 중간 원소 E_i를 하나의 노드로 <strong>병합</strong> 합니다.</p>
<p><img src="..\images\b-트리삭제-병합.png" alt="B-트리 삭제(병합)"></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-정렬-sorting/" itemprop="url">
                자료구조 | 정렬(sorting)
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T11:38:10.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                6 minutes read (About 876 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="개요">개요</span></h1><p>컴퓨터 안에는 수십 수만가지의 데이터 들이 있으며, 이러한 수많은 데이터들을 잘 정리하고 보관하는 것은 빠른 데이터 찾기와 데이터 추가 및 삭제 등의 작업의 효율에 매우 큰 영향을 미친다. 때문에 컴퓨터의 많은 자료들을 효율적으로 분류하고 원하는 자료를 찾고 추가 하기 위해서는 ‘정렬’에 대해 알아야 할 필요가 있다.</p>
<p>본 강의에서 <strong>리스트</strong> 란 하나 이상의 필드로 된 레코드의 집합이라는 의미로 사용하며, 이때 코드를 서로 구별하기 위해 사용되는 필드를 <strong>키</strong> 라고 한다.</p>
<h1><span id="일반적인-자료의-탐색-방법">일반적인 자료의 탐색 방법</span></h1><p>흔히 리스트를 탐색하는 가장 직관적인 방법은 앞에서 부터 차례대로 비교하면서 자료를 분류하는 것이다.<br>프로그래밍에서 for 문을 사용하여 리스트의 제일 앞에서 부터 뒤까지 훑어 가면서 equal 문을 통해 데이터를 찾는 작업은 매우 흔한 프로그래밍의 구현이다.</p>
<p>이렇게 어떤 리스트의 왼편에서 오른편으로 차례대로 데이터를 찾는 것을 <strong>순차 탐색</strong> 이라고 한다.</p>
<p>다음 C 언어로 순차탐색 프로그램을 구현한 코드이다.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(Element elements[], <span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">sizeof</span>(*elements) / <span class="keyword">sizeof</span>(elements[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"address of the elements: "</span> &lt;&lt; elements &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"count is: "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elements[i].key == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Element element1 = &#123;<span class="string">"123"</span>&#125;;</span><br><span class="line">    Element element2 = &#123;<span class="string">"namhoon"</span>&#125;;</span><br><span class="line">    Element elements[] = &#123;element1, element2&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = seqSearch(elements, <span class="string">"namhoon"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위 프로그램을 살펴보면 for 문을 돌면서 n 개의 레코드를 탐색하는 평균은 (n+1)/2 이므로, O(n)의 시간복잡도를 가진다.</p>
<p>만약 어떤 리스트가 정렬된 순차 리스트라면 이런 순차 탐색 말고 <strong>이원 탐색</strong> 을 사용하여 자료를 찾을 수 있으며 이 경우 시간 복잡도는 O(logn) 이다.</p>
<h1><span id="정렬의-종류">정렬의 종류</span></h1><h2><span id="삽입-정렬">삽입 정렬</span></h2><p>i 개의 정렬된 레코드에 새로운 레코드를 끼워넣어 i+1 개의 정렬된 레코드 리스트를 만드는 정렬 방법이다.</p>
<p>아래 프로그램은 C로 구현한 insert 함수이다.</p>
<p><img src="/images/삽입정렬시Insert함수의개념도.png" alt="삽입 정렬 시 insert 함수의 개념도"></p>
<p>정렬된 리스트 a[1:i] 에 e 원소를 집어넣어 a[1:i+1]의 리스트를 만들어 내는 함수이다.</p>
<p>index 역할을 하는 i가 점차 작아지면서 a[i].key가 e.key 보다 큰 경우 한칸씩 우측으로 밀어내고, a[i].key가 e.key 보다 작아지는 i 값에서 a[i+1]에 e를 넣어준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void insert(element e, element a[], int i)&#123;</span><br><span class="line">  a[0]=e;</span><br><span class="line">  while(e.key&lt;a[i].key)&#123;</span><br><span class="line">    a[i+1] = a[i];</span><br><span class="line">    i--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  a[i+1] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>아래 함수는 insert 함수를 활용하여 삽입정렬을 하는 프로그램이다.</p>
<p><img src="../images/삽입정렬의개념도.png" alt="삽입 정렬의 개념도"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void insertionSort(element a[], int n)&#123;</span><br><span class="line">  int j;</span><br><span class="line">  for(j=2;j&lt;=n;j++)&#123;</span><br><span class="line">    element temp = a[j];</span><br><span class="line">    insert(temp, a, j-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="병합정렬merge-sort">병합정렬(Merge Sort)</span></h2><p>병합정렬은 입력 리스트를 길이가 1인 n 개의 정렬될 서브트리로 간주하는 것으로 시작합니다.</p>
<p>아래 merge 함수는 두개의 서로 다른 리스트를 병합하는 것을 보여줍니다.</p>
<p><img src="\images\merge개념도.png" alt="합병 정렬을 위한 merge 함수 개념도"></p>
<p><img src="\images\병합정렬의개념도.png" alt="병합 정렬의 개념도"></p>
<p>merge sort 의 각 단계는 O(n) 의 시간이 걸리고 logn 번의 단계가 적용되므로 O(nlogn) 의 복잡도를 가집니다.</p>
<p><strong>Time Complexity: O(nlogn)</strong></p>
<p>또한 각 병합과정에서 새로운 배열이 필요하므로 inplace sort가 아니다.</p>
<h2><span id="퀵-정렬quick-sort">퀵 정렬(Quick Sort)</span></h2><p>퀵 정렬은 앞서 살펴본 정렬법 중에서 가장 좋은 평균 성능을 가지고 있다.<br>퀵 정렬의 순서는 먼저 피벗 레코드를 선택하여 피벗의 왼쪽에는 레코드 키들이 피벗의 키보다 작거나 같고 피벗의 오른쪽에는 레코드 키들이 피벗의 키보다 크거나 같도록 하는 방법을 사용한다. 최종적으로는 피벗의 왼쪽에 있는 레코드들과 피벗의 오른쪽에 있는 레코드들이 서로 독립적으로 정렬이 된다.</p>
<p><img src="/images\퀵정렬의개념도.png" alt="퀵정렬의 개념도"></p>
<p>다음은 퀵 정렬을 수행하는 프로그램이다.<br>i와 j가 각각 왼쪽과 오른쪽에서 가운데 방향으로 진행하며, a[i].key는 pivot 보다 커질 때까지 a[j].key는 pivot 보다 작아질 때 까지<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void quickSort(element a[], int left, int right)&#123;</span><br><span class="line">  int pivot,i,j;</span><br><span class="line">  pivot = a[left].key;</span><br><span class="line">  do&#123;</span><br><span class="line">    do j++;while(a[i].key&lt;pivot);</span><br><span class="line">    do j--;while(a[j].key&gt;pivot);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="히프정렬">히프정렬</span></h2><p><img src="\images\히프정렬을위한Adjust함수.png" alt="히프 정렬을 위한 adjust 함수"></p>
<p><img src="\images\히프정렬의개념도.png" alt="히프 정렬의 개념도"></p>
<p><img src="배열에서의히프정렬.png" alt="배열에서의 히프 정렬"></p>
<p>히프 정렬에서는 최대 길이 [log_2(n+1)] 을 가지고 adjust를 n-1번 호출한다.</p>
<p>즉, O(nlogn) 이다.</p>
<h2><span id="버블-정렬">버블 정렬</span></h2><p><img src="\images\버블정렬의개념도.png" alt="버블 정렬의 개념도"></p>
<h2><span id="선택-정렬">선택 정렬</span></h2><p><img src="\images\선택정렬의개념도.png" alt="선택 정렬의 개념도"></p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-히프(Heap)/" itemprop="url">
                자료구조 | 히프 구조
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T11:34:03.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                5 minutes read (About 763 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="히프heap란">히프(heap)란?</span></h1><p>히프는 우선순위 큐를 구현하는 데 자주 사용된다. 우선순위 큐에서는 우선순위가 가장 높은(또는 낮은) 원소를 먼저 삭제한다.<br>히프에 대한 설명을 하기 전에 최대 트리와 최소 트리에 대한 설명을 먼저 진행한다.</p>
<p><strong>최대 트리</strong> 란 각 노드의 키 값이 그 자식의 키 값보다 작지 않은 트리이며,<br><strong>최소 트리</strong> 란 각 노드의 키 값이 그 자식의 키 값보다 크지 않은 트리를 말한다.</p>
<p>여기서 <strong>최대 히프</strong> 란 최대 트리이면서 완전 이진트리이며, <strong>최소 히프</strong> 란 최소 트리이면서 완전 이진트리를 의미한다.</p>
<p>이러한 최대 히프 및 최소 히프에서는 부모를 쉽게 찾아 삽입이 가능하다.</p>
<p>히프의 생성은 C를 통하여 다음과 같이 구현한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_ELEMENTS 200</span><br><span class="line">#define HEAP_FULL(n) (n==MAX_ELEMENTS-1)</span><br><span class="line">#define HEAP_EMPTY(n) (!n)</span><br><span class="line">typedef struct&#123;</span><br><span class="line">  int key;</span><br><span class="line">  &#125; element;</span><br><span class="line"></span><br><span class="line">element heap[MAX_ELEMENTS];</span><br><span class="line">int n=0;</span><br></pre></td></tr></table></figure></p>
<h1><span id="최대-히프에서의-삽입">최대 히프에서의 삽입</span></h1><p>최대 히프에서 원소를 삽입하는 경우 추가되는 원소가 가장 아래부터 루트 쪽으로 올라가는 bubbling up 기법이 사용된다.<br>다음은 최대 히프에서의 원소의 삽입을 구현한 C 프로그램이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define MAX_ELEMENTS 200 /*최대 히프 크기 +1*/</span><br><span class="line">#define HEAP_FULL(n) (n == MAX_ELEMENTS-1)</span><br><span class="line">#define HEAP_EMPTY(n) (!n)</span><br><span class="line"></span><br><span class="line">typedef struct element&#123;</span><br><span class="line">  int key;</span><br><span class="line">&#125;element;</span><br><span class="line"></span><br><span class="line">element heap[MAX_ELEMENTS];</span><br><span class="line">int n=0;</span><br><span class="line"></span><br><span class="line">void push(element item, int *n)</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  if(HEAP_FULL(*n))&#123;</span><br><span class="line">    fprintf(stderr, &quot;The heap is full. \n&quot;);</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  i = ++(*n);</span><br><span class="line">  while ((i != 1) &amp;&amp; (item.key &gt; heap[i/2].key))&#123;</span><br><span class="line">    heap[i] = heap[i/2];</span><br><span class="line">    i /= 2;</span><br><span class="line">  &#125;</span><br><span class="line">  heap[i] = item;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct element node1 = &#123;7&#125;;</span><br><span class="line">    struct element node2 = &#123;16&#125;;</span><br><span class="line">    struct element node3 = &#123;49&#125;;</span><br><span class="line">    struct element node4 = &#123;82&#125;;</span><br><span class="line">    struct element node5 = &#123;5&#125;;</span><br><span class="line">    struct element node6 = &#123;31&#125;;</span><br><span class="line">    struct element node7 = &#123;6&#125;;</span><br><span class="line">    struct element node8 = &#123;2&#125;;</span><br><span class="line">    struct element node9 = &#123;44&#125;;</span><br><span class="line">    push(node1, &amp;n);</span><br><span class="line">    push(node2, &amp;n);</span><br><span class="line">    push(node3, &amp;n);</span><br><span class="line">    push(node4, &amp;n);</span><br><span class="line">    push(node5, &amp;n);</span><br><span class="line">    push(node6, &amp;n);</span><br><span class="line">    push(node7, &amp;n);</span><br><span class="line">    push(node8, &amp;n);</span><br><span class="line">    push(node9, &amp;n);</span><br><span class="line">    for(int k=1;k&lt;10;k++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,heap[k].key);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\최대히프에서의삽입.png" alt="최대 히프에서의 삽입"></p>
<h1><span id="최대-히프에서의-삭제">최대 히프에서의 삭제</span></h1><p>최대 히프에서 원소의 삭제는 제일 위에서 이루어 진다.<br>먼저, 키값이 가장 큰 원소를 삭제하고 마지막 원소를 제거하고 두 자식 노드중 큰 값이 위로 올라가고 아래를 메꾸는 방식으로 진행된다.<br>최대 히프의 삭제를 구현한 프로그램은 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">element pop(int *n)</span><br><span class="line">&#123;</span><br><span class="line">  int parent, child;</span><br><span class="line">  element item, temp;</span><br><span class="line">  if(HEAP_EMPTY(*n))&#123;</span><br><span class="line">    fprintf(stderr, &quot;The heap is empty\n&quot;);</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  item=heap[1];</span><br><span class="line">  temp = heap[(*n)--];</span><br><span class="line">  parent = 1;</span><br><span class="line">  child = 2;</span><br><span class="line">  while(child &lt;= *n)&#123;</span><br><span class="line">    if((child &lt; *n) &amp;&amp; (heap[child].key &lt; heap[child+1].key))</span><br><span class="line">      child++;</span><br><span class="line">    if(temp.key &gt; heap[child].key) break;</span><br><span class="line">    heap[parent] = heap[child];</span><br><span class="line">    parent = child;</span><br><span class="line">    child *= 2;</span><br><span class="line">  &#125;</span><br><span class="line">  heap[parent] = temp;</span><br><span class="line">  return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="\images\최대히프에서의삭제개념도.png" alt="최대 히프에서의 삭제 개념도"></p>
<h1><span id="b-히프">B - 히프</span></h1><p>B - 히프란 최소 트리의 집합이다.</p>
<p><img src="\images\b히프.png" alt="B 히프"></p>
<p><img src="\images\b히프에서의삽입.png" alt="B 히프에서의 삽입"></p>
<p><img src="\images\b히프에서의삭제.png" alt="B 히프에서의 삭제"></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-트리/" itemprop="url">
                자료구조 | 트리(Tree)
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T11:28:13.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                17 minutes read (About 2475 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#트리tree란">트리(tree)란?</a></li>
<li><a href="#이진-트리">이진 트리</a><ul>
<li><a href="#이진-트리-순회">이진 트리 순회</a></li>
<li><a href="#예제">예제</a></li>
</ul>
</li>
<li><a href="#스레드-이진-트리">스레드 이진 트리</a></li>
<li><a href="#이원-탐색-트리bst-binary-search-tree">이원 탐색 트리(BST, Binary Search Tree)</a><ul>
<li><a href="#이원-탐색트리의-탐색">이원 탐색트리의 탐색</a></li>
<li><a href="#insertion-in-bst">INSERTION IN BST</a></li>
<li><a href="#deletion-in-bst">DELETION IN BST</a></li>
</ul>
</li>
<li><a href="#선택-트리">선택 트리</a><ul>
<li><a href="#승자-트리">승자 트리</a></li>
<li><a href="#패자-트리">패자 트리</a></li>
</ul>
</li>
<li><a href="#분리-집합의-표현">분리 집합의 표현</a></li>
<li><a href="#이진-트리의-개수-계산">이진 트리의 개수 계산</a></li>
<li><a href="#avl-트리">AVL 트리</a><ul>
<li><a href="#avl-트리에서의-삽입">AVL 트리에서의 삽입</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="트리tree란">트리(tree)란?</span></h1><p>트리 구조란 정보의 항목들이 가지로 연결될 수 있게 데이터가 조작되는 것이며, 가계표, 족보, 왕조의 나열 등에서 쉽게 찾아볼 수 있다.<br>가계표를 예를 들어 설명을 하면 최 상단에 조부모님이 계시고 그 아래로 아버지와 어머니, 동생 친척들이 쭉 나열이 되는데, 이러한 조직 체계를 트리를 통해 나타낼 수 있다.</p>
<p>트리 구조에서 <strong>노드</strong> 란 각 항목들을 의미하며 한 정보 아이템에서 다른 노드로 뻗어진 가지를 포함한 개념이다.<br>각 노드는 아래로 계속해서 가지를 뻗어나갈 수 있는데, <strong>한 노드에서 뻗어져 나간 가지들(서브트리)</strong> 의 수를 그 노드의 <strong>차수</strong> 라고 부른다.<br>또한, 차수가 0인 노드를 <strong>리프 혹은 단말 노드</strong> 라고 부르며, 뻗어나간 구조의 상위의 노드를 아래 노드의 <strong>부모(parent)</strong> 라 하고 아래 노드를 상위 노드의 <strong>자식(child)</strong> 이라고 부른다. 또한 한 노드에서 뻗어져 나온 병렬관계의 노드를 서로의 <strong>형제(sibling)</strong> 이라고 부른다.</p>
<p>특정 노드의 차수와 구분하여 <strong>트리의 차수</strong> 트리에 있는 노드의 최대 차수를 말한다.</p>
<h1><span id="이진-트리">이진 트리</span></h1><p>다시 가계표의 예를 들면 한 부모 밑에는 수많은 자식들이 생길 수 있으나, 컴퓨터가 이를 처리하는 시점에서 특정 부모노드 아래에 숫자를 알 수 없는 자식들이 존재하게 된다면 포인터 필드가 가변적이기에 효율적으로 메모리를 사용할 수 없다. 이 때문에 일정한 크기의 노드를 사용하기 위한 트리의 표현법이 나타나게 되었고, 한 노드가 가지만을 가지도록 만들어진 트리를 <strong>이진 트리</strong> 라고 한다.</p>
<p>제일 위의 노드(root)로 부터 2배씩 증가하며 가지들이 뻗어나와 크리스마스 트리 형태를 띄는 형태를 이진트리라고 부르며 모든 노드들이 규칙적으로 2개씩 가지를 쳐 나가 각 층의 노드가 꽉꽉 들어차면 이를 <strong>포화 이진 트리</strong> 라고 한다.<br><strong>깊이가 k인 포화 이진트리의 노드 수는 (2^k-1)개</strong> 이다.</p>
<p>컴퓨터에서는 이러한 이진트리를 메모리에 저장할 방법을 찾게 되었고 최 상단 노드부터 차례로 메모리에 저장을 하게 되면 포화 이진트리가 아닌 대부분의 이진트리에서는 메모리 중간 중간이 비게 되어 효율적인 메모리 사용에 어려움을 겪게 되었는데, 이를 해결하기 위해 열결표현 방식을 사용하여 각 노드가 다른 노드의 링크를 연결하여 포인터를 들고 있는 방식으로 저장하게 되었다.</p>
<p><strong>어떠한 트리도 이진 트리로 표현할 수 있다.</strong></p>
<p>다음은 C 언어를 이용한 이진 트리의 구현이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/*node 구조체로 *treePointer 라는 별칭 선언*/</span><br><span class="line">typedef struct node *treePointer;</span><br><span class="line">/*node 구조체를 선언한다.*/</span><br><span class="line">typedef struct node&#123;</span><br><span class="line">  char data;</span><br><span class="line">  treePointer leftChild, rightChild;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line">treePointer createNode(char newData)</span><br><span class="line">&#123;</span><br><span class="line">  treePointer newNode = (treePointer)malloc(sizeof(node));</span><br><span class="line">  newNode-&gt;leftChild = NULL;</span><br><span class="line">  newNode-&gt;rightChild = NULL;</span><br><span class="line">  newNode-&gt;data = newData;</span><br><span class="line"></span><br><span class="line">  return newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inorder(treePointer ptr)</span><br><span class="line">&#123;</span><br><span class="line">  if(ptr)&#123;</span><br><span class="line">    inorder(ptr-&gt;leftChild);</span><br><span class="line">    printf(&quot;%c&quot;, (*ptr).data);</span><br><span class="line">    inorder(ptr-&gt;rightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*추가된 노드를 출력하는 부분*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    treePointer nodeA = createNode(&apos;A&apos;);</span><br><span class="line">    treePointer nodeB = createNode(&apos;B&apos;);</span><br><span class="line">    treePointer nodeC = createNode(&apos;C&apos;);</span><br><span class="line">    treePointer nodeD = createNode(&apos;D&apos;);</span><br><span class="line">    treePointer nodeE = createNode(&apos;E&apos;);</span><br><span class="line">    treePointer nodeF = createNode(&apos;F&apos;);</span><br><span class="line">    treePointer nodeG = createNode(&apos;G&apos;);</span><br><span class="line">    treePointer nodeH = createNode(&apos;H&apos;);</span><br><span class="line"></span><br><span class="line">    (*nodeA).leftChild=nodeB;</span><br><span class="line">    (*nodeA).rightChild=nodeC;</span><br><span class="line">    (*nodeB).leftChild=nodeD;</span><br><span class="line">    (*nodeB).rightChild=nodeE;</span><br><span class="line">    (*nodeD).rightChild=nodeG;</span><br><span class="line">    (*nodeC).leftChild=nodeF;</span><br><span class="line">    (*nodeF).rightChild=nodeH;</span><br><span class="line">    inorder(nodeA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="이진-트리-순회">이진 트리 순회</span></h2><p>앞서 설명한 이진 트리를 조회하기 위해서 다양한 방법을 사용하는데, 한 노드에서 왼쪽으로 이동(L), 오른쪽으로 이동(R), 노드 방문(V) 의 순서에 따라 중위 순회, 후위 순회, 전위 순회로 구분한다.</p>
<p>먼저 <strong>전위 순회(preorder traversal)</strong> 는 이름 그대로 노드를 먼저 방문하는 경우 즉, VLR의 순서로 노드를 방문하는 경우이다.<br><strong>후위 순회(postorder traversal)</strong> 은 노드를 제일 마직막에 방문하는 경우 즉, LRV의 순서로 노드를 방문하는 경우이다.<br><strong>중위 순회</strong> 란 노드를 중간에 방문하는 경우 즉, LVR의 순서로 노드를 방문하는 경우이다.</p>
<p>중위 순회를 하는 경우를 C 코드로 나타내면 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void inorder(treePointer ptr)</span><br><span class="line">&#123;</span><br><span class="line">  if(ptr)&#123;</span><br><span class="line">    inorder(ptr-&gt;leftChild);</span><br><span class="line">    printf(&quot;%c&quot;, (*ptr).data);</span><br><span class="line">    inorder(ptr-&gt;rightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위의 코드를 살펴보면 반복법이 아닌 순환법을 이용하여 즉, 스택의 도움 없이 순회를 진행하는데 이는 스택을 이용하여 스택에 노드를 저장하고 제거하는 방식으로도 순회가 가능하다. 이러한 순회를 <strong>반복적 중위 순회</strong> 라고 하며 이를 C 코드로 구현하면 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void iterInorder(treePointer ptr)&#123;</span><br><span class="line">  int top = -1; /*스택 초기화*/</span><br><span class="line">  treePointer stack[MAX_STACK_SIZE];</span><br><span class="line">  for(;;)&#123;</span><br><span class="line">    for(;node;node=node-&gt;leftChild)</span><br><span class="line">      push(node);/*스택에 삽입*/</span><br><span class="line"></span><br><span class="line">    node=pop();/*스택에서 제거*/</span><br><span class="line">    if(!node)/*스택이 비어있는 경우 중지*/</span><br><span class="line">      break;</span><br><span class="line">    printf(&quot;%d&quot;, node-&gt;data);</span><br><span class="line">    node=node-&gt;rightChild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="예제">예제</span></h2><p>이진 트리에서 리프 노드의 수를 세는 C 함수를 작성하여라.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int totalCount=0;</span><br><span class="line">void countLeaf(treePointer ptr)&#123;</span><br><span class="line">  if(ptr&amp;&amp;(!(*ptr).leftChild)&amp;&amp;(!(*ptr).rightChild))&#123;</span><br><span class="line">    totalCount++;</span><br><span class="line">    printf(&quot;\n리프 노드: %c, count:%d\n&quot;, (*ptr).data, totalCount);</span><br><span class="line">  &#125;</span><br><span class="line">  if(ptr)&#123;</span><br><span class="line">    countLeaf((*ptr).leftChild);</span><br><span class="line">    printf(&quot;%c&quot;,(*ptr).data);</span><br><span class="line">    countLeaf((*ptr).rightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="스레드-이진-트리">스레드 이진 트리</span></h1><p>2n개의 링크 중 n+1개가 null link 이므로 효율성이 떨어지는 문제가 생기게 되고 이를 해결하기 위해 null link에 포인터를 넣어 다른 노드의 링크를 거는 것을 <strong>스레드</strong> 라고 한다.</p>
<h1><span id="이원-탐색-트리bst-binary-search-tree">이원 탐색 트리(BST, Binary Search Tree)</span></h1><p>이원 탐색 트리는 탐색, 삽입, 삭제 연산에 있어서 지금까지 공부했던 어떤 자료 구조보다도 성능이 좋다.<br>이원 탐색트리의 모든 원소는 키를 가지고 <strong>어떤 두 원소도 동일한 키를 갖지 않으며</strong>, <strong>왼쪽 서브트리가 존재한다면 그 키들은 루트의 키보다 작고 오른쪽 서브트리가 존재한다면 루트의 키보다 크다</strong>. 또한, <strong>왼쪽과 오른쪽 서브트리도 모두 이원탐색 트리이다.</strong></p>
<h2><span id="이원-탐색트리의-탐색">이원 탐색트리의 탐색</span></h2><p>탐색은 루트부터 시작하여 루트와 키 값이 같다면 탐색은 종료된다. 탐색하고자 하는 키 값이 루트의 키보다 작다면 왼쪽 서브트리를 탐색하고 크다면 오른쪽 서브트리를 탐색한다. 왼쪽과 오른쪽 서브트리는 모두 이원탐색 트리이므로 각각을 다시 탐색하는 순환 탐색 방식을 사용한다.</p>
<p>다음은 이원 탐색 트리의 순환적 탐색을 구현한 프로그램이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">element * search(treePointer tree, int key)&#123;</span><br><span class="line">  if(!root) return NULL;</span><br><span class="line">  if(k == root-&gt;data.key) return &amp;(root-&gt;data);</span><br><span class="line">  if(k&lt;root-&gt;data.key)</span><br><span class="line">    return search(root-&gt;leftChild, k);</span><br><span class="line">  return search(root-&gt;rightChild, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>아래는 동일한 기능의 반복 함수로 구현한 프로그램이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">element* iterSearch(treePointer tree, int k)</span><br><span class="line">&#123;</span><br><span class="line">  white(tree)&#123;</span><br><span class="line">    if(k==tree-&gt;data.key) return &amp;(tree-&gt;data);</span><br><span class="line">    if(k&lt;tree-&gt;data.key)</span><br><span class="line">      tree = tree-&gt;leftChild;</span><br><span class="line">    else</span><br><span class="line">      tree = tree-&gt;rightChild;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Time Complexity: O(h)</strong></p>
<p>BST 에서의 찾는 시간은 찾고자 하는 노드의 높이만큼 분기를 수행하므로 O(h) 이다.</p>
<h2><span id="insertion-in-bst">INSERTION IN BST</span></h2><p><img src="\images\이원탐색트리에서의삽입개념도.png" alt="이원 탐색 트리에서의 삽입 개념도"></p>
<p><strong>Time Complexity: O(h)</strong></p>
<p>BST 에서의 삭제는 search 후에 단순 삽입으로 search 시의 time complexity와 같은 complexity 를 가진다.</p>
<h2><span id="deletion-in-bst">DELETION IN BST</span></h2><p><img src="\images\이진탐색트리에서의삭제개념도.png" alt="이진 탐색 트리에서의 삭제 개념도"></p>
<p><strong>Time Complexity: O(h)</strong></p>
<p>BST 에서의 삭제는 다음과 같이 진행된다.</p>
<ol>
<li>BST에서 해당 노드를 찾음</li>
<li>해당 노드를 삭제하고, maximum value in left subchild 로 대체 하거나 혹은 minimum in right subchild 로 대체한다.</li>
<li>대체된 노드에 대한 삭제를 진행한다. 이 경우 해당 노드는 차수가 0이거나 혹은 1 이므로 삭제는 매우 간편하다.</li>
</ol>
<p>위의 각 과정별로 시간 소모를 생각해 보면, 노드를 찾는데에 O(h), 삭제하고 서브 트리에서 값을 찾는데에 O(h) 삭제에 1 이므로 BST 에서 deletion 시에 time Complexity 는 O(h) 이다.</p>
<h1><span id="선택-트리">선택 트리</span></h1><h2><span id="승자-트리">승자 트리</span></h2><p>다음은 8개의 런(k=8) 을 가진 승자 트리의 개념도 입니다.</p>
<p><img src="\images\선택트리의개념도.png" alt="선택 트리의 개념도"></p>
<h2><span id="패자-트리">패자 트리</span></h2><p>다음은 위의 승자 트리에 대응하는 패자 트리의 개념도 입니다.</p>
<p><img src="\images\패자트리의개념도.png" alt="패자 트리의 개념도"></p>
<h1><span id="분리-집합의-표현">분리 집합의 표현</span></h1><h1><span id="이진-트리의-개수-계산">이진 트리의 개수 계산</span></h1><h1><span id="avl-트리">AVL 트리</span></h1><p>AVL 트리란 균형 이진 트리의 한 종류이며, 이원 탐색트리가 항상 완전 이진트리로 유지되도록 한 트리입니다.</p>
<p><strong>탐색, 삽입, 삭제 시간: O(logn)</strong></p>
<p>AVL 트리에서 각 노드는 <strong>균형 인자(balance factor)</strong> 를 가지는데, 이는 왼쪽 트리의 높이에서 오른쪽 트리의 높이를 뺀 값으로 높이의 균형도를 나타냅니다.</p>
<p><strong>balance factor = h_L - h_R</strong></p>
<p>AVL 트리에서는 어떤 서브트리 T 에서도 BF(T) 의 절대값은 1 이하입니다.</p>
<h2><span id="avl-트리에서의-삽입">AVL 트리에서의 삽입</span></h2><p><strong>LL rotation</strong></p>
<p><img src="\images\lL로테이션.png" alt="LL 로테이션"></p>
<p><strong>RR rotation</strong><br><strong>LR rotation</strong></p>
<p><img src="\images\lR로테이션.png" alt="LR 로테이션"></p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-강의-09-우선순위-큐/" itemprop="url">
                자료구조 강의 09. 우선순위 큐
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T11:07:13.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                5 minutes read (About 739 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#1-한쪽-끝과-양쪽-끝-우선순위-큐">1. 한쪽 끝과 양쪽 끝 우선순위 큐</a></li>
<li><a href="#좌향-트리">좌향 트리</a></li>
<li><a href="#이항히프b-heap">이항히프(B-Heap)</a></li>
</ul>
<!-- tocstop -->
<h1><span id="1-한쪽-끝과-양쪽-끝-우선순위-큐">1. 한쪽 끝과 양쪽 끝 우선순위 큐</span></h1><p><strong>우선순위 큐(priority queue)</strong> 는 각 원소가 연관된 우선순위를 갖고 있는 원소들의 모임이다.<br>가령 시스템의 작업 우선도를 설정해 줄 때에는 작업들을 우선 순위에 따라 분류해야 하며, 2개의 서버로 이루어진 시스템의 경우에 하나의 시스템이 사고로 인해 종료되는 경우 반대쪽 서버로 그 작업 내역들이 병합되어야 하는데 이러한 경우 우선순위 큐를 통해 두 작업 리스트를 병합해야 한다.</p>
<p>이러한 우선순위 큐 <strong>한쪽 끝 우선순위 큐</strong> 와 <strong>양쪽 끝 우선순위 큐</strong> 가 있으며, 한쪽 끝 우선순위 큐는 <strong>최대 우선순위 큐</strong> 와 <strong>최소 우선순위 큐</strong> 로 나뉜다.</p>
<p><strong>최소 우선순위 큐</strong> 에 의해 지원되는 연산은 다음과 같다.<br>SP1. 최소 우선순위를 가진 원소의 반환<br>SP2. 임의 우선순위를 가진 원소의 삽입<br>SP3. 최소 우선순위를 가진 원소의 삭제</p>
<p>이러한 우선순위 큐를 잘 표현하기 위한 고전적인 자료 구조로써 <strong>히프(heap)</strong> 를 사용한다.</p>
<p>양쪽 끝 우선순위 큐는 최소 우선순위 큐와 최대 우선순위 큐가 하나로 합해진 최소-최대 우선순위 큐이다.</p>
<p>실제 활용도 측면에서, 양쪽 끝 우선순위 큐는 네트워크 버퍼를 구현하는 데 사용되는데 네트워크 링크를 통해 전송되기를 원하는 패킷들을 가지고 있는 경우 가장 높은 우선순위를 가진 패킷이 전송되고 삭제 되는 <strong>최대 삭제</strong> 가 행해지는 반면, 네트워크 내의 다른 곳으로 부터 새로운 패킷이 도착하였는데 버퍼가 가득 차 있다면 우선 순위가 가장 낮은 패킷을 지우는 <strong>최소 삭제</strong> 가 일어나게 된다. 이처럼 작업 큐의 양쪽에서 삽입과 삭제가 가능한 큐를 양쪽 끝 우선순위 큐라고 부른다.</p>
<h1><span id="좌향-트리">좌향 트리</span></h1><p>좌향트리는 합병성 우선순위 큐의 효율적 구현을 제공한다.<br>좌향 트리의 종류에는 HBLT(Height Biased Leftist Tree)와 WBLT(Weight Biased Leftist Tree)가 있는데, 일반적으로 HBLT를 좌향트리하고 부른다.</p>
<h1><span id="이항히프b-heap">이항히프(B-Heap)</span></h1><p>좌향 트리에서 지원되는 것과 같은 기능을 수행한다. 개별적인 연산을 수행하는 데 걸리는 시간보다 우선순위 큐의 순차를 수행하는데 걸리는 시점에 관심이 있다.<br>이항 히프란 최소 트리의 집합이며, 최소 트리 가운데 최소값을 갖는 트리를 가리키는 하나의 포인터가 가르키게 된다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-강의-01-기본-개념/" itemprop="url">
                자료구조 강의 01. 기본 개념
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T10:29:33.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                3 minutes read (About 449 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#개요-시스템-생명-주기">개요: 시스템 생명 주기</a></li>
<li><a href="#포인터와-동적-메모리-할당">포인터와 동적 메모리 할당</a></li>
<li><a href="#알고리즘-명세">알고리즘 명세</a></li>
<li><a href="#데이터-추상화">데이터 추상화</a></li>
<li><a href="#성능-분석">성능 분석</a><ul>
<li><a href="#공간-복잡도">공간 복잡도</a></li>
<li><a href="#시간-복잡도">시간 복잡도</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="개요-시스템-생명-주기">개요: 시스템 생명 주기</span></h1><h1><span id="포인터와-동적-메모리-할당">포인터와 동적 메모리 할당</span></h1><h1><span id="알고리즘-명세">알고리즘 명세</span></h1><h1><span id="데이터-추상화">데이터 추상화</span></h1><h1><span id="성능-분석">성능 분석</span></h1><p>본 강의의 목적 중 하나는 프로그램에 대한 평가 능력을 향상시키는 것이다.<br>프로그램의 판단함에 있어서 다양한 기준이 있지만, 크게는 컴퓨터와 상관 없이 시공간의 추산에 초점을 두는 <strong>성능 분석(performance analysis)</strong> 과 컴퓨터에 의존적인 실행 시간을 얻어내는 <strong>성능 측정(performance measurement)</strong> 이 있다.</p>
<p>이번 강의 에서는 성능 측정은 배제하고 성능 분석에 초점을 두어 강의를 진행하며 성능 분석은 다음의 두 복잡도로 분석을 진행한다.</p>
<ol>
<li>공간 복잡도</li>
<li>시간 복잡도</li>
</ol>
<h2><span id="공간-복잡도">공간 복잡도</span></h2><p>공간 복잡도의 정의는 프로그램을 실행시켜 완료하는 데 필요로 하는 공간의 양으로, 실제 메모리를 차지하는 양을 나타낸다. 각 각의 변수가 얼마나 많은 메모리를 차지하는 지 등을 다루며 이러한 공간 복잡도는 <strong>고정 공간 요구</strong> 및 <strong>가변 공간 요구</strong> 로 나뉘게 된다.</p>
<p><strong><em>고정 공간 요구</em></strong><br>프로그램 입출력의 횟수나 크기에 관계없는 공간 요구를 의미한다.<br>가령 명렁어 공간, 단순 변수, 상수 고정 크기의 구조화 변수 등을 포함한다.</p>
<p><strong><em>가변 공간 요구</em></strong><br>해결하고자 하는 문제의 특정 인스턴스 I에 의존하는 크기를 가진 구조화 변수들을 위해 필요로 하는 공간이다.</p>
<h2><span id="시간-복잡도">시간 복잡도</span></h2><p>컴파일 시간과 실행 시간을 합한 것이다.</p>

                        
    </div>
    
            
</article>



        
    
    
    </div>
</section>

            <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 Jake.Lee 이남훈&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" href="https://github.com/frontalnh">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
                <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        //plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110077250-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-110077250-2');
</script>


    


<script src="/js/script.js"></script>

                    
                        <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
                            
</body>

</html>