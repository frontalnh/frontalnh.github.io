<!DOCTYPE html>
<html class="has-navbar-fixed-top">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>자료구조 | 트리(Tree) - Jake.Lee&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">






<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="/css/style.css">
<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>

</head>

<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">Categories</a>
            
            <a class="navbar-item " href="/tags">Tags</a>
            
            <a class="navbar-item " href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" href="https://github.com/frontalnh">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

        <section class="section">
    <div class="container">
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
                자료구조 | 트리(Tree)
                    
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T11:28:13.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                17 minutes read (About 2475 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#트리tree란">트리(tree)란?</a></li>
<li><a href="#이진-트리">이진 트리</a><ul>
<li><a href="#이진-트리-순회">이진 트리 순회</a></li>
<li><a href="#예제">예제</a></li>
</ul>
</li>
<li><a href="#스레드-이진-트리">스레드 이진 트리</a></li>
<li><a href="#이원-탐색-트리bst-binary-search-tree">이원 탐색 트리(BST, Binary Search Tree)</a><ul>
<li><a href="#이원-탐색트리의-탐색">이원 탐색트리의 탐색</a></li>
<li><a href="#insertion-in-bst">INSERTION IN BST</a></li>
<li><a href="#deletion-in-bst">DELETION IN BST</a></li>
</ul>
</li>
<li><a href="#선택-트리">선택 트리</a><ul>
<li><a href="#승자-트리">승자 트리</a></li>
<li><a href="#패자-트리">패자 트리</a></li>
</ul>
</li>
<li><a href="#분리-집합의-표현">분리 집합의 표현</a></li>
<li><a href="#이진-트리의-개수-계산">이진 트리의 개수 계산</a></li>
<li><a href="#avl-트리">AVL 트리</a><ul>
<li><a href="#avl-트리에서의-삽입">AVL 트리에서의 삽입</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="트리tree란">트리(tree)란?</span></h1><p>트리 구조란 정보의 항목들이 가지로 연결될 수 있게 데이터가 조작되는 것이며, 가계표, 족보, 왕조의 나열 등에서 쉽게 찾아볼 수 있다.<br>가계표를 예를 들어 설명을 하면 최 상단에 조부모님이 계시고 그 아래로 아버지와 어머니, 동생 친척들이 쭉 나열이 되는데, 이러한 조직 체계를 트리를 통해 나타낼 수 있다.</p>
<p>트리 구조에서 <strong>노드</strong> 란 각 항목들을 의미하며 한 정보 아이템에서 다른 노드로 뻗어진 가지를 포함한 개념이다.<br>각 노드는 아래로 계속해서 가지를 뻗어나갈 수 있는데, <strong>한 노드에서 뻗어져 나간 가지들(서브트리)</strong> 의 수를 그 노드의 <strong>차수</strong> 라고 부른다.<br>또한, 차수가 0인 노드를 <strong>리프 혹은 단말 노드</strong> 라고 부르며, 뻗어나간 구조의 상위의 노드를 아래 노드의 <strong>부모(parent)</strong> 라 하고 아래 노드를 상위 노드의 <strong>자식(child)</strong> 이라고 부른다. 또한 한 노드에서 뻗어져 나온 병렬관계의 노드를 서로의 <strong>형제(sibling)</strong> 이라고 부른다.</p>
<p>특정 노드의 차수와 구분하여 <strong>트리의 차수</strong> 트리에 있는 노드의 최대 차수를 말한다.</p>
<h1><span id="이진-트리">이진 트리</span></h1><p>다시 가계표의 예를 들면 한 부모 밑에는 수많은 자식들이 생길 수 있으나, 컴퓨터가 이를 처리하는 시점에서 특정 부모노드 아래에 숫자를 알 수 없는 자식들이 존재하게 된다면 포인터 필드가 가변적이기에 효율적으로 메모리를 사용할 수 없다. 이 때문에 일정한 크기의 노드를 사용하기 위한 트리의 표현법이 나타나게 되었고, 한 노드가 가지만을 가지도록 만들어진 트리를 <strong>이진 트리</strong> 라고 한다.</p>
<p>제일 위의 노드(root)로 부터 2배씩 증가하며 가지들이 뻗어나와 크리스마스 트리 형태를 띄는 형태를 이진트리라고 부르며 모든 노드들이 규칙적으로 2개씩 가지를 쳐 나가 각 층의 노드가 꽉꽉 들어차면 이를 <strong>포화 이진 트리</strong> 라고 한다.<br><strong>깊이가 k인 포화 이진트리의 노드 수는 (2^k-1)개</strong> 이다.</p>
<p>컴퓨터에서는 이러한 이진트리를 메모리에 저장할 방법을 찾게 되었고 최 상단 노드부터 차례로 메모리에 저장을 하게 되면 포화 이진트리가 아닌 대부분의 이진트리에서는 메모리 중간 중간이 비게 되어 효율적인 메모리 사용에 어려움을 겪게 되었는데, 이를 해결하기 위해 열결표현 방식을 사용하여 각 노드가 다른 노드의 링크를 연결하여 포인터를 들고 있는 방식으로 저장하게 되었다.</p>
<p><strong>어떠한 트리도 이진 트리로 표현할 수 있다.</strong></p>
<p>다음은 C 언어를 이용한 이진 트리의 구현이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/*node 구조체로 *treePointer 라는 별칭 선언*/</span><br><span class="line">typedef struct node *treePointer;</span><br><span class="line">/*node 구조체를 선언한다.*/</span><br><span class="line">typedef struct node&#123;</span><br><span class="line">  char data;</span><br><span class="line">  treePointer leftChild, rightChild;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line">treePointer createNode(char newData)</span><br><span class="line">&#123;</span><br><span class="line">  treePointer newNode = (treePointer)malloc(sizeof(node));</span><br><span class="line">  newNode-&gt;leftChild = NULL;</span><br><span class="line">  newNode-&gt;rightChild = NULL;</span><br><span class="line">  newNode-&gt;data = newData;</span><br><span class="line"></span><br><span class="line">  return newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inorder(treePointer ptr)</span><br><span class="line">&#123;</span><br><span class="line">  if(ptr)&#123;</span><br><span class="line">    inorder(ptr-&gt;leftChild);</span><br><span class="line">    printf(&quot;%c&quot;, (*ptr).data);</span><br><span class="line">    inorder(ptr-&gt;rightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*추가된 노드를 출력하는 부분*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    treePointer nodeA = createNode(&apos;A&apos;);</span><br><span class="line">    treePointer nodeB = createNode(&apos;B&apos;);</span><br><span class="line">    treePointer nodeC = createNode(&apos;C&apos;);</span><br><span class="line">    treePointer nodeD = createNode(&apos;D&apos;);</span><br><span class="line">    treePointer nodeE = createNode(&apos;E&apos;);</span><br><span class="line">    treePointer nodeF = createNode(&apos;F&apos;);</span><br><span class="line">    treePointer nodeG = createNode(&apos;G&apos;);</span><br><span class="line">    treePointer nodeH = createNode(&apos;H&apos;);</span><br><span class="line"></span><br><span class="line">    (*nodeA).leftChild=nodeB;</span><br><span class="line">    (*nodeA).rightChild=nodeC;</span><br><span class="line">    (*nodeB).leftChild=nodeD;</span><br><span class="line">    (*nodeB).rightChild=nodeE;</span><br><span class="line">    (*nodeD).rightChild=nodeG;</span><br><span class="line">    (*nodeC).leftChild=nodeF;</span><br><span class="line">    (*nodeF).rightChild=nodeH;</span><br><span class="line">    inorder(nodeA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="이진-트리-순회">이진 트리 순회</span></h2><p>앞서 설명한 이진 트리를 조회하기 위해서 다양한 방법을 사용하는데, 한 노드에서 왼쪽으로 이동(L), 오른쪽으로 이동(R), 노드 방문(V) 의 순서에 따라 중위 순회, 후위 순회, 전위 순회로 구분한다.</p>
<p>먼저 <strong>전위 순회(preorder traversal)</strong> 는 이름 그대로 노드를 먼저 방문하는 경우 즉, VLR의 순서로 노드를 방문하는 경우이다.<br><strong>후위 순회(postorder traversal)</strong> 은 노드를 제일 마직막에 방문하는 경우 즉, LRV의 순서로 노드를 방문하는 경우이다.<br><strong>중위 순회</strong> 란 노드를 중간에 방문하는 경우 즉, LVR의 순서로 노드를 방문하는 경우이다.</p>
<p>중위 순회를 하는 경우를 C 코드로 나타내면 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void inorder(treePointer ptr)</span><br><span class="line">&#123;</span><br><span class="line">  if(ptr)&#123;</span><br><span class="line">    inorder(ptr-&gt;leftChild);</span><br><span class="line">    printf(&quot;%c&quot;, (*ptr).data);</span><br><span class="line">    inorder(ptr-&gt;rightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위의 코드를 살펴보면 반복법이 아닌 순환법을 이용하여 즉, 스택의 도움 없이 순회를 진행하는데 이는 스택을 이용하여 스택에 노드를 저장하고 제거하는 방식으로도 순회가 가능하다. 이러한 순회를 <strong>반복적 중위 순회</strong> 라고 하며 이를 C 코드로 구현하면 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void iterInorder(treePointer ptr)&#123;</span><br><span class="line">  int top = -1; /*스택 초기화*/</span><br><span class="line">  treePointer stack[MAX_STACK_SIZE];</span><br><span class="line">  for(;;)&#123;</span><br><span class="line">    for(;node;node=node-&gt;leftChild)</span><br><span class="line">      push(node);/*스택에 삽입*/</span><br><span class="line"></span><br><span class="line">    node=pop();/*스택에서 제거*/</span><br><span class="line">    if(!node)/*스택이 비어있는 경우 중지*/</span><br><span class="line">      break;</span><br><span class="line">    printf(&quot;%d&quot;, node-&gt;data);</span><br><span class="line">    node=node-&gt;rightChild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="예제">예제</span></h2><p>이진 트리에서 리프 노드의 수를 세는 C 함수를 작성하여라.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int totalCount=0;</span><br><span class="line">void countLeaf(treePointer ptr)&#123;</span><br><span class="line">  if(ptr&amp;&amp;(!(*ptr).leftChild)&amp;&amp;(!(*ptr).rightChild))&#123;</span><br><span class="line">    totalCount++;</span><br><span class="line">    printf(&quot;\n리프 노드: %c, count:%d\n&quot;, (*ptr).data, totalCount);</span><br><span class="line">  &#125;</span><br><span class="line">  if(ptr)&#123;</span><br><span class="line">    countLeaf((*ptr).leftChild);</span><br><span class="line">    printf(&quot;%c&quot;,(*ptr).data);</span><br><span class="line">    countLeaf((*ptr).rightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="스레드-이진-트리">스레드 이진 트리</span></h1><p>2n개의 링크 중 n+1개가 null link 이므로 효율성이 떨어지는 문제가 생기게 되고 이를 해결하기 위해 null link에 포인터를 넣어 다른 노드의 링크를 거는 것을 <strong>스레드</strong> 라고 한다.</p>
<h1><span id="이원-탐색-트리bst-binary-search-tree">이원 탐색 트리(BST, Binary Search Tree)</span></h1><p>이원 탐색 트리는 탐색, 삽입, 삭제 연산에 있어서 지금까지 공부했던 어떤 자료 구조보다도 성능이 좋다.<br>이원 탐색트리의 모든 원소는 키를 가지고 <strong>어떤 두 원소도 동일한 키를 갖지 않으며</strong>, <strong>왼쪽 서브트리가 존재한다면 그 키들은 루트의 키보다 작고 오른쪽 서브트리가 존재한다면 루트의 키보다 크다</strong>. 또한, <strong>왼쪽과 오른쪽 서브트리도 모두 이원탐색 트리이다.</strong></p>
<h2><span id="이원-탐색트리의-탐색">이원 탐색트리의 탐색</span></h2><p>탐색은 루트부터 시작하여 루트와 키 값이 같다면 탐색은 종료된다. 탐색하고자 하는 키 값이 루트의 키보다 작다면 왼쪽 서브트리를 탐색하고 크다면 오른쪽 서브트리를 탐색한다. 왼쪽과 오른쪽 서브트리는 모두 이원탐색 트리이므로 각각을 다시 탐색하는 순환 탐색 방식을 사용한다.</p>
<p>다음은 이원 탐색 트리의 순환적 탐색을 구현한 프로그램이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">element * search(treePointer tree, int key)&#123;</span><br><span class="line">  if(!root) return NULL;</span><br><span class="line">  if(k == root-&gt;data.key) return &amp;(root-&gt;data);</span><br><span class="line">  if(k&lt;root-&gt;data.key)</span><br><span class="line">    return search(root-&gt;leftChild, k);</span><br><span class="line">  return search(root-&gt;rightChild, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>아래는 동일한 기능의 반복 함수로 구현한 프로그램이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">element* iterSearch(treePointer tree, int k)</span><br><span class="line">&#123;</span><br><span class="line">  white(tree)&#123;</span><br><span class="line">    if(k==tree-&gt;data.key) return &amp;(tree-&gt;data);</span><br><span class="line">    if(k&lt;tree-&gt;data.key)</span><br><span class="line">      tree = tree-&gt;leftChild;</span><br><span class="line">    else</span><br><span class="line">      tree = tree-&gt;rightChild;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Time Complexity: O(h)</strong></p>
<p>BST 에서의 찾는 시간은 찾고자 하는 노드의 높이만큼 분기를 수행하므로 O(h) 이다.</p>
<h2><span id="insertion-in-bst">INSERTION IN BST</span></h2><p><img src="\images\이원탐색트리에서의삽입개념도.png" alt="이원 탐색 트리에서의 삽입 개념도"></p>
<p><strong>Time Complexity: O(h)</strong></p>
<p>BST 에서의 삭제는 search 후에 단순 삽입으로 search 시의 time complexity와 같은 complexity 를 가진다.</p>
<h2><span id="deletion-in-bst">DELETION IN BST</span></h2><p><img src="\images\이진탐색트리에서의삭제개념도.png" alt="이진 탐색 트리에서의 삭제 개념도"></p>
<p><strong>Time Complexity: O(h)</strong></p>
<p>BST 에서의 삭제는 다음과 같이 진행된다.</p>
<ol>
<li>BST에서 해당 노드를 찾음</li>
<li>해당 노드를 삭제하고, maximum value in left subchild 로 대체 하거나 혹은 minimum in right subchild 로 대체한다.</li>
<li>대체된 노드에 대한 삭제를 진행한다. 이 경우 해당 노드는 차수가 0이거나 혹은 1 이므로 삭제는 매우 간편하다.</li>
</ol>
<p>위의 각 과정별로 시간 소모를 생각해 보면, 노드를 찾는데에 O(h), 삭제하고 서브 트리에서 값을 찾는데에 O(h) 삭제에 1 이므로 BST 에서 deletion 시에 time Complexity 는 O(h) 이다.</p>
<h1><span id="선택-트리">선택 트리</span></h1><h2><span id="승자-트리">승자 트리</span></h2><p>다음은 8개의 런(k=8) 을 가진 승자 트리의 개념도 입니다.</p>
<p><img src="\images\선택트리의개념도.png" alt="선택 트리의 개념도"></p>
<h2><span id="패자-트리">패자 트리</span></h2><p>다음은 위의 승자 트리에 대응하는 패자 트리의 개념도 입니다.</p>
<p><img src="\images\패자트리의개념도.png" alt="패자 트리의 개념도"></p>
<h1><span id="분리-집합의-표현">분리 집합의 표현</span></h1><h1><span id="이진-트리의-개수-계산">이진 트리의 개수 계산</span></h1><h1><span id="avl-트리">AVL 트리</span></h1><p>AVL 트리란 균형 이진 트리의 한 종류이며, 이원 탐색트리가 항상 완전 이진트리로 유지되도록 한 트리입니다.</p>
<p><strong>탐색, 삽입, 삭제 시간: O(logn)</strong></p>
<p>AVL 트리에서 각 노드는 <strong>균형 인자(balance factor)</strong> 를 가지는데, 이는 왼쪽 트리의 높이에서 오른쪽 트리의 높이를 뺀 값으로 높이의 균형도를 나타냅니다.</p>
<p><strong>balance factor = h_L - h_R</strong></p>
<p>AVL 트리에서는 어떤 서브트리 T 에서도 BF(T) 의 절대값은 1 이하입니다.</p>
<h2><span id="avl-트리에서의-삽입">AVL 트리에서의 삽입</span></h2><p><strong>LL rotation</strong></p>
<p><img src="\images\lL로테이션.png" alt="LL 로테이션"></p>
<p><strong>RR rotation</strong><br><strong>LR rotation</strong></p>
<p><img src="\images\lR로테이션.png" alt="LR 로테이션"></p>
<hr>

                        
    </div>
    
        <div class="columns is-variable is-1 is-multiline is-mobile">
            
                <span class="column is-narrow">
                    <a class="tag is-light article-tag" href="/tags/data-structure/">#
                        data structure
                    </a>
                </span>
                
        </div>
        
            
                <div class="columns is-mobile is-multiline article-nav">
                    <span class="column is-12-mobile is-half-desktop  article-nav-prev">
                        
                            <a href="/2018/03/27/자료구조-히프(Heap)/">
                                자료구조 | 히프 구조
                            </a>
                            
                    </span>
                    <span class="column is-12-mobile is-half-desktop  article-nav-next">
                        
                            <a href="/2018/03/27/자료구조-강의-09-우선순위-큐/">
                                자료구조 강의 09. 우선순위 큐
                            </a>
                            
                    </span>
                </div>
                
</article>


    <div class="sharebox">
        
<div class="sharethis-inline-share-buttons"></div>
<script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5b29f0b2a7603d0012fa866b&amp;product=inline-share-buttons" async="async"></script>

    </div>
    

        
            <div class="comments">
                <h3 class="title is-4">
                    Comments
                </h3>
                
<script>
    var disqus_config = function () {
        this.page.url = 'http://frontalnh.github.io/2018/03/27/자료구조-트리/';
        this.page.identifier = '2018/03/27/자료구조-트리/';
        
        this.language = 'en';
        
    };
    (function() {
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'jake-lee-blog' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<div id="disqus_thread">
    
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            </div>
            
    </div>
</section>
            <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 Jake.Lee 이남훈&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" href="https://github.com/frontalnh">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
                <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        //plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110077250-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-110077250-2');
</script>


    


<script src="/js/script.js"></script>

                    
                        <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
                            
</body>

</html>