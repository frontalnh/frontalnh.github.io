{"pages":[{"title":"About","text":"","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"12 factor app 시작하기","text":"1. codebase Introduction of git flow Start programming with a feature branch release version hotfix 2. Dependencies 3. Configuration 4. Backing services 1. codebase모든 어플리케이션 코드는 version control system 을 통해 하나로 관리되어야 한다. 가령 여러개의 루트 repository 가 있다면 이것은 앱이 아니라 하나의 분산 시스템에 가까울 것이다. 하나의 코드베이스에서 여러개의 배포를 진행할 수 있고, 각 배포버전별로 코드 버전이 관리된다면 훌륭할 것이다. Introduction of git flow일반적인 프로젝트에서 이러한 버전관리는 훌륭한 버전관리 툴인 git 을 사용해서 진행하며 git flow 는 훌륭한 워크플로우를 제공한다. install git flow on Mac 1brew install git-flow start git flow project 1git flow init 다음은 git flow 에서 브랜치의 종류와 그 역할에 대해 알려준다. master branch 는 실제 공식 배포버전을 관리하며 일반적으로 production deploy 버전을 관리한다. feature branch 는 실제 각 개발자들이 작업을 하는 브랜치이며, 이는 develop 브랜치에서 갈라져 나오고 추후 다시 develop 브랜치로 병합된다. develop 브랜치는 각 개발자들이 작업한 브랜치들이 머지되는 장소이며 모든 커밋의 내용이 기록된다. release branch 는 develop 브랜치로 부터 당겨져오며 여기에서는 오직 버그 수정이나 혹은 documentation 수정 등 release 와 관련된 작업들만 수행된다. 이를 통해 특정 팀에서 해당 release 버전으로 테스트 혹은 출시준비과정을 진행하는 동안 다른 브랜치에서 작업을 수행하며, 다음 release 전까지 해결될 사항들을 정리할 수 있다. 해당 브랜치는 develop 으로부터 갈라져 나온다. 만약 코드리뷰를 한다면 해당 브랜치에서 하는 것이 가장 깔끔해 보인다. hotfix branch hotfix 브랜치는 바로 master branch 에서 갈라져 나와 빠른 버그 수정 등을 수행하는 branch 이며, 버그가 수정되면 재빨리 다시 master 브랜치로 머지되어야 한다. 이 브랜치는 master 브랜치로부터 갈라져 나오는 유일한 브랜치이다. Start programming with a feature branch아래 명령어로 새로운 develop 브랜치로 부터 feature 브랜치를 만들어서 갈라져 나온다. 12345678910111213141516# 로컬에 새 브랜치 생성git flow feature start branch_name# 리모트 브랜치에 배포git flow feature publish branch_name# 새로운 내용을 커밋git add .git commit -m \"content\"git push# 머지를 요청하기 전에 반드시 리베이스를 받는다git pull -r origin develop# feature 브랜치 머지git feature finish branch_name release version새로운 버전을 출시하기 위한 git flow 코드는 다음과 같다. 12345# from develop branchgit flow release start 0.0.1# from release branchgit flow release finish 0.0.1 hotfix공식 배포 버전에서 빠른 버그 수정을 위한 hotfix 브랜치에서 작업을 하는 과정은 다음과 같다. 12git flow hotfix start hotfix_branchgit flow hotfix finish hotfix_branch 2. Dependencies어플리케이션을 작성함에 있어 다양한 외부 라이브러리들에 의존하게 된다. 특히 각 언어별로 존재하는 패키지 매니저를 사용한다면 글로벌하게 설치되는 패키지도 있고 내부적으로 설치되는 패키지도 있는데 이처럼 글로벌하게 설치되는 패키지의 경우 시스템 환경에 어플리케이션이 의존하게 되는 문제가 있다. 12 factor app 에서는 이러한 시스템 환경에 전혀 의존하지 않는 프로그램을 작성함을 원칙으로 한다. 가령 node.js 환경에서 어플리케이션을 개발하는 경우 npm 패키지를 설치함에 있어 package.json 이라는 패키지 관리 documentation 을 하게 된다. 이처럼 의존하는 dependency 를 명확하게 명시하여서 다른 시스템 환경에서도 바로 빌드가 되어 오류없이 프로그램이 실행하도록 한다. 3. Configuration대부분의 경우 어플리케이션은 배포할때마다 다른 configuration 이 필요하게 된다. 가령 develop server 의 경우 develop database 에 연결되어야 하고, production server의 경우 production database에 연결되어야 하는 것처럼 어플리케이션의 소스코드와는 달리 이러한 설정 값들은 배포마다 달라지게 된다. 때문에, 12 factor app 에서는 이러한 설정값을 코드베이스에 포함시키는 것을 엄격하게 금지하고 있으며, 이러한 모든 설정들을 environment variable 에 저장하는 것을 추천한다. 이러한 env variable 들은 여러 deployment setting 에 대해 혼합된 정보를 절대 가지지 않으며 각 배포환경마다 독립되게 존재하여야 한다. 4. Backing services가령 이메일 서버나 혹은 데이터 베이스와 같이 어플리케이션이 동작하는데 필요한 부수적인 다른 서비스들을 backing service 라고 부른다. 이러한 backing service 들은 언제나 장애가 생길 수 있으므로 12 factor app 에서는 그 어떤 코드의 변경 없이 백업으로 준비된 backing service 에 붙을 부 있어야 한다. 참조 - 12 factor app","link":"/2019/01/17/12-factor-app-시작하기/"},{"title":"Angular FormData를 활용한 파일 입력 받기","text":"html 상에서 input (type=file) 만들기1&lt;input type=&quot;file&quot; (change)=&quot;onChange($event)&quot;&gt;&lt;/input&gt; onChange로 file 추출 및 저장하기123onChange(event)&#123; let file = event.srcElement.files[0];&#125; formData에 key, value 매핑하기123456789101112console.log(file);폼데이터를 선언한다.let formData:FormData = new FormData();formData에 key와 value를 메겨준다.formData.append(&apos;fileName&apos;,this.fileName+&apos;.&apos;+file.name.split(&apos;.&apos;)[1]);여기서 file.name.split(&apos;.&apos;)[1]는 확장자를 찾아주는 것이다.formData.append(&apos;imageFile&apos;, file, file.name); 참조자료","link":"/2017/11/19/Angular-FormData를-활용한-파일-입력-받기/"},{"title":"Angular Production Build","text":"123ng build --prodng build --aot","link":"/2017/11/19/Angular-Production-Build/"},{"title":"Angular Router의 활용","text":"라우터 및 라우팅 파라미터 설정Route를 활용하여 라우팅을 할 경로와 매칭하는 컴포넌트를 선언한다. Example12345export const routes: Routes = [ &#123; path: &apos;&apos;, redirectTo: &apos;product-list&apos;, pathMatch: &apos;full&apos; &#125;, &#123; path: &apos;product-list&apos;, component: ProductList &#125;, &#123; path: &apos;product-details/:id&apos;, component: ProductDetails &#125;]; 여기서 :id는 해당 경로의 라우팅 할때의 파라미터 값이 들어간다. 특정 라우팅을 수행하는 링크 걸기html태그에서 해당 라우팅으로 이동할 수 있도록 링크를 걸 수 있다. Example - html 코드 내에서 라우팅 시키는 경우 undefined example - 컴포넌트 상에서 라우팅 시키는 경우123goToProductDetails(id) &#123; this.router.navigate([&apos;/product-details&apos;, id]);&#125; 참고자료 라우팅 이벤트를 감지하여 함수 실행시키기라우팅이 일어날 때마다 해당 이벤트를 감지하여 함수를 실행시킨다. Example12345678910constructor(router:Router) &#123; router.events.subscribe(event:Event =&gt; &#123; if(event instanceof NavigationStart) &#123; &#125; // NavigationEnd // NavigationCancel // NavigationError // RoutesRecognized &#125;);&#125; 현 페이지의 라우터 전달값을 받기12345this.route.params.subscribe( params=&gt;&#123; this.sectionIndex=params[&apos;pageIndex&apos;]; &#125;)","link":"/2017/11/19/Angular-Router의-활용/"},{"title":"Angular Structural Directives의 활용","text":"structural DirectivengFor어레이를 돌면서 반복적으로 나타내기 위한 요소이다.흔히 리스트를 출력할 때 사용한다. ngFor 내에서 인덱스를 붙이는 경우의 활용1&lt;li *ngFor=&quot;let item of items; index as i; trackBy: trackByFn&quot;&gt;...&lt;/li&gt; ngFor 안에서 ngFor를 사용하는 경우의 활용1*ngFor=&quot;let subMenuName of menuName[&apos;submenu&apos;]; let idx = index;&quot; ngIf","link":"/2017/11/19/Angular-Structural-Directives의-활용/"},{"title":"Angular hmr 적용하기","text":"hmr 이란?Hot Module Replacement의 약자로 모듈의 변경사항을 실시간으로 어플리케이션에 반영한다. angular에 environment 추가하기environment.hmr.ts 파일 만들기1234export const environment = &#123; production: false, hmr: true&#125;; src/environments/environment.prod.ts 수정하기1234export const environment = &#123; production: true, hmr: false&#125;; src/environments/environment.ts 수정하기1234export const environment = &#123; production: false, hmr: false&#125;; angular-cli.json 수정하기123456&quot;environmentSource&quot;: &quot;environments/environment.ts&quot;,&quot;environments&quot;: &#123; &quot;dev&quot;: &quot;environments/environment.ts&quot;, &quot;hmr&quot;: &quot;environments/environment.hmr.ts&quot;, &quot;prod&quot;: &quot;environments/environment.prod.ts&quot;&#125;, package.json 수정하기12345678&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;ng serve&quot;, &quot;hmr&quot;: &quot;ng serve --hmr -e=hmr&quot;, &quot;lint&quot;: &quot;tslint \\&quot;src/**/*.ts\\&quot;&quot;, &quot;test&quot;: &quot;ng test&quot;, &quot;pree2e&quot;: &quot;webdriver-manager update&quot;, &quot;e2e&quot;: &quot;protractor&quot;&#125; npm run hmr 명령어를 통해 environment를 적용할 수 있다. hmr 모듈 import 하기1npm install --save-dev @angularclass/hmr src/hmr.ts 생성하기123456789101112131415import &#123; NgModuleRef, ApplicationRef &#125; from &apos;@angular/core&apos;;import &#123; createNewHosts &#125; from &apos;@angularclass/hmr&apos;;export const hmrBootstrap = (module: any, bootstrap: () =&gt; Promise&lt;NgModuleRef&lt;any&gt;&gt;) =&gt; &#123; let ngModule: NgModuleRef&lt;any&gt;; module.hot.accept(); bootstrap().then(mod =&gt; ngModule = mod); module.hot.dispose(() =&gt; &#123; const appRef: ApplicationRef = ngModule.injector.get(ApplicationRef); const elements = appRef.components.map(c =&gt; c.location.nativeElement); const makeVisible = createNewHosts(elements); ngModule.destroy(); makeVisible(); &#125;);&#125;; src/main.ts 수정하기123456789101112131415161718192021222324import &#123; enableProdMode &#125; from &apos;@angular/core&apos;;import &#123; platformBrowserDynamic &#125; from &apos;@angular/platform-browser-dynamic&apos;;import &#123; AppModule &#125; from &apos;./app/app.module&apos;;import &#123; environment &#125; from &apos;./environments/environment&apos;;import &#123; hmrBootstrap &#125; from &apos;./hmr&apos;;if (environment.production) &#123; enableProdMode();&#125;const bootstrap = () =&gt; platformBrowserDynamic().bootstrapModule(AppModule);if (environment.hmr) &#123; if (module[ &apos;hot&apos; ]) &#123; hmrBootstrap(module, bootstrap); &#125; else &#123; console.error(&apos;HMR is not enabled for webpack-dev-server!&apos;); console.log(&apos;Are you using the --hmr flag for ng serve?&apos;); &#125;&#125; else &#123; bootstrap();&#125; 새로운 환경 반영하기1npm run hmr 출처","link":"/2017/12/16/Angular-hmr-적용하기/"},{"title":"Angular host listener의 활용","text":"Host Listener란?호스트의 이벤트를 감지하는 라이브러리 HostListener Decorator Component 작성아래와 같이 호스트의 이벤트를 감지한다.여기서 window는123456789101112import &#123; HostListener&#125; from &quot;@angular/core&quot;;import &#123; DOCUMENT &#125; from &quot;@angular/platform-browser&quot;;import &#123; Inject &#125; from &quot;@angular/core&quot;;export class LayoutNavComponent implements OnInit &#123; constructor(@Inject(DOCUMENT) private document: Document) &#123; &#125;&#125;@HostListener(&quot;window:scroll&quot;, [])onWindowScroll() &#123; //we&apos;ll do some stuff here when the window is scrolled let windowScrollPos = this.document.documentElement.scrollTop;&#125; observable과 throttle을 활용하여 event 반응하기throttle time이 200ms인 observable을 생성하고, subject를 통해 새로운 인자값을 전달한다.생성한 observable을 subscribe 해 주고, subject를 통해 계속해서 새로운 인자값을 전달한다.12345678910111213141516171819202122import &#123; Subject &#125; from &apos;rxjs/Subject&apos;;import &apos;rxjs/add/operator/throttleTime&apos;;export class AppComponent implements OnInit &#123; private resizeSubject = new Subject&lt;number&gt;(); private resizeObservable = this.resizeSubject.asObservable().throttleTime(200); @HostListener(&apos;window:resize&apos;, [&apos;$event.target.innerWidth&apos;]) onResize(width: number) &#123; this.resizeSubject.next(width); &#125; ngOnInit() &#123; this.resizeObservable.subscribe(x =&gt; this.doSomethingWithThrottledEvent(x)); &#125; private doSomethingWithThrottledEvent(width: number) &#123; // . . . &#125;&#125; 참조","link":"/2017/12/04/Angular-host-listener의-활용/"},{"title":"Angular ng-bootstrap을 활용한 Modal 사용법","text":"angular에서 bootstrap 활용을 위한 ng-bootstrap 패키지를 활용하여 모달을 사용한다. ModalService의 준비12345678910111213141516171819202122import &#123; Injectable &#125; from &apos;@angular/core&apos;;// 모달을 사용하기 위한 importimport &#123;NgbModal, NgbActiveModal&#125; from &apos;@ng-bootstrap/ng-bootstrap&apos;;import &#123; LoginModalComponent &#125; from &apos;../_components/login-modal/login-modal.component&apos;;import &#123; ApplyCheckModalComponent &#125; from &apos;../_components/apply-check-modal/apply-check-modal.component&apos;;@Injectable()export class ModalService &#123; constructor(private modalService: NgbModal) &#123; &#125; openLoginModal()&#123; const modalRef = this.modalService.open(LoginModalComponent); modalRef.componentInstance.name = &apos;World&apos;; &#125; // open apply checking modal openApplyCheckModal()&#123; const modalRef = this.modalService.open(ApplyCheckModalComponent); //필요한 데이터를 전달 modalRef.componentInstance.name = &apos;World&apos;; &#125;&#125; 원래는 NgbModal 모듈을 이용하여 바로 특정 모달 컴포넌트를 여는 방식이지만여러 페이지에서 다양한 모달을 쉽게 열고 닫기 위해서 새로운 ModalService 서비스를 만들었다. 이 서비스에서 열고자 하는 다양한 modal component를 import하여 쉽게 열 수 있다. 또한 MgbModal을 통해 open 한 modal에 componentInstance를 통해 data를 전달할 수 있다. Modal Component.ts123456789101112131415161718192021222324import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123;NgbModal, NgbActiveModal&#125; from &apos;@ng-bootstrap/ng-bootstrap&apos;;import &#123; Router, ActivatedRoute &#125; from &apos;@angular/router&apos;;@Component(&#123; selector: &apos;app-login-modal&apos;, templateUrl: &apos;./login-modal.component.html&apos;, styleUrls: [&apos;./login-modal.component.css&apos;]&#125;)export class LoginModalComponent implements OnInit &#123; constructor(public activeModal: NgbActiveModal) &#123; &#125; ngOnInit() &#123; // reset login status this.authenticationService.logout(); &#125; close()&#123; this.activeModal.close(); &#125;&#125; 모달 내에서 모달을 닫기 위해 NgbActiveModal 모듈을 사용하였다. Modal Component.html123456789101112&lt;div&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;div class=&quot;&quot; style=&quot;text-align:center;&quot;&gt; &lt;span style=&quot;font-weight:bold; margin-right:1rem;&quot;&gt;아이디가 없으신가요?&lt;/span&gt; &lt;span&gt;&lt;a [routerLink]=&quot;[&apos;/register/selectTypePage&apos;]&quot; style=&quot;color:#65b8b4; font-weight:bold;&quot; (click)=&quot;close()&quot;&gt;회원가입&lt;/a&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;/div&gt;&lt;/div&gt; 모달을 한번 감싸주고그 안에서 modal-header, modal-body, modal-footer class 들을 사용하여 안을 꾸며준다. Module.ts 에 등록12345678910@NgModule(&#123; declarations: [ ], imports: [ ], providers: [ ], bootstrap: [], entryComponents: [EmailCheckModalComponent]&#125;) app.module의 entryComponents에 등록하여 미리 컴포넌트를 로드시켜 놓는다. 참조하기","link":"/2017/11/19/Angular-ng-bootstrap을-활용한-Modal-사용법/"},{"title":"Angular ngx infinite scroll을 이용한 무한 스크롤 구현","text":"설치하기1npm install ngx-infinite-scroll --save 동작 특성window scroll 이벤트를 감지하여 callback을 발생시킨다.실제 요소가 스크롤 될때 콜백을 수행하기 위해서는 다음 설정이 되어야 한다. 12[scrollWindow]=&quot;false&quot;set an explict css &quot;height&quot; value to the element import 하기1234567891011121314import &#123; NgModule &#125; from &apos;@angular/core&apos;;import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;import &#123; InfiniteScrollModule &#125; from &apos;ngx-infinite-scroll&apos;;import &#123; platformBrowserDynamic &#125; from &apos;@angular/platform-browser-dynamic&apos;;import &#123; AppComponent &#125; from &apos;./app&apos;;@NgModule(&#123; imports:[ BrowserModule, InfiniteScrollModule ], declarations: [ AppComponent, ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125;platformBrowserDynamic().bootstrapModule(AppModule); 아래 예제에서는 스크롤이 내려가면 onScroll 함수가 호출된다.123456789101112131415161718import &#123; Component &#125; from &apos;@angular/core&apos;;@Component(&#123; selector: &apos;app&apos;, template: ` &lt;div class=&quot;search-results&quot; infiniteScroll [infiniteScrollDistance]=&quot;2&quot; [infiniteScrollThrottle]=&quot;50&quot; (scrolled)=&quot;onScroll()&quot;&gt; &lt;/div&gt; `&#125;)export class AppComponent &#123; onScroll () &#123; console.log(&apos;scrolled!!&apos;) &#125;&#125;","link":"/2017/12/06/Angular-ngx-infinite-scroll을-이용한-무한-스크롤-구현/"},{"title":"Angular polyfill을 활용한 exploler호환","text":"angular application을 ie에서 사용할때 ie는 Object.assign()을 지원하지 않기 때문에 polyfill.ts를 사용하여야 한다. polyfills.ts에는 이미 ie와 사파리 브라우저에서 사용하기 위한 다양한 import가 주석처리 되어 있으므로 이를 주석해제하면 해결할 수 있다. 파이프를 사용하기 위한 intl 설치1npm install --save intl 애니메이션 사용을 위한 web-animation설치1npm install --save web-animations-js ngClass 사용을 위한 classlist설치1npm install --save classlist.js","link":"/2017/12/01/Angular-polyfill을-활용한-exploler호환/"},{"title":"Angular 다양한 종류의 Template and Data Binding","text":"Template And Data Binding in Angular를Angular에서는 다양한 종류의 Binding을 제공한다.binding의 종류에 따라 (element / component / directive) property (element / component / directive) event (rarely) an attribute name. 의 세가지 경우가 있다. property bindinghtml 태그의 다양한 속성을 바인딩 해준다. 대상Element propertyComponent propertyDirective property example1예제에서 보여지듯이 다양한 종류의 속성을 바인딩 할 수 있다.이미지를 불러오는 경로인 (src) 컴포넌트의 입력값을 주는 [hero] 바인딩, class 속성을 가르쳐주는 [ngClass] 등의바인딩 사례가 있다. 123&lt;img [src]=&quot;heroImageUrl&quot;&gt;&lt;app-hero-detail [hero]=&quot;currentHero&quot;&gt;&lt;/app-hero-detail&gt;&lt;div [ngClass]=&quot;&#123;&apos;special&apos;: isSpecial&#125;&quot;&gt;&lt;/div&gt; example2[ngStyle]을 활용하여 동적으로 background-image 할당. 1&lt;div class=&quot;profile-image&quot; [ngStyle]=&quot;&#123; &apos;background-image&apos;: &apos;url(&apos; + image + &apos;)&apos;&#125;&quot;&gt; Event Bindinghtml 태그에서 발생하는 다양한 종류의 event에 대한 binding이다. 대상Element eventComponent eventDirective event example 123&lt;button (click)=&quot;onSave()&quot;&gt;Save&lt;/button&gt;&lt;app-hero-detail (deleteRequest)=&quot;deleteHero()&quot;&gt;&lt;/app-hero-detail&gt;&lt;div (myClick)=&quot;clicked=$event&quot; clickable&gt;click me&lt;/div&gt; (click)을 통해 클릭을 하는 시점에 함수를 발동하는 등의 역할을 수행한다. (focus) and (focusout)input 등의 경우 입력모드가 발동된 시점이나 특정 element가 focus 된 경우 동작을 나타낸다. example 1&lt;input name=&quot;date&quot; type=&quot;text&quot; (focus)=&quot;focusFunction()&quot; (focusout)=&quot;focusOutFunction()&quot;&gt; (ngModelChange)해당 모델의 데이터 값이 바뀔 때마다 특정 함수를 실행할 수 있다. Example undefined 참고자료 Two Way Binding을이벤트와 속성등을 양방향으로 연결하는 바인딩이다. 대상Event and property example 1&lt;input [(ngModel)]=&quot;name&quot;&gt; Attribute Binding대상Attribute example 1&lt;button [attr.aria-label]=&quot;help&quot;&gt;help&lt;/button&gt; 다음과 같이 value, selected를 바인딩 하는 데에도 사용 가능하다.참조 undefined class binding특정 조건에서 class를 바인딩 해준다. example 1&lt;div [class.special]=&quot;isSpecial&quot;&gt;Special&lt;/div&gt; style binding스타일 속성을 바인딩한다. example 1&lt;button [style.color]=&quot;isSpecial ? &apos;red&apos; : &apos;green&apos;&quot;&gt; 너비, 높이 등을 유동적으로 세팅하기 위해 다음과 같은 코드를 흔히 사용한다. 123&lt;div class=&quot;home-component&quot; [style.width.px]=&quot;width&quot; [style.height.px]=&quot;height&quot;&gt;Some stuff in this div&lt;/div&gt; 사이즈 조절을 위한 style binding Structural DirectiveHTML Layout에 영향을 주는 요소들이다.대표적으로ngIf ngFor 등이 있다.","link":"/2017/11/19/Angular-다양한-종류의-Template-and-Data-Binding/"},{"title":"Angular 무한 스크롤 적용하기","text":"알고리즘 pseudo code 페이지 로딩 시점에 get(9) 스크롤바가 하단에 가까우면 받아오고, 받아오기 인덱스 trueif(height&lt;200px)get(9)getIndex=true 받아오는 동안에는 요청 안하기if(getIndex==true)return 0 받아온 값이 없을 경우에는 return 0하고 searchEndIndex를 true로 하기if(res.length==0)return 0searchEndIndex=true HostListener Decorator Component 작성아래와 같이 호스트의 이벤트를 감지한다. 123456789101112131415161718import &#123; HostListener, Inject&#125; from &quot;@angular/core&quot;;import &#123; DOCUMENT &#125; from &quot;@angular/common&quot;;export class LayoutNavComponent implements OnInit &#123; constructor(@Inject(DOCUMENT) private document: Document) &#123; &#125;&#125;@HostListener(&quot;window:scroll&quot;, [&apos;$event.target&apos;])onWindowScroll() &#123; //we&apos;ll do some stuff here when the window is scrolled console.log(this.document.body.scrollHeight); console.log(&quot;scrollTop:&quot;,this.document.documentElement.scrollTop); let scrollHeight=this.document.documentElement.scrollHeight; let readHeight=this.document.documentElement.scrollTop+this.document.documentElement.clientHeight; if((-10&lt;=(readHeight-scrollHeight))&amp;&amp;((readHeight-scrollHeight)&lt;=10))&#123; this.groupService.getGroupsBySearchKey(this.locationService.locationDepth1, this.locationService.locationDepth2, this.groupService.searchKey); &#125;&#125; scroll event의 성능향상을 위한 Tip모든 이벤트 마다 onScroll 함수를 발생시키면 CPU의 성능을 많이 차지하므로다음과 같이 함수에 delay를 주어 이를 해결할 수 있다.123456789101112function () &#123; if (waiting) &#123; return; &#125; waiting = true; scroll(); setTimeout(function () &#123; waiting = false; &#125;, 100);&#125; 하드웨어 가속시키기하드웨어 가속이란 그래픽 처리 장치를 이용하여 중앙처리 장치의 처리량을 줄이고, 브라우저의 렌더링을 효율화하는 것을 말한다.css 작업에 하드웨어 가속을 활성화하면, 작업처리가 빨라져서 웹페이지의 렌더링을 보다 빠르게 할 수 있다. 특정 엘레멘트에 어떤 지시를 내리면 엘리먼트는 자신의 레이어에 분류되고 페이지에 있는 다른 엘리멘트와 독립되어 렌더링 된다.결론만 말하면 css에 다음과 같은 속성을 붙이면 하드웨어를 가속화 하여 빨리 렌더링이 가능하다.1transform: 3dtransforms(0,0,0) 위 명령어는 3d가 아닌 엘레먼트에 가짜로 3d속성을 주므로써 해당 element의 렌더링을 cpu가 아닌 gpu가 담당하게 하여 렌더링 속도를 높이며, will-change 명령어는 엘레먼트에 어떤 변경을 할 것인지 브라우저에게 미리 알려주므로써 최적화 하는 것이다. 페이지는 순식간에 갱신돼 부드러운 화면처리가 가능하게 된다. 참조","link":"/2017/11/19/Angular-무한-스크롤-적용하기/"},{"title":"Angular의 기본 개념 및 사용","text":"기본 명령어 Component Module declaration imports bootstrap Service WorkFlow main.ts 라이브러리 Express Example 활용법 Structural Deretive Pipe Method in Components Model Property Binding Class Binding Event Binding (click)=”func()” Two Way Binding Routes Http Library 언디파인 방지 기본 명령어새 프로젝트 만들기 ng new [project name] 빌드 및 실행 $ ng build$ node server.js 참고 페이지 Component컴포넌트는 어플리케이션을 구성하는 작은 조각이다. @Component 를 클래스 위에 선언하여 컴포넌트를 꾸며주고 필요한 정보를 명시한다. Selector selector는 css선택자이며, 태그의 이름이다. template 우리가 로드하려고 하는 템플릿을 작성한다. 브래킷인 `안에 작성한다.` 각컴포넌트는 html, css, class를 가진다. 컴포넌트는 template을 가진 일종의 directive이다. ng generate component [componentname]을 통해 아주 간편하게 컴포넌트를 생성할 수 있다. Module모듈은 우리의 어플리케이션을 angulr하게 조직하기 위해 필요한 것이다. 모든 어플리케이션은 앱을 lauch하기 위한 적어도 하나의 root module을 가진다. 모듈은 기능적으로 관력이 있는 컴포넌트들을 묶어준다. declaration컴포넌트들을 선언한다. imports브라우저에서 앱을 런칭하기 위해 필요한 디펜던시를 인젝트해준다. bootstraproot component를 명시하여 모듈이 bootstrap될 때 render하도록 한다. Service컴포넌트 사이에 중복된 코드와 데이터를 교환하는데 사용된다. WorkFlow Service에 @Injectable()을 추가한다. 뿐만 아니라 import{Injactable} from “@angular/core”도 해주어야 한다. Injector 즉, Module에게 Providers를 제공하여 서비스에 대해 알게 해야 한다. providers:[Service] 컴포넌트에 Dependency를 Inject 해준다. ngOnInit() : constructor(pricate service:Service){} main.ts필요한 라이브러리를 import해준다. BrowserModule 앵귤러 웹사이트를 동작하기 위한 라이브러리이다. platformBrowserDynamic 웹사이트를 render하기 위한 앵귤러의 라이브러리이다. 라이브러리ExpressExpress는 자체적인 최소한의 기능을 갖춘 라우팅 및 미들웨어 웹 프레임워크이며, Express 애플리케이션은 기본적으로 일련의 미들웨어 함수 호출입니다. app.use() 및 app.METHOD() 함수를 이용해 애플리케이션 미들웨어를 앱 오브젝트의 인스턴스에 바인드하십시오. 이때 METHOD는 미들웨어 함수가 처리하는 요청(GET, PUT 또는 POST 등)의 소문자로 된 HTTP 메소드입니다. 다음 예에는 마운트 경로가 없는 미들웨어 함수가 표시되어 있습니다. 이 함수는 앱이 요청을 수신할 때마다 실행됩니다. Example12345var app = express();app.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;); 활용법Structural Deretivehtml element들을 추가 제거 대체하여 레이아웃을 변형한다.*ngFor = &quot;let carPart of catParts&quot;어레이를 돌며 객체를 꺼낼때 사용한다. *ngIf=&quot;carPart.inStock&gt;0&quot; if문을 사용한다. Pipetemplate output을 변형하기 위해 쓰인다. Method in Componentstemplate output을 변형하기 위해 쓰이며, 선언없이 바로 정의한다. Model특정 객체를 선언하도록 ts에서 선언한다.export constexport const를 통해 상수 객체를 선언하고 가져다 쓸 수 있따. Property Binding프로퍼티 바인딩은 컴포넌트의 property를 any Dom element property로 지정할 수 있게 한다.여기서 컴포넌트의 property가 업데이트 되면 DOM도 자동으로 업데이트 된다.하지만 DOM에서 업데이트 되었다고 컴포넌트의 property가 업데이트 되지는 않는다. Class Binding[class.name]=&quot;property&quot;를 통해 property가 참이면 클래스에 name을 추가할 수 있다. Event BindingDOM에서 발생하는 다양한 이벤트들을 처리할 수 있다. (click)=”func()”클릭이벤가 발생하면 컴포넌트의 func()를 실행시킨다. Two Way Binding[(ngModel)}=&quot;property&quot;이를 통해 two way data binding이 가능하다.이를 쓰기 위해서는 FormModule을 Import해야 한다. RoutesAngular 내에서 url을 부여하여 옮겨다니기 위함이다. RouterModule을 Import 해준다.import{RouterModule} from &quot;@angular/router&quot; RouterModule을 imports에 추가해 준다..forRoot([{path:&quot;/race&quot;,component:raceComponent},{}]) 링크를 걸어준다.a [routerLink]=&quot;[&#39;/races&#39;]&quot; router-outlet 태그를 먹여준다.&lt;router-outlet&gt;&lt;/router-outlet&gt; Http Library json파일을 만든다. HttpModule을 Import 해준다.Http를 위한 library를 추가해야 하지만 HttpModule 내에서 이미 서비스를 provide하므로 할필요 없다. injector에 httprovider를 추가해준다. 서비스에 http를 dependency inject해준다. 그리고 get request를 한다. req에 의해 반환되는 data를 listen한다. 언디파인 방지if(Array.isArray(this.carParts){}로 감싸 this.carParts가 undefined된 경우를 처리할 수 있다.","link":"/2017/11/17/Angular의-기본-개념-및-사용/"},{"title":"1. Angular Framework 시작하기","text":"설치하기 angular-cli 에서 scss 사용하기 angular migration Module entryComponents Component 컴포넌트 안에 input 주기 example [readonly]=”true” Library Angular bootstrap Angular material code flow Promise 세팅 로그인 구현 Work Flow ETC 주의 사항 설치하기앵귤러는 npm을 사용하여 다음과 같이 설치한다.이때 반드시 -g 옵션을 사용하여 global하게 설치를 해 주어야 ng 명령어가 등록이 되며, 앵귤러 cli를 설치하기에 앞서서 typescript기반인 angular를 동작시키기 위한 typescript를 설치해 주어야 한다.123sudo npm install -g typescriptsudo npm install -g @angular/cli@latestsudo npm install --save-dev @angular/cli@latest 만약 aws 환경에서 위 코드를 실행하면 root 권한으로 인한 많은 문제가 발생한다 이때는 뒤에 –unsafe-perm을 붙여서 설치해 준다.12sudo npm install -g @angular/cli@latest --unsafe-permsudo npm install --save-dev @angular/cli@latest --unsafe-perm 앵귤러를 설치한 후에는 앵귤러에 필요한 각종 모듈을 설치해 주면 되며 package.json을 설정하며 필요한 모듈을 설치한다.1npm install 도 추가적으로 설치해주어야 하는 기본적인 node-module이다.1sudo npm install underscore angular-cli 에서 scss 사용하기sass는 루비라는 언어로 동작하기 때문에 먼저 루비를 설치해 줍니다.리눅스와 맥의 경우는 루비가 기본으로 설치되어 있기 때문에 window의 경우만 설치해 줍니다. 다음의 링크를 통해 설치를 진행합니다.다운로드 반드시 64비트인 x64로 설치해 줍니다. ubuntu의 경우는 apt-get을 통해 설치하며 모든 설치 이후 다음 ruby-dev를 설치해주어야 한다.1apt-get install ruby-dev 루비 설치가 완료되었으면 다음 명령어를 통해 sass를 설치해 줍니다.1gem install sass sass를 설치하였으면 angular-cli를 활용하여 sass 기반의 프로젝트를 만듭니다.1ng new 프로젝트 이름 --style=sass 만약 기존의 프로젝트가 있는 경우라면 다음과 같이 css 기반 프로젝트를 sass기반 프로젝트로 바꾸어 줍니다.1ng set defaults.styleExt scss angualr-cli.json 에 다음의 내용을 추가해 줍니다.12345&#123; &quot;defaults&quot;: &#123; &quot;styleExt&quot;: &quot;scss&quot; &#125;&#125; angular migration참조 ModuleentryComponentsmodule.ts의 entryComponents는 html내에서 확인되는 태그가 아닌 동적으로만 생성되는 태그를 앵귤러가 알 수 있게 해준다.앵귤러는 이를 통해 태그를 찾고 컴파일을 수행한다.만약 html 내에서 확인되는 다른 많은 태그들은 단순히 declarations에만 있으면 된다. Component컴포넌트 안에 input 주기example undefined [readonly]=”true”인풋이 입력되지 않도록 읽기전용으로 바꾼다. LibraryAngular bootstrapnpm install --save @ng-bootstrap/ng-bootstrap Angular materialcode flow1234567891011//앵귤러 매터리얼 설치npm install --save @angular/material @angular/cdk//매터리얼에 필요한 애니메이션 설치npm install --save @angular/animationsimport &#123;BrowserAnimationsModule&#125; from &apos;@angular/platform-browser/animations&apos;;imports: [BrowserAnimationsModule],//달력입력박스를 위한 module.ts에서 임포트import &#123;MdButtonModule, MdCheckboxModule&#125; from &apos;@angular/material&apos;;// css 파일에서 추가시켜줌@import &quot;~@angular/material/prebuilt-themes/indigo-pink.css&quot;; Angular Material 시작하기 Promise세팅12npm install promisevar Promise = require(&apos;promise&apos;); 로그인 구현Work Flow _guards디렉토리 생성 alert component 생성 alert service 생성 auth guard생성 authentication service 생성 jasonwatmore의 Angular를 이용한 로그인 구현 포스팅 ETC주의 사항 임포트시 양방향으로 서로서로 import를 하는 circulr 임포트를 하면 안된다.","link":"/2017/11/17/Angular-시작하기/"},{"title":"Building a node.js app with typescript","text":"개요In this post, you will learn how to deploy a node.js server in a typescript environment. 기본적인 서버 및 데이터베이스의 구축에서 부터 실제 배포 및 개발환경 세팅에 이르는 실제 운영을 위한 여러 고려사항들을 검토하고 논의하며 ubuntu 운영체제를 기본 환경으로 사용한다. InstallationAt first, install node.js web server 먼저 홈페이지에 들어가서 노드js를 설치한다.nodejs 홈페이지 nodejs를 설치했다면 apt-get의 로컬 패키지를 업데이트 해준다.1sudo apt-get update 리눅스계열 os의 경우 다음 code로 설치한다.npm의 경우 원래는 nodejs 안에 포함되어 같이 깔리지만 커맨드가 안잡힌다면 아래 별도 명령어를 통해 다시 설치해 준다. 12sudo apt-get install -y nodejssudo apt-get npm cmd에서 node –version으로 설치가 잘 되었는지 확인하고 npm을 통해 다양한 모듈을 세팅한다.만약 aws 서버의 경우 보안 문제 때문에 제대로 설치가 되지 않을 수 있다.그럴때는 –unsafe-perm 을 붙여 설치를 진행해 본다.대부분의 문제가 해결될 것이다. npm의 버전이 맞지 않아 패키지 설치에 문제가 있는 경우 npm을 최신버전으로 업데이트 해야 한다.하지만, npm을 업데이트 하기 전에 그에 상응하는 최신 nodejs를 설치해 주기 위해 nodejs 버전관리 모듈인 n을 설치해 주고 새로운 nodejs를 설치해 준다.12sudo npm install n -gsudo n stable 설치가 완료된 뒤에 다음 명령어를 입력하여 제대로 버전이 바뀌었는지를 확인한다.1node -v 여기서 버전이 제대로 업데이트 되지 않았다면 다음과 같이 수동으로 입력해 준다.1sudo ln -sf /usr/local/n/versions/node/6.0.0/bin/node /usr/bin/node npm을 최신으로 업데이트 해 준다.1sudo npm install npm@latest -g shell을 재실행 시킨 뒤 npm의 버전이 변경되었는지 확인한다.1npm -v Compile Typescripttypescript 컴파일러인 tsc 를 통해 다음과 같이 컴파일 할 수 있다. 1tsc typescript compile 할 때에 필요한 다양한 옵션을 tsconfig.json 파일에 명실 할 수 있다. 필자의 경우는 file import 시에 다음과 같이 alias 를 사용하였기 때문에 해당 alias 의 위치를 tsc 가 찾을 수 있도록 tsconfig.json 에 paths를 등록해 준다. 1234567891011121314151617181920212223242526&#123; \"compilerOptions\": &#123; \"target\": \"es6\", \"module\": \"commonjs\", \"sourceMap\": true, \"allowSyntheticDefaultImports\": true, \"allowJs\": true, \"outDir\": \"./dist/\", \"noImplicitAny\": false, \"lib\": [\"es2015\"], \"esModuleInterop\": true, \"experimentalDecorators\": true, \"emitDecoratorMetadata\": true, \"baseUrl\": \"./src\", \"paths\": &#123; \"@domain/*\": [\"server/domain/*\"], \"@common/*\": [\"server/common/*\"], \"@utils/*\": [\"server/utils/*\"], \"@infra/*\": [\"server/infra/*\"], \"@api/*\": [\"server/api/*\"], \"@interfaces/*\": [\"server/interfaces/*\"] &#125; &#125;, \"include\": [\"./src/**/*\"], \"exclude\": [\"node_modules\", \"**/*.spec.ts\"]&#125; 이처럼 path의 경우 단지 컴파일러에게 해당 파일이 어디에 있는지에 대한 위치정보만을 가르쳐줄 뿐이며, 이는 컴파일되어도 alias의 값이 그대로 들어가게 된다. 이러한 module-alias 를 실행하기 위해서는 다음과 같이 module-alias 를 설치하고 메인 파일에서 이를 등록해 주어야 한다. 1npm install --save module-alias index.ts 1require(&apos;module-alias/register&apos;); 이러한 alias의 위치를 실행시점에서 지정해 주어야 하며, 그는 package.json 파일에 다음과 같이 지정해 주어야 node 엔진이 해당 파일을 찾아서 실행이 가능하다. package.json 123456789101112&#123; \"_moduleAliases\": &#123; \"@domain\": \"dist/domain\", \"@infra\": \"dist/infra\", \"@util\": \"dist/util\", \"@common\": \"dist/common\", \"@interfaces\": \"dist/interfaces\", \"@utils\": \"dist/utils\", \"@api\": \"dist/api\", \"@root\": \"dist\" &#125;&#125; Paths 뿐만 아니라 컴파일 시에 타겟 언어를 지정하고, 모듈관리, 소스맵 등의 다양한 옵션을 설정해 준다. How to manage environment variables서버를 운용함에 있어 개발 환경과 실제 운영서버에 따라 달라지는 다양한 환경변수들을 관리하는 것은 보안 및 시스템의 관리 측면에서 매우 중요하다. 본 프로젝트에서는 docker container 기술을 사용하여 운영서버를 배포하며, 개발 서버의 경우 로컬 머신을 사용한다. 여기서 운영서버의 경우 docker image 를 생성하는 시점에서 사용되는 Dockerfile 에 운영시에 사용되는 environment variable 을 저장 서버를 여러 배포환경에서 배포하기 위해 dotenv 라이브러리를 사용하여 .env 파일 내의 환경 변수를 프로세스 환경변수로 사용할 수 있다. 여기서 만약 .env 파일 내의 변수가 기존의 환경 변수와 충돌이 난다면 .env 파일에서 설정한 변수는 무시된다.","link":"/2018/01/22/Building a node.js app with typescript/"},{"title":"Angular 에러 처리","text":"","link":"/2017/12/04/Angular-에러-처리/"},{"title":"Angulr에서의 List 출력과 Pagination","text":"PagerService 준비하기출력하고자 하는 데이터를 페이지에 담기 위한 PagerService를 준비한다. PagerService1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import * as _ from &apos;underscore&apos;;export class PagerService &#123; getPager(totalItems: number, currentPage: number = 1, pageSize: number = 10) &#123; // calculate total pages let totalPages = Math.ceil(totalItems / pageSize); let startPage: number, endPage: number; if (totalPages &lt;= 10) &#123; // less than 10 total pages so show all startPage = 1; endPage = totalPages; &#125; else &#123; // more than 10 total pages so calculate start and end pages if (currentPage &lt;= 6) &#123; startPage = 1; endPage = 10; &#125; else if (currentPage + 4 &gt;= totalPages) &#123; startPage = totalPages - 9; endPage = totalPages; &#125; else &#123; startPage = currentPage - 5; endPage = currentPage + 4; &#125; &#125; // calculate start and end item indexes let startIndex = (currentPage - 1) * pageSize; let endIndex = Math.min(startIndex + pageSize - 1, totalItems - 1); // create an array of pages to ng-repeat in the pager control let pages = _.range(startPage, endPage + 1); // return object with all pager properties required by the view return &#123; totalItems: totalItems, currentPage: currentPage, pageSize: pageSize, totalPages: totalPages, startPage: startPage, endPage: endPage, startIndex: startIndex, endIndex: endIndex, pages: pages &#125;; &#125;&#125; component.ts 혹은 데이터를 총괄하는 service.ts컴포넌트에서 사용할 두 변수를 선언한다1234// pager objectpager: any = &#123;&#125;;// paged itemspagedItems: any[]; 컴포넌트에서 pagerService를 import하고 특정 페이지로 이동하기 위한 함수인 setPage()함수를 정의한다.12345678910setPage(page: number) &#123; if (page &lt; 1 || page &gt; this.pager.totalPages) &#123; return; &#125; // get pager object from service this.pager = this.pagerService.getPager(this.contents.length, page,6); // get current page of items this.pagedItems = this.contents.slice(this.pager.startIndex, this.pager.endIndex + 1);&#125; pagedItems에는 받아온 데이터를 pager의 startIndex와 endIndex+1까지로 잘라 담아준다. component.html실제 pagination을 입혀준다.123456789101112131415161718192021222324&lt;div class=&quot;row-wrapper&quot;&gt; &lt;nav class=&quot;&quot; style=&quot;display:inline-block&quot;&gt; &lt;!-- pager --&gt; &lt;ul *ngIf=&quot;paymentService.pager.pages &amp;&amp; paymentService.pager.pages.length&quot; class=&quot;pagination&quot;&gt; &lt;li [ngClass]=&quot;&#123;disabled:paymentService.pager.currentPage === 1&#125;&quot; class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link direction first&quot; (click)=&quot;paymentService.setPage(1)&quot; aria-label=&quot;First&quot;&gt;First&lt;/a&gt; &lt;/li&gt; &lt;li [ngClass]=&quot;&#123;disabled:paymentService.pager.currentPage === 1&#125;&quot; class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link direction previous&quot; (click)=&quot;paymentService.setPage(paymentService.pager.currentPage - 1)&quot; aria-label=&quot;Previous&quot;&gt;Prev&lt;/a&gt; &lt;/li&gt; &lt;li *ngFor=&quot;let page of paymentService.pager.pages&quot; [ngClass]=&quot;&#123;active:paymentService.pager.currentPage === page&#125;&quot; class=&quot;page-item&quot;&gt; &#123;% raw %&#125; &lt;a class=&quot;page-link&quot; (click)=&quot;paymentService.setPage(page)&quot;&gt;&#123;&#123;page&#125;&#125;&lt;/a&gt; &#123;% endraw %&#125; &lt;/li&gt; &lt;li [ngClass]=&quot;&#123;disabled:paymentService.pager.currentPage === paymentService.pager.totalPages&#125;&quot; class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link direction next&quot; (click)=&quot;paymentService.setPage(paymentService.pager.currentPage + 1)&quot; aria-label=&quot;Next&quot;&gt;Next&lt;/a&gt; &lt;/li&gt; &lt;li [ngClass]=&quot;&#123;disabled:paymentService.pager.currentPage === paymentService.pager.totalPages&#125;&quot; class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link direction last&quot; (click)=&quot;paymentService.setPage(paymentService.pager.totalPages)&quot; aria-label=&quot;Last&quot;&gt;Last&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/div&gt; 다음을 클릭할때에는 service.ts의 setPage()를 호출하여 pagedItems를 바꾸어 준다.만약에 데이터를 index를 통해 나누어 받아오고 싶은 경우에는 setPage()의 if 문에서 범위를 넘는 페이지의 요청에 대해 서버에 요청을 날려 다음 데이터들을 받아올 수 있다.","link":"/2017/11/17/Angulr에서의-List-출력과-Pagination/"},{"title":"Business strategy 비즈니스 전략 수립의 프로세스","text":"","link":"/2017/11/30/Business-strategy-비즈니스-전략-수립의-프로세스/"},{"title":"Business strategy 시장 세분화","text":"현재 시장에서 기업의 위치를 명확하게 설정하라다른 시각으로 비즈니스 세계를 들여다보고 공략할 시장의 범주를 정해서 기업을 운영해야 한다. 예를 들어 사우스웨스트 항공은 다른 항공사들이 시도하지 않던 방법으로 비행기 내의 기내식을 없애고 다른 기타의 불필요한 서비스도 없애 버렸는데, 이는 바로 특정 고객에 집중하여 성공한 예이다. 모든 고객을 만족시킬 필요는 없다.나아가 모든 고객을 목표로 삼을 필요도 없다. 지배할 시장을 찾아라비즈니스시장에서 시장을 지배하는 것은 큰 의미를 가진다.내가 운영하는 기업이 중소기업이라서, 기업의 규모가 작아서라는 이유로 시장을 지배하지 못한다면 그 기업은 반드시 망한다.시장 세분화가 중요한 이유는 바로 한 산업의 시장을 극도로 세분화 한다면, 그 세분화된 시장 안에서는 시장을 지배할 수 있기 때문이다. 시장을 바라보는 방식에 변화를 주고 지배할 수 있는 시장을 찾아 선점하라. 일용품 시장인가 특제품 시장인가?사용자들은 크게 두 부류로 나누어 진다.예를 들어 펜 시장의 경우 단순히 글씨만 잘 써지면 된다 하는 고객들이 있다. 이들이 바로 일용품 구매자 이다.이 고객들은 아주 기본적인 기능에 집중하고 가격에 매우 민감하다. 다른 부류는 펜의 디자인, 그립감 등 가격 외의 것에 민감한 부류이다. 이 고객들은 가격을 넘어서 기본적인 펜 이상의 품질을 원한다. 이들이 바로 특제품 구매자 이다. 이렇게 가격에 따른 민감도에 따라 그래프를 그리면 U자 형태의 그래프를 보이게 되는데, 대부분의 경우 그래프의 양끝을 겨냥해야 성공 가능성이 높다.하지만, 수많은 회사가 그 중간 고객을 겨냥하고 있다.중간 고객은 충성도가 높지 않고, 이 시장을 지배할 방법을 찾기란 불가능에 가깝다. 시장 세분화의 법칙여러가지 방법이 있으나 다음과 같은 기준에 따라 세분화 하는 것이 바람직하다. 고객의 니즈와 기호 일용품과 특제품 제품 유형 시장 유형 인구 통계적 유형 지리적 조건 고객 유형 또는 구매 경로 다음과 같은 질문이 시장 세분화에 도움이 된다. 고객들은 무엇을 구매하는가? 누가 구매하는가? 그들은 왜 구매하는가? 어떤 방법으로 구매하는가 구매한 제품을 어떻게 이용하는가? 어디에서 높은 수익을 올리고 있는가? 어디에서 낮은 수익을 올리고 있는가? 집중할 세준시장을 찾아내는 것은 매우 중요하다. 세분시장 분석서 예시12345678910111213141516171819202122232425262728293031323334351. 세분 시장의 정의지역: 오하이오, 인디애나, 일리노이,특성: 대형 소매업체에서 연간 5천만 달러 이상의 캔디를 판매하는 제조업체2. 고객의 니즈캔디가 깨지지 않도록 잘 보호해야 하고, 내용물이 오염되지 않도록 위생 상태가 좋아야 하며, 납품 기일을 준수해야 한다.3. 고객의 기호색 배합이 바래지 않아야 한다.가격이 저렴해야 한다.공급이 안정적이어야 한다.4. 세분시장의 총매출액: 5000만 달러5. 회사의 현시장 점유율: 120만 달러(24%)6. 특제품 또는 일용품의 구분특제품 구매자 90%, 일용품 구매자는 극소수7. 잠재고객의 수5개 회사만으로 이루어진 집중화 시장8. 경쟁사의 시장 점유율브라운 사:33%ABC 사: 10%9. 시장의 5년 평균 연간 실질 성장률5년 전 250만 달러, 지난해 460만 달러였으며 과거 5년간 이 시장의 매출총액 규모가 2배로 성장했다. 하지만 현재 연간 실질성장률은 8%에 불과한 것으로 추정된다.10. 최근 시장의 주요 사건최대 구매업체인 존스 사가 가장 가까운 경쟁사를 인수하려 하고 있다.11. 간접 경쟁열성형 플라스틱 용기다이컷 종이 커버","link":"/2017/11/30/Business-strategy-시장-세분화/"},{"title":"Css opacity 적용하기","text":"rgb를 이용하는 방법제일 뒷자리가 투명도를 조절하는 부분이다.1rgba(0, 0, 0, 0.5) hexo code를 이용하는 방식숫자 앞에 투명도를 붙여준다.1234567891011121314151617181920212223for 50% white you&apos;d use #80FFFFFF.100% — FF95% — F290% — E685% — D980% — CC75% — BF70% — B365% — A660% — 9955% — 8C50% — 8045% — 7340% — 6635% — 5930% — 4D25% — 4020% — 3315% — 2610% — 1A5% — 0D0% — 00","link":"/2017/12/02/Css-opacity-적용하기/"},{"title":"Fuzzy control systems","text":"fuzzy control이란? 퍼지 제어의 동작 프로세스 퍼지 스스템의 구성요소 퍼지 시스템의 디자인 프로세스 fuzzy control이란?퍼지 컨트롤이란 입력 신호를 퍼지 시스템을 통해 퍼지화 하고 그에 맞는 출력을 출력하는 제어방식을 의미한다.이러한 학습과 추론이 가능한 시스템을 fuzzy expert system이라고 부른다. 퍼지 제어의 동작 프로세스 먼저, 시스템에 입력으로 들어오는 값은 fuzzy encoder를 통해 fuzzy value로 변환되게 되는데, 이를 fuzzification이라 한다.여기서 fuzzification이란 기존의 단순한 제어 시스템 에서는 입력값이 on과 off 두가로 표현되는 boolean한 값이 들어오는데, 입력값을 특정 값과, 그것이 일어날 확률(어떤 사건에 소속될 확률을 나타냄) membership function의 쌍인 fuzzy set으로 표현해 주는 것이다.이러한 입력들의 형태는 Fuzzy Linguistic Variable인데, 가령 “온도가 높다” 혹은 “온다가 낮다”처럼 언어적인 입력을 말하고, 이것이 fuzzy encoder를 통해서 정확한 값과 그 값이 발생할 확률인 membership function의 쌍인 fuzzy set으로 변환되는 과정을 fuzzy encoding 이라고 한다.아래 도식에서 fuzzy encoder 에서 이런 역할을 수행한다. FIE(Fuzzy Inference Engine) 을 거쳐 특정 입력값에 대한 퍼지 출력을 보낸다.여기서 FIE는 KBS(Knowledge Base System)을 기반으로 분석을 시행한다.FIE는 다양한 Rule 을 토대로 결과값을 추론하는 역할을 하고 결정을 내린다. 출력된 퍼지 출력을 fuzzy decoder 를 통해 crisp한 값으로 변환한다. 퍼지 스스템의 구성요소fuzzy encoder다음의 기능을 수행한다. Input Interface A/D Converter Quantization Discretization Fuzzification fuzzy inference Engine robust reasoning system max-min or other operators FIE의 종류에는 다음과 같은 것들이 있다.Direct Methods: Mamdani, Larsen, MizumotoIndirect Methods: Baldwin, TsugamotoHybrid Methods: Sugeno, Simplified KBS(Knowledge Base System) ~= Fuzzy Memory예제들에 관해서 학습하고 또는 실험적인 데이터를 기반으로 학습을 한다.rule base란 일련의 규칙들의 집합이며, 주로 state와 action으로 구분이 된다.이를 state space description으로 나타내면다음과 같다. fuzzy decoder output Interface D/A Converter Defuzzification 퍼지 시스템의 디자인 프로세스 Define control I/O variables Determine Fuzzy Inference engine obtain fuzzy rule base(most important) choose fuzzy decoding schema","link":"/2017/12/10/Fuzzy-control-systems/"},{"title":"Fuzzy pattern recognition and fuzzy clustering","text":"패턴 인식 개요 패턴 인식의 구성요소 FCM(Fuzzy c-Means Clustering) 패턴 인식 개요실용적인 패턴을 인식하기 위해 패턴 인식을 사용한다.공간의 특정 생김새를 분석하거나, 이들은 분류하여 의미있는 결과를 유추하고자 할 때 패턴 인식을 사용한다. 패턴 인식에는 다음과 같은 데이터의 종류들이 있다.object data실제 인식하고자 하는 물체이다.이것은 그냥 사진일 수도 있고, 센서들에 의해 측정된 row data일 수도 있다. relational data물체 데이터들 사이의 상대적 데이터 이다. labeled data이미 분류된 대표적인 데이터 이다. 패턴 인식의 구성요소object(O)인식하고자 하는 실제 객체이다. object data(X)해당 객체의 속성들을 수치로 나열한다. 이는 벡터의 형태로 나열될 수 있다.n개의 객체의 p개의 속성에 대해 패턴 인식을 실시하며, object data x는 p차 벡터로 표현된다. Fuzzy c-Particion(U)각 행은 모든 객체들에 대한 membership degree를 나타내고각 열은 모든 클래스에 대한 membership degree를 나타낸다. 각 행의 총합은 0이상이며, 각 열의 총합은 1을 만족한다. 이러한 Fuzzy c-Partition은 conversion을 통해 crisp c-Partition으로 변환된다. FCM(Fuzzy c-Means Clustering)","link":"/2017/12/11/Fuzzy-pattern-recognition-and-fuzzy-clustering/"},{"title":"Fuzzy systems fuzzy sets and systems","text":"Fuzzy Concept Fuzzy Set multi valued logic VS boolean logic Fuzzy Set의 표현 a-cut(alpha cut) definitions extension principle Fuzzy control system Fuzzy Concept수학의 법칙은 현실 세계를 기반으로 하기 때문에 정확하지 않다.하지만 수학 그 자체는 정확하므로 현실세계를 나타내지 않는다.즉 정확하지 않은 현실 세계를 표현하기 위해 Fuzzy 라는 개념이 나타나게 되었다. Fuzzy Setfuzzy set은 binary set의 multi-valued logic으로의 확장이다.여기서 특정 원소가 특정 범위에 ‘소속’될 확률을 membership function 이라고 하며,membership function 의 값이 0,1 이외의 다른 값을 가지는 것이 가능한 집합이다.fuzzy logic이란 널리 사용되는 머신 컨트롤이다. fuzzy라는 말은 논리가 참 혹은 거짓만으로 표현되지 않고 ‘부분적 참’과 같은 형태로 표현되는 것을 포함한다. genetic algorithm이나 neural network와 같은 다양한 대체적인 접근법들 또한 fuzzy logic과 같이 다양한 경우에서 훌륭하게 동작하나 fuzzy logic은 문제의 답이 사람들이 이해할 수 있는 형태로 표현되기 때문이다. 때문에, 그들의 경험이 컨트롤러의 디자인에 이용될 수 있다. 이것은 사람을 통해 이미 훌륭하게 동작하는 업무를 기계화 하는 것을 매우 간편하게 만들어 준다. 보통 집합 u_A: X -&gt; {0,1} =&gt; 원소에 mapping 됨 퍼지 집합 u_A: X -&gt; [0,1] =&gt; 모든 실수에 mapping 됨 multi valued logic VS boolean logic Fuzzy Set의 표현A={(2, 1.0), (3, 0.5)} 특정 원소와 membership function의 값의 나열로 표현된다. 혹은 A=1.0/2 + 0.5/3 여기서 +는 덧셈이 아닌 합집합 즉, UNION을 의미한다. a-cut(alpha cut)membership function 이 a보다 큰 구간을 의미한다. definitionsfuzzy proposition:fuzzy proposition이란 하나의 퍼지 가설로써 “방 온도가 중간이다.”와 같은 명제이다. support of A:이러한 fuzzy proposition을 A라고 하면 이 명제를 뒷바침 하는 x의 집합을 support of A라고 하며 membership function이 0보다 큰 x의 집합을 의미한다. crossover point:membership function이 0.5인 x의 값들의 집합 convexity: 모든 x 에 대해 특정 두 x를 골랐을 때 그 값 사이의 모든 x값의 membership function이 선택한 두 x 값의 membership function의 최소값보다 큰 경우.즉, 볼록하다고 생각하면 된다. normality: membership function이 1인 x가 존재하는 경우이다. fuzzy number: convexity와 normality를 둘 다 만족하는 fuzzy set resolution identity: fuzzy set은 유한개 혹은 무한개의 a-cuts로 나누어 질 수 있다. extension principlefuzzy set A의 도메인은 non-fuzzy function f를 통해 확장될 수 있다.여기서 f(A)를 extended fuzzy set이라 한다. extened fuzzy set의 예 Fuzzy control systemfuzzy-control-image Fuzzy control system이란 fuzzy logic에 기반한 컨트롤 시스템이다. (여기서 fuzzy logic이란 아날로그 입력값을 분석할 때 기존의 0과 1만 존재하는 디지털 로직과 달리 0과 1 사이의 연속적인 논리 값으로 분석을 하는 수학적 시스템이다.)","link":"/2017/12/10/Fuzzy-systems-fuzzy-sets-and-systems/"},{"title":"Getting started with javascript","text":"How does it works자바스크립트를 기본적으로 chrome 브라우저에서 실행되는 script 언어로 시작하였으나, node.js 라는 런타임 환경이 나온 이후로 브라우저 밖에서도 javascript를 사용할 수 있게 되었다. 아무래도 브라우저 내에서 사용되던 언어인 만큼 window 라는 전역 object 가 context의 root 역할을 수행한다. 런타임 환경 내에서 실행되는 모든 변수는 window 라는 전역 객체에 그 상태가 기록되며, 브라우저에서 동작하는 성격상 브라우저의 창 즉, window 가 런타임 환경에서 최상위 root context 가 된다. 기본적으로 html 이라는 사용자가 보는 가시적인 페이지와 연동되기 위해 event 라는 개념을 사용하며, 사용자가 브라우저에서 하는 모든 활동은 event 를 발생시키며, 각 이벤트가 발생하면 수행되는 일련의 함수의 집합으로 프로그램이 구성된다. 이러한 event 를 듣고 수행하는 것들을 일컬어 event target 이라고 하며, 이러한 event target 으로는 root context 인 window 객체 이외에도 document, element 객체가 있다. 각 객체들은 addEventListener 함수를 통해 특정 이벤트가 발생할때 실행할 함수들을 등록할 수 있으며, 이를 통해 web page 와 사용자가 상호작용을 하게 된다. 또한, javascript runtime environment 인 node.js 는 각종 패키지들을 사용할 수 있는데, 여기서 node 는 실행하는 루트의 package.json 파일을 참조하여 노드 모듈을 참조하고 실행하며, 때문에 실행하는 위치의 root 에 package.json 파일이 있어야만 패키지들을 찾고 실행할 수 있기 때문에 이를 유의하여야 한다. Javascript modulesnpm 패키지를 사용하기위한 설정을 package.json 에 설정해 준다. path alias 사용하기package.json 1234567891011&#123; \"_moduleAliases\": &#123; \"@domain\": \"dist/domain\", \"@infra\": \"dist/infra\", \"@util\": \"dist/util\", \"@common\": \"dist/common\", \"@interfaces\": \"dist/interfaces\", \"@utils\": \"dist/utils\", \"@api\": \"dist/api\" &#125;&#125; MultithreadingJavascript 는 기본적으로 single thread 방식으로 동작한다. 즉, 하나의 프로세스 내에서도 하나의 단일 스레드 내에서 동작하는 것을 기본으로 한다. 하지만, 브라우저 내에서 데이터를 로드하면서 화면을 전환하거나 혹은 화려한 ui 를 그리는 도중에도 사용자와의 interaction 을 해서 편의를 높이는 등 다양한 부분에 있어 병렬처리에 대한 필요성이 대두되었으며, 브라우저는 Web Worker 라는 개념을 통해 병렬처리를 가능하도록 하였다. web worker 는 현재 실행중인 main thread 와 병렬적으로 background thread 에서 특정 작업을 수행하여 병렬적으로 특정 task 를 수행할 수 있게 해 준다.","link":"/2019/01/18/Getting-started-with-javascript/"},{"title":"Hexo 와 Github page로 블로그 시작하기","text":"hexo 블로그 시작하기hexo와 github page를 사용하여 블로그를 시작한다. Hexo-cli 설치하기1npm install -g hexo-cli Hexo 시작하기처음 블로그를 만드는 경우는 다음과 같이 생성하며, 만약 pull 받은 경우에는 반드시!! npm install을 해주어야 한다. 123hexo init blogcd blognpm install 설정하기1234567891011121314151617181920_config.yaml 파일 수정# Sitetitle: Writer, IT Blog # 타이틀subtitle: Eirc Han's IT Blog using Hexo # 서브 타이틀description: Eirc Han's IT Blog using Hexo # 블로그 설명author: Eric Han # 저자 이름language: en # 기본 언어. 다국어 지원timezone: Asia/Seoul # 해당 타임존 설정 (https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)# URLurl: http://futurecreator.github.io/ # 앞에서 만든 github page 주소root: / # 기본은 / 이고 만약 서브디렉토리 구조를 가진다면 루트를 지정하는 부분.permalink: :year/:month/:day/:title/ # 기본 permalink (고정 url). 새글 생성 시 자동으로 지정된 형식의 URL이 할당된다.permalink_defaults:# Deploymentdeploy: type: git repo: https://github.com/futureCreator/futurecreator.github.io.git git에 배포하기 위한 환경 설정하기1npm install hexo-deployer-git --save 배포하기hexo generate generate 된 파일 clearhexo cleanhexo deploy 한줄로 끝내기hexo g -d 포스트 작성하기hexo new &quot;my post&quot; 로컬 서버로 돌려보기hexo server 태그 여러개 붙이기1234tags :- tag_1- tag_2- tag_n 컴파일 에러 hexo 에서 {{}} 처럼 이중 브래킷을 사용하는 경우 컴파일 에러가 발생한다. 이 경우에는 다음 코드를 사용 하여 블록을 씌워주면 해결된다. 12345&#123;% raw %&#125;//content&#123;% endraw %&#125; 광고달기참조글","link":"/2017/11/15/Hexo-와-Github-page로-블로그-시작하기/"},{"title":"Neural Network의 기본 개념","text":"neural network의 역사 왜 인공신경망이 각광을 받게 되었는가? 인공신경망이란? 생체 신경망과 컴퓨터 신경망의 연산속도 문자의 인식 기초적인 생체 신경망 Neural Network Computation McCulloch-Pitts Theory(old) Hebbian Learning General Processing Element neural network의 역사1940년 후반, 디지털 컴퓨터의 출현 1950년 후반, perceptron과 ADALINE의 출현 1969년 ~ 1980년 초반, single layer perceptron에서 xor 문제 발생 1986년, 전환점을 맞이하게 된다.multi layer perceptron이 xor 문제를 해결하다. 1990년, optical neural network, 디지털 하드웨어 왜 인공신경망이 각광을 받게 되었는가? 경험, 데이터, 실험을 통해 강력한 학습이 가능하다. 물체의 분류와 식별이 가능해진다. 빠른 병렬연산으로 이상적으로 빛의 속도로 연산이 가능하다. 잠재 지능이 존재한다. 수많은 범용 어플리케이션이 나오고 있다. 인공신경망이란?인공 신경망이란 processing elements 로 구성된 여러개의 장치들이 connection strength or weight이 다른 여러 개의 연결망을 통해 연결된 복합체이다.많은 패턴들과 수치 데이터들이 학습되고 저장될 수 있다.여기서 weights란 인공 신경만이 학습하고 저장하기 위한 수치값들로 메모리에 저장되는 값이다. adaption이란 예제와 실험들로 학습하는 것을 말한다. 생체 신경망과 컴퓨터 신경망의 연산속도컴퓨터의 속도가 생체 신경망에 비해 10,000,000배나 더 빠른 속도를 보인다.하지만 컴퓨터는 병렬적 처리를 하지 못하는데 반해 생체신경망은 막대한 병렬연산이 가능하고 복잡하게 연결되어 있기 때문에 컴퓨터가 100msec가 걸려야 풀 수 있는 한번의 인식을 단지 0.1msec 만에 해결한다. 문자의 인식손으로 작성되었는가 혹은 컴퓨터로 타이핑 되었는가, 기울기 확대율, 회전율 등에 따라 다른 인식율을 보인다. 기본적인 패턴인식은 패턴을 픽셀단위로 분해아여 벡터화 시킨다.인공 신경망의 node와 connection strength를 조절하여 분석한다. 기초적인 생체 신경망뉴런 부분적인 투과성을 가진다. potential 차이가 존재하며 이온들이 이동한다. 이온들이 potential차가 평행을 이루는 지점까지 운동한다. 시냅스 시냅스는 Neuro-transmitter이다.시냅스가 Ca(+)의 투과성을 높여주면 action potential이 증가한다. 투과성이 critical point를 넘기게 되면 action potential이 이동하여 다른 뉴런에 연결된다. Neural Network Computation 뇌는 수많은 연결을 통해 어떻게 엄청난 능력을 가지게 되었는가? McCulloch-Pitts Theory(old) 뉴런의 활동은 일어나거나 일어나지 않거나 두가지 상태를 가진다. 중간은 없다. 신경이 흥분되려면 두 개 이상의 시냅스가 흥분되어야 한다. delay는 오직 스냅스에서만 발생한다. 억제 시냅스는 뉴런 활동성을 저해한다. 연결망의 구조는 시간에 따라 변하지 않는다. 뉴런은 단순한 장치이지만, 적절하게 연결되어 신경 시스템을 구성하면 막대한 계산이 가능하다. Hebbian Learning 생체신경망은 최초에 직렬적으로 작동할 능력과 지식을 갖추지 못했다. Pavlov’s Conditioned Response 뉴런 A 의 축색돌기가 뉴런 B를 자극하기에 충분하고 지속적으로 계속적으로 자극이 발생한다면 하나 혹은 여러개의 뉴런에서 성장 혹은 신진대사가 이루어 지고 뉴런 C의 효율이 높아진다.그리고 마침내 뉴런 C를 자극하는 다른 뉴런인 뉴런 B가 증가하게 된다. Hebb’s assumption says, “The excitation of neuron A has enough stimulus for neuron B, but that of neuron C doesn’t have. Now, with neuron A, the connection strength of neuron C increases, and eventually, without neuron A, neuron B can be excited by neuron C only.” General Processing Element인공 신경세포를 노드 혹은 유닛으로 나타내는 단위이다. 수학에서 뉴럴 네트워크의 설계는 시간에 따라 변하는 역동적인 시스템이다. 학습 법칙connection strength는 학습이 진행됨에 따라 업데이트되며, data of weights가 무엇을 배우지에 관한 정보를 기록하게 된다. vector notations","link":"/2017/11/29/Neural-Network의-기본-개념/"},{"title":"Neural network Perceptron과 ADALINE","text":"Perceptron 이란? photo perceptron의 예 Perception Convergence Theorem problems in perceptron (single layer) - XOR 문제 하이퍼 플레인과 hidden node multi layer perceptron을 이용한 XOR 문제의 해결 weight vector는 왜 hyper plane과 수직을 이루는가? ADALINE(ADAptive LInear NEuron)이란 무엇이며 perceptron 과의 차이점은 무엇인가? ADALINE Least Mean Squares(LMS) RLMS(Relative Least Mean Squares) Neural network 설계 프로세스 Perceptron 이란?frank rosenblatt 박사가 1950년 발표한 내용으로 McCulloch-pitts 모델의 확장 개념이다.통계적으로 구분된 이론이다.(확률적, 거시적) photo perceptron의 예 Perception Convergence Theorem두개의 패턴을 학습하는 과정에서, 유한번의 사이클 내에 두 개의 패턴을 구분할 수 있다. 여기서 N과 P는 각각 Negative, Positive를 의미한다.P와 N에서 랜덤하게 벡터를 뽑아서 Weight와 곱해준 값이P의 경우 Positive 해 질때 까지 계속 덧셈을 하고N의 경우 Negative 해 질때까지 계속 뺄셈을 하여 Positive 하고 Negative 함을 맞추어 준다. problems in perceptron (single layer) - XOR 문제single layer perceptron에서는 XOR 함수를 만족하는 weight를 찾을 수 없는 문제가 발생한다. 하이퍼 플레인과 hidden node하이퍼 플레인이란 n차 공간에서 TLU(Threshold Logic Unit)역할을 하는 n-1차 공간이다. hidden node란 xor 문제를 해결하는 mid-layer들을 의미한다. multi layer perceptron을 이용한 XOR 문제의 해결멀티레이어 퍼셉트론을 이용하여 XOR 문제를 해결할 수 있다. weight vector는 왜 hyper plane과 수직을 이루는가?weight vector는 hyper plane과 수직을 이룬다. ADALINE(ADAptive LInear NEuron)이란 무엇이며 perceptron 과의 차이점은 무엇인가?ADALINE이란 adaptive signal processing을 수행한다. 다음과 같은 면에서 perceptron과 차이점을 가진다. dc 바이어스와 그에 대한 weight가 포함되어 있다. perceptron은 0, +1의 출력을 가지는데 반해 -1 +1의 bipolar 출력을 가진다. TLU가 단지 선형함수이다. ADALINEALC: Adaptive Linear Combiner Least Mean Squares(LMS)L개의 입력값을 통한 출력값과 L개의 desired output을 비교하여 mean of square error가 가장 작은 weights를 구한다. solution RLMS(Relative Least Mean Squares)학습되어야 할 데이터의 숫자가 증가하거나 벡터의 사이즈가 증가하는 경우에 문제가 생긴다.모호한 방정식을 풀어야 하거나, 방정식의 개수가 weight보다 많은 경우 문제가 생긴다.또한 inverse matrix를 구해야 하는 경우도 문제가 되는데, 데이터의 숫자가 많아짐에 따라 Determination이 0이 되는 값이 있을 수 있다.이 경우 LMS를 줄여주는 방향으로 weight를 스스로 변화시키는 방법으로 weight를 조절해 갈 수 있는데 이를 RLMS라고 한다. Neural network 설계 프로세스perceptron의 경우 TLU가 non-linear하기 때문에 계산하기 어려우므로 ADALINE을 이용한다. 1. 학습되어야 할 데이터쌍이 몇개인가?문제의 복잡도에 따라 다르다. 학습되어야 할 데이터가 많을 수록 더 많은 learning cycle을 필요로 한다.neural net의 저장용량에 따라 cross-talk 없이 효과적인 학습과 재현이 가능해야 한다.최종적으로, incremental learning이 필요하다. 2. 각 학습 입력쌍의 기대되는 출력값은 무엇인가?GMP(Genralized Modus Ponens)와 밀접한 관련이 있다.학습 쌍이 학습 알고리즘 상의 weight에 저장되어 있다면, 같은 입력 패턴이 들어갔을ㄷ대 반드시 같은 결과 패턴이 나와야 한다. 3. weight vector의 차원은 무엇이며 초기 추측값은 무엇인가?센서의 개수와 잘 정의된 입력값에 관계가 있다.초기 추측값은 랜덤하게 선택하거나 대충 선택한다. 4. bias weight이 필요한가? 필요하다면 언제 필요한가?어떤 필터에서는 필요가 없다.hyper plane이 원점과 거리가 매우 멀다면 필요하다. 5. pattern의 통계적 성질이 시간에 따라 변하면 어떠한가?일반적으로 시간에 따른 변수들의 통계적 특성이 불변한다고 가정한다.만약에 변한다면 학습 주기는 처음부터 다시 시작되어야 한다. incremental learning을 한다면 하나의 패턴쌍을 제거할 수 있는가? 어떤것이 변하는가? 6. learning coefficient 적합한 값은 얼마인가?학습계수는 최저값과 최고값이 있어야 한다. 학습에서 이 크기는 매우매우 중요하다.작은 학습계수는 학습의 수렴이 천천히 일어나게 하고, 큰 학습 계수는 가끔 매우 긴 수렴 주기로 가게 하거나 혹은 발산하게 할 수 있다. 7. learning cycle의 종료 규칙을 어떻게 정하는가?출력 조건과 관련이 있다. 만약 기대값과 실제 출력값이 허용치 안에서 계속 머문다면 학습 주기를 종료한다.","link":"/2017/11/29/Neural-network-Perceptron과-ADALINE/"},{"title":"Neural network Bidirectional Associative Memory(BAM)","text":"","link":"/2017/11/30/Neural-network-Bidirectional-Associative-Memory-BAM/"},{"title":"Neural network back propagation","text":"back propagation 이란? Back propagation Algorithm 작동 원리 BPN Learning Process(Encoding) BPN Retrieving Process(Decoding) BPN GDR(Generalized Delta Rule) BPN Learning Algorithm back propagation 이란?multi layer perceptron에서의 학습 알고리즘 이다. Back propagation Algorithm다음과 같은 이유로 multi layer perceptron에서 BP를 사용한다. 넓은 입력공간에서 복잡한 패턴을 가진다. 병렬 처리를 통해 빠른 계산속도를 가진다. adaption을 위해 error back propagation을 한다. Back propagation을 하는 MLP의 구조를 BPN(Back Propagation Network)라고 한다. 작동 원리BPN은 다음과 같은 복잡한 패턴 매칭 문제를 해결할 수 있다. 입출력 쌍 패턴 분석을 propagation adoption 방식을 사용하고 학습할 수 있다. 입력 자극이 hidden layer로 그리고 output layer 로 전달된다. 다음과 같은 순서로 학습이 이루어 진다. 패턴 입력이 인풋으로 주어짐 히든 레이어로 전달된 출력 레이어로 전달되고 출력 패턴이 나옴 desired pattern에서 output pattern의 차를 통해 error를 검출 검출된 error가 출력 레이어로 부터 히든 레이어로 전달되고 다시 입력단으로 전달됨 히든 레이어에서 에러의 상대적 기여도가 사용되고, 모든 노드에 대해 수행됨 connection strength가 업데이트 되고, 트레이닝 패턴이 다시 encode됨 BPN Learning Process(Encoding)히든 레이어의 노드가 모든 입력 패턴을 인식할 수 있도록 스스로 재구성됨 BPN Retrieving Process(Decoding) 입력된 입력패턴이 학습된 패턴과 같거나 유사하면 output layer에 나타남 입력된 입력 패턴이 학습된 데이터가 아니면, 히든 레이어에서 자극값을 생성하는 것이 억제됨 BPNBack propagation 알고리즘의 핵심은 error가 weight를 스스로 업데이트 하는 것이다.error BP는 지도 학습(supervised learning)의 핵심이다.여러개의 입출력 쌍을 통해 출력을 예상할 수 있다. Mapping network:input과 output을 계산하는 함수 GDR(Generalized Delta Rule)입력 벡터를 통해 i 번체 히든 노드의 입력의 합을 구한다. output of th k^th output unit BPN Learning Algorithm 적용된 input으로 부터 전달된 신호를 기반으로 관련 출력을 계산하라 에러를 계산하라(desired-actual) error 를 감소시키기 위한 weight update의 방향을 결정하라. weight update의 양을 계산하라 weight를 업데이트 하라 1~5의 과정을 에러가 tolerance ranges 안에 들어갈 때 까지 반복하라.","link":"/2017/12/09/Neural-network-back-propagation/"},{"title":"NodeJs mongoose 라이브러리를 활용한 mongodb 통신","text":"세팅하기 ObjectId 이용하기 Model을 사용하여 update 하기 $inc 를 활용하여 increase 하기 없으면 create하고 있으면 update하기 $or를 활용하여 or 서치하기 세팅하기 mongoose 설치npm install mongoose mongoose 임포트 해주기var mongoose = require(&#39;mongoose&#39;); 몽구를 이용하여 db 연결mongoose.connect(&#39;mongodb://username:password@host:port/database?options...&#39;);mongoose를 활용한 nodeje mongodb 연결 ObjectId 이용하기1mongoose.Types.ObjectId(req.params._id) Model을 사용하여 update 하기12345678Apply.update(&#123;_id:saved_id&#125;,req.body,&#123;upsert:true&#125;,function(err,docs)&#123; if(err)&#123; console.log(err); res.sendStatus(500); &#125;else&#123; res.sendStatus(200); &#125;&#125;) $inc 를 활용하여 increase 하기 undefined 없으면 create하고 있으면 update하기12345678910111213router.put(&apos;/&apos;,function(req,res)&#123; console.log(&quot;스케줄 업데이트 처리 req.body:&quot;, req.body); delete req.body._id; Schedule.findOneAndUpdate(&#123;day:req.body.day, time:req.body.time&#125;,req.body,&#123;upsert:true&#125;,function(err,docs)&#123; if(err)&#123; console.log(err); res.sendStatus(500); &#125;else&#123; res.sendStatus(200); &#125; &#125;)&#125;) upsert: true 항목을 추가한다. $or를 활용하여 or 서치하기12345678910ar userExists = function(u, callback) &#123; User.find(&#123;$or:[ &#123;&apos;username&apos;: u.username&#125;, &#123;&apos;email&apos;: u.email&#125;]&#125; , function(err,user) &#123; if (err || user.length &gt; 0) &#123; // user does not come back null, so check length callback(1); return; &#125; //no error, no user callback(0); &#125;);&#125;; NPM mongoose package Document","link":"/2017/11/19/NodeJs-mongoose-라이브러리를-활용한-mongodb-통신/"},{"title":"Node.js에서의 bcrypt 암호화","text":"강력한 암호화 방식인 bcrypt를 node에서 사용한다. NPM 참조","link":"/2017/11/19/Node-js에서의-bcrypt-암호화/"},{"title":"NodeJs nodemailer를 활용한 이메일 보내기","text":"W3School 참고자료 Gsuite 사용시 권한 설정하기참조","link":"/2017/11/19/NodeJs-nodemailer를-활용한-이메일-보내기/"},{"title":"NodeJs 파일 업로드 및 삭제하기","text":"Formidable 설치하기npm i -S formidable html 에서 파일 입력받기1&lt;input type=&quot;file&quot; (change)=&quot;fileChange($event)&quot; placeholder=&quot;Upload file&quot; accept=&quot;.pdf,.doc,.docx&quot;&gt; 입력받은 파일을 formData에 담아 서버로 전송하기1234567891011121314151617181920fileChange(event) &#123; let fileList: FileList = event.target.files; if(fileList.length &gt; 0) &#123; let file: File = fileList[0]; let formData:FormData = new FormData(); formData.append(&apos;uploadFile&apos;, file, file.name); let headers = new Headers(); /** No need to include Content-Type in Angular 4 */ headers.append(&apos;Content-Type&apos;, &apos;multipart/form-data&apos;); headers.append(&apos;Accept&apos;, &apos;application/json&apos;); let options = new RequestOptions(&#123; headers: headers &#125;); this.http.post(`$&#123;this.apiEndPoint&#125;`, formData, options) .map(res =&gt; res.json()) .catch(error =&gt; Observable.throw(error)) .subscribe( data =&gt; console.log(&apos;success&apos;), error =&gt; console.log(error) ) &#125;&#125; node server에서 수신하기12345678910111213router.post(&apos;/cover_img&apos;,function(req,res)&#123; console.log(&quot;커버이미지 저장 시작!&quot;); var form = new formidable.IncomingForm(); form.parse(req, function (err, fields, files) &#123; console.log(files); var oldpath = files.uploadFile.path; var newpath = &quot;/var/www/html/contents_cover_img/&quot; + files.uploadFile.name; fs.rename(oldpath, newpath, function (err) &#123; if (err) throw err; res.sendStatus(200); &#125;); &#125;)&#125;) 참고자료","link":"/2017/11/19/NodeJs-파일-업로드-및-삭제하기/"},{"title":"NodeJs urlencode를 활용한 한글 인코딩","text":"12Npm install urlencode --savevar urlencode = require(&apos;urlencode&apos;); console.log(urlencode(&apos;변환&apos;)); console.log(urlencode.decode(&apos;%EB%B3%80%ED%99%98&apos;)); 참고자료","link":"/2017/11/19/NodeJs-urlencode를-활용한-한글-인코딩/"},{"title":"Nodejs Google Api를 활용한 push 서버 구축","text":"Code FlowNPM install fcm-node UsageApi 서버 만들기","link":"/2017/12/08/Nodejs-Google-Api를-활용한-push-서버-구축/"},{"title":"Python 설치 및 기본설정","text":"python 다운로드파이썬을 다운로드 한다.다운로드 하기 여기서 유의할 점은 아직 tensorflow는 python 3.5까지 밖에 지원하지 않는다는 점이다.그리고 반드시! 64bit 버전을 설치해야 한다. python 환경변수 추가 하기시스템 환경변수에 python을 추가한다.시스템속성-환경변수의path에 python 설치경로를 추가한다. 또, PYTHONPATH란 이름으로 python의 lib 폴더 디렉토리를 환경변수로 추가한다. pip 사용을 위해 환경변수 추가하기시스템속성-환경변수의 path에에서 python의 script폴더를 추가해준다. pip 설치하기파이썬의 다양한 라이브러리를 이용하기 위한 패키지 매니저인 pip을 설치한다.1sudo apt-get install python3-pip GPIO의 활용General Purpose Input Output 단자를 활용하기 위한 패키지를 설치한다.1sudo apt-get install python-rpi.gpio python3-rpi.gpio 통신을 위한 requests 라이브러리1pip3 install requests python-picamera파이썬 카메라 설치sudo apt-get install python-picamera 파이 카메라 기본 활용 코드12345678import timeimport picamerawith picamera.PiCamera() as camera: camera.start_preview() time.sleep(5) camera.capture(&apos;/home/pi/Desktop/image.jpg&apos;) camera.stop_preview() 파이 카메라의 활용 링크 pytesseract설치123456789pip install --upgrade pippip install wheelsudo apt-get install python-opencvSudp apt install tesseract-ocrPip install pytesseract webbrowser웹 브라우저 열기12import webbrowserwebbrowser.open(&quot;http://www.naver.com&quot;) timeos파일 시스템의 파일 목록 받아오기1os.listdir() 파일 시스템의 이름 바꾸기1os.rename(src,destination) turtle개요윈도우에서 그림을 그리는 라이브러리 example123456789101112131415161718192021import turtleder draw_square(): window=turtle.Screen() window.bgcolor(&quot;red&quot;) brad=turtle.Turtle() brad.shape(&quot;turtle&quot;); brad.color(&quot;yellow&quot;); brad.speed(2) brad.forward(100) brad.right(90) brad.forward(100) brad.right(90) brad.forward(100) brad.right(90) brad.forward(100) brad.right(90) window.exitonclick()draw_square() class기본 구조상속12345678910class Parent(): def __init__(self, last_name, eye_color): print(&quot;Parent Constructor called&quot;); self.last_name=last_name self.eye_color=eye_colorclass Child(Parent): def __init__(self, last_name, eye_color): Parent.__init__(self,last_name,eye_color) self.number_of_toys=number_of_toys","link":"/2017/12/17/Python-설치-및-기본설정/"},{"title":"angular lazy image loading","text":"ngx-lazy-load-images 설치하기1npm i ngx-lazy-load-images --save 모듈 import 하기123456789import &#123; NgModule &#125; from &apos;@angular/core&apos;;import &#123; LazyLoadImagesModule &#125; from &apos;ngx-lazy-load-images&apos;;@NgModule(&#123; imports: [ LazyLoadImagesModule ]&#125;)export class AppComponent &#123;&#125; 사용하고자 하는 img에 lazy-load-images directive 사용하기img 태그에 사용하는 것이 아니고 img의 상위 태그에 directive를 넣어야 한다.123456789&lt;!-- Image tags --&gt;&lt;div class=&quot;image-list&quot; lazy-load-images&gt; &lt;img *ngFor=&quot;let imageUrl in images&quot; [attr.data-src]=&quot;imageUrl&quot;&gt;&lt;/div&gt;&lt;!-- Background images --&gt;&lt;div class=&quot;image-list&quot; lazy-load-images&gt; &lt;div *ngFor=&quot;let imageUrl in images&quot; [attr.data-background-src]=&quot;imageUrl&quot;&gt;&lt;/div&gt;&lt;/div&gt; img 에 data-src 속성 넣기 undefined 참조","link":"/2017/12/02/angular-lazy-image-loading/"},{"title":"angular pipe의 활용","text":"pipe 란? 여러개의 pipe를 사용하기 Date Pipe Currency Pipe pipe 란?angular pipe란 입력받은 데이터를 사용자가 원하는 형태로 변형시켜 출력할 수 있게 해 준다. 여러개의 pipe를 사용하기계속해서 pipe를 나열하여 chaning 하여 사용할 수 있다. example undefined Date Pipeexample undefined 참조 Currency Pipe undefined 참조","link":"/2017/11/26/angular-pipe의-활용/"},{"title":"angular safe navigation operator를 활용한 한전한 null 값 출력하기 ","text":"개요흔히 bracket 안에 다양한 model을 바인딩 하는 경우 null 혹은 undefined에 대해 많은 에러가 일어나게 된다. 예를 들어 다음과 같은 경우123&#123;% raw %&#125;&#123;&#123;user.name&#125;&#125;&#123;% endraw %&#125; user 안에 값이 없다면 null안에서 name property를 가져올 수 없으므로 전체 어플리케이션에 치명적인 오류가 일어나게 된다. safe navigation operator의 활용다음과 같이 Object?.property를 사용하는 경우Object의 값이 null이어도 시스템 에러를 발생시키지 않아보다 안전한 프로그램이 될 수 있다.123&#123;% raw %&#125;&#123;&#123;user?.name&#125;&#125;&#123;% endraw %&#125;","link":"/2017/11/26/angular-safe-navigation-operator를-활용한-한전한-null-값-출력하기/"},{"title":"angular 에서 youtube 재생하기","text":"컴포넌트에 safe pipe를 사용할 수 있도록 Pipe를 만든다12345678910import &#123; Pipe, PipeTransform &#125; from &apos;@angular/core&apos;;import &#123; DomSanitizer&#125; from &apos;@angular/platform-browser&apos;;@Pipe(&#123; name: &apos;safe&apos; &#125;)export class SafePipe implements PipeTransform &#123; constructor(private sanitizer: DomSanitizer) &#123;&#125; transform(url) &#123; return this.sanitizer.bypassSecurityTrustResourceUrl(url); &#125;&#125; app.module에 SafePipe를 선언해 준다.생성한 pipe를 module에 포함시켜 준다. 123456@NgModule(&#123; declarations : [ ... SafePipe ],&#125;) html 작성iframe을 사용 할 때 src에 safe pipe를 사용한다.1&lt;iframe width=&quot;100%&quot; height=&quot;300&quot; [src]=&quot;url | safe&quot;&gt;&lt;/iframe&gt; x-frame-options 해결하기유투브 공유하기 url을 퍼와서 재생하면 x-frame-option to ‘sameorigin’이라는 에러가 발생하게 된다.여기서 X-Frame-Option이란 http response header의 한 종류로써 자신의 컨텐츠가 , 등에서렌더링이 되도록 허용하는지의 유무를 나타낸다. 이 옵션은 나의 컨텐츠가 다른 사이트에 무단으로 포함되는 것을 막고 다른 사이트를 통해 클릭 공격 등을 시도하는 것을 막을 수 있다. 즉, Youtube가 컨텐츠를 업로드 하는 시점에 x-frame-option을 설정하여 무단으로 퍼갈 수 없도록 하는 것이다.때문에 Youtube에서 컨텐츠를 가져와 embed 하고 싶은 경우에는 반드시 공유=&gt;퍼가기 를 누르면 나오는 소스코드의 src 부분을가져와야 한다. 이 url 에 포함된 중간의 embed 라는 문자는 해당 컨텐츠가 다른 사이트 에서도 재생 될 수 있도록 x-frame-option이 지정되어 있기에퍼가는 것이 가능해 진다.","link":"/2018/01/13/angular-에서-youtube-재생하기/"},{"title":"angular와 nodejs를 활용한 socket.io 사용하기","text":"server.js 작성 클라이언트에서 socket.io 설치 및 임포트 angular service angular component server.js 작성express 에서 socket.io를 실행하기 위해 express.io를 설치한다. 노드 http 서버와 결합시킬 socket.io에 http를 전달하여 initialize한다. connection 이벤트가 발생하면 특정 동작을 한다. io.emit을 통해 데이터를 전달한다.12345678910111213141516var io = require(&apos;socket.io&apos;).listen(server);io.on(&apos;connection&apos;, (socket) =&gt; &#123; console.log(&apos;user connected&apos;); socket.on(&apos;disconnect&apos;, function() &#123; console.log(&apos;user disconnected&apos;); &#125;); socket.on(&apos;add-message&apos;, (message) =&gt; &#123; io.emit(&apos;message&apos;, &#123; type: &apos;new-message&apos;, text: message &#125;); // Function above that stores the message in the database databaseStore(message) &#125;);&#125;); 클라이언트에서 socket.io 설치 및 임포트소켓 io를 라우터에 전달한다.123456npm i socket.io-client --savenpm install socket.io --saveconst server = http.createServer(app);var io = require(&apos;socket.io&apos;).listen(server);const all = require(&apos;./server/routes/all&apos;)(mysql, conn, express, io); angular serviceio()는 socket을 반환한다. socket.emit을 통해 이벤트를 발생시킨다. 123456789101112131415161718192021222324252627import &#123; Injectable &#125; from &apos;@angular/core&apos;;import &#123; Subject &#125; from &apos;rxjs/Subject&apos;;import &#123; Observable &#125; from &apos;rxjs/Observable&apos;;import * as io from &apos;socket.io-client&apos;;@Injectable()export class ChatService &#123; private url = &apos;http://localhost:5000&apos;; private socket; sendMessage(message)&#123; this.socket.emit(&apos;add-message&apos;, message); &#125; getMessages() &#123; let observable = new Observable(observer =&gt; &#123; this.socket = io(this.url); this.socket.on(&apos;message&apos;, (data) =&gt; &#123; observer.next(data); &#125;); return () =&gt; &#123; this.socket.disconnect(); &#125;; &#125;) return observable; &#125;&#125; angular component123456789101112131415161718messages = [];connection;message;sendMessage()&#123; this.chatService.sendMessage(this.message); this.message = &apos;&apos;;&#125;ngOnInit() &#123; this.connection = this.chatService.getMessages().subscribe(message =&gt; &#123; this.messages.push(message); &#125;)&#125;ngOnDestroy() &#123; this.connection.unsubscribe();&#125; 참조use with router","link":"/2017/11/29/angular와-nodejs를-활용한-socket-io-사용하기/"},{"title":"Beanstalk 시작하기","text":"InstallationEb 를 설치하기 위해 awscli 와 awsebcli 를 설치해 준다. 123pip install awsclipip install awsebcli --upgrade --userbrew install awsebcli elastic beanstalk 을 초기화 하고 생성 및 배포한다. 123eb initeb createeb deploy ConfigurationBeanstalk 을 통해 어플리케이션을 배포하게 되면 여러개의 filebeat 와 함께 배포하기만약 프로젝트 내에서 Elastic Stack 을 사용하여 어플리케이션에서 나오는 모든 로그 및 데이터를 filebeat 를 통해서 배포해야 할 필요가 있다면, filebeat 와 함께 multi docker 모드를 사용하여 beanstalk 에 배포할 수 있다. 먼저, filebeat 를 단독으로 ECR(Elastic Container Resistry) 에 올린다. 이 과정에서 반드시 아마존에 로그인이 되어야 하며, 다음과 같은 명령어를 통해 ecr 에 별도로 로그인을 수행한다. 아래 명령어는 기본 aws 유저가 아닌 eb cli 접근이 가능한 프로그램 유저를 설정해 두고 해당 유저의 정보로 로그인을 함을 의미한다. 아래 명령어를 입력하면 AWS 에서 로그인을 하기 위한 명령어를 output 으로 제공하는데 해당 문자열을 복사하여 다시 cli에 입력하면 로그인이 완료된다. 1aws ecr get-login --no-include-email --profile eb-cli 아래 명령어를 통해 aws access key 와 secret key 를 등록하고 사용할 수 있다. 1aws configure 다음과 같은 command option 을 통해 내가 어떤 사용자인지 알리고, 미리 configure 되어있는 해당 사용자의 정보로 authentication 을 진행할 수 있다. 1aws [command] --profile 사용자이름","link":"/2019/01/15/beanstalk-시작하기/"},{"title":"Rxjs 시작하기","text":"RxJs 란? 알기쉬운 Rxjs 강의 01. Rxjs 의 기본 개념 What is Reactive programming Installation Observable Rxjs 강의 02. Data stream 만들기 - from, of, interval, range Rxjs 강의 03. Data stream 합치기 - merge Rxjs 강의 04. Data stream 걸러내기 - filter Rxjs 강의 05. Data stream 변형하기 - map Rxjs 강의 06. 복잡한 Data stream 처리하기 - mergeMap, mergeAll RxJs 란?알기쉬운 Rxjs 강의 01. Rxjs 의 기본 개념What is Reactive programmingReactive Programming is an asynchronous programming paradigm concerned with data streams and the propagation of change 일반적인 프로그래밍 특히 객체 지향 프로그래밍에서는 눈에보이는 객체들을 기반으로한 프로그래밍이 일반적이었습니다. 때문에 어떤 일련의 작업은 순차적인 작업들의 나열이라고 볼 수 있습니다. 즉, 컴퓨터가 어떤 일을 시킬 때에는 일반적으로 시간이 흐름에 따라 순차적으로 어떤 일을 처리하라고 명령을 내리는 것이 일반적인 생각입니다. 하지만, 실제 생활에서는 다음과 같이 순차적인 작업이 아닌 다소 추상적인 작업들이 필요한 경우가 있습니다. 1시간에 한번씩 청소를 해. 청소는 30분 동안 하되, 10분 간격으로 두번 쉬면서 총 3번에 걸쳐서 청소를 해. 만약 컴퓨터에게 위와 같은 작업을 시키기 위해서는 어떻게 해야 할까요? reactive programming 은 이러한 추상적인 시간 개념을 포괄하는 여러 복잡한 비동기 작업을 수행하기 위한 노력은 Data stream 이라는 개념을 도입함으로써 해결하고자 합니다. 즉, 시간에 따른 일련의 데이터의 흐름 자체를 프로그래밍 적으로 순차적 작업이 아닌 여러 비동기 작업들을 물흐르듯이 간편하게 처리하고자 합니다. Rxjs 란 이러한 reactive programming 을 위한 여러 개념들을 구현한 javascript 구현체이며, reactive programming 을 위한 javascript library 라고 생각하시면 됩니다. Installation본 강의 에서는 기본적으로 javascript 를 구동가능한 node.js runtime 이 설치되어 있다고 가정합니다. 다음과 같이 rxjs 를 설치해 줍니다. 1npm install --save rxjs Observable위의 설명처럼 Observable 이란 이러한 일련의 data stream 을 표현하기 위한 자료 구조입니다. 여기서 observable 이란 직역하면 관측가능한 이라는 뜻을 가지며, 말 그대로 그 흐름을 관측 가능한 data stream 이라고 이해하면 됩니다. Observer가 subscribe 하는 observable 시퀀스의 내용들은 observer에게 차례로 전달됩니다. 12345678910const &#123; from &#125; = require(\"rxjs\");const observableItem = from([1,2,3,4,5]);console.log(observableItem); // Observableconst observer = &#123; next:()=&gt;&#123;&#125;, complete:()=&gt;&#123;&#125;, err:()=&gt;&#123;&#125;&#125;const subscribtion = observableItem(observer); Rxjs 강의 02. Data stream 만들기 - from, of, interval, rangeRxjs 강의 03. Data stream 합치기 - mergeRxjs 강의 04. Data stream 걸러내기 - filterRxjs 강의 05. Data stream 변형하기 - mapRxjs 강의 06. 복잡한 Data stream 처리하기 - mergeMap, mergeAll","link":"/2017/12/07/Rxjs-시작하기/"},{"title":"aws sdk cookbook","text":"Setting AWS Region1AWS_REGION=&apos;us-east-1&apos;","link":"/2019/06/03/aws-sdk-cookbook/"},{"title":"Building node API server based on DDD architecture","text":"Building node API server based on DDD architectureDomain LayerDomain 레이어는 각 서브 도메인 마다 model, service, repository를 가지며 다음과 같은 역할을 수행한다. - Model ​ 해당 도메인의 모델링이 정의되고, 해당 도메인 내에서의 항상성과 유효성을 담당한다. - Service ​ 주로 여러 도메인을 아우르는 로직을 처리한다. - Repository ​ 도메인 단위로 DB 입출력을 담당하며, 실제 구현은 infra layer의 repository implementation에서 이루어 지며, interface만 정의되어 있다. API Layer도메인의 서비스들을 조합하며 엔드 유저 레벨에서의 기능수행이 이루어 진다. 가령 특정 재화를 구매함에 따라 결제를 수행하는 어플리케이션이 있다면 본 api 레이어에는 ‘결제’와 같은 엔드 유저 레벨에서의 함수가 들어가며, 결제 데이터 생성, 구매자의 감소 등과 같은 로직은 도메인의 모델 및 서비스 레벨에서 처리된다. Infra layer도메인의 비즈니스 로직들이 잘 수행될 수 있도록 DB, http 라우터 등 외부 환경을 다루는 실제 구현이 이루어 진다. 본 레이어에서 도메인의 repository interface에 정의된 함수들을 실제로 구현하며, express router를 활용하여 외부 요청에 대한 라우팅을 수행한다. 또한 본 레이어에는 middleware, auth guard, errorHandler 처럼 도메인에 접근하기 전에 전처리되거나 비즈니스 로직 이후 클라이언트에게 반환할 반환값에 대한 후처리 로직이 들어간다. auth guard 는 decorator 를 사용하여 제작되었다. Branching Model모든 작업 내용은 feature/[브랜치 명] 에서 작업하고, dev 서버에 배포하기 위한 버전을 develop 브랜치에 푸시한다. Release 브랜치에서 develop 브랜치를 pull 하면서 코드리뷰를 진행하고 모든 코드리뷰 사항이 반영되면 release 브랜치에 머지된다. release 브랜치에서 스프린트 및 일정관리, 테스트 작업을 진행하며 안정화되면 master 브랜치로 push 하고 서비스 배포한다. - Master: 실제 서비스 배포를 위한 브랜치 - Release: 개발 진행의 경과가 되는 브랜치로 QA 및 일정관리의 지표가 된다. - Develop: 각 개발자들이 실시간으로 머지하는 브랜치로 테스트 서버의 소스코드가 보관된다. - Feature: 각 개발자들이 임의로 자신들의 작업량을 작업한다. Input validation본 프로젝트에서는 클라이언트의 요청값을 검증함에 있어 모든 요청의 형태를 DTO 형태로 정의하고 해당 DTO 에 값을 넣기 전에 Joi 라이브러리를 사용하여 요청값에 대한 검증을 수행한다. tsconfig setting각 파일에서 다른 파일을 import 함에 있어서 보다 가독성을 높이기 위해 @domain과 같이 태그를 하여 손쉽게 import를 할 수 있습니다. tsconfig.json 파일의 예 12345678910111213&#123; \"compilerOptions\": &#123; \"paths\": &#123; \"@domain/\": [\"server/domain/\"] &#125; &#125;&#125; 위처럼 옵션을 설정하면 복잡한 filepath 대신 위의 태그네임을 통해 import 할 수 있습니다. 이때 위의 태그네임이 잘 반영이 되지 않는 경우가 있는데, 이는 웹팩에서 트랜스파일링을 하는 과정에서 webpack.config.js 세팅을 바꾸어 줌으로써 해결이 가능합니다. 태그 네이밍을 하기 위해서 tsconfig-paths-webpack-plugin 을 사용하는데 해당 플러그인은 다음과 같이 루트 plugin이 아닌 resolve 내의 plugin 내에 설정되어야 합니다. webpack.config.js의 예 \\1234567891011121314151617181920&#123;​ resolve: &#123;​ plugins: [​ new TsconfigPathsPlugin(&#123;​ configFile: './tsconfig.json' // setup tsconfig path​ &#125;)​ ];​ &#125;&#125;\\ Authorfrontalnh(Namhoon Lee)","link":"/2019/03/22/building-node-api-server-based-on-ddd-architecture/"},{"title":"C 언어 | 상수와 기본 자료형","text":"자료형이란 무엇인가요?자료형이란 데이터를 표현하는 기준이 되며, 정수형 자료형, 혹은 실수형 자료형 인지 등의 데이터의 표현 기준을 정해주고, 명확한 데이터의 크기를 알려줌으로써 메모리에 보다 효과적으로 자료가 저장될 수 있도록 해줍니다. 대표적인 자료형으로는 char, int, float, double 등이 있으며 각각 1바이트, 4바이트, 4바이트, 8바이트의 크기를 가집니다. 이러한 자료형의 크기를 구하는 연산자로는 sizeof() 함수가 있으며 다음과 같이 사용합니다.12int num = 1numSize = sizeof(num) 우리가 컴퓨터에서 표현하는 자료는 앞서 말했듯이 정수와 실수의 큰 기준으로 나뉘게 되며, 여기서 실수형을 표현하는 경우 정확도 향상을 위해 float 이 아닌 double을 사용 합니다. 또 어떤 자료형들이 있나요?C 프로그래밍 시에 자료형 앞에 unsigned와 같은 키워드가 붙은 것을 많이 보았을 겁니다.이 것은 바로 해당 자료형이 unsigned로 나타내는 것을 의미하며 즉, 음수를 구분하지는 못하지만 2배 더 큰 숫자까지 나타낼 수 있게 해주는 것을 의미합니다. 그밖에, 문자를 표현하기 위한 char 자료형이 있는데 이는 ASCII 코드에 의거하여 문자를 나타내는 것을 의미합니다.이러한 ASCII 코드는 1바이트 즉 256가지의 문자를 표현하며, 기본적으로 컴퓨터 내에서 정수형 자료형으로 나타내어 지므로, 정수형 표현과 문자형 표현이 모두 가능합니다. 가령 다음의 예제를 살펴봅시다.123char examplChar = &quot;a&quot;printf(&quot;%d&quot;, examplChar) 이 경우 문자 a의 정수형 표현을 ASCII 코드표에서 찾아 나타내어 줍니다. 상수란 무엇인가요?상수는 int, double에 근거한 것으로 메모리 내에 이름이 없는 literal 상수와 이름이 있는 symbolic 상수로 구분됩니다.이러한 상수는 한번 선언되면 그 값이 바뀔 수 없으며, 만약 이름이 있는 symbolic 상수로 선언되는 경우 이름은 대문자와 아래바 _ 로 구성되는 것이 일반적입니다. 다음의 예는 literal 상수의 예를 보여줍니다.1int exampleNum = 5 + 6 이렇게 literal 상수는 별도의 선언이 없이 값을 나타내며, 위의 경우 5와 6은 literal 상수입니다. 다음은 symbolic 상수의 예를 나타냅니다.1const int MAGIC_NUMBER = 1 이렇게 기본 자료형 int 앞에 const 키워드를 붙여 줌으로써 symbolic 상수를 선언하며, 선언과 동시에 초기화가 되어야 합니다. 만약 상수에 자료형을 지정해 주고 싶다면 어떻게 할까요? 다음은 상수 자료형에 float 으로 표기를 지정해 주는 예를 나타냅니다.1long exampleNum = 5.1235L 이처럼 상수의 뒤에 U, L, UL, LL, F 등을 나타냄으로써 자료형을 알려줄 수 있습니다. 자료형 형 변환이렇게 한번 선언된 자료형은 프로그래밍 도중에 변경될 수 있으며 이것을 형 변환 이라고 합니다. 형변환 에는 자동으로 형이 변환되는 자동 형 변환 과 사용자가 형을 변환해 주는 강제 형 변환 이 있습니다. 먼저 자동 형 변환은 보통 자료형을 일치시켜 계산해야 하는 경우 또는 대입 시에 강제로 형 변환이 되는 경우, 연산 시 빠른 연산을 위해 CPU 에서 자동으로 변환이 되는 경우가 있습니다. 먼저 자료형 일치를 위한 자동 형 변환의 예를 살펴봅시다.123int num1 = 5double num2 = 5.6235double result = num1 + num2 위의 예의 경우 num1 과 num2 는 다른 자료형을 가졌기 때문에, 덧셈연산이 불가능 합니다.이렇게 되면 컴퓨터는 자동으로 num1 과 num2 중 하나의 자료형에 맞추어 연산을 진행하게 되는데, 그 판단의 근거는 정확도를 높이는 방향 으로 진행된다는 것 입니다. 위 예의 경우 num1 과 num2 가 int 형으로 변환되어 계산이 된다면 큰 오차가 생기므로 적은 오차범위를 가지도록 둘 다 double 형으로 변환이 되어 계산이 되게 됩니다. 다음 예는 대입의 과정에서 자동 형 변환이 일어나는 경우입니다.12int num1 = 129char result = num1 num1 은 int 형으로 선언이 되었지만 char 자료형에 할당됨에 따라 4바이트에서 1바이트로 그 크기가 줄어들게 됩니다.이 경우에는 최상위 바이트의 손실이 일어나게 되며 이 경우 00000000 00000000 00000000 10000001 에서 10000001 로 바뀌게 되어 부호가 바뀌게 되는 문제가 생깁니다. 다음은 강제 형 변환 의 예를 살펴봅시다.12345int num1 = 5int num2 = 10double resultresult = (double)num1/num2 위 예는 num1과 num2의 연산을 통해 얻은 0.5를 double로 강제 형 변환 시켜주어 result에 할당하는 예를 보여줍니다.이처럼 (자료형) 키워드를 앞에 붙여줌으로써 강제로 해당 자료형을 바꾸어 줄 수 있습니다.","link":"/2018/05/21/c-언어-상수와-기본-자료형/"},{"title":"c 언어 스트림과 데이터의 이동","text":"스트림과 데이터의 이동컴퓨터 프로그래밍에서 입력이란 프로그램을 기준으로 프로그램 안으로 데이터가 흘러들어가는 것이고 출력이란 프로그램을 기준으로 데이터가 나오는 것이다. 우리는 흔히 컴퓨터 프로그램에 입력을 입력하고 문자열이 출력되는 것을 보면서 어떻게 컴퓨터가 모니터에 저런 문자열을 출력할 수 있는지 궁금해 한다. 우리가 입력하는 문자열이 어떻게 모니터에 출력되는 것일까? 우리가 작성하는 프로그램과 모니터는 기본적으로 연결되어 있는 것이 아닌 떨어져 있는 개체이며 둘 사이에 무언가 정보를 주고 받기 위해서는 이들을 연결시켜주는 다리가 필요하다. 이러한 매개물이 바로 스트림 이다. c 언어 내의 printf 혹은 scarf 와 같은 함수는 운영체제에게 스트림의 형성을 요구하는 것이며 이는 표준 입출력 라이브러리인 stdin, stdout 을 통해 이루어 진다. 단일 문자의 입출력12345678910111213#include &lt;stdio.h&gt;int main(void)&#123; int ch1, ch2; ch1 = getchar(); // 표준 입력 스트림으로부터 하나의 문자를 입력 받아서 반환 ch2 = fgetc(stdin); // 문자를 입력받을 스트림을 지정 putchar(ch1); // 인자로 전달된 문자정보를 stdout으로 표현되는 표준 출력 스트림으로 전송하는 함수 fputc(ch2, stdout); // 문자를 전송할 스트림을 지정할 수 있다. 가령 파일을 대상으로 데이터를 전송한다. return 0;&#125; 문자열의 입출력문자열의 출력 12345678910111213141516171819#include &lt;stdio.h&gt;int main(void)&#123; char *str = \"Simple String\"; printf(\"1, puts test -------- \\n \"); puts(str); puts(\"So Simple String\"); printf(\"2. fputs test ------ \\n\"); fputs(str, stdout); // 두번째 인자에서 출력의 대상 선택 printf(\"\\n\"); fputs(\"So Simple String\", stdout); printf(\"\\n\"); printf(\"3. end of main --- \\n\"); return 0;&#125; 문자열의 입력 123456789101112131415#include &lt;stdio.h&gt;int main(void)&#123; char str[7]; int i; for (i = 0; i &lt; 3; i++) &#123; fgets(str, sizeof(str), stdin); // str의 사이즈 만큼 문자열을 입력받는다. printf(\"Read %d: %s \\n\", i + 1, str); &#125; return 0;&#125; 표준 입출력과 버퍼위처럼 표준 입출력 함수를 통해 데이터를 입출력 하는 경우 해당 데이터들은 운영체제가 제공하는 메모리 버퍼 를 중간에 통과하게 된다. 이 메모리 버퍼는 데이터를 임시로 모아두는 메모리 공간이다. 컴퓨터는 왜 이러한 입출력 스트림을 바로 저장하지 않고 입 출력 버퍼에 보관후에 저장하는 것일까? 이는 바로 데이터의 효율성 때문이다. 모니터와 키보드라는 외부 자원을 활용하는 것은 컴퓨터에게는 상당히 무거운 태스크 이며 이를 최소한으로 수행하기 위해 주고 받는 데이터를 모은 다음 한번에 처리하는 것이다.","link":"/2016/08/12/c-언어-스트림과-데이터의-이동/"},{"title":"css dev note","text":"배경 설정하기 배경 그라디언트 커서 모양 만들기 배경 설정하기배경을 전체로 설정하고 가운데를 보이게 할 수 있다.가장 일반적인 배경 설정이다.123background-position: center;background-repeat: no-repeat;background-size: cover; 배경 그라디언트1234567#grad &#123; background: red; /* For browsers that do not support gradients */ background: -webkit-linear-gradient(left top, red, yellow); /* For Safari 5.1 to 6.0 */ background: -o-linear-gradient(bottom right, red, yellow); /* For Opera 11.1 to 12.0 */ background: -moz-linear-gradient(bottom right, red, yellow); /* For Firefox 3.6 to 15 */ background: linear-gradient(to bottom right, red, yellow); /* Standard syntax */&#125; 커서 모양 만들기1li &#123; cursor: pointer; cursor: hand; &#125;","link":"/2017/11/26/css-dev-note/"},{"title":"css 기본 개념","text":"선택자 선택자12345678910111213141516171819202122232425262728// 아이디 선택자#id_of_the_element&#123; //contents&#125;//클래스 선택자.class_of_the_element&#123; //contents&#125;// 속성 선택자input[type=text]&#123; // contents&#125;// 자손 선택자header&gt;h1&#123; &#125;// 반응, 상태, 구조 선택자div:first-child&#123; &#125;선택자:active&#123; &#125;","link":"/2017/11/26/css-기본-개념/"},{"title":"c 언어 포인터","text":"C 언어 포인터c 에서 포인터를 통해 직접 데이터의 주소에 접근할 수 있으며, 이러한 특성 때문에 C 언어가 low 하다고 불린다. 123456int main(void)&#123; int num =5; // 정수형 변수 num을 생성한다. int * pnum = &amp;num; // 정수형 변수 num을 가리키는 포인터 변수 pnum을 선언한다. *pnum = 10; // pnum이 가리키는 변수에 10을 저장하라&#125; 이처럼 특정 자료를 가리키는 자료형을 정의 할 수 있고, 이를 포인터라 한다. 포인터는 특정 자료형을 가리키고 있다. 여기서 포인터는 어떤 변수를 가리키는 그 자체이므로 메모리의 특정 주소값을 가진다. 때문에 포인터를 선언할 때에는 매우 신중해야 하는데 선언 후 아무 값도 할당 하지 않는다면 포인터는 쓰레기 값으로 초기화 되기 때문이다. 1int *pnum = 399; 가령 위와 같은 코드는 매우 위험한데 이는 pnum이라는 포인터에 399를 할당하고 있고, 우리는 399 의 주소값이 얼마나 중요한 주소인지 전혀 이해하고 있지 못하기 때문이다. 이를 해결하기 위해 반드시 우리는 해당 포인터 값이 이상한 값을 가리키지 않도록 해야 하는데 주로 다음과 같이 널 포인터를 지정해 준다. 12int *ptr2 = 0;int *ptr2 = NULL; 위와 같이 NULL 혹은 0 으로 초기화 하면 시스템은 이것을 0 번째 주소값으로 인식하지 않고 아무것도 가리키지 않는 포인터를 만들어 낸다. 포인터와 배열의 관계c 언어에서 배열의 이름은 그 자체로 포인터 이며, 정확히 말하면 배열의 첫번째 요소의 주소값이다. 123int arr[3] = &#123;1, 2, 3&#125;;printf(\"%p\", arr); // 주소값이 나온다.printf(\"%p\", arr[0]); // 위와 같은 주소값이 나온다. 즉, 배열의 주소는 첫번째 값의 주소를 의미한다. 변수 형태의 문자열 vs 상수형태의 문자열 12345char str1[] = \"my string\";char * str2 = \"your string\";str1[0] = \"x\";// 문자열 변경 성공str2[0] = \"x\"; // 문자열 변경 실패 위처럼 모든 문자열 혹은 배열을 선언하면 그 자체는 그 문자열 혹은 배열의 첫번째 요소의 주소값이 된다. 하지만 위에서 처럼 문자열 혹은 배열 자체를 선언하는 경우와 그것의 주소값을 선언하는 경우에 따라 그 값의 변경 가능 유무가 결정이 된다. 위의 예처럼 str1의 경우 문자열 자체를 저장한 변수형 문자열이며, str2의 경우 문자열에 대한 주소값을 저장하는 상수 형태의 문자열이기 때문에 가리키는 값의 내용이 변경될 수 없다. 포인터 변수로 이루어진 배열다음과 같이 포인터 변수로 이루어진 배열을 선언할 수 있다. 12char * strArr[3] = &#123;\"Simple\", \"String\", \"Array\"&#125;;printf(\"%s \\n\",strArr[0]) // Simple 위처럼 “” 로 감싸진 문자열은 그 자체로 주소값을 나타내기 때문에 위와 같은 결과가 나오게 된다. 큰 따옴표로 묶여서 표현되는 문자열은 그 형태에 상관없이 메모리 공간에 저장된 후 그 주소값이 반환된다.","link":"/2018/08/12/c-언어-포인터/"},{"title":"css 스크롤바 숨기기","text":"123#element::-webkit-scrollbar &#123; display: none;&#125;","link":"/2017/12/26/css-스크롤바-숨기기/"},{"title":"css 애니메이션의 활용","text":"transition을 활용한 사이즈 애니메이션12transition: height 2s;-webkit-transition: height 2s;","link":"/2017/11/30/css-애니메이션의-활용/"},{"title":"go - dep을 통한 go 패키지 관리","text":"Installation윈도우https://github.com/golang/dep/releases 위 링크를 통해 설치를 진행한 뒤 해당 .exe 파일을 go rootpath의 bin 폴더 안에 넣어준다. 프로젝트 폴더 포팅dep을 사용하기 위해서는 반드시 다음과 같은 구조로 폴더를 만들고 포팅해야 한다.GOPATH/src/github.com/directory/projectname download1dep ensure 참조","link":"/2018/05/30/dep을-통한-go-패키지-관리/"},{"title":"direnv 시작하기","text":"direnv(Directory Environment) 란?direnv는 이름 그대로 폴더별로 환경을 관리해주는 도구이다. direnv로 설정을 해 놓으면 폴더 이동을 할 때마다 자동으로 설정해놓은 환경변수나 원하는 런타임 버전 지정 등을 알아서 할 수 있다. 그래서 한번 설정해 놓으면 해당 프로젝트에서 다른 설정에 대해서는 잊어버리고 쉽게 작업을 할 수 있고 어떤 환경 설정을 해놨는지가 궁금해지면 설정 파일을 열어보면 그만이다. direnv는 Go로 작성되었는데 홈페이지에 나온대로 각 OS의 패키지 매니저를 이용해서 설치하거나(macOS라면 brew install direnv) 릴리스 페이지에서 OS에 맞는 바이너리를 받아서 설치해서 사용하면 된다. direnv 를 cli 에 적용하기 설치 후에는 쉘에서 direnv가 실행되도록 해야 하므로 bash를 쓰고 있다면 ~/.bashrc파일에 eval &quot;$(direnv hook bash)&quot;를 추가하면 폴더 이동을 할 때마다 자동으로 실행되게 된다. bash 외에 다른 쉘을 쓰고 있다면 zsh, fish, tcsh를 다 지원하므로 홈페이지를 참고해서 설정하면 된다. 위 명령어를 통해 cli 에서 디렉토리를 이동하는 경우에 훅을 걸어 특정 설정을 적용시킬 수 있다. .direnv 파일의 예 direnv 참고 블로그","link":"/2018/11/22/direnv-시작하기/"},{"title":"ejs 를 통해 express 에서 server rendering 하기","text":"ejs 를 통해 express 에서 server rendering 하기설치하기1npm install --save ejs server code 작성123app.set('views', __dirname + '/views');app.set('view engine', 'ejs');app.engine('html', require('ejs').renderFile);","link":"/2018/08/06/ejs-를-통해-express-에서-server-rendering-하기/"},{"title":"ES6의 중요한 핵심 개념들","text":"ES6의 중요한 핵심 개념들ES6 에서의 변수 선언이전 자바스크립트 버전에서는 변수를 선언하는 유일한 방법은 var 이었지만 ES6에서는 다양한 변수선언 방법을 선언하며 다음은 몇가지 새로운 변수 선언 방법이다. const다른 언어와 마찬가지로 ES6에도 const를 정의할 수 있다.const 를 사용하여 한번 선언된 변수가 덮어씌워질 수 없도록 강제할 수 있다. letES6 에서는 let 을 사용하여 전역 변수를 보호할 수 있다. 가령 var 를 사용하면 다음과 같이 전역 변수가 덮어씌우 지지만 example 123456789var test = 'global'if(test)&#123; var test = 'overwritten' console.log(test) // overwritten&#125;console.log(test) // overwritten 다음과 같이 if 문 안에서 let을 사용하면 전역변수를 보호할 수 있다. 123456789var test = 'global'if(test)&#123; let test = 'overwritten' console.log(test) // overwritten&#125;console.log(test) // global Template String기존 javascript 에서는 문자열과 변수를 함치기 위해 string의 덧셈 연산을 통해 수행하였지만.ES6 문법에서는 ${} 와 같은 스트링 템플릿을 통해 변수를 스트링에 전달할 수 있다. example123var name = 'jhon'var text = `my name is $&#123;name&#125;`console.log(text) // my name is jhon Arrow functionarrow function 을 통해 한 줄에 함수를 선언할 수 있다.arrow function 은 여러 방면에서 매우 편리한데, 가령 리턴을 생략해도 자동으로 해당 내용이 리턴으로 들어가며, 만약 input 변수가 하나인 경우 괄호 마저 생략이 가능하다. 뿐만 아니라 arrow function 은 this의 사용을 방해하지 않기 때문에 this를 사용하면 함수 밖의 context에 바로 접근이 가능하다. 123456789// Oldvar old = function(var1, var2)&#123; return var1 + var2&#125;//newvar arrowFunc = (var1, var2) =&gt;&#123; var1 + var2&#125; Transpiling of ES6아직 많은 브라우저에서 ES6 문법을 지원하지 않고 js는 계속해서 빠른 속도로 변화하고 있기 때문에, 이를 사용하기 위해서는 ES6 문법을 ES5 문법으로 transpile 해주어야 한다. 이러한 작업은 주로 babel 을 통해 이루어 진다. 이러한 transpile은 브라우저 레벨에서 이루어 질 수 도 있고, 서버단에서 transpile 후에 클라이언트로 전달해 주기도 하는데 전자의 경우 간편하게 처리 가능하다 성능면에서 productiondp 레벨에서 사용하기에는 많은 문제가 있다. 전자의 경우 다음코드를 html 에 추가함으로써 간편하게 transpile이 가능하다. 1234&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.js\"&gt;&lt;/script&gt;&lt;script src=\"script.js\" type=\"text/babel\"&gt; &lt;/script&gt; Objects and ArraysES6 에서는 object와 array를 보다 편리하게 사용하기 위한 다양한 문법을 제공한다. Destructuring assignment객체 혹은 배열 내의 자료에 접근하기 위한 매우 편리한 방법인 destructuring assignment를 제공한다.과거의 경우 일일히 해당 프로퍼티에 접근하여 하나씩 엔티티를 가져와야 했다면, 이 방법을 통해 간편하게 entity를 추출할 수 있다. 12345678910111213// destructuring assignment in objectvar personalInfo = &#123; name: 'namhoon', age: 27&#125;var &#123; name, age &#125; = personalInfo; // extracts key value// destructuring assignment in arrayvar list = ['namhoon', 'jake', 'james'];var [firstItem] = list;console.log(firstName); // 'namhoon' Object Literal EnhancementES6 에서는 오브젝트 내에서 함수 및 엔티티를 지정함에 있어 훨씬 편리하다 다음과 같이 외부의 변수를 간편하게 객체 내에 추가할 수 있고, 함수의 선언도 간편해 졌다. 1234567891011121314151617var name = 'namhoon';var age = 25;var personalInfo = &#123;name, age&#125;//&#123;name:'namhoon', age:25&#125;var print = function()&#123; console.log('my name is $&#123;this.name&#125; and im $&#123;this.age&#125; years old');&#125;// new versionvar personalInfo = &#123; name, age, print()&#123; // eaily define function! console.log('my name is $&#123;this.name&#125; and im $&#123;this.age&#125; years old'); &#125;&#125; The Spread Operatorspread operator(…variable) 을 통해 간편하게 배열을 다룰 수 있다.과거 js에서는 배열 혹은 객체 내의 다양한 인자들을 명시하거나 변경하기 위해 필요없는 다를 항목들까지 일일히 명시해야 했다면, spread operator는 우리를 이러한 귀찮음에서 해방시켜 준다. 이런한 spread operator는 다양한 경우에 사용될 수 있으며, 다음은 그 사용 사례이다. array를 이어 붙이는 경우12var peaks = [\"Tallac\", \"Ralston\", \"Rose\"] var canyons = [\"Ward\", \"Blackwood\"]var tahoe = [...peaks, ...canyons] array를 간편하게 복제하는 경우1234var peaks = [\"Tallac\", \"Ralston\", \"Rose\"];var [last] = [...peaks].reverse()console.log(last) // Roseconsole.log(peaks.join(', ')) // Tallac, Ralston, Rose 함수의 인자들을 묶어서 표현하는 경우1234567891011121314151617function directions(...args) &#123; var [start, ...remaining] = args var [finish, ...stops] = remaining.reverse() console.log(`drive through $&#123;args.length&#125; towns`) console.log(`start in $&#123;start&#125;`) console.log(`the destination is $&#123;finish&#125;`) console.log(`stopping $&#123;stops.length&#125; times in between`)&#125;directions( \"Truckee\", \"Tahoe City\", \"Sunnyside\", \"Homewood\", \"Tahoma\") 객체 내 인자들을 묶어서 표현하는 경우12345678910var morning = &#123; breakfast: \"oatmeal\", lunch: \"peanut butter and jelly\"&#125;var dinner = \"mac and cheese\"var backpackingMeals = &#123; ...morning, dinner&#125;console.log(backpackingMeals) Classes이전 버전의 js에서는 class 가 존재하지 않았기 대문에 클래스가 필요한 경우 함수를 만들고 해당 함수에 대한 프로토 타입을 정의하는 방식으로 클래스를 만들어 사용했다.하지만 ES6 부터는 정식을로 Class 를 지원하며 다른 클래스를 extends 할 수 있어 인터페이스의 개념도 추가되었다. 여기서 extends 를 사용하는 경우 construct를 다른 함수에서 super() 를 사용해야 하며, 그 사용사례는 다음과 같다. 1234567891011class Expedition extends Vacation &#123; constructor(destination, length, gear) &#123; super(destination, length) this.gear = gear &#125; print() &#123; super.print() console.log(`Bring your $&#123;this.gear.join(\" and your \")&#125;`) &#125;&#125; ES6 Modules이전 버전의 js 에서는 외부 라이브러리를 가져오는 방법으로만 import 가 가능했지만, ES6 부터는 정식으로 module 을 제공하고 있다.특히 같은 파일 내에서 여러 개의 모듈을 export 하는 것도 가능하며, object destructuring 을 통해 간편하게 import 할 수 있으며, 특정 모듈을 원하는 이름 으로 import 하는 것도 가능하다.다음은 그 사용사례를 보여준다. 12import &#123; print, log &#125; from './text-helpers'import &#123; print as p, log as l &#125; from './text-helpers' 과거버전의 js와 ES6 에서 통용되는 Common.js는 module.exports 를 사용하여 module을 export 하는데 주의할 점은 이렇게 export된 module은 import 를 통해 import 될 수 없다는 것이다. 그 대신 아래와 같이 require를 사용하여 import를 해야 한다. 1const &#123; log, print &#125; = require('./txt-helpers') 많은 라이브러리들이 common.js 를 기반으로 export 되었으므로, 외부 라이브러리를 사용할 때 무분별하게 import 문을 사용하면 import 되지 않는 문제가 있으니 특히 주의해야 한다.","link":"/2018/07/28/es6의-중요한-핵심-개념들/"},{"title":"Deploying BCH node on linux","text":"Brief explanationBinary: /usr/bin/bitcoindConfiguration file: /etc/bitcoin/bitcoin.confData directory: /var/lib/bitcoindPID file: /var/run/bitcoind/bitcoind.pid (OpenRC and Upstart) or /var/lib/bitcoind/bitcoind.pid (systemd)Lock file: /var/lock/subsys/bitcoind (CentOS) Run node with bitcoind아래 명령어를 통해 bitcoin node 를 백그라운드에서 실행시킨다. 1bitcoind -daemon -rpcuser=&lt;user_name&gt; -rpcpassword=&lt;user_password&gt; -rpcport=&lt;port&gt; additional bitcoind options Interact with chain with bitcoin-cli123456bitcoin-cli getinfobitcoin-cli getnetworkinfo # 네트워크 정보 받아옴.bitcoin-cli getblockchaininfo # 블록체인 정보 받아옴.bitcoin-cli listtrasactions # 트랜잭션 목록 나열bitcoin-cli getrawtransaction &lt;transaction_id&gt; truebitcoin-cli stop # stop bitcoin daemon","link":"/2019/05/14/deploying-bch-node-on-linux/"},{"title":"Getting started with docker","text":"Docker 시작하기현대의 대부분의 소프트웨어는 클라우드 환경에서 동작하게 되고, 서비스를 잘게 나누어 다양한 클라우드 환경에서 쉽게 배포하고 운영하기 위한 컨테이너 기술의 필요성이 대두되었다. 도커는 운영체제 위에서 프로세스를 독립적으로 실행가능하게 만들어 주는 리눅스 컨테이너 기술이다. 기본적으로 container 라는 환경을 구성하고 그 안에서 docker image를 실행시키는 방식이다. 여기서 docker image는 실행에 필요한 코드 및 패키지 등 모든 필요사항을 가진다. 도커는 운영체제 위에서 동작하며 같은 커널에서 어플리케이션이 동작하지만 메모리나 OS 등이 완벽하게 격리될 수 있다. Installation아래와 같이 brew 로 docker 를 설치하고, 권한을 할당하여 sudo 없이 docker 를 실행 할 수 있게 해준다. 12brew install docker docker-compose docker-machine &amp;&amp;sudo chmod 666 /var/run/docker.sock 먼저 도커를 실행하면 도커 엔진이 실행되며 도커 이미지를 도커 엔진이 실행하면 컨테이너가 생성된다. 먼저 container를 설정하기 위해서 우리는 dockerfile을 작성해야 하는데 기본적인 dockerfile의 형태는 다음과 같다. Dockerfile 1234567891011121314151617181920212223242526# set node.js environmentFROM node:8-alpine# set working directoryWORKDIR /user/src/app# 앱 의존성 설치COPY package*.json ./# docker image안에 앱의 소스코드를 넣음COPY . .RUN npm install# Make port 80 available to the world outside this containerEXPOSE 8080# Define environment variableENV NAME World# Run app.py when the container launchesCMD [\"npm\",\"start\"]# RUN chmod +x ./docker-entry.sh# ENTRYPOINT \"./docker-entry.sh\" 그 뒤에 다음 명령어를 통해 docker image를 만들어 준다. 12docker build -t test . // image의 별명을 입력받아 docker image를 만들어 준다.docker image ls // 이미지의 목록을 불러온다. 앱 실행하기 다음 명령어를 통해 해당 machine의 4000번 포트를 외부 80번 포트에 연결해 준다. 1docker run -p 4000:80 -d test # test 라는 이미지를 실행한다. Docker container 중지하기 1docker container stop __container_name_or_id__ docker 로그인 하기 1docker login Docker image 배포하기 1234# docker image tag 붙이기docker tag image username/repository:tag# docker 배포하기docker push username/repository:tag 도커 허브의 이미지 받아서 실행하기 1docker run -p 4000:80 username/repository:tag 지우기 1docker container rm __image_id__ 모든 도커 컨테이너 삭제 docker rm $(docker ps -a -q) 모든 도커 이미지 삭제 docker rmi $(docker images -q) 실행중인 컨테이너의 쉘에 접근 docker exec -it container_id /bin/bash docker 실행하면서 bash 실행하기 docker run -p 80:80 -it {컨테이너 이름} /bin/bash Docker network아래 옵션을 주면 네트워크 포트가 매핑된다. 하지만 아래와 같은 host 네트워크는 리눅스 운영체제에서만 동작하고 mac 이나 window 환경에서는 호스트의 포트에 매핑이 되지 않으니 주의하여야 한다. 1docker run --network host Docker Composecontainer 내에서 여러개의 image가 돌아야 하고 서비스가 복잡해 질수록 많은 이미지들을 관리해야할 필요가 생기게 된다. 여기서 docker-compose.yml을 사용한다. 즉, docker compose 는 여러개의 도커 컨테이너가 동작하기 위한 방법을 기술한 것이다. Docker-compose.yml 파일은 docker container가 배포 환경에서 어떻게 동작해야 할지 명시한다. docker compose의 동작 순서는 다음과 같다. dockerfile 과 함께 어플리케이션의 환경을 정의하여 어디에든 배포할 수 있도록 설정한다. docker compose 파일에 서비스들을 정의하여 독립된 환경에서 함께 실행될 수 있도록 한다. docker compose 를 실행시킨다. docker-compose example 12345678version: '3'services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" 123docker swarm initdocker stack deploy -c docker-compose.yml getstartedlabdoocker service ls 앱과 swarm을 내리기 12docker stack rm getstartedlabdocker swarm leave --force 여기서 swarm 이란 여러 서버에서 동작하는 앱처럼 분산환경에서 배포하기 위한 것이다. 여러 대의 machine을 swarm 이라 불리는 dockerized cluster로 합쳐준다. swarm을 실행하면 전체 노드들의 관리자로써 swarm을 통제할 수 있게 된다. 다음은 해당 machine을 swarm의 관리자로 임명하고 초기화하는 명령어이다. 1docker swarm init Docker-machine을 통해 virtual machine을 생성할 수 있는 hypervisor를 만들 수 있다. 아래 명령어를 docker-machine을 통해 vm들을 생성하는 명령어이다. 123docker-machine create --driver virtualbox myvm1docker-machine create --driver virtualbox myvm2docker-machine ls 다음 명령어를 통해 특정 vm이 swarm의 manager가 되도록 한다. 1docker-machine ssh myvm1 \"docker swarm init --advertise-addr &lt;myvm1 ip&gt;\" 특정 vm이 swarm에 참여하도록 하려면 다음 명령어를 수행한다. 123docker-machine ssh myvm2 \"docker swarm join \\--token &lt;token&gt; \\&lt;ip&gt;:2377\" swarm에 포함된 node 들을 보는 명령어는 다음과 같다. 1docker-machine ssh myvm1 \"docker node ls\"","link":"/2019/01/23/docker-시작하기/"},{"title":"express 시작하기","text":"Express란?Express는 자체적인 최소한의 기능을 갖춘 라우팅 및 미들웨어 웹 프레임워크이며, Express 애플리케이션은 기본적으로 일련의 미들웨어 함수 호출이다. Installationnpm install express --save","link":"/2018/03/18/express의-기본-개념/"},{"title":"Event Sourcing And CQRS","text":"Event Sourcing이벤트 소싱이란 기존의 관계형 데이터베이스의 저장 방식과 달리 데이터 저장을 수많은 이벤트들을 묶음으로 저장하는 것을 의미한다.사실 event sourcing 이란 사실 현실에서는 너무도 흔한 방법이다. 가령 회계장부를 기록한다고 할때 우리는 회사의 보유 자금을 현재 상태만을 기록하는 것이 아니라 과거 매출, 비용 등의 합산으로 계산한다. 그래야 과거의 정보가 투명하게 공개되고 다양한 재무 데이터의 활용이 가능하기 때문이다. 이처럼 실제 행위의 집합들을 저장하는 방식을 event sourcing이라 한다. 하지만, 다음과 같은 경우를 생각해보자만약 과거의 데이터를 수정해야 할 일이 생긴다면 어떨까?이 경우도 실제 회계에서 하는 방법과 같은 원칙을 따른다. 바로 과거의 특정 기록으로 돌아가 해당 부분만을 수정하고 뒤를 전부 다시 작성하는 것이다. 이는 매우 비효율 적이어 보이지만 데이터 그 자체가 매우 중요한 회계에서는 너무도 당연한 진리이다. 이는 데이터 혹은 이벤틀의 삭제에도 영향을 주는데, event soucing에서는 원칙적으로 delete가 없다. 이는 회계장부 작성과도 그 흐름을 동일시 하는데, 가령 회계장부를 작성할 때에는 잘못된 정보를 기입하면 그 후에 그를 상쇄시키는 추가적인 기록을 추가한다. 그래야만 누군가가 고의로 데이터를 조작했는데와 같은 정보들을 유추할 수 있기 때문이다. 동일한 논리가 event sourcing에서도 적용된다. 왜 이런 event sourcing이 현대 software에서 중요하게 되었을까? 그것은 바로 현대 사회에서 데이터의 가치가 너무도 중요하기 때문이다. 과거 쇼핑몰에서는 고객이 단순히 구매 혹은 판매 등의 정보만을 기록한 반면 요즘 사회에서는 장바구니에 물건을 넣었다 빼는 빈도와 주기 시기 등에 대한 데이터를 활용하여 각종 비즈니스 정책들이 결정되며 이 모든 사소한 행위 데이터를 기록하는 것은 너무도 중요하고 그것이 event sourcing의 필요성이다. 이처럼 event sourcing을 통한다면, 특정 시기의 정확한 상황을 재현할 수 있는데, 가령 우리가 역사를 기록하는 것과 같은 원리이다. 특정 시기의 단편적 정보가 아닌 그 시기에 일어나는 일련의 사건들을 정확히 재구현 할 수 있을때 즉, 마치 타임머신을 타고 여행하듯이 정치 사회 경제에 대한 총체적인 재구성을 통해서만 그 시기의 명확한 사회적 상황을 알 수 있다. 이처럼 비즈니스 세계에서도 event sourcing을 통해 과거의 특정 상황에 대한 명확한 인사이트를 가질 수 있다. 이러한 event sourcing 은 소프트웨어 테스트 시에도 활용될 수 있다.가령, 기존의 모든 테스트 행위를 event로 기록해 놓으면, 개발이 완료된 뒤에 정확히 같은 테스트를 수천번이고 반복해서 수행해 볼 수 있다.가령 보험 서비스의 경우에 A 라는 사람의 주소가 바뀌면 Manager가 해당 주소가 바뀜을 알리고 회계부서, 지급 부서 등 많은 부서에 해당 사실을 알리고 로직을 처리해야 한다. 하지만 event 를 사용하면 그저 Manager는 쿨하게 “A의 주소가 바뀜!” 만을 외치면 기타 여러 부서에서 주의깊게 관찰하고 있다가 이벤트가 발생하면 그에 맞는 로직을 스스로가 처리하여 Manager의 독립성이 높아지게 된다. 그 순서는 다음과 같다. Command 발생 Command Hander에 발생한 Command를 전달하고 event 발생 aggregation 변형 CQRS 패턴이란?위와 같은 event sourcing에 있어 데이터의 읽기와 쓰기는 너무도 다른 기능이다. 쓰기의 경우 특정 이벤트를 저장하는 아주 단순한 로직인데 반해 읽기의 경우 읽기의 구간 특정 시기의 스냅샷과 같은 복잡한 로직이 동반되는 경우가 다반사 이다. CQRS에서는 이렇게 이벤트의 저장과 읽기를 위해 두 종류의 명령을 내리는데 하나는 데이터를 저장하는 Command 와 이벤트를 읽어 오는 query 이다.","link":"/2018/05/22/event-sourcing-and-cqrs/"},{"title":"Five changes that blockchain technology will bring","text":"Five changes that blockchain technology will bringThe rise of blockchain technologyOne of the hottest topics of the day is AI technology.The intellectual ability of AI surpasses human experts overwhelmingly in certain areas, and the effects of AI in many areas are astonishing.However I think that the technology that will transform our lifestyle in the near future is by far the blockchain.Block chain technology is a technology that blocks transaction ledger, stores them on their computers and smartphones, and binds them with chains.These blockchain technologies completely transform existing online platforms that require existing central DBs and central servers, and are expected to make the following significant changes Decentralized databaseThe Internet was created and all the internet service and products were consists of servers who keeps all the data and the clients who provide data and can use very small amount of data. Although all the information is freely available through the Internet, in fact, there have been many problems in the context of the fact that a small number of companies can run businesses with their own database and generate huge profits from these data. 어떤 경우에는 For example, in Honduras, the ownership of land in certain parts of Honduras is based solely on information stored in the central database, and thus, in many underdeveloped countries, personal ownership, if exploited by a third party or government, was virtually a piece of waste paper that existed only.But blockchain technology does not need a central DB and it is safe to call it democratization of information because everyone can know, share, and preserve personal information and ownership because all participants on the platform act as notaries.Through these blockchain technologies, individuals can escape the gull of exploitation of large enterprises, and realize the democratization of information in the real sense. 진정한 의미의 공유경제의 실현최근에는 많은 공유기업들의 전성시대 였다. 가령 우버, AirBnb 등과 같은 기업은 개인의 유휴자산을 다른 사람들에게 판매할 수 있는 창구를 만들어 주고, 사회 전체의 입장에서 재화의 효율적인 사용을 해 줄 수 있는 창구가 되었지만, 기업의 입장에서 보면 수많은 유휴자산을 거래하는 중심자 역할을 하고 막대한 양의 수수료로 수익을 거두었다. 사실상 공유경제라기 보다는 새로운 시장을 창출해 내었다고 하는 편이 무방하겠다. 하지만 블록체인 기술은 이러한 공유경제 기술의 최고봉이라 할 수 있다.가령 숙방업을 공유하는 블록체인 플랫폼을 만들었다고 가정하다. 만약 누군가가 집을 공유하고 싶다면 이러한 블록체인에 자신의 집을 등록하기만 하면 모든 시스템 적인 부분을 제공받을 수 있다.누가 어떤 숙소를 이용하는 지에 대한 모든 정보는 플랫폼에 남게 되고 모두가 공증을 서므로 기존에 비해 훨씬 안전하다.또한 블록체인을 통한 결제가 이루어 지므로 매우 저렴하고 안전하게 결제까지 이루어 질 수 있다.기존에는 자신의 재화를 판매하기 위해 마케팅 등 다양한 노력이 필요했지만, 블록체인 이후의 사회에서는 재화 자체가 하나의 비즈니스를 뜻하게 된다 해도 무방하다. 세계의 부의 흐름바람직한 사회라면 선진국에서 후진국으로의 자금의 흐름이 원활해야 한다는 것은 그 누구도 이견이 없을 것이다.하지만 이러한 자금의 흐름을 살펴보면 대부분은 기업의 원조, 혹은 사회 단체의 원조가 아닌 개인의 송금이 가장 크다.후진국의 국민이 다른 나라에 가서 취업을 하고 받은 임금을 다른 나라로 송금하는 경우가 매우 많고 이것이 선진국에서 후진국으로의 화폐이동의 가장 큰 부분을 담당한다. 하지만 현재의 경우 국가와 국가 사이에 돈이 오고가기 위해서는 수많은 단계가 필요하며 금융 시스템을 통과하면수 막대한 양의 중간 수수료(약 20% 가량)이 발생하게 되고 이는 후진국의 경제 개발에 큰 걸림돌이 되고 있다. 하지만 최근 생겨나오는 블록체인을 통한 거래를 통해서는 거래 수수료가 2%에 불과하기 때문에 부가 훨씬 더 원활하게 돌 수 있다. 데이터의 민주화현대 사회에서는 수많은 디지털 정보들이 발생하고 개인의 디지털 정보들이 모이면 디지털 상에서의 자신을 대변할 수 있는 일종의 디지털 트윈이 생겨나게 된다.현대 사회의 많은 기업들은 개인의 이러한 디지털 트윈을 카피하여 어떤 상품을 제공하고 마케팅을 할지에 대한 의사결정을 하며 이는 다시 거대 기업의 이윤증가에 기여하게 된다.하지만 블록체인 기술은 자신의 디지털 트윈을 자신이 소유하고 필요한 부분만을 기업에게 공급함으로써 자신의 개인 정보를 보호받을 수 있고, 기업도 필요한 정보만을 쉽게 취득할 수 있기에 양측에 보탬이 된다. 콘텐츠의 가치를 지켜라인터넷이 발명되어 가장 큰 가치를 잃은 사람들은 아마도 콘텐츠 제작자일 것이다.기존에는 훌륭한 컨텐츠를 만들면 대부분의 수익을 해당 콘텐츠 제작자가 가져갔고, 사실 이것이 자유 경제사회에서 어쩌면 당연한 부분이다.하지만 소수의 독점기업들이 판권을 뒤흔들고 판매처를 확고히 부여잡은 오늘의 사회에서는 컨텐츠 제작자에게 합당한 보상이 돌아가지 못한다.하지만 블록체인 기술은 개인의 지적재산권을 확실하게 지켜주기에 콘텐츠 자체의 가치를 높일 수 있다.","link":"/2018/01/15/five-changes-that-blockchain-technology-will-bring/"},{"title":"Getting started with AWS lambda","text":"Create IAM UserUsing AWS CLI다음과 같은 AWS CLI 를 확인하여 Administrators 유저 그룹을 만들고 루트 계정을 생성한다. 12345brew install aws # install aws cliaws iam create-group --group-name Administrators # create iam groupaws iam list-groups # list groupsaws iam attach-group-policy --group-name Administrators --policy-arn arn:aws:iam::aws:policy/AdministratorAccess # AdministratorAccess Policy 적용aws iam list-attached-group-policies --group-name Admins # 적용된 Policy 확인 Create Lambda function함수의 확인 1aws lambda list-functions Serverless Application Management(SAM)Lambda Function 을 작성하고 배포하는 일련의 과정을 위해서 SAM 을 사용한다. 123brew install aws-sam-cli # install SAMsam init # initialize samsam local start-api # test locally local test아래 함수를 실행하면 로컬의 3000번 포트에서 lambda 함수들이 동작된다. 1sam local start-api create package람다함수가 클라우드 환경에서 실행되기 위해서는 S3 버킷에 배포되어야 하고 이를 위해 package 화를 시켜야 한다. 123sam package \\ --output-template-file packaged.yaml \\ --s3-bucket &lt;bucketname&gt; 위 명령어를 실행하면 sam-app/hello_world 디렉토리를 압축하여 .zip 파일을 만들고 amazon s3 에 업로드 한다. 여기서 새롭게 생긴 packaged.yaml 파일은 template.yaml 파일과 동일한 내용을 가지지만 차이가 있다면, packaged.yaml 파일의 경우 codeUri 가 실제 클라우드 uri 를 가진다는 것이다. Deploy AWS lambda패키지화를 다 시키고 s3 를 업데이트 했다면 lambda 함수를 배포할 차례이다. 12345sam deploy \\ --template-file packaged.yaml \\ --stack-name samp-app \\ --capabilities CAPABILIY_IAM \\ --region ap-northeast-2 npm serverlessSAM 이 아니라 serverless 는 npm 패키지로 좀 더 쉽다. 아래와 같이 설치하고 1npm install -g serverless # install serverless serverless.yaml 123456789service: my-appprovider: name: aws runtime: nodejs8.10 functions: helloWorld: handler: handler.js handler.js 1234module.exports.run = (event, context, callback)=&gt;&#123; console.log(\"Debugging...\"); callback(null,\"hello world\");&#125; deploy 12sls deploy # deploy projectsls deploy function --function helloWorld # deploy function invoke 1sls invoke --function helloWorld --log What is AWS LambdaCLI Tool","link":"/2019/05/06/getting-started-with-aws-lambda/"},{"title":"Getting started with AWS Cloudfront","text":"Cloudfront sms 정적, 동적 웹 콘텐츠를 빠르게 distribute 하기 위한 서비스이다. 이를 위해 aws 는 edge location 이라는 데이터 센터의 네트워크에 사용자의 데이터를 보관한다. 여기서 제일 빠르게 배포될 수 있는 edge location 으로 route 된다. 만약 해당하는 edge location 에 파일이 없다면, cloudfront 는 원본 위치에서 파일을 가져온다. cloudfront 를 사용하지 않으면 네트워크는 해당 파일이 어디에 있는지 모르기 때문에 여러 네트워크를 경유해서 낮은 latency 를 가지게 된다. 당시의 파일은 여러개의 edge location 에 복사되어 저장된다. How to setup specify origin server like s3 ec2 etc… upload file to origin serverincluding web pages, fines, if you use s3bucket make it public create cloudfron distribution Cloudfron assigns a domain name to you new distribution that you can see in cloudformation console edge locations which is collections of servers in geographically dispersed data centers copies of your objects","link":"/2019/06/18/getting-started-with-aws-cloudfront/"},{"title":"Getting started with aws vpc","text":"What is VPCVPC 란 Virtual Private Cloud 의 약어로 사용자가 모든 AWS 자원에 대한 Access Control 이 가능한 private network 입니다. 즉, 사용자는 VPC 안의 Internet Gateway, Route Table, Subnet 등 다양한 네트워크 리소스를 마음대로 제어할 수 있으며 자신의 네트워크에 접근할 수 있는 사용자들에 대한 권한설정이 가능합니다. 다음 그림은 AWS 의 VPC 를 시각적으로 표현한 도식입니다. 아마존에는 수많은 region 이 존재하며, 이는 전 세계에 분포되어 있으며, 각 지역별 가용한 zone 을 Availavility Zone 이라고 부릅니다. 사용자는 여러 availability 존에 분산하여 리소스를 운영함으로써 aws 에 지역적인 결함이 생겨도 문제없이 서비스를 운영할 수 있습니다. VPC 는 이러한 여러 Region 을 모두 포괄하는 개념입니다. VPC를 세팅함에 있어 다음과 같은 순서로 진행합니다. Choosing IP AddressVPC 는 네트워크로써 외부에서 접근하기 위한 IP 주소를 가지며, 내부 ip를 사용합니다.사용할 내부 IP의 범위를 설정하며 이는 CIDR 표기법으로 작성합니다. Routing Table 을 설정합니다.VPC 내부에서 외부로 자원을 요청할 때, VPC 는 외부 주소를 확인해야 합니다. 이처럼 외부 주소를 라우팅 해주는 Route Table 이 필요하며 Routing Table 은 외부 요청에 대한 Routing 을 담당합니다. Security Group각 VPC 에는 여러 개의 Security 그룹을 가질 수 있으며, VPC 내의 리소스 마다 해당 VPC에 종속되는 Security 그룹을 할당합니다. Choosing IP Address사용할 내부 IP 의 범위를 설정합니다. Routing Table아래와 같이 요청을 Route 해줄 Routing Table 을 설정합니다. 네트워크 외부로의 요청에 대한 Routing 을 담당합니다. 해당 VPC 의 모든 내부 ip 는 local 로 routing 하며 그 외의 모든 주소에 대해서는 Internet Gateway 에 요청을 전달하고 적합한 목적지로 요청을 Routing 해줍니다. Setup Subnet요청에 대한 접근 관리는 Security Group 설정으로 관리됩니다. 위 그림에서 위의 4개의 인스턴스는 웹 서버를 의미하며, 아래의 세개의 인스턴스는 웹 서버에서만 접근이 가능한 private resource 입니다. 각 subnet 은 vac 의 서로 다른 내부 ip range 를 할당하여 가상으로 다른 네트워크로 분리합니다. 이 경우 두개의 resource 를 각각 public subnet 과 private subnet 으로 나누어 관리할 수 있으며 각 subnet 마다 다른 security 그룹을 할당하여 접근을 관리할 수 있습니다. ## Outbound request in VPC아래와 같이 외부로의 요청을 처리하는 NAT 는 VPC 의 내부 ip range 로의 모든 요청을 VPC 내부로 Route 하고 그 외의 모든 요청을 NAT Gateway 를 통한 외부접근으로 설정한다.","link":"/2019/04/20/getting-started-with-aws-vpc/"},{"title":"Getting started with AWS cli","text":"AWS 에는 수많은 기능이 있고, 이를 실제 웹사이트에서 console 을 통해 제어하는 것은 개발자에게 매우 비효율적인 일이 아닐 수 없다. AWS 는 이렇게 사용자의 컴퓨터에서 AWS 상의 많은 기능을 제어하기 위해 AWS CLI 프로그램을 제공하며, 본 포스트에서는 AWS CLI 의 기본적인 사용법을 알아보고자 한다. InstallationMacMac OS 에서는 다음과 같이 pip 명령어를 통해 aws cli 를 쉽게 설치할 수 있다. 1pip install awscli UbuntuAuthenticationAWS 는 현재 cli 프로그램을 사용하는 내가 어떤 유저인지 모르기 때문에 이를 AWS 에게 알려주어야 하며, 그것이 authentication 자체이다. 사용자의 PC에는 여러 AWS 유저들에 대한 정보를 저장할 수 있는데, AWS 는 매우 복잡한 유저 관리 체계를 가지기 때문에 이는 매우 필요한 일이다.(가령 특정 AWS 서비스의 조작을 위한 별도 Program user 를 생성하는 경우 여러 개발자가 하나의 계정을 공유하여 사용하는 것은 매우 빈번한 일이다.) Command 를 입력할 때 특정 사용자임을 밝히기 아래 명령어를 통해 aws access key 와 secret key 를 등록하고 사용할 수 있다. 1aws configure 다음과 같은 command option 을 통해 내가 어떤 사용자인지 알리고, 미리 configure 되어있는 해당 사용자의 정보로 authentication 을 진행할 수 있다. 1aws [command] --profile 사용자이름 MFA 를 사용하는 경우의 인증 콘솔 계정의 경우 cli 를 통한 작업을 진행할 경우 MFA 를 적용했다면 Access Deny 된다. 이 경우 MFA 유저를 위해 별도의 임시 인증을 거쳐야 하는데 이는 다음 명령어로 해결이 가능하다. 1aws sts get-session-token --serial-number &lt;arn-mfa-device&gt; --token-code 126355 --profile jee arn-mfa-device 는 각 AWS계정 정보에 들어가서 보안자격증명 탭에 할당된 MFA 디바이스를 보시면 알 수 있다. token-code 는 Authy와 같은 2FA 토큰 값을 입력해 주면 된다. 커맨드를 실행하시면 임시 Access Key가 발급되고 Access ID, Secret Access Key, Session Token을 환경변수나 credential에 profile로 등록하신후 사용하면 된다. 때문에, 만료시간이 있기때문에 매번 재발급받아야하는데 AWS에서는 이를 각자 Cron Tab등으로 만들어서 사용하는 것을 권장한다. 다음과 같이 credential 에 등록하여 사용하면 된다. ~/.aws/credential 1234[profile name]AWS_ACCESS_KEY_ID = &lt;aws_access_key_id&gt;AWS_SECRET_ACCESS_KEY = &lt;aws_secret_access_key&gt;AWS_SESSION_TOKEN = &lt;asw_session_token&gt; ConfigurationAWS 사용자 및 기타 전역 설정에 대한 정보는 /.aws 의 config 파일에 저장되어 있다. 해당 파일을 열어보면 다음과 같이 세팅되어 있다. config 1234567[profile user1]aws_access_key_id = XXXXXXXXXXXXXXXXXXXXXXXXaws_secret_access_key = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXregion = ap-northeast-2[default]region = ap-northeast-2 그 중에서도 유저 정보는 credentials 에 다음과 같이 저장되어 있다. ~/.aws/credentials 12345678[default]aws_access_key_id = XXXXXXXXXXXXXXXXXXXXaws_secret_access_key = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXregion = ap-northeast-2[&lt;profile_name&gt;]aws_access_key_id = XXXXXXXXXXXXXXXXXXXXaws_secret_access_key = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 이처럼 기본 user 인 [default] 유저와 특정 유저를 나타내는 [profile user_name] 이 나뉘어 있다. 여기에 정의된 특정 profile 은 command line 에서 --profile user1 과 같이 사용될 수 있다.","link":"/2019/01/29/getting-started-with-aws-cli/"},{"title":"Getting started with AWS","text":"Route53Route53 은 AWS 가 제공하는 DNS 서비스이며, 실제 도메인을 구입하고 도메인의 routing 을 설정하고 subdomain 지정 등 많은 일을 수행할 수 있다. Route 53은 도메인과 동일한 이름의 퍼블릭 호스팅 영역을 자동으로 생성한다. 퍼블릭 호스팅 영역이란 특정 도메인(예: example.com)과 그 하위 도메인(apex.example.com, acme.example.com)의 트래픽을 인터넷에서 라우팅하는 방식에 대한 정보를 담고 있는 컨테이너로, 호스팅 영역에 레코드를 생성하여 도메인 및 하위 도메인에 대한 트래픽의 라우팅 방법을 지정한다. 트래픽을 리소스로 라우팅하려면 호스팅 영역에 리소스 레코드 세트 라고도 하는 레코드를 생성해야 합니다. 각각의 레코드에는 도메인의 트래픽을 라우팅할 방법에 관한 다음과 같은 정보가 포함되어 있습니다. 이름 레코드의 이름은 Route 53을 사용하여 트래픽을 라우팅하려는 도메인 이름(예: example.com) 또는 하위 도메인 이름(예: www.example.com)과 일치합니다. 호스팅 영역에 있는 모든 레코드의 이름은 반드시 호스팅 영역의 이름으로 끝나야 합니다. 예를 들어 호스팅 영역의 이름이 example.com이라면 모든 레코드 이름이 example.com으로 끝나야 합니다. Route 53 콘솔은 자동으로 이 작업을 수행합니다. 형식 레코드 유형은 일반적으로 트래픽을 라우팅할 리소스 유형을 결정합니다. 예를 들어 트래픽을 이메일 서버로 라우팅하려면 [Type]을 [MX]로 지정합니다. IPv4 IP 주소를 가진 웹 서버로 트래픽을 라우팅하려면 [Type]을 [A]로 지정합니다. 값 [Value]는 [Type]과 밀접한 관련이 있습니다. [Type]을 [MX]로 지정하는 경우, [Value]에 하나 이상의 이메일 서버의 이름을 지정해야 합니다. [Type]을 [A]로 지정하는 경우, 192.0.2.136과 같은 IPv4 형식의 IP 주소를 지정해야 합니다. * 출처: AWS 홈페이지 Load balancerRoute53 에서 라우팅 된 요청을 여러 인스턴스에 분배해주는 부하 부산기이다. 로드 밸런서는 특정 서브도메인을 특정 타겟 그룹으로 보내도록 설정할 수 있으며, 이는 로드밸런서가 특정 프로토콜 통신을 위해 듣고 있는 포트의 rule 을 바꾸어 줌으로써 해결할 수 있다. 가령 80 번 포트 리스너에서 특정 서브 도메인을 특정 타겟 그룹으로 전달 할 수 있으며, 이때 반드시 타겟 그룹을 미리 설정해 두어야 한다. 타겟 그룹은 여러 인스턴스들과 특정 포트를 등록해 두는 것으로 이를 통해 로드 밸런서가 특정 타겟 그룹의 여러 인스턴스들에게 부하를 분산해서 할당한다. AWS CLIAWS 에는 수많은 기능이 있고, 이를 실제 웹사이트에서 console 을 통해 제어하는 것은 개발자에게 매우 비효율적인 일이 아닐 수 없다. AWS 는 이렇게 사용자의 컴퓨터에서 AWS 상의 많은 기능을 제어하기 위해 AWS CLI 프로그램을 제공하며, 본 포스트에서는 AWS CLI 의 기본적인 사용법을 알아보고자 한다. InstallationMac OS 에서는 다음과 같이 pip 명령어를 통해 aws cli 를 쉽게 설치할 수 있다. 1pip install awscli AuthenticationAWS 는 현재 cli 프로그램을 사용하는 내가 어떤 유저인지 모르기 때문에 이를 AWS 에게 알려주어야 하며, 그것이 authentication 자체이다. 사용자의 PC에는 여러 AWS 유저들에 대한 정보를 저장할 수 있는데, AWS 는 매우 복잡한 유저 관리 체계를 가지기 때문에 이는 매우 필요한 일이다.(가령 특정 AWS 서비스의 조작을 위한 별도 Program user 를 생성하는 경우 여러 개발자가 하나의 계정을 공유하여 사용하는 것은 매우 빈번한 일이다.) Command 를 입력할 때 특정 사용자임을 밝히기 아래 명령어를 통해 aws access key 와 secret key 를 등록하고 사용할 수 있다. 1aws configure 다음과 같은 command option 을 통해 내가 어떤 사용자인지 알리고, 미리 configure 되어있는 해당 사용자의 정보로 authentication 을 진행할 수 있다. 1aws [command] --profile 사용자이름 MFA 를 사용하는 경우의 인증 콘솔 계정의 경우 cli 를 통한 작업을 진행할 경우 MFA 를 적용했다면 Access Deny 된다. 이 경우 MFA 유저를 위해 별도의 임시 인증을 거쳐야 하는데 이는 다음 명령어로 해결이 가능하다. 1aws sts get-session-token --serial-number &lt;arn-mfa-device&gt; --token-code 126355 --profile jee arn-mfa-device 는 각 AWS계정 정보에 들어가서 보안자격증명 탭에 할당된 MFA 디바이스를 보시면 알 수 있다. token-code 는 Authy와 같은 2FA 토큰 값을 입력해 주면 된다. 커맨드를 실행하시면 임시 Access Key가 발급되고 Access ID, Secret Access Key, Session Token을 환경변수나 credential에 profile로 등록하신후 사용하면 된다. 때문에, 만료시간이 있기때문에 매번 재발급받아야하는데 AWS에서는 이를 각자 Cron Tab등으로 만들어서 사용하는 것을 권장한다. 다음과 같이 credential 에 등록하여 사용하면 된다. ~/.aws/credential 1234[profile name]AWS_ACCESS_KEY_ID = ~AWS_SECRET_ACCESS_KEY = ~AWS_SESSION_TOKEN = ~ ConfigurationAWS 사용자 및 기타 전역 설정에 대한 정보는 /.aws 의 config 파일에 저장되어 있다. 해당 파일을 열어보면 다음과 같이 세팅되어 있다. config 1234567[profile user1]aws_access_key_id = XXXXXXXXXXXXXXXXXXXXXXXXaws_secret_access_key = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXregion = ap-northeast-2[default]region = ap-northeast-2 그 중에서도 유저 정보는 credentials 에 다음과 같이 저장되어 있다. credentials 123[default]aws_access_key_id = XXXXXXXXXXXXXXXXXXXXaws_secret_access_key = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 이처럼 기본 user 인 [default] 유저와 특정 유저를 나타내는 [profile user_name] 이 나뉘어 있다. 여기에 정의된 특정 profile 은 command line 에서 --profile user1 과 같이 사용될 수 있다.","link":"/2019/01/29/getting-started-with-aws/"},{"title":"Getting started with DEX","text":"What is DEX?DEX 란 Decentralized Exchange 의 약어로 중간자 없이 가상화폐 지갑과 지갑 사이의 p2p 교환을 해주는 것이다. DEX 에서는 custody 즉, 누가 거래에서의 키를 보관하는가에 대한 중대한 이슈가 있으며, DEX 는 모든 교환과정에 있어 개인이 키를 소유하고 완변하게 decentralized 되 토큰의 교환을 하는 것에 그 목적이 있다. Basic Procedure본 프로젝트에서 DEX 의 기본적인 프로세스는 다음과 같다. 먼저, 브라우저 상에서 토큰의 교환을 원하는 사용자가 매도 혹은 매수 주문을 걸면, 해당 주문정보를 EIP 712 로 서명한 서명정보와 함께 전달하면, Relayer API 를 통해 해당 기록이 off-chain 상의 orderbook 에 기록되게 된다. 그 이후, orderbook 을 조회하여 여러 주문들의 쌍을 받아와 교환이 가능한 거래쌍을 선정하여 스마트 컨트랙으로 전송한다.(즉, 하나의 taker order와 하나 이상의 maker order 들을 전달하며, 모든 주문은 서명이 완료된 주문이다. 여기서, 전송을 하는 과정에 있어 주문에 필요한 다양한 정보들을 전부 parameter 로 전달하면 gas 비 문제등 많은 문제들이 존재하기 때문에, 거래에 필요한 데이터를 data 라는 필드로 만들어 OrderParam 에 포함하여 전달한다. 또한, 위 과정을 진행함에 앞서 실제 거래의 주체가 아닌 relayer 를 통해 자금을 교환하기 때문에 플랫폼에서 만들어둔 relayer account 를 approve 하여 일정 자금에 대한 사용권한을 주어야 한다. 스마트 컨트랙에 전달된 인자들이 들어오면, 컨트랙은 주어진 주문 쌍을 분석하여 거래를 진행하기 위한 Result 들의 집합으로 나누고, 해당 주문을 filled 라는 orderHash:amount 쌍에 기록한다. Smart Contract주문의 전달모든 주문은 Order Server 내의 orderbook 에 기록되고, 매칭이 가능한 조합들을 모아 스마트 컨트랙트의 matchOrders 를 호출하며, 그 인자는 다음과 같다. 123OrderParam memory takerOrderParam,OrderParam[] memory makerOrderParams,OrderAddressSet memory orderAddressSet 여기서 order param 은 주문에 필요한 maker와 taker 의 요청정보이며, 그 형태는 다음과 같다. OrderParam 12345678struct OrderParam &#123; address trader; uint256 baseTokenAmount; uint256 quoteTokenAmount; uint256 gasTokenAmount; bytes32 data; # 주문정보를 조합하여 32byte 로 축약, 가스비 절약 목적 OrderSignature signature; # EIP 712 서명&#125; 위에서 base token 과 quote token 이 무엇인지 헷갈릴 수 있는데, taker가 매도 혹은 매수를 할때 기준이 되는 토큰을 base token이라고 한다. 즉, taker 가 특 정 토큰을 구매한다고 하면 그 구매의 대상이 되는 토큰을 base token 이라고 하며, 판매를 한다고 하면, 판매의 대상이 되는 그 토큰을 quote token 이라고 한다. 또한 여기서 OrderSignature 는 브라우저가 생성하고자 하는 주문정보를 EIP 712 로 서명한 서명정보로 추후 스마트 컨트랙트에서 해당 사용자의 주문정보를 해시하여 위 시그내처를 통해 유효성을 검증하는 과정을 거친다. 인증과정에서의 데이터의 흐름 사용자의 orderParam 쌍 =&gt; param 의 data property 에서 order rebuild =&gt; EIP712 hash 를 orderParam 의 signature 로 validate * 여기서 signature 의 목적은 무엇일까? 여기서 signature 는 사용자가 본래 요청하고자 했던 주문정보가 스마트 컨트랙트에서 체결되는 시점에도 해당 사용자가 요청한 주문과 내용이 맞는지 검증하는 것이다. 가령, DEX 에서 두 사용자가 거래를 진행할때 다른 사용자가 특정 사용자의 계정을 스마트컨트랙에 거래를 요청하는 경우, 주문정보가 동일하더라도 주문을 작성한 유저가 요청한 주문이 아니므로 거래가 이루어 져서는 안되며, 특정 주문내용을 바꾸어서 컨트랙트에 체결을 요청하는 등 다양한 악용을 막는 역할을 수행한다. * EIP 712 란 무엇인가? EIP 712 란 Ethereum Improvement Proposals 712 의 약어로 이더리움에서 향후 지원하게 될 다양한 제안들중 하나이다. 과거 사용자가 어떤 거래를 함에 있어 sign 을 할때에는 sign 의 대상이 되는 message 가 hash 화 되어 존재하기 때문에, 서명을 하는 사용자가 자신이 서명하는 내용에 대해 잘 알기 힘든 문제가 있었으며, 가령 유사한 해시값을 가진 피싱 사이트로 유도하여 사이닝을 유도한다던가 하는 다양한 위험에 노출되어 있었다. 이를 해결하기 위해 안전하고 값이 변조되지 않는 해싱을 보장하면서도 readability 를 가질 수 있는 서명방법을 고안하게 되었으며 그 제안내용이 EIP712 에 제안되었다. EIP712 를 통해 사용자는 자신이 서명하는 정보에 대해 명확하게 인지할 수 있게 된다고 볼 수 있다. EIP 서명의 절차에 대해 간략하게 소개하면, 먼저 서명을 하고자 하는 데이터의 형태를 정의하는데 이러한 typed structured data 를 먼저 정의하는 것으로 서명이 시작된다. 데이터의 정의가 완료되면, 여러 DAPP 들 사이에 구별되기 위한 domain separator 를 정하여 서명을 검증할 스마트 컨트랙트의 주소부터 version, salt 등의 데이터로 구성된다. EIP 서명이 완료되면, 사용자는 signature 를 얻게 되며 추후 스마트 컨트랙트는 주문정보를 직접 해싱하여 사용자가 제공한 signature 로 validation 을 진행하여 유효성을 검증한다. 거래의 체결matchOrders 함수가 호출되는 시점에 매칭된 오더들의 정보가 filled 에 orderHash:filledAmount 의 mapping 형태로 기록되며, 만약 주문이 체결되었다면 기존에 있던 주문들에 새로운 주문이 발생하면서 체결이 될 것이다. 여기서 기존에 있던 주문을 한 사용자를 maker 라 칭하며, 주문을 체결하는 주문을 발생시킨 사용자를 taker 라 명명한다. 또한, 거래의 특성상 taker 가 넣은 주문을 만족시키는데 필요한 하나 이상의 주문이 필요하게 되므로 주문이 매칭 될 때에는 하나의 taker 주문에 한개 이상의 maker 주문이 매칭된다. Taker 의 매도 주문taker 의 매도주문으로 인해 주문이 체결되는 경우의 시나리오는 다음과 같으며, n개의 거래쌍이 이루어 졌다고 전제한다. maker 가 relayer 에게 만족하는 quote token 과 maker fee, maker gas fee(maker rebate fee 는 차감한다.) 를 n번 지급한다. taker 가 maker 에게 만족하는 base token 을 n번 지급한다. relayer 가 taker 에게 만족하는 quote token 중 taker gas fee 를 제하고 1회 지급한다. Taker 의 매수 주문","link":"/2019/02/25/getting-started-with-dex/"},{"title":"Getting started with Embeded Linux","text":"임베디드 시스템 개발 환경임베디드 시스템을 개발하기 위해서는 기본적으로 임베디드 스템 개발을 위한 컴퓨터인 호스트 PC와 실제 임베디드 시스템이 설치된 개발하고자 하는 하드웨어인 Target PC가 있어야 한다. 타깃에는 호스트에서 만들어져서 설치된 여러 컴포넌트와 타깃을 부팅하기 위한 부트로더와 커널 그리고 임베디드 응용 프로그램이 존재하게 된다. 호스트에 설치된 개발 툴에는 타깃에서 수행될 수 있는 바이너리를 생성하는 크로스 컴파일러가 존재한다. 임베디드 시스템 개발 과정 부트로더 개발 커널 및 파일 시스템 개발 응용 프로그램 개발 부트 로드 개발 타깃 보드에 전원이 인가되면 부트 롬으로부터 가장 먼저 수행되는 프로그램이다. OS 의 커널을 로드한다. 커널 및 디바이스 드라이버 및 파일 시스템 개발 호스트 피씨에서 개발되며 하나의 이미지 파일 형태로 부트 롬에 저장되거나 별도의 저장 장치에 파일 시스템을 통한 파일 형태로 구현된다. 임베디드 응용 프로그램 호스트에서 개발하며 호스트의 크로스 컴파일러에 의해 타깃 보드에 맞는 바이너리가 생성된다.","link":"/2018/11/28/getting-started-with-embeded-linux/"},{"title":"Getting started with docker swarm","text":"installationhttps://www.virtualbox.org/wiki/Downloads Basic setupCreate virtual machine for docker1docker-machine create --driver=virtualbox &lt;VM_NAME&gt;","link":"/2019/06/19/getting-started-with-docker-swarm/"},{"title":"Getting started with ethereum","text":"Getting started with ethereumKinds of accounts이더리움에는 두가지 종류의 account 가 있는데, External Account 와 Contract Account 가 그것이다. 먼저 External Account 는 공개키 방식의 계정이며, address 역할을 하는 public key 와 nonce 로 구성이 되며, Contract Account 는 일반적인 smart contract 이다. 여기서 account 와 account 사이에 자금이 이동하면 그것을 transaction 이라고 말한다. Transaction이더리움에서 transaction 이란 하나의 EOA 로부터 다른 account 로 전송되는 message 를 포함한 signed data packet 을 의미하며 다음과 같은 정보들을 담고 있으며, EOA 로 부터 EOA 로 가는 경우는 이더를 송금하는 것을 내포하고, 만약 수신자가 Contract Account 라면 해당 contract 가 어떤 코드를 실행하도록 trigger 하는 것이 된다. receipient signature value data: which can contain the message sent to a contract 여기서 data 는 contract 가 실행에 필요한 정보를 들고 있으며 Contract ABI(Application Binary Interface) 에 따라 컨트랙트와 소통한다. 이 ABI 는 외부 와컨트랙트 간의 상호작용에 필요할 뿐만 아니라 contract 간의 상호작용에도 적용된다. 따라서 data 는 다음의 규약에 따라 인코딩 되어 사용되며 ABI(Application Binary Interface 에 따라 정의된다. 함수 선택자data 의 함수 시그니처의 Keccak-256 (SHA-3) hash 의 첫 4바이트는 어떤 함수를 호출할지를 나타내며 function 시그니처로 부터 도출된다. 1234567pragma solidity &gt;=0.4.16 &lt;0.6.0;contract Foo &#123; function bar(bytes3[2] memory) public pure &#123;&#125; function baz(uint32 x, bool y) public pure returns (bool r) &#123; r = x &gt; 32 || y; &#125; function sam(bytes memory, bool, uint[] memory) public pure &#123;&#125;&#125; 위의 예제에서 baz 함수를 호출하고자 하는 transaction 의 data의 함수선택자는 0xcdcd77c0 인데 이는 method 의 id 로 ASCII format 으로 작성된 function signature 인 baz(uint32,bool 의 Keccak hash(sha3) 의 첫번째 4 바이트이다. 함수 Parameter또한 해당 함수의 parameter 로 69와 true 를 제공한다면 69를 32바이트 로 패딩한 0x0000000000000000000000000000000000000000000000000000000000000045 가 값이 된다. 0x0000000000000000000000000000000000000000000000000000000000000001 ABI(Application Binary Interface)컴퓨터 과학에서 흔히 말하는 ABI 는 두가지 종류의 binary 프로그램 모듈 사이의 인터페이스이다. 쉬운 예로는 library 와 operating 시스템의 경우가 있는데, 하나의 라이브러리는 여러 시스템 상에서 동작해야 하므로 해당 소스코드가 다양한 운영체제에서 동작하기 위해서는 약속된 인터페이스가 필요하다. 또 한 예로는 유저에 의해 실행되는 프로그램의 예가 있는데 가령 여러 운영체제에서 해당 프로그램을 실행하여도 동작하기 위해서는 이러한 ABI 가 정의되어 있어야 한다. 이와 같은 맥락에서 이더리움 에서의 ABI 란 특정 함수가 이더리움에서 실행되기 위한 포맷팅의 규약으로써 이해될 수 있다. 아래는 스마트 컨트랙트 내에서 특정 데이터를 ABI 인코딩 하는 것을 보여준다. 1abi.encode(&quot;AAAA&quot;) 위 코드는 아래와 같이 3단어로 구성된 96(32byte *3) 사이즈의 바이트 문자열을 리턴한다. 1230x00000000000000000000000000000000000000000000000000000000000000200x00000000000000000000000000000000000000000000000000000000000000040x4141414100000000000000000000000000000000000000000000000000000000 한 줄씩 살펴보면 먼저 첫번째 라인은 해당 문자열의 starting offset(32 in decimal) 를 32byte 문자열에 padding 한 것이며, 두번째 문자열은 인코딩 하는 데이터의 길이인 4를 32바이트 문자열에 padding 하여 나타낸다. 마지막으로 세번째 문자열은 실제 우리의 데이터인 “AAAA” 를 UTF-8 인코딩하여 32 바이트 문자열에 padding 하여 나타내어 준다. 위의 encoding 방식보다 다소 간편하게 인코딩을 하고 싶다면 abi.encodePacked(&quot;AAAA&quot;) 라는 함수를 사용할 수 있다. 이 함수는 32바이트보다 작은 문자는 그냥 해당 문자열을 바이트로 출력하고 32바이트에 padding 하지도 않는다. 한가지 흥미로운 사실이 있는데, keccak256 을 사용하여 hashing 을 할때 복수개의 인자를 전달하면 이것을 내부적으로 abi.encodePacked 함수로 인코딩 하여 해싱을 한다는 것이다. 현재는 복수개의 인자를 전달하면 warning 을 출력하기는 하지만, 알아두도록 하자. 다음은 Keccak256 에서 abi.encodePacked 를 사용하는 예이다. 아래의 두 hashing 은 정확히 동일한 역할을 수행한다. 1keccak256(&quot;AAAA&quot;, &quot;BBBB&quot;, 42); 1keccak256(abi.encodePacked(&quot;AAAA&quot;, &quot;BBBB&quot;, 42));","link":"/2019/02/24/getting-started-with-ethereum/"},{"title":"Getting started with GraphQL","text":"Queries and MutationsGraphQL 서버에 어떻게 query 할 것인가? example query 12345&#123; hero&#123; name &#125;&#125; arguments 123456&#123; human(id: &quot;1000&quot;)&#123; name height &#125;&#125; alias 12345678&#123; empireHero: hero(episode: EMPIRE)&#123; name &#125; jediHero:hero(eposode:JEDI)&#123; name &#125;&#125; fragments reusable units called fragments 1234567891011121314151617181920query HeroComparison($first: Int = 3)&#123; leftComparison: hero(episode: EMPIRE)&#123; ...comparisonFields &#125; rightComparison: hero(episode: JEDI)&#123; ...comparisonFields &#125;&#125;fragment comparisonFields on Character&#123; name friendConnection(first: $first)&#123; totalCount edges&#123; node&#123; name &#125; &#125; &#125;&#125; varables 12345678query HeroNameAndFriends($episode: Episode)&#123; hero(eposide: $episode)&#123; name friends&#123; name &#125; &#125;&#125; now, in our client code we can simply pass a different variable rather than needing to constructor an entirely new query. directives 12345678query Hero($episode: Episode, $withFriends: hero(episode: $episode)&#123; hero(episode: $episode)&#123; name friends @include(if:$withFriends)&#123; name &#125; &#125;&#125;) Schemas and TypesValidationExecutionIntrospection","link":"/2018/12/04/getting-started-with-graphql/"},{"title":"Getting started with machine learning with python","text":"One example of where this handcoded approach will fail is in detecting faces in images. Today, every smartphone can detect a face in an image. The most successful kinds of machine learning algorithms are those that automate decision-making processes by generalizing from known examples In this setting, which is known as supervised learning the user provides the algorithm with pairs of inputs and desired outputs, and the algorithm finds a way to produce the desired output given an input. scikit-learn is a very popular tool, and the most prominent Python library for machine learning. A Python distribution made for large-scale data processing, predictive analytics, and scientific computing 1pip install numpy scipy matplotlib ipython scikit-learn pandas pillow 1scikit-learn` is built on top of the NumPy and SciPy scientific Python libraries. In addition to NumPy and SciPy, we will be using `pandas` and `matplotlib 1234import numpy as npx = np.array([[1, 2, 3], [4, 5, 6]])print(\"x:\\n&#123;&#125;\".format(x)) pandas is a Python library for data wrangling and analysis classification어떤 데이터들을 분류하는 문제이다. 여기서 분류의 대상의 data, 분류종류를 class 그리고 특정 데이터가 분류되었을때 그 분류 이름을 label이라고 부른다.","link":"/2019/01/23/getting-started-with-machine-learning-with-python/"},{"title":"getting started with mac","text":"환경변수 설정123Vim ~/.bash_profileSource ~/.bash_profile","link":"/2017/03/28/getting-started-with-mac/"},{"title":"Getting started with gradle","text":"PrerequisitesGradle requires Java JDK or JRE in Mac 1234brew tap caskroom/cask &amp;&amp; # only if you didn't install caskbrew cask install java &amp;&amp;brew cask info java &amp;&amp;brew tap caskroom/cask ### install gradle 1brew install gradle Create new Gradle ProjectInitialize1gradle init Directory12345678├── build.gradle ├── gradle│ └── wrapper│ ├── gradle-wrapper.jar │ └── gradle-wrapper.properties ├── gradlew ├── gradlew.bat └── settings.gradle build.gradle: Gradle build script for configuring the current project gradlew: Gradle wrapper script for unix-based system gradle.bat: Gradle wrapper script for Windows settings.gradle: Gradle settings script for configuring the Gradle build Create a task하나의 Project 는 여러개의 Task 를 포함하며, 각 Task 는 기본적인 연산을 수행한다. Gradle 은 task 라이브러리들을 가지고 있으며, 이를 통해 프로젝트를 설정할 수 있다. 가령 COPY 라는 type 은 특정 파일을 특정 위치로 복사해 준다. example) build.gradle 1234task copy(type: Copy, group: \"Custom\", description: \"Copies sources to the dest directory\") &#123; from \"src\" into \"dest\"&#125; 여기서 group 과 description 은 하드코드된 값으로 프로그래머가 원하는 값을 지정하면 된다. 실행하기 1./gradlew copy Apply a pluginGradle 에는 다양한 종류의 plugin 이 존재한다. 예를 들어 base 플러그인의 Zip type을 활용하여 zip archive 를 생성할 수 있다. 12345678plugins&#123; id \"base\"&#125;task zip(type: Zip, group: \"Archive\", description: \"Archive sources in a zip file\")&#123; from \"src\" setArchiveName \"basic-demo-1.0.zip\"&#125; 실행 ./gradlew zip CommandShow tasks아래 명령어를 통해 존재하는 task 들을 확인할 수 있다. task 들은 group 별로 정렬되어 나타나며, 각 task 마다의 description 이 명시되어 있다. 1./gradlew tasks Analyze and debug buildgradle 은 build scan 이라는 웹 기반의 build 상태 확인을 제공한다. 아래 명령어는 gradle 에서 확인한다. example) 1./gradlew zip --scan Discover available properties아래 명령어를 통해 gradle 의 다양한 property 들을 확인할 수 있다. property들이란 gradle 을 통해 빌드하는 과정에서 설정되는 다양한 속성들을 의미하며, 가령 build directory, project directory 같은 중요한 사항들이 포함된다. 아래 명령어를 통해 property 들을 확인할 수 있다. 1./gradlew properties The name of the project matches the name of the folder by default. You can also specify groupand version properties, but at the moment they are taking their default values, as is description. The buildFile property is the fully-qualified path name to your build script, which resides in the projectDir — by default. You can change many of the properties. For example, you might try adding the following lines to your build script file, and re-execute gradle properties.","link":"/2019/05/03/getting-started-with-gradle/"},{"title":"Getting started with IOST","text":"Account기본적으로 public-private key pairs 를 사용한다. 사용자는 owner key와, active key 세팅을 통해서 여러 계정 시스템을 관리할 수 있으며, 이는 새로운 permission 을 추가하고 관리방식을 customize 할 수 있다. IOST 에서 계정은 id와 permissions 를 가지고 만들어지며, 복수개의 permissions 를 가질 수 있다. 각 permission 은 여러개의 item 을 등록하는데, 각 item 은 base58로 encode 된 public key 이거나 account_name@permission_name 형태의 permission pair 이다. 각 permission은 threshold 를 가지는데, 만약 사이닝한 transaction item 의 weight 의 합이 threshold 보다 큰 값을 가지면 transaction 은 승인되는 것으로 본다. Javascript SDK123456789101112131415161718192021222324252627const IOST = require('iost')// use RPCconst rpc = new IOST.RPC(new IOST.HTTPProvider(\"http://localhost:30001\"));rpc.blockchain.getChainInfo().then(console.log);// init iost sdklet iost = new IOST(&#123; // will use default setting if not set gasRatio: 100, gasLimit: 2000000, delay:0,&#125;, new IOST.HTTPProvider('http://localhost:30001'));let account = \"abc\";let kp = new IOST.KeyPair(/* your private key in type Buffer */);iost.setPublisher(account, kp);// send a calllet handler = iost.callABI(\"iost.token\", \"transfer\", [\"iost\", \"form\", \"to\", \"1000.000\"]);handler .onPending(console.log) .onSuccess(console.log) .onFailed(console.log) .send() .listen(); // if not listen, only onPending or onFailed (at sending tx) will be called Command line wallet tooliwallet 설치 1go get github.com/iost-official/go-iost/cmd/iwallet Operating nodeDeployment of full node스크립트로 설치하기 아래처럼 환경변수를 사용자의 기호에 따라 설정할 수 있다. 1curl https://raw.githubusercontent.com/iost-official/go-iost/master/script/boot.sh | PREFIX=/data/iserver bash 위 스크립트를 실행하면 필요한 도커 이미지를 받아오고 아래 커맨드로 도커 이미지를 실행시킨다. 12345678910## startdocker start iserver## stopdocker stop iserver## restartdocker restart iserverdocker run --rm -p 30000-30003:30000-30003 -d iostio/iost-node Checking node로그는 $PREFIX/logs/iost.log 에 기록되며 도커 컨테이너 로그 확인을 다음과 같이 수행 할 수 도 있다. docker logs -f isserver 블록체인 데이터는 $PREFIX/storage 에 저장된다.","link":"/2019/05/14/getting-started-with-iost/"},{"title":"Getting started with PyQt","text":"What is PyQt?Qt 란 GUI 크로스 플랫폼 프레임워크로 운영체제에 관계없이 같은 코드로 동작하는 프레임워크이다. PyQt 는 이러한 Qt 프레임워크의 python 바인딩이다. Qt Designer 는 WYSIWYG(What You See Is What You Get) 방식의 간편한 디자인 툴도 제공한다. Basic UsageQApplication.exec() 은 qt 어플리케이션을 시작하고 event loop 에 진입시킨다. OCXObject linking and embedding Custom Control 의 약어로 모듈화된 파일이다.","link":"/2019/03/27/getting-started-with-pyqt/"},{"title":"getting started with redux","text":"Flux 란?flux 는 하나의 개발 철학이며 기존의 MVC 모델이나 양방향 데이터 바인딩에 대한 대안으로 제안된 개념이다. flux에는 다음과 같은 3가지 개념이 있다. action dispatcher stores action은 시스템 전체의 상태변화를 묘사하는 다양한 형태의 행위이다. 가령 마우스 클릭이나 axios 요청 등의 행위들이 여기에 포함될 수 있다. 이러한 일련의 action들의 모음으로 시스템이 흘러가며 이를 통해 일관된 행동 양상을 유지하고 시스템의 다음 행보를 예측이 가능하게 된다. 일반적인 flux의 플로우는 다음과 같다. store는 action의 변화를 인지하도록 준비한다. action이 dispatcher를 통해 dispatch 된다. dispatcher는 store의 subscriber에게 변화를 알린다. store는 해당하는 action에 따라 상태를 업데이트한다. 어플리케이션의 view는 해당 상태의 변화에 따라 업데이트 된다. 다음 액션이 실행될 수 있다. 이렇게 시스템 전체가 일련의 action의 나열로 이루어짐에 따라 개발자들은 다음 시스템의 상태를 예상가능하게 되고 개발자의 통제 내에서 모든 시스템 변화가 이루어 질 수 있게 된다. 여기서 중요한 점은 모든 action이 순차적으로 이루어진다는 것이다. 이는 기존의 양방향 데이터바인딩 시스템과 매우 대조적인데 양방향 시스템에서는 모든 데이터가 실시간으로 변화하고 있기에 일관된 데이터의 변화 방향을 인지할 수 없지만 시스템의 순간순간의 상태는 각 액션 사이의 상태값의 변화이기에 모든 순간의 상태값에 대해 인지할 수 있다. Redux리덕스란 이러한 flux 패턴의 하나의 구현체이며 단 하나의 스토어를 가진다는 점에서 플럭스와 차이가 있다. 가령 요리책을 다루는 app의 경우 redux 스토어는 모든 요리방법들의 리스트와 상세 내역을 가지게 된다. 여기서 액션이란 요리방법을 추가하고 특정 레시피에 재료를 추가하는 행위라 할 수 있겠다. 실제 비즈니스 로직에서는 이런 다양한 액션들을 묶어서 사용자가 사용하는 수준으로 만들어줄 필요가 생기고 그것이 action 액션은 애플리케이션에서 스토어로 보내는 데이터 묶음이며, 스토어의 유일한 정보원이다. store.dispatch() 액션의 종류 { type: COMPLETE_TODO, index: 5 } 리듀서 이전 상태와 액션을 받아 다음 상태를 반환하는 순수 함수이다. (prevState, action) 스토어 액션과 리듀서를 함께 가져오는 객체이다. createStore(_action) =&gt; store store.dispatch(_action) 프로세스 Create actionDescribe what happens store.dispatch(action) Redux store executes reducer function Root reducer makes one state tree by merging reducer outputs Store.subscribe(listener) =&gt; call all listener","link":"/2018/03/28/getting-started-with-redux/"},{"title":"Getting started with solidity","text":"Restricting Access하나의 컨트랙트 내의 속성들은 다른 컨트랙트에서 접근 될 수 없는 것이 기본이며, public 키워드를 명식적으로 사용함에 따라 다른 컨트랙트에서도 접근이 가능하게 된다. 또다른 접근 제한자로는 modifier 가 있는데, 이는 특정 함수에 지정하여 해당 함수를 호출하기 전에 자격에 맞지 않으면 접근을 제한 할 수 있는 기능을 제공한다. 12345678910111213contract AccessRestriction &#123; modifier onlyBy(address _account) &#123; require( msg.sender == _account, &quot;Sender not authorized.&quot; ); // Do not forget the &quot;_;&quot;! It will // be replaced by the actual function // body when the modifier is used. _; &#125;&#125; Data typesmemory and storagesolidity 에서 memory 와 storage 를 이루는 데이터 chunk 의 크기는 32bytes 이다. memory 란 모든 함수 call 마다 새롭게 할당되는 임시 데이터 저장소로 이 메모리에 읽기, 쓰기 등의 작업을 수행할 때마다 가스비가 올라간다. variables솔리디티에서 변수는 memory address 를 가르치는 포인터이다. arraysolidity 에서 array 의 첫번째 인자는 그 array 의 길이값을 저장한다. Bytessolidity 에서 bytes 는 동적으로 할당되는 byte array 이며, 그 크기는 32byte 이다. 또한, solidity 에서 변수는 memory address 를 가르치는 포인터이므로 해당 포인터로 부터 32 바이트를 더해주면 실제로 해당 bytes 의 값이 저장된 주소값을 얻을 수 있다. 1234b = new bytes(32);add(b, 32); // b의 값이 저장된 주소값mstore(add(b, 32), x); // b=x EventsEvent 는 솔리디티에서 일종의 로깅의 역할을 수행한다. 이더리움 상에서 일어나는 다양한 활동들에 대한 내역을 추적하고, 사용자 데이터를 자정하기 위해 이더리움은 로그 시스템을 적용하였으며, Event 의 발생은 일종의 로그 형태로 저장된다. DAPP 개발자는 이더리움의 RPC 인터페이스를 통해 이러한 이벤트들을 구독할 수 있다. Topic 은 이러한 이벤트들을 찾을 수 있도록 해주며, 가령 특정 컨트랙트에서 발생한 로그들을 듣는 등의 일들을 할 수 있다. 여기서 각 이벤트를 정의할 때 다음과 같이 indexed 옵션을 주면, 이렇게 구독을 하는 중에 해당 속성을 읽을 수 있다. 만약 indexed 옵션을 주지 않으며, ABI 인코딩된 데이터가 내려오게 된다. 1234567contract ExampleContract &#123; event ExampleEvent( address indexed _from, bytes32 indexed _id, uint _value );&#125;","link":"/2019/02/25/getting-started-with-solidity/"},{"title":"Getting started with truffle","text":"12npm install -g truffletruffle init","link":"/2019/02/28/getting-started-with-truffle/"},{"title":"Getting started with ubuntu","text":"InstallationGit, node.js, aws-cli 를 설치해 준다. 123456789sudo apt update &amp;&amp;sudo apt install git &amp;&amp;sudo apt-get update &amp;&amp;sudo apt-get install nodejs &amp;&amp;sudo apt-get install npm &amp;&amp;sudo apt update &amp;&amp; # install python to install aws-clisudo apt install python3-pip &amp;&amp; # install pipsudo pip3 install awscli &amp;&amp; # install aws-clisudo apt install awscli Setup Terminalinstallation1234567891011sudo apt-get install terminator &amp;&amp;sudo apt-get update &amp;&amp;sudo apt upgrade &amp;&amp;sudo apt-get install zsh &amp;&amp;sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" &amp;&amp;chsh -s /usr/bin/zsh root&amp;&amp; # update default shellwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zsh &amp;&amp; # download templatesudo su&amp;&amp;cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc ## copy .zshrc templatesource ~/.zshrc &amp;&amp;npm install --global pure-prompt --allow-root --unsafe-perm=true install plugin12345# zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting# zsh-autosuggestionsgit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions ~/.zshrc 1234567plugins=( git zsh-syntax-highlighting zsh-autosuggestions)autoload -U promptinit; promptinitprompt pure install fzf12git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf~/.fzf/install update vs code default terminalvscode setting 1&quot;terminal.integrated.shell.linux&quot;:&quot;/usr/bin/zsh&quot; shortcutssplit terminals horizontally: ctrl shift o split terminals vertically: ctrl shift e close current panel: ctrl shift w move terminal: alt + arrow","link":"/2019/05/02/getting-started-with-ubuntu/"},{"title":"Getting started with WAF","text":"WAF stands for website application firewall A WAF keeps the malicious traffic off your website how does it works?the waf works as a vaccine for a website. application firewalls go beyond the metadata of the packets transferred at the network level. they focus on the data in transfer.","link":"/2019/06/18/getting-started-with-waf/"},{"title":"git 기본 설정하기","text":"전역 설정하기git 의 사용자 정보 및 사용자별 다른 연결 정보등과 같은 공통의 설정들은 &lt;home&gt;/.gitconfig 파일에 설정할 수 있다. 이는 git config --global user.name = &lt;USER_NAME&gt; 등과 같은 명령어를 통해서도 가능하지만 파일에 직접 설정을 작성할 수 있다. .gitconfig 1234567891011[user] name = &lt;사용자 이름&gt; email = &lt;사용자 이메일&gt; username = &lt;USER_NAME&gt; [credential] helper = cache # 비밀번호를 캐싱하여 계속 입력하지 않아도 되도록 한다. [credential \"&lt;CODE_COMMIT_REPOSITORY&gt;\"] # 코드 커밋을 사용한다면 설정한다. helper = !aws codecommit credential-helper $@ UseHttpPath = true 위 설정은 간단히 아래의 커맨드로도 가능하다. 1234git config --global user.name &lt;USER_NAME&gt;git config --global user.email &lt;USER_EMAIL&gt;git config credential.helper cachegit config --list # 설정한 내용 확인 ssh 기반 인증만약 특정 레포지토리가 공개키 방식의 인증과정을 거치고 특정 키를 레포지토리에 등록시켜 두었다면, 해당 인증서를 통해 인증하여 레포지토리와 통신할 수 있다. 이때 여러 레포지토리들은 각각 다른 키를 사용할 수 있는데 이러한 ssh 연결 정보를 특정 레포지토리의 .git/config 파일에 설정해 둘 수 있으며, 그 명령어는 다음과 같다. 1git config --local --add core.sshCommand 'ssh -i ~/your_key' 혹은 아래와 같이 직접 .git/config 파일을 수정할 수 있다. 12[core]sshCommand = &quot;ssh -i ~/.ssh/keyfile&quot;","link":"/2019/05/29/git-기본-설정하기/"},{"title":"golang - test code 작성하기","text":"go test code 작성하기이번 포스트에서는 go 언어로 test code를 작성하는 법을 알아보도록 한다. 먼저, go 에서 test code를 작성하기 위해서는 다음과 같은 규약을 따라야 한다. 테스트 함수의 이름은 Test... 가 되어야 한다. 테스트 함수는 t *testing.T 만을 입력값으로 받는다. test code가 작성된 파일의 이름은 뒤가 _test.go 가 되어야 한다. 유용한 testing 함수와 활용방안t.Error &amp; t.Errorft.Error 함수는 문제가 일어나는 지점에서 에러를 발생시키며 좀 더 자세한 오류의 내용을 명시하고 싶은 경우 t.Errorf 를 사용한다. example123456func TestSum(t *testing.T) &#123; total := Sum(5, 5) if total != 10 &#123; t.Errorf(\"Sum was incorrect, got: %d, want: %d.\", total, 10) &#125;&#125; t.Logt.Log는 테스트 진행 중 콘솔창에 나타내고 싶은 말들을 명시한다.어떤 입력값이 입력되는 지를 나타내거나 혹은 절차에 관한 간략한 설명을 곁들이는 것이 좋다. example1234567func TestSum(t *testing.T) &#123; total := Sum(5, 5) t.Log(\"testing sum function... input data: %d, %d\", 5, 5) if total != 10 &#123; t.Errorf(\"Sum was incorrect, got: %d, want: %d.\", total, 10) &#125;&#125; Test Table테스트 하고자 하는 입출력 값을 table에 담아 보다 보기 좋게 명시할 수 있으며 다음과 같이 사용될 수 있다. example123456789101112131415161718192021222324252627282930313233package main_testimport \"testing\"func Sum(a int, b int) int&#123; return a+b&#125;func TestSum(t *testing.T) &#123; tests := map[string]struct&#123; input struct&#123; testData1 string testData2 string &#125; output struct&#123; testOutput1 string testOutput2 string &#125; err error &#125;&#123; input: struct&#123; testData1: \"test data 1\", testData2: \"test data 2\", &#125;, output: struct&#123; testOutput1: \"test output 1\", testOutput2: \"test output 2\", &#125; &#125; for testName, test := range tests&#123; Sum(test) &#125;&#125; mock 객체를 활용한 test 시의 dependency 처리go 함수 내에 dependency injection이 있는 경우 일일히 모든 dependency들을 세팅해 주는 것은 테스트의 코스트가 너무 커진다.때문에 테스트를 위한 fake interface를 구현하여 inject 해 줌으로써 해결한다.","link":"/2018/06/11/golang-test-code-작성하기/"},{"title":"Golang cookbook","text":"Setup1234vi ~/.bash_profileexport GOPATH = /Users/_username/Desktop/git/_projectNameecho $GOPATH # 고패스 확인source ~/.bash_profile Typetype assertion 1variable.(type) GolandGland 자동 copy right Preferences - Editor - File and Code Templates - Files 탭에서 Go File 클릭 - package ${GO_PACKAGE_NAME} 앞에 copyright 주석을 추가하시면 됩니다!","link":"/2018/08/28/golang-cookbook/"},{"title":"gRPC 시작하기","text":"GRPC란 무엇인이며 어떻게 동작하는가?GRPC란 google에서 제공하는 rpc 프로토콜 프레임워크이다.이를 통해 간편하게 클라이언트와 서버 간에 rpc 통신을 할 수 있게 해준다. grpc의 간략한 동작 순서는 다음과 같다. 서버에서 grpc server가 listen을 하고 있다. 클라이언트에서 gRPC stub을 통해 서비스에 접근한다. 서버에서 gRPC stub 명령을 받아 수행 후 클라이언트에 반환해 준다. gRPC를 통해 간편하게 server를 만들어 listen을 수행하고, 이를 호출하는 client 프로그램을 만들어 RPC 통신을 한다. RPC 통신이란?Remote Procedure Call 의 약어로 다른 컴퓨터에 있는 특정 method를 마치 자신의 컴퓨터에 있는 것처럼 호출하는 것으로 분산 어플리케이션과 서비스를 만드는데 중요한 역할을 한다. grpc에서는 데이터 전송을 위한 marshal를 위해 protocall buffer를 사용한다. protocall buffer란?protocall buffer란 어떤 언어와 플랫폼에서도 사용가능하고 확장성이 좋으며, 통신 프로토콜이나 데이터 저장등에 사용하기 위해 정형화된 데이터를 serializing 할 수 있는 좋은 방법이다.protocall buffer 에서는 serialize 하고자 하는 구조체가 .proto 파일에 메세지의 형태로써 정의되어야 한다. 이러한 .proto file은 protoc 컴파일러를 통하여 접근 가능한 객체로 변환되고, 각 언어에 맞는 protoc가 존재한다. .proto 파일의 예123456789101112131415161718message Person &#123; required string name = 1; required int32 id = 2; optional string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; required string number = 1; optional PhoneType type = 2 [default = HOME]; &#125; repeated PhoneNumber phone = 4;&#125;","link":"/2018/05/24/grpc-시작하기/"},{"title":"hbs 시작하기","text":"Installation1sudo npm install -g handlebars import settingsrequire(&#39;handlebars&#39;) handlebar’s expression undefined 위처럼 {{}} 사이에 expression을 이용 할 수 있다. how to compile다음과 같이 컴파일 할 수 있다. 12var source = document.getElementById(&quot;entry-template&quot;).innerHTML;var template = Handlebars.compile(source);","link":"/2018/07/02/hbs-시작하기/"},{"title":"How to start a startup","text":"제품을 만들고 고객과 대화를 하는 것 외에는 하지마라. 사업 계획의 수립일단 아이디어가 어느정도 구체화 되었다면, 해당 아이디어에 대한 시장 가능성과 실제 아이디어의 실행을 위한 방법들을 수립해야 하며 크게 상황분석 =&gt; 전략 수립 =&gt; 전략 실행 의 흐름으로 이어진다. 시장과 경쟁자에 대한 명확한 분석을 통해 독보적인 차별점을 도출하자여기서 가장 먼저 해야 할 일은 바로 기업의 내부적 정보와 외부적 정보를 수집하는 것이다. 가령 우리 스타트업이 가장 잘하는 것은 무엇인지 또 할 수 있는것과 할 수 없는 것은 무엇인지 우리가 다른 스타트업에 비해 뛰어나게 잘하는 것과 부족한 것이 무엇인지를 냉철하게 판단해야 한다. 이를 위해서는 하고자 하는 비즈니스에 끊임없는 고민이 필요하며, 시장에 어떤 경쟁자들이 있고, 그들의 강점과 약점이 무엇인지를 명확하게 이해하는 것이 중요하다. 대부분의 성공한 스타트업들은 이미 시장에 자리잡은 경쟁자가 있음에도 불구하고 명확한 차별점을 내세우고 기존 시장에 참여한 기업들이다 즉, 시장을 분석하고 내가 가장 잘 하는 강점을 무기로 삼아 시정을 침투해야하며, 이를 위한 정보의 수집은 매우 중요하다. 가장 간단하게는 다음과 같은 질문을 해볼 수 있다. 나와 우리 팀이 가장 잘하는 것은 무엇이고 그 근거는 무엇인가? 이미 시장에 있는 경쟁자들이 잘하는 것은 무엇이고 우리가 그들보자 나은점이 무엇인가? 시장의 고객들은 기존 경쟁자들의 어떤 차별점에 반응하고, 그들의 체워지지 않은 니즈는 무엇인가? 현상분석다음으로 조사해야할 부분은 시장의 상황과 트렌드 그리고 다양한 이슈들을 말미암아 스타트업의 성공가능성과 실패 가능성을 점치는 것이다. 가령 커피를 판다고 하면 시장에 어떤 커피들이 인기를 끌고 있으며, 전체 커피 시장과 고객의 니즈는 향후 어떤 방향으로 나아갈 것인가에 대한 분석이 이것이다. 고객의 선호와 취향이 변모해 나가는 트렌드를 이해하고 하고자 하는 비즈니스가 그 흐름에 부합하는 지를 숙고하자. 비즈니스 전략의 수립내가 시장의 다른 경쟁자들에 비해 무엇을 잘하고, 또 경쟁력을 가지지 못하는 약점을 명확하게 인지하였다면, 기업의 모든 자원을 기업이 가진 강점에 쏟아부어야 한다. 가량 다른 기업이 이미 잘하고 있고, 그들이 가진 강점의 나와 우리 팀이 아무런 근거 없이 ‘더 잘할 수 있다’ 라는 마인드 셋으로 전략을 세우는 것은 많은 스타트업이 하는 실수이다. 여기서 세운 전략을 기업을 운영함에 있어 잊지 말아야 할 본질이고, 나의 모든 자원을 합리적으로 분배할 근거가 되기에 이 내용을 바탕으로 말미암아 기업의 사명 선언문과 단기적 프로젝트의 목표를 규정한다. 구체적인 실행계획 수립사업의 큰 정책적 방안을 수립하였다면 단기적인 실행 계획을 세운다. 구체적인 실행의 일정부터 예산이 허락하는 범위 내에서 짜임새 있는 예산안을 수립한다.","link":"/2019/03/03/how-to-start-a-startup/"},{"title":"git 시작하기","text":"git 시작하기git 설치하기git cli 와 gui를 모두 설치한다이때 gui를 설치하지 않아도 되지만, 이런 경우 ssh 설정이 복잡하므로 간단하게 설치를 마쳐준다.만약 ubuntu의 경우는 패키지 매니저인 apt-get을 사용하여 다음과 같이 설치한다. 1sudo apt-get install git-all git home 디렉토리 변경하기git 아이콘을 우클릭하여 대상 뒤의 –cd-home을 없애고 시작위치에 원하는 위치를 넣어준다. 원격 repo 연결하기git 세팅을 완료했다면 온라인 상의 코드들을 조작하기 위해 git 서버에 연결한다.git 서버에 연결하는 방법은 2가지가 있는데, 하나는 http 방식이고 다른 하나는 ssh 방식이다. 먼저, ssh를 활용하여 연결하기 위해서 컴퓨터의 ssh key를 생성하고, 생성된 공개키는 git에 등록한다.공개키를 사용하려면 일단 공개키를 만들어야 하는데, 공개키를 만드는 방법은 모든 운영체제가 비슷하다.먼저 키가 있는지부터 확인하자. 사용자의 SSH 키들은 기본적으로 사용자의 ~/.ssh 디렉토리에 저장한다. 리눅스 혹은 ubuntu의 경우 ssh-keygen을 통해 공개키/개인키 쌍을 생성할 수 있다. 1ssh-keygen 위 명령어를 통해 공개키를 생성하였으면 ~/.ssh 디렉토리에 id_rsa.pub가 생성되었을 것이다.해당 공개키를 git 홈페이지의 repository의 설정에서 등록해 주면 된다. 참조 git pull 명령을 수행하는 동중 permission denied가 되는 경우가 있는데 이는 특정 유저에게 해당 파일에 대한 변경 권한이 없는 것으로 다음과 같이 해결한다. 12chown &lt;USER&gt;.&lt;GROUP&gt; -R /home/&lt;USER&gt;/.configchown &lt;USER&gt;.&lt;GROUP&gt; -R /home/&lt;USER&gt;/.gitconfig 만약 위처럼 ssh를 통해 연결이 어렵다면 pull 혹은 clone 시에 https를 기반으로 받으면 ssh 연결이 아닌 https를 통해 받을 수 있으니 시도해 보기 바란다. git 명령어 모음브랜치 생성 및 변경12git branch [브랜치명]git checkout [브랜치명] git branch [브랜치명] 명령어로 브랜치를 생성하고git checkout [브랜치명] 명령어를 통해 브랜치를 변경한다.여기서 checkout은 단순히 브랜치를 옮기는 것으로 지금까지의 변경내용이 바뀌지 않고 해당 브랜치로 이동하기 때문에해당 브랜치에 지금의 변경내용이 전부 반영된다. 브랜치 삭제하기git branch -d [branch Name] 추가된 파일 포함시키고 커밋하기파일 추가git add 커밋하기 1git commit -m &quot;메세지&quot; 원격저장소에 사용하기업스트림(upstream) 브랜치 설정로컬 저장소를 init 명령어로 생성했을땐 수동으로 업스트림 브랜치를 설정할 필요가 있다. 업스트림 브랜치란 원격 저장소와 바로 연결된 로컬 저장소를 말하며 push나 pull 명령등에서 원격 저장소 이름을 생략할 수 있게 한다. 1git push --set-upstream origin master 원격 저장소와 코드를 주고 받기 위해 가장 먼저 해야 할 일은 원격 저장소가 어디에 있는지를 알려주는 일이다.다음과 같은 코드를 입력하기 원격저장소 origin의 위치를 등록해 준다. 1git remote add origin git@github.com:hea9549/expiritAdmin.git 밀어넣기git push origin [branch] 강제로 밀어넣기git push -u origin master 머지하기git checkout master를 통해 마스터로 이동한다git merge [commit name] 풀받기git pull [remote 저장소] [브랜치] 커밋을 되돌리기이번에는 기존에 한 커밋을 되돌리는 법을 배운다. 먼저 커밋 내역을 확인할 수 있도록 log를 확인한다. 1git log 뒤로 돌리기 1git revert HEAD 명령어를 통해 HEAD에 마지막으로 커밋된 내용을 뒤로 돌린다. 원격 브랜치 가져오기git checkout -t origin/eventsource 로컬 작업 내용 버리기 혹은 저장하기당신이 어떤 프로젝트에서 한 부분을 담당하고 있다고 하자. 그리고 여기에서 뭔가 작업하던 일이 있고 다른 요청이 들어와서 잠시 브랜치를 변경해야 할 일이 생겼다고 치자. 아직 완료하지 않은 일을 커밋하는 것은 좀 껄끄럽다. 이런 상황에서는 커밋하지 않고 나중에 다시 돌아와서 작업을 다시 하고 싶을 것이다. 이 문제는 git stash라는 명령으로 해결할 수 있다. 123git stash // stash differencegit stash clear // deled stasedgit stash list // list up stashed 과거의 커밋 내용을 수정하기open source 활동을 하거나 혹은 대규모의 프로젝트를 진행할때 겪는 가장 큰 문제는 내가 작성한 과거의 코드내용, 즉 과거의 커밋 내용을 수정하는 것이다. 대부분의 경우 feature 브랜치에서 많은 내용을 수정하고 중간중간 변경 사항에 대해 commit 으로 기록하기 때문에 과거의 커밋을 바꾸기 위해서는 까마득한 예전의 코드로 돌아가 그 특정 부분을 수정하고 그 뒤의 변경사항을 다시 재적용 시키는 일이 필요하다. 이 경우에는 git rebase 명령을 사용하여 해결할 수 있으며 다음과 같은 절차를 거친다. git log 를 통해 나의 이전 커밋 내용을 확인한다. git rebase -i HEAD~n 를 통해 HEAD로 부터 얼마나 뒤 내용을 수정하고 rebase를 진행할지 정해준다. 가령 HEAD 로 부터 3 번째 커밋부터의 커밋들에 수정사항이 있다면 git rebase -i HEAD~3 명령어를 입력한다. 위 명령어를 입력하면 과거의 커밋들이 나타나고 커밋명 앞에 pick 이라는 키워드가 있다. 여기서 우리가 수정하기를 원하는 커밋의 pick 키워드를 e(edit) 으로 바꿔준다. 이제 git이 edit 하고자 하는 커밋으로 코드를 돌려주고 원하는 내용을 수정한 뒤에 git commit --amend 를 해주면 해당 커밋을 수정하여 다시 커밋하고 git rebase --continue 명령을 통해 뒤의 커밋들을 쭉 적용시켜 줄 수 있다. 특정 파일만 특정 커밋으로 되돌리기1git checkout &lt;COMMIT_HASH&gt; &lt;FILE_NAME&gt; 유용한 기능들CLI 에서 비밀번호 저장하기 git config credential.helper store 변경내용 임시 저장하기 git stash 임시 저장내용 불러오기 git stash pop 2FA 인증git authentication git 에서 2FA 인증을 하는 경우 personal access token을 발급받아서 해야한다.","link":"/2018/03/19/git-시작하기/"},{"title":"How To Write A Pitch Email","text":"no cold email가급적으로 cold 이메일을 피하는 것은 매우 중요하다. 이메일 피칭은 일종의 sales 이며, 수신자는 이를 즉시 인지하게 된다. 때문에 부정적인 이미지를 주지 않기 위해 warm introduction 을 하는 것이 매우 중요하다. 가장 많이 하는 실수중 하나는 여러 명의.사람들에게 무작위 cold email 을 보내는 것이다. 이는 personalized 되지도 않았고 무작위로 copy and paste 되기 일쑤이다. 이는 전혀 효과적이지 않다. 수신자는 당신의 프로모션에 관심이 없고, 당신을 만나야 할 이유가 명확하게 5초 이내에 설득되지 않으면 당신의 이메일은 쓰레기통으로 들어갈 것이다. 주제문단이 가장 가장 가장 가장 중요하다.다른 수많은 이메일과 독보적인 차이를 보이지 못하면 바로 삭제될 것이다 기본 포맷첫문단에서는 간단한 인사를 건내고 그 사람의 신상정보에 대해 아는 것이 있다면 작성해라. SNS 나 링크드인에서 찾은 사람이 있다면 언급해주자. 두번째 문단에서는 제품에 대한 피칭을 진행한다.3~4 줄로 세번째 문단에서는 해당 제품이 해당 기업에 어떤 가치를 제공할지에 대해 이야기 하라 어떤 기회를 가져다주고 해당 기업을 조사하여 personalize 해야한다. 만약 가격을 제시한다면 이곳이 적당하다. 마지막 문단에서는 인사를 하고 전화나 이메일로 컨택을 요청한다. 제일 중요한 것은 진정성이다.피칭 메일을 작성하는 사람의 머릿속에 드는 가장 큰 생각은 바로 어떻게 내 제품을 사게 만들것인가이다. 하지만, 진정으로 수신자의 마음을 움직이기 위해서는 진정으로 그 사람을 이해하고 우리가 그들에게 제공할 수 있는 가치가 무엇인지를 계속 고민해야 한다. 만약, 메일을 쓰는 내내 그들의 입맛ㅇ르 당기게 하고, 제품만 팔고자 하는 마음을 가지고 있다면, 정말 진정성 있는 제안서가 나오기 힘들다. 특히 이런저런 이메일 피칭법을 보고 다른 피칭 메일을 참조하면서 정형화된 형식의 메일만이 나올뿐이며, 그 메일은 아마도 수신자의 마음을 움직이지는 못할 것이다. 피칭을 하는 과정은 내 제품을 이해하고 받는 이에게 내가 어떤 가치를 제공할 수 있는지를 고민하는 과정이지, 내 판매고를 올리기 위한 과정이 아니다. 내가 가진 제품의 확실한 경쟁력을 계속해서 제고하면서 진정성 있는 메일을 작성해야 할 것이다.","link":"/2019/03/01/how-to-write-a-pitch-email/"},{"title":"How to write a service introduction","text":"서비스 소개서를 작성함에 있어 가장 핵심이 되는 것은 바로 청자가 원하는 것이 무엇인지를 명확하게 파악하고 그리고 우리 제품을 가능한한 알기 쉽고 직관적으로 이해 할 수 있도록 하는 것이다. 서비스 소개서의 시작은 고객의 관심을 사로잡을 수 있도록 상대방의 니즈 혹은 현재 하고있는 비즈니스에 명확하게 도움이 되는 포인트를 설득력있고 알기쉽게 제시한다. 이렇게 독자의 마음을 열었다면, 그 다음으로는 우리의 제품이 해당 니즈에 어떻게 도움이 되며, 아주 쉽게 우리 제품에 대해 명확한 이해가 수반되어야 한다. 이때의 기준은 독자가 우리의 서비스 소개서를 읽은 뒤에 다른 누군가에게 가서 우리의 제품에 대해 명확하게 설명할 수 있을 정도가 바람직하다.","link":"/2018/03/18/how-to-write-a-service-introduction/"},{"title":"go language 시작하기","text":"설치하기Go 는 패키지 매니저가 없으며 VCS에서 직접 받아와서 라이브러리를 사용합니다. 먼저, 다음 페이지에서 window 용 Go 를 설치해줍니다. 공식 다운로드 사이트 설치가 완료 되었다면. 아래와 같은 구조로 디렉터리를 만들어 줍니다.1234Go/ bin/ pkg/ src/ main.go 만들기main.go1234567891011package main //namespace declaration 하는 부분으로 기능과 논리들을 그룹화시켜준다.import &quot;fmt&quot; // format의 약자로 standard lib에 있다.// 여기서 main 은 keyword 로써 해당 함수가 라이브러리가 아닌 어플리케이션으로 동작함을 나타낸다.// go 어플리케이션이 여기서 시작된다.// func는 function을 선언하는 keyword 이다.func main() &#123; fmt.Println(&quot;Hello, World&quot;) //여기서 println의 앞의 P가 대문자 인데, 이는 외부 라이브러리에서 가져왔음을 의미한다. // 같은 원리로 함수를 선언할때 대문자로 시작하면 외부에서 접근이 가능한 것이다.&#125; 실행하기1go run main.go 빌드하기123456go build # 실행가능한 binary 파일을 만들어 준다.이 경우 파일명이 아니라 폴더 명으로 파일이 생성된다../go-study윈도우용 빌드GOOS=windows go build -o main.exe main.go 슬라이스슬라이스는 배열의 값을 가리킵니다(point). 그리고 배열의 길이를 가지고 있습니다. []T 는 타입 T 를 가지는 요소의 슬라이스(slice) 입니다.12345678910111213package mainimport &quot;fmt&quot;func main() &#123; p := []int&#123;2, 3, 5, 7, 11, 13&#125; fmt.Println(&quot;p ==&quot;, p) for i := 0; i &lt; len(p); i++ &#123; fmt.Printf(&quot;p[%d] == %d\\n&quot;, i, p[i]) &#125;&#125; 레인지for 반복문에서 range 를 사용하면 슬라이스나 맵을 순회(iterates)할 수 있습니다.1234567891011package mainimport &quot;fmt&quot;var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;func main() &#123; for i, v := range pow &#123; fmt.Printf(&quot;2**%d = %d\\n&quot;, i, v) &#125;&#125; _ 를 이용해서 인덱스(index)나 값(value)를 무시할 수 있습니다. 만약 인덱스만 필요하다면 “ , value ” 부분을 다 제거하면 됩니다.12345678910111213package mainimport &quot;fmt&quot;func main() &#123; pow := make([]int, 10) for i := range pow &#123; pow[i] = 1 &lt;&lt; uint(i) &#125; for _, value := range pow &#123; fmt.Printf(&quot;%d\\n&quot;, value) &#125;&#125; 맵맵은 값에 키를 지정합니다. 맵은 반드시 사용하기 전에 make 를 명시해야합니다. (주의: new 가 아닙니다) make 를 수행하지 않은 nil 에는 값을 할당할 수 없습니다.1234567891011121314151617package mainimport &quot;fmt&quot;type Vertex struct &#123; Lat, Long float64&#125;var m map[string]Vertexfunc main() &#123; m = make(map[string]Vertex) m[&quot;Bell Labs&quot;] = Vertex&#123; 40.68433, -74.39967, &#125; fmt.Println(m[&quot;Bell Labs&quot;])&#125; 맵 리터럴 (Map literals)맵 리터럴은 구조체 리터럴과 비슷하지만 key 를 반드시 지정해야 합니다.1234567891011121314151617181920package mainimport &quot;fmt&quot;type Vertex struct &#123; Lat, Long float64&#125;var m = map[string]Vertex&#123; &quot;Bell Labs&quot;: Vertex&#123; 40.68433, -74.39967, &#125;, &quot;Google&quot;: Vertex&#123; 37.42202, -122.08408, &#125;,&#125;func main() &#123; fmt.Println(m)&#125; 다양한 함수12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; m := make(map[string]int) m[&quot;Answer&quot;] = 42 fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;]) m[&quot;Answer&quot;] = 48 fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;]) delete(m, &quot;Answer&quot;) fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;]) v, ok := m[&quot;Answer&quot;] fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)&#125; switch다른 일반적인 언어를 아는 분이라면 switch 에 대해서 잘 알 것입니다. 다른 언어와 다른점은 case의 코드 실행을 마치면 알아서 break를 한다는 점입니다. ( fallthrough 로 끝나는 case는 스스로 break를 하지 않습니다 )1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;runtime&quot;)func main() &#123; fmt.Print(&quot;Go runs on &quot;) switch os := runtime.GOOS; os &#123; case &quot;darwin&quot;: fmt.Println(&quot;OS X.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(&quot;%s.&quot;, os) &#125;&#125; 메소드고에는 클래스가 없습니다. 하지만 메소드를 구조체(struct)에 붙일 수 있습니다. 메소드 리시버(method receiver) 는 func 키워드와 메소드의 이름 사이에 인자로 들어갑니다.12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := &amp;Vertex&#123;3, 4&#125; fmt.Println(v.Abs())&#125; 인터페이스인터페이스는 메소드의 집합으로 정의됩니다. 그 메소드들의 구현되어 있는 타입의 값은 모두 인터페이스 타입의 값이 될 수 있습니다.123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Abser interface &#123; Abs() float64&#125;func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat implements Abser a = &amp;v // a *Vertex implements Abser a = v // a Vertex, does NOT // implement Abser fmt.Println(a.Abs())&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)","link":"/2018/05/14/go-language-시작하기/"},{"title":"hyperwallet 결제","text":"hyperwalletHyper wallet 결제 방식 Payment fund 는 미리 준비된 카드나 은행 계좌로 옮겨진다. 요청에 따라 미래에 결제를 완료할 수 있다. Client 객체를 통해 결제를 진행한다. 핵심적인 엔티티의 의미는 다음과 같다. DestinationTokenFor Portal solutions, provide a user-token For Select solutions, provide a user-token For Direct solutions, provide a bank-account-token For Card solutions, provide a prepaid-card-token Destination Token에 따라 계좌 혹은 유저 계정으로 돈을 보낼 수 있다.var Hyperwallet = require(‘hyperwallet-node’);var client = new Hyperwallet({ username: ‘testuser@12345678’, password: ‘myAccPassw0rd’ }); client.createPayment({ “amount”: “20.00”, “clientPaymentId”: “DyClk0VG”, “currency”: “USD”, “destinationToken”: “usr-c4292f1a-866f-4310-a289-b916853939de”, “programToken”: “prg-83836cdf-2ce2-4696-8bc5-f1b86077238c”, “purpose”: “OTHER”}, function(error, body) { // handle response body here}); expiresOnWhen the payment will expire if unclaimedcurl -X “POST” “https://api.sandbox.hyperwallet.com/rest/v3/transfers&quot; \\-u testuser@12345678:myAccPassw0rd \\-H “Content-Type: application/json” \\-H “Accept: application/json” \\-d “{ “clientTransferId”: “6712348070812”, “destinationAmount”: “125”, “destinationCurrency”: “USD”, “notes”: “Partial-Balance Transfer”, “memo”: “TransferClientId56387”, “sourceToken”: “usr-ac5727ac-8fe7-42fb-b69d-977ebdd7b48b”, “destinationToken”: “trm-e3af62b4-24d5-100f-a4eb-ada857b8fc30”}” Transfer 이란 Hyperwallet계좌에서 실제 계좌 혹은 카드로 돈을 전송하는 것을 의미한다.sourceToken 엔티티는 대금의 출처를 의미한다. 선지급 카드 혹은 유저 계좌가 들어갈 수 있다. 싱가포르에서 한국으로 입금 혹은 한국에서 싱가포르로 입금이 가능한가? hyperwallet에서 test를 진행하기 위하여 tutorial 에서 발급받은 program key 를 기준으로 테스트를 진행이 가능하다.여기서 user를 생성하고 account를 연결하여 transfer 및 payment를 테스트 가능하다.계좌를 입력하는 경우 iban 코드가 필요한데 이는 international bank account number로 각 계좌마다 존재한다. 하지만 국내 은행의 경우 이러한 iban 이 없는 경우가 ㅁ낳다.Bank swift code는 각 은해마다 존재한다.","link":"/2018/07/13/hyperwallet-결제/"},{"title":"","text":"Hyperledger fabric 시작하기Prerequisition docker 설치하기 virtual box 다운로드 VM 환경 설정먼저 다음 명령어를 통해 docker를 사용하기 위한 VM을 생성해 줍니다. 1docker-machine create --driver virtualbox blockchain 새로 생성된 VM의 환경변수를 Host에 적용해 줍니다 1docker-machine env blockchain 운영체제에 따라 다음과 같은 명령을 실행해 줍니다. MacOS 1$ eval $(docker-machine env blockchain) Windows 1@FOR /f &quot;tokens=*&quot; %i IN (&apos;docker-machine env blockchain&apos;) DO @%i Docker 사용을 위한 환경 설정이 잘 되었는지 확인합니다. 1docker images Download hyperledger fabric docker image다음의 명령을 통해서 모든 이미지를 받습니다. 123docker pull hyperledger/fabric-baseimage:x86_64-0.2.2docker pull hyperledger/fabric-membersrvc:x86_64-0.6.1-previewdocker pull hyperledger/fabric-peer:x86_64-0.6.1-preview 이미지를 다 받으셨으면 docker images 명령을 통해서 이미지 리스트를 확인합니다. 1docker images baseimage의 경우 Tab를 latest로 태깅을 해야 합니다. 향후 블록체인의 운영모드에서 체인코드 디플로이를 할 경우 baseimage를 통해 체인코드 구동을 위한 Docker 이미지를 만드는데 hyplerledger/fabric-baseimage:latest 를 사용합니다. 12docker tag hyperledger/fabric-baseimage:x86_64-0.2.2 hyperledger/fabric-baseimgae:latestdocker images docker configurationDocker-compose.yml 123456789101112131415161718192021222324membersrvc: image: hyperledger/fabric-membersrvc:x86_64-0.6.1-preview ports: - \"7054:7054\" command: membersrvcvp0: image: hyperledger/fabric-peer:x86_64-0.6.1-preview ports: - \"7050:7050\" - \"7051:7051\" - \"7053:7053\" environment: - CORE_PEER_ADDRESSAUTODETECT=true - CORE_LOGGING_LEVEL=DEBUG - CORE_PEER_ID=vp0 - CORE_PEER_PKI_ECA_PADDR=membersrvc:7054 - CORE_PEER_PKI_TCA_PADDR=membersrvc:7054 - CORE_PEER_PKI_TLSCA_PADDR=membersrvc:7054 - CORE_SECURITY_ENABLED=true - CORE_SECURITY_ENROLLID=test_vp0 - CORE_SECURITY_ENROLLSECRET=MwYpmSRjupbT links: - membersrvc command: sh -c \"sleep 5; peer node start --peer-chaincodedev\" Fabric 소스 준비하기컴퓨터의 go path 내에 hyper ledger-fabric 의 코드를 받습니다. 12345mkdir -p $GOPATH/src/github.com/hyperledgercd $GOPATH/src/github.com/hyperledgergit clone https://github.com/hyperledger/fabric.gitcd fabricgit checkout v0.6.1-preview 우선 예제 코드를 빌드하여 블록체인 네트워크 상에서 동작을 확인해 봅시다. MacOS 12cd $GOPATH/src/github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02go build Windows 12cd %GOPATH%\\src\\github.com\\hyperledger\\fabric\\examples\\chaincode\\go\\chaincode_example02&gt; go build 위의 과정을 문제없이 완료하였으면 chaincode_example02 디렉토리 하위에 chaincode_example02 라는 이름으로 실행파일이 생성되었을 겁니다.(Windows는 chaincode_example02.exe ) 개발모드에서는 이 실행파일을 몇 개의 환경변수와 함께 실행하기만 하면 블록체인 런타임에서 트랜잭션 테스트가 가능한 상태가 됩니다. 스마트 컨트랙의 배포체인 코드를 validating peer 컨테이너에 복사해 넣고 rest api로 deploy만 호출하면 블록체인 네트워크 전체에 코드가 적용됩니다. 다음은 운영모드에서 어떻게 체인크도그 반영되는지를 보여줍니다. 체인코드의 디플로이 프로세스 운영모드에서 체인코드 디플로이가 요청되면 요청을 받은 Peer는 블록체인 네트워크상에 연결되어 있느 모든 피어에게 동일한 체인코드를 전송합니다. 체인 코드를 받은 각 validating peer는 체인코드르 빌드하여 체인 구동을 위한 docker-image를 만들고, 실행하게 됩니다. validating peer는 docker remote api서비스에 체인코드를 위한 docker-image 생성 및 실행을 요청하고 docker-engine은 hyper ledger/fabric-baseimage를 이용하여 체인코드 docker이미지를 생성하고 실행합니다. Validating Peer의 수정docker machine은 VM 환경을 만들 때 기본적으로 https 통신을 하도록 docker 엔진을 구동하고, validating peer 가 docker engine api 에 요청하기 위해서는 블록체인의 ssl certificate를 가지고 있어야합니다. 이렇게 validating peer 가 ssl certificate를 가지기 위해 다음과 같은 절차를 거칩니다. 실행중인 validating peer 컨테이너에 certificate들을 복사합니다. 실행중인 Validating Peer 컨테이너에 터미널로 접속해서 설정파일을 수정합니다. Validating Peer에서 빠져나와서 실행중인 Validating Peer 컨테이너를 새로운 이미지 명으로 commit 합니다. 새로 생성된 이미지로 Validating Peer를 다시 구동합니다. 컨테이너에 ssl 인증서 복사12345컨테이너에서 로컬로 복사docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH로컬에서 컨테이너로 복사docker cp [OPTIONS] SRC_PATH CONTAINER:DEST_PATH 인증서 위치 123$ cd $HOME/.docker/machine/machines/blockchain$ mkdir key$ cp &#123;cert,ca,key&#125;.pem key 도커 컨테이너 아이디 확인 1docker ps 컨테이너에서 Peer의 설정파일에 인증서 위치를 명시 1234docker exec -it 컨테이너ID bash위 그럼을 기준으로 명령 예는 다음과 같습니다.docker exec -it 4409df7072c4 bash docker의 bash 에 접근하였으면 다음과 같은 설정파일을 수정한다. 12 cd membersrvc# vi membersrvc.yaml","link":"/2019/04/08/hyperledger-fabric-시작하기/"},{"title":"java - class와 instance에 대해 알아보자","text":"Class와 Instance가 무엇인지 알아보자.객체 지향 언어란?객체(Object) 란 실제 세계의 많은 사물들을 컴퓨터 내에서 하나의 객체로써 표현하는 하나의 프로그래밍 패러다임을 의미한다.가령 사과, 사과 장수, 사과의 판매 처럼 실존하는 형태와 형태의 행위들을 표현할 수 있게 된다. Class 란?Class 란 하나의 틀(mold) 라고 보면 된다.가령 현실 세계의 사과 장수는 수없이 많고, 각 사과장수는 공통된 특성을 가지고 공통된 행위가 가능하다.컴퓨터 프로그래밍 에서는 이러한 상태와 특성 그리고 행위를 표현 가능하며 각각을 property와 method 라고 부른다. 가령 사과 장수라면, 나이, 가지고 있는 사과의 개수, 판매하고자 하는 사과의 가격 등의 특성을 가지고 ‘사과를 판매’ 하거나 ‘사과를 구매’ 하는 등의 행위가 가능할 것이다. Instance란?Instance란 위에서 정의한 class로 찍어낸 실제 객체를 의미한다.가령 현실 세계에서 사과장수는 하나의 추상적인 개념이다. 즉, 사과의 갯수, 나이 처럼 각종 특성을 가지는 하나의 무형의 존재이지만 실제 사과장수는 현실에서 존재한다. 가령 옆집에 사는 사과장수의 경우 정해진 나이와 사과의 갯수를 가지고 실존하는 것이며, 이를 object 또 instance라고 부른다. Java에서는 class를 통해 instance를 만들어 낼 수 있으며, 새로운 instance를 생성하면 그 데이터가 저장되고 데이터를 가르치는 참조변수에 그 주소값을 저장한다. 생성자(Constructor) 란?가령 AppleSeller 라는 class 와 appleSeller1이라는 참조 변수를 가지는 instance를 만들었다고 가정하자.이 만드는 과정에는 그 사과장수의 나이와 사과의 갯수처럼 최초로 설정해 주어야 하는 값들이 있고, 이러한 설정을 Constructor 즉 생성자 내부에서 처리할 수 있다.","link":"/2018/06/13/java-class와-instance에-대해-알아보자/"},{"title":"it-chain 04","text":"[ Opensource Blockchain Engine, IT-CHAIN] 04. AuthenticationOpen Source Blockchain Engine인 It-chain 의 네번째 포스트입니다. 이번 포스트에서는 IT-CHAIN에서 블록의 인증과정에 대해 알아보겠습니다. 어떻게 노드들의 신분을 인증하는가?모든 노드는 각자 고유의 private key와 public key를 발행하며 이는 it-chain의 자체 라이브러리인 heimdal을 통해 이루어 집니다. heimdal를 통해 키를 생성하면 private key 와 public key 두 쌍의 키가 생기게 되는데, 여기서 public key를 활용하여 각 노드들의 id를 만들어 노드들의 신분을 보장하며, 각 노드는 트랜잭션을 발행하는 시점에 해당 트랜잭션을 자신의 private key로 sign한 signature를 함께 동봉합니다. 트랜잭션의 Signing트랜잭션을 발행할 때 TX와 함께 signatature를 동봉하게 되는데 이는 보내는 사람의 private key로 sign한 정보이다. It-chain: https://github.com/it-chain/engine Opensource Blockchain Engine It-chain 시리즈 01. P2P 네트워크와 합의 알고리즘 02. 블록의 생성과 동기화 LNH","link":"/2018/09/30/it-chain04/"},{"title":"it-chain 02","text":"[ Opensource Blockchain Engine, IT-CHAIN] 02. Blockchain ComponentOpen Source Blockchain Engine인 It-chain 의 두번째 포스트입니다. 이번 포스트에서는 IT-CHAIN에서 블록의 합의를 담당하는 Blockchain component에 대해 알아보겠습니다. It-chain의 Blockchain Component블록체인에서 일어나는 모든 거래는 Transaction이라고 불리며, 하나의 블록은 여러 Transaction들의 집합으로 구성됩니다. 때문에 블록체인에서는 생성된 블록이 올바른 블록인지 확인하고 체인에 추가하는 과정이 필요하며, 이 과정은 It-chain의 Blockchain Component에서 이루어 집니다. 또한, It-chain에서는 블록의 저장 및 조회를 위한 별도의 라이브러리를 구현하였으며, Blockchain Component는 yggdrasill에서 정의한 interface에 맞게 구조체를 구현한다면 yggdrasill에 block을 저장, 조회할 수 있습니다. yggdraill에 연속적으로 저장된 block들을 우리는 blockchain이라고 부릅니다. Block 의 상태Blockchain Component에서 Block은 다음과 같은 상태로 존재합니다. Block State Description Created 합의되지 않았고, blockchain에 저장되지 않았다. Staged 합의되었지만, blockchain에 저장되지 않았다. Committed 합의되었고, blockchain에 저장되었다. 위에서 언급한 바와 같이 블록체인 네트워크를 구성하는 노드들은 계속해서 새로운 블록들을 합의하는 과정중에 있고 합의가 완료되며 오직 리더 노드 에서 블록을 생성하여 다른 노드들에게 전파하고 블록을 받은 노드는 자신이 생성한 블록과 비교하여 검증여부를 판단합니다. 즉, 각 노드에서 막 생성된 블록은 Created 상태에 있으며, 이 블록을 Consensus 알고리즘을 통해 합의를 이루고 합의가 완료되며 Staged 상태로 바뀌게 됩니다. Staged 상태의 블록이 실제 yggdrasill 내의 데이터베이스에 저장된다면, 블록은 Commited 상태로 변경됩니다. 노드 사이에서 블록의 동기화동기화(Synchronize)는 특정 노드의 블록 체인을 네트워크 내 임의의 노드의 블록 체인과 동일하게 만드는 과정을 의미합니다. 동기화(Synchronize) 과정의 목적은 모든 블록에 대하여 대표값(Seal), 이전 블록의 대표값(PrevSeal), 트랜잭션 모음(TxList), 트랜잭션 대표값(TxSeal), 블록 생성 시각(TimeStamp), 생성자(Creator), 블록 체인의 길이(Height) 등의 블록 체인과 관련된 모든 정보들을 다른 노드의 것과 같게 만드는 것에 있으며, 이를 통해 블록체인에 참여하는 모든 노드가 같은 블록의 모음을 가지게 될 수 있습니다. 동기화(Synchronize)는 다음과 같이 확인(Check), 구축(Construct), 재구축(PostConstruct) 의 과정을 거칩니다. 확인(Check) 특정 노드의 블록 체인이 동기화가 필요한 상태인지를 점검합니다. 이 과정은 임의의 노드에게 Blockchain 길이와 lastSeal을 받아와서 자신의 블록 체인 정보가 같은 지 비교하여, 동기화가 필요한 상태인지 점검하는 것으로, 이미 동기화가 완료된 상태라면, 동기화(Synchronize) 과정을 중단하고, 그렇지 않을 경우, 구축(Construct) 을 수행합니다. 구축(Construct) 구축에소는 임의의 노드에게 블록 정보를 요청하여, 응답받고, 응답받은 블록을 블록 체인에 저장하는 과정을 반복합니다. 블록 요청은 특정 노드의 블록 체인 길이(Height)를 활용해, 임의의 노드에 블록을 요청함으로써 수행되며, 특정 노드가 새로 참여하는 노드일 경우 임의의 노드의 블록 체인 내 최초 블록부터 마지막 블록까지 요청하고, 기존에 참여중이던 노드일 경우 보유 중인 블록 체인 내 마지막 블록의 다음 블록부터 임의의 노드의 블록 체인 내 마지막 블록까지 요청합니다. 임의의 노드의 모든 블록이 특정 노드의 블록체인에 저장되면 구축(Constrcut)이 완료됩니다. 특정 노드는 구축(Construct) 의 진행 중에 새롭게 합의되는 블록을 블록 임시 저장소(BlockPool)에 보관하며, 구축(Construct) 이 완료되고 나면, 블록 임시 저장소에 블록이 보관되어 있는 지 확인합니다. 보관중인 블록이 있다면, 재구축(PostConstruct)을 수행합니다. 재구축(PostConstruct) 이미 구축(Construct) 된 블록 체인에 블록 임시 저장소(BlockFool)에 보관중인 블록들을 부수적으로 추가하는 것을 의미하며, 재구축(PostConstrcut) 을 수행하고 나면, 동기화(Synchronize) 과정이 모두 완료됩니다. 이번 포스트에서는 It-chain 내에서 블록의 검증과 저장을 수행하는 Blockchain 컴포넌트에 대해 알아보았습니다. 다음 포스트에서는 it-chain에서 dApp을 발행하고 실행하는 ivm 컴포넌트에 대해 알아보겠습니다. It-chain: https://github.com/it-chain/engine Opensource Blockchain Engine It-chain 시리즈 01. P2P 네트워크와 합의 알고리즘 LNH","link":"/2018/07/30/it-chain02/"},{"title":"it-chain 03","text":"[ Opensource Blockchain Engine, IT-CHAIN] 03. IVM ComponentOpen Source Blockchain Engine인 It-chain 의 세번째 포스트입니다. 이번 포스트에서는 IT-CHAIN에서 Smart Contract 의 배포와 실행을 담당하는 IVM COMPONENT에 대해 알아보겠습니다. It-chain의 IVM ComponentIt-chain 에서는 icode라 불리는 smart contract을 배포할 수 있으며, It-chain 위에서 일어나는 Transaction 이 내포하는 의미는 바로 어떤 노드에서 어떤 smart contract의 어떤 함수를 실행시켰는가에 관한 정보이며 그 구조 중 일부는 다음과 같습니다. 12345&#123; icodeId: _icodeid, type: invoke | query function: _functionName&#125; 여기서 트랜잭션을 실행시킨다는 것은 해당하는 icode 에게 특정 요청을 전달하는 것입니다. transaction의 종류에는 invoke와 query가 있는데, 여기서 invoke는 데이터를 쓰는 작업이고 query는 데이터를 읽는 작업이라고 볼 수 있습니다. 각 아이코드는 특정 함수에 대한 handler를 가지고 있으며 특정 함수를 실행하면 그에 매칭되는 핸들러가 동작하여 아이코드 내에서 일련의 작업이 일어나게 됩니다. Icode 들은 어디에 저장되나요?각 노드에서 배포된 Smart contract인 icode 들은 자신의 고유값을 기준으로 한 git repository에 자장되며, 어떤 노드에서 특정 icode를 실행하기 위해서는 git repository에서 해당 icode 를 받아와서 자신의 노드에 docker container를 구축하여 그 내부에서 icode를 실행시킵니다. 즉, 새로운 스마트 컨트랙이 생성되면 이는 특정 git repository 로 업로드되고 사용되기 전까지 해당 git repository에 저장되어 있습니다. Docker Container 관리를 위한 Tesseract Library블록체인 노드에서 여러개의 icode 가 하나의 노드에서 실행되어야 하며, 각 icode는 서로에게 독립적으로 작동하기 위해서 각 icode가 실행되는 환경을 가상화하여 독립시킬 필요성이 생기게 되었으며, 이를 해결하기 위해 it-chain 에서는 리눅스 컨테이너 기술인 Docker 를 사용하게 됩니다. Docker 란 하나의 노드에서 여러개의 독립 실행 환경을 구성해 줄 수 있으며, 각 실행환경을 Container라는 단위로 부릅니다. IVM에서 각 icode는 각각 저마다의 독립된 실행공간인 Container 를 가지며 it-chain에서는 각 컨테이너를 생성하고 관리하는 별도의 라이브러리인 Tesseract 라는 독자적인 라이브러리를 사용하고 있으며, Tesseract 라이브러리는 각 컨테이너의 DB에 데이터를 저장하고 출력하는 작업을 수행합니다. Smart Contract 작성을 위한 SDK LibrarySmart Contract 이란 사용자가 특정 함수나 요청을 전달하였을 때 항상 동일한 결과를 내놓는 일종의 블랙박스라고 볼 수 있습니다. icode는 docker위에서 동작하며 위의 invoke 등을 처리함에 있어 sdk의 함수들을 사용하는데 여기서 sdk는 ivm의 tesseract에게 grpc 통신을 통해 데이터를 쓰고 읽는 작업을 처리합니다. Icode 는 언제 실행되나요?먼저, icode 의 각 함수는 transaction을 만들어내고 이 tx는 리더에게 전달됩니다. 리더는 tx를 받아 블록을 만들고 해당 블록을 받아 내부에 있는 tx를 실행시킴으로서 실제 icode 가 실행이 됩니다. 현재 잇체인 팀은 계속해서 icode의 실행의 유효성을 보장하기 위한 다양한 시도들을 하고 있습니다. 가령, 현재 it-chain은 transaction 내의 임의 함수로 인해 각 노드에서 다른 결과가 나오는 등 노드 별로 같은 결과값을 가지고 공유하기 위한 연구와 시도등이 있으며, it-chain 팀은 이를 해결하기 위해 각 노드에서 생성된 블록의 transaction 들을 바로 실행시키고 반영하기 전에 미리 한번 각 transaction을 실행시킨 뒤 상대방이 실행시킨 결과값과 나의 결과값이 일치할 때에만 icode 를 실행시키는 등의 장치를 구현중에 있습니다. 스마트 컨트랙의 실행과 World State Database실행된 스마트 컨트랙트는 각 노드의 상태를 변경시키고 변경된 상태들에 각 컨테이너가 접근할 수 있어야 하기에 공용으로 사용할 상태값 저장 공간이 필요하게 되었으며 이를 World State Database 라고 부릅니다. it-chain에서 world state database 는 키밸류 DB 인 Level DB를 사용하여 구현되었습니다. 이번 포스트에서는 It-chain 내에서 Smart Contract을 배포 및 실행, 관리하는 IVM Component에 대해 알아보았습니다. 다음 포스트에서는 it-chain에서 노드의 인증을 담당하는 Authentication에 대해 알아보겠습니다. It-chain: https://github.com/it-chain/engine Opensource Blockchain Engine It-chain 시리즈 01. P2P 네트워크와 합의 알고리즘 02. 블록의 생성과 동기화 LNH","link":"/2018/08/30/it-chain03/"},{"title":"Javascript Cookbook","text":"Javascript CookbookObjectassign()assign 함수는 특정 객체의 값을 복사하는 함수입니다. assign 함수를 통해 두 개 이상의 객체를 병합하는 등의 작업을 수행 가능합니다. assign 함수는 아래와 같이 사용되며 대상 객체를 반환합니다. example 1Object.assign(target, ...source) 객체 복사하기 12var source = &#123; a: 1 &#125;;var target = Object.assign(&#123;&#125;, source); 위와 같이 Object.assign은 객체를 복사하는 데 사용될 수 있으며, {} 처럼 빈 객체를 넣고 반환값을 받음으로써 빈 객체에 source 가 되는 object를 복사할 수 있습니다. 객체 병합하기 assign 함수를 통해 객체를 병합 할 수 있습니다. 가령 a, b 객체가 있고 각각의 키값을 하나로 병합하고 싶다면 다음과 같이 수행 할 수 있습니다. 1234var obj1 = &#123; a:1, b:2 &#125;;var obj2 = &#123; a:1, c:4, d:5 &#125;;var target = Object.assign(&#123;&#125;, obj1, obj2); 이처럼 만약 동일한 key를 가졌다면 뒤에 오는 source의 key, value 들로 덮어씌워지는 방식으로 복사될 것입니다. keys()entries()entries 함수는 object의 키들을 열거가능한 [key, value] 쌍을 리턴해 주며, 다음과 같이 사용됩니다. example 123var obj = &#123; a:1, b:2, c:3 &#125;;var entries = Object.entries(obj);// [[\"a\", 1],[\"b\", 2],[\"c\", 3]] 객체 내의 다양한 키들을 순환하는 로직을 구현 하는 경우 이는 매우 효과적이며 다음과 같이 사용됩니다. exmaple 123456var obj = &#123; a:1, b:2, c:3 &#125;;var entries = Object.entries(obj);entries.foreach((key, value)=&gt;&#123; // do some stuff console.log(key, value);&#125;) Mapjs에서 Map 이란 일종의 key 와 value의 쌍으로 흔히 object와 비슷한 역할을 수행하지만, object와 달리 어떤 종류의 값도 저장할 수 있는 장점이 있으며, 흔히 대량의 자료가 저장되는 경우 object에 비해 훨씬 좋은 성능을 보인다. 이번 포스트에서는 Map 이 가진 다양한 함수들과 이에 대한 활용법에 대해 알아보도록 한다. example 1new Map([iterable]) //key, value pair set12var map = new Map([[a, 1], [b, 2]]);map.set(c, 3); get12var map = new Map([[a, 1], [b, 2]]);map.get(1); delete(key)12var exampleMap = new Map([a, 1], [b, 2]);exampleMap.delete(a); foreach1234var example = new Map([a, 1], [b, 2]);example.foreach((value, key)&#123; // do some stuff here.&#125;) Arraysort()array의 sort는 배열을 정렬하기 위한 아주 좋은 method 입니다. sort는 뒤에 오는 콜백함수를 계속 실행하여 callback(a, b)의 값이 0보다 작은 경우 a를 앞으로 보내고, 0보다 큰 경우 a를 뒤로 보내는 방식으로 동작합니다. 1234567891011121314151617181920/* 정상 동작 */score.sort(function(a, b) &#123; // 오름차순 return a - b; // 1, 2, 3, 4, 10, 11&#125;);score.sort(function(a, b) &#123; // 내림차순 return b - a; // 11, 10, 4, 3, 2, 1&#125;);student.sort(function(a, b) &#123; // 오름차순 return a.name &lt; b.name ? -1 : a.name &gt; b.name ? 1 : 0; // 광희, 명수, 재석, 형돈&#125;);student.sort(function(a, b) &#123; // 내림차순 return a.name &gt; b.name ? -1 : a.name &lt; b.name ? 1 : 0; // 형돈, 재석, 명수, 광희&#125;); splice()array.splice(i,1)를 통해 index i 로 부터 1개의 요소를 제거하고 제거한 자리에 값을 추가한다. example 1234var array = [0, 1, 2, 3, 4, 5];array.splice(2, 1);//array에는 세번째 요소가 빠진 상태가 된다.[0, 1, 3, 4, 5] delete특정 요소를 삭제할 때 사용한다. 12var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];delete arr[1]; poparray를 stack으로 사용하는 경우 pop() 함수는 매우 유용하며, 가장 우측의 element를 제거한다. example 1234567let list = [1, 2, 3, 4, 5, 6, 7];console.log(&apos;original list: &apos;, list);let poped = list.pop();console.log(&apos;poped item: &apos;, poped);console.log(&apos;list after pop() executed: &apos;, list); Push리스트에 특정 아이템을 추가하고 추가된 이후에 총 아이템의 갯수를 반환한다. 이 함수는 원래의 리스트를 변형한다. 12345console.log('original list: ', list);let count = list.push('pushed item');console.log('Total item count after push() executed: ', count);console.log('list after push() executed: ', list); shiftshift는 주로 que의 구현에 많이 사용되며, 제일 앞의 element를 제거하고 반환해 준다. 12345console.log(&apos;original list: &apos;, list);let shifted = list.shift();console.log(&apos;shifted item: &apos;, shifted);console.log(&apos;list after shift() executed: &apos;, list); unshift()제일 앞쪽에 밀어 넣는다. example 12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Lemon&quot;); // Adds a new element &quot;Lemon&quot; to fruits foreach(()=&gt;{})모든 어레이값에 대해 연산을 수행하는 함수이며 다음과 같이 사용된다. 1234var arr = [1, 2, 3, 4, 5];arr.foreach((element, index, array)=&gt;&#123; console.log(element);&#125;) reducereduce는 array의 모든 값에 대해 계속해서 callback함수를 실행시키는 함수이며 다음과 같은 용도로 사용합니다. syntax 1234var arr = [1, 2, 3, 4, 5];arr.reduce((accumulator, currentValue, currentIndex, array)=&gt;&#123; // do some stuff here.&#125;) 여기서 첫번째 인자인 accumulator는 계속해서 다음 callback의 인자로 전달되는 값이며 어떤 변환을 하더라도 해당 변환 내용이 다음으로 전달되며, currentValue는 현재 값을 나타냅니다. 배열에서 가장 큰 값을 구하기 accumulator를 통해 계속 앞의 return 값을 받아와 비교하면서 가장 큰 값을 구할 수 있습니다. 1234var arr = [1, 2, 3, 4, 5];var max = arr.reduce((before, current)=&gt; return before&lt;current ? current : before)","link":"/2019/03/12/javascript-cookbook/"},{"title":"javascript class 활용하기","text":"Class의 활용 Math String 특정 문자를 원하는 문자로 바꾸기 특정 문자열을 쪼개기 스트링을 배열로 쪼게기 Promise를 이용한 효율적인 비동기 처리 기본 코드 Promise.catch this의 개념 일반적인 this의 의미 new와 this call Class의 활용MathMath를 활용한 랜덤 넘버 생성Math.floor(Math.random() * 1000000000) String특정 문자를 원하는 문자로 바꾸기.replace(&quot;바꿀 문자열&quot;,&quot;바꾼 뒤의 문자열&quot;) 특정 문자열을 쪼개기str.split(&quot; &quot;) 스트링을 배열로 쪼게기123&quot;1234567890&quot;.match(/.&#123;1,2&#125;/g);// Results in:[&quot;12&quot;, &quot;34&quot;, &quot;56&quot;, &quot;78&quot;, &quot;90&quot;] Promise를 이용한 효율적인 비동기 처리promise를 이용하여 효율적으로 비동기 함수를 관리한다. 기본 코드1234567891011121314151617181920212223242526272829303132333435//Promise 선언var promisefunction = function (param) &#123; return new Promise(function (resolve, reject) &#123; // 비동기를 표현하기 위해 setTimeout 함수를 사용 window.setTimeout(function () &#123; // 파라메터가 참이면, if (param) &#123; // 해결됨 resolve(&quot;해결 완료&quot;); &#125; // 파라메터가 거짓이면, else &#123; // 실패 reject(Error(&quot;실패!!&quot;)); &#125; &#125;, 3000); &#125;);&#125;;//Promise 실행promisefunction(true).then(function (text) &#123; // 성공시 console.log(text);&#125;, function (error) &#123; // 실패시 console.error(error);&#125;); Promise.catch비동기시에 에러를 잡는다.12345678_promise(true) .then(JSON.parse) .catch(function () &#123; window.alert(&apos;체이닝 중간에 에러가!!&apos;); &#125;) .then(function (text) &#123; console.log(text); &#125;); this의 개념일반적인 this의 의미일반적으로 . 앞의 object를 말한다고 보면 된다. 즉 자신을 호출한 대상 내의 변수나 함수들을 지칭하는 개념이다. new와 thisnew를 통해 새로운 객체를 만들게 되면 자신을 호출한 대상이 없으므로 this의 값이 자기 자신으로 리셋이 된다. call함수1.call(함수2,변수) 함수2내의 this값이 함수1을 가르키도록 한다.","link":"/2018/01/14/javascript-class-활용하기/"},{"title":"javascript - Functional Programming with Javascript","text":"Functional Programming with JavascriptWhat is the functional programming함수형 프로그래밍은 자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다. 명령형 프로그래밍에서는 상태를 바꾸는 것을 강조하는 것과는 달리, 함수형 프로그래밍은 함수의 응용을 강조한다. 수학적 함수와 명령형 프로그래밍에서 사용되는 함수는 차이가 있는데, 명령형의 함수는 프로그램의 상태의 값을 바꿀 수 있는 부작용이 생길 수 있다. 이 때문에 명령형 함수는 참조 투명성이 없고, 같은 코드라도 실행되는 프로그램의 상태에 따라 다른 결과값을 낼 수 있다. 반대로 함수형 코드에서는 함수의 출력값은 그 함수에 입력된 인수에만 의존하므로 인수 x에 같은 값을 넣고 함수 f를 호출하면 항상 f(x)라는 결과가 나온다. 부작용을 제거하면 프로그램의 동작을 이해하고 예측하기가 훨씬 쉽게 된다. 이것이 함수형 프로그래밍으로 개발하려는 핵심 동기중 하나이다. 여기서 가장 중요한 개념 중 하나인 pure function 이란 부작용이 없는 함수 즉, 함수의 실행이 외부에 영향을 끼치지 않는 함수를 의미한다. 때문에 pure function 은 병렬적인 연산이 가능하고, 스레드에 안전하다. 이러한 pure 함수는 언제나 같은 값을 반환함이 보장되기 때문에 아무런 제약없이 사용되어도 안전하며, 때문에 이러한 pure function 들은 다른 함수의 input 으로 제공되어도 안전하다. 이렇게 함수형 프로그래밍 에서는 함수 자체가 변수처럼 선언되고 input 으로 사용되는 등 변수와 같이 취급되는 fist class citizen이다. 이렇게 함수를 인자로 받는 함수를 higher order function 이라고 한다. 선언형 프로그래밍과 명령형 프로그래밍example of imperative programming1234567var string = \"This is the midday show with Cheryl Waters\"; var urlFriendly = \"\";for (var i=0; i&lt;string.length; i++) &#123; if (string[i] === \" \") &#123;urlFriendly += \"-\"; &#125;else&#123; urlFriendly += string[i]; &#125; &#125; console.log(urlFriendly); example of declarative programming12const string = \"This is the mid day show with Cheryl Waters\" const urlFriendly = string.replace(/ /g, \"-\") console.log(urlFriendly) 위 예제와 같이 선언형 프로그래밍에서는 모든 작업이 replace라는 선언아래 감추어져 있고, 개발자가 코드를 보았을 때 어떤일이 벌어지는지 매우 명확하게 알 수 있다. code itself describes what is happening","link":"/2018/07/25/javascript-functional-programming-with-javascript/"},{"title":"javascript - Date 에 대해 알아보자","text":"Javscript의 Date Object와 다양한 활용법에 대해 알아보자.웹사이트를 만들거나 다양한 작업을 함에 있어서 정확한 ‘날짜 표기’ 는 매우 중요하며 이는 js에서 Date Object를 통해 구현된다.이번 포스트에서는 Date의 내장 함수와 그에 따른 활용법에 대해 알아본다. Create date object다음과 같은 방법으로 date object를 생성할 수 있다. 1var date = new Date(\"2018-4-30\"); 이처럼 생성 시점에 날짜를 전달 함으로써 그 날에 해당하는 date object를 반환받을 수 있으며, 다음과 같이 다양한 형태의 날짜를 입력하여도 올바른 반환값이 나온다. 1var date = new Date()","link":"/2018/06/09/javascript-date-에-대해-알아보자/"},{"title":"Marketing workbook","text":"SASS marketing tactic free tool, educational content free trial Identify ideal customer who is the actual customer SEO, content marketing collect email(by register in homepage) live chat B2B marketing Quora 에서 질답하며 인사이트를 확보하고 고객의 비즈니스를 이해한다. 커뮤니티, 포럼에 참석한다. inbound.org, growthhackers.com Hackers new, insidehackers 링크드인과 페이스북 그룹을 통해 기업 관계자들과 친분을 쌓는다. 슬랙 커뮤니티에 활동하라 다른 브랜드와 협업하라","link":"/2019/03/27/marketing-workbook/"},{"title":"Kubernetes cookbook","text":"PrerequisiteInstall 1curl https://sdk.cloud.google.com | bash login 123gcloud auth logingcloud auth login --no-launch-browser # no browsergcloud config list project set project 12gcloud config set project &lt;PROJECT_ID&gt;gcloud config list project # list project install kubernetese 1curl -sS https://get.k8s.io | bash","link":"/2019/07/01/kubernetes-cookbook/"},{"title":"Getting started with linux","text":"What is User and Group in linux system?리눅스 운영체제는 기본적으로 여러 명의 유저가 동시에 접속하여 각자 다른 작업을 수행하여도 잘 동작하도록 설계되었다. 때문에, 여러 사용자가 각자 프로그램을 제어할때 서로 같은 시스템 자원을 사용하게 되어 생기는 문제를 핸들링 해야 할 필요가 생기게 되었는데, 그러한 권한관리 시스템을 구성하는 개념이 user 와 group 이며, 여기서 permission의 개념이 등장한다. 때문에 각 파일과 디렉토리는 유저별로 할당된 권한이 있으며 이를 확인하는 명령어는 다음과 같다. 1ls -l &lt;file or directory&gt; 위 명령어를 입력하면 다음과 같은 결과가 출력되는데 12-rw-r--r-- 1 root root 1031 Nov 18 09:22 /etc/passwddrw-r--r-- 1 root root 1031 Nov 18 09:22 /etc 여기서 첫번째 - 표시는 해당 파일 혹은 디렉토리가 파일임을 나타내고 만약 두번째처럼 d 로 시작한다면 디렉토리를 나타낸다. 뒤이어 오는 rw-, r–, r– 는 각각 파일의 소유자와 같은 그룹의 유저들 그리도 나머지 유저들에 대한 권한을 나타낸다. r 은 read w 는 write x 는 executre 로써 각각 읽기, 쓰기, 실행하기의 권한을 나타낸다. Create and Delete User Accounts1useradd &lt;name&gt; -d /home/&lt;user's home&gt; -e &lt;YYYY-MM-DD&gt; -f &lt;0 or -1&gt; - s /bin/&lt;shell&gt; 위처럼 유저를 생성 할 수 있으며, d, e, f, s 의 옵션과 내용은 각각 해당 유저의 로그인시 홈 디렉토리, 유효기간, 유효일자, 기본 shell type 을 의미한다. 이렇게 유저를 생성하며, 누구나 해당 유저에 접근하여 사용할 수 있기 때문에, 실제 사용시에는 다음과 같이 비밀번호를 설정해 주어야 한다. 1passwd &lt;username&gt; Understanding Sudo이렇게 기본 유저의 경우 각 파일과 디렉토리 별로 권한이 있기 때문에, 활동이 상당히 제한적일 수밖에 없다. 이 때문에, 컴퓨터 시스템을 조작하거나 기타 여러 작업을 수행하기 위해서는 sudo 명령어와 같이 시스템의 루트 권한을 가져오는 명령어가 필요한 경우가 종종 있다. 이러한 sudo 명령어는 대부분의 운영체제에 기본으로 설치되어 있지만 없는 경우 다음과 같이 설치해 준다. 12345# in ubuntu osapt-get install sudo# in centosyum install sudo 이런 sudo 명령어는 허가된 사용자에 대해서만 사용이 가능하기 때문에 이 리스트를 sudoer 라는 파일을 통해 관리하게 된다. sudoer 파일은 매우 중요한 파일이기 때문에 텍스트 에디터에서 접근하면 치명적인 에러와 접속 불가 상태에 빠질수 있기 때문에 visudo 와 같은 별도 명령어를 사용한다. visudo 12345# User privilege specificationroot ALL=(ALL:ALL) ALLcjones ALL=(ALL:ALL) ALLkbrown ALL=(ALL:ALL) ALLlmartin ALL=(ALL:ALL) ALL Working with groups리눅스는 유저들을 관리하기 위해 group 이라는 개념을 사용하며 그 그룹들은 /etc/group/ 파일에서 관리되며, 이 파일에는 어떤 그룹에 어떤 유저들이 포함되어 있는지 명시되어 있다. 다음 명령어를 통해 그룹을 생성하고 변경할 수 있다. 12newgrp &lt;group&gt;chgrp &lt;new_group&gt; Chmod Command이렇게 설정된 permission 을 간편하게 변경하기 위한 명령어로 chmod명령어가 있으며 그 사용법은 다음과 같다. 앞서 설명한 것처럼 파일 혹은 디렉토리의 권한은 rwx 와 같은 형태로 표현되며 모든 권한이 없는 상태는 — 와 같다. 이렇게 모든 권한이 있는 상태와 없는 상태를 2진 표기법으로 3자리로 나타내며, 이를 8진수로 표기하여 다음과 같이 설정할 수 있다. 1chmod 400 ./example 위 명령어는 example 이라는 파일의 권한을 r-------- 로 변경하는 명령어이다. 또 아래와 같은 간편한 명령어도 존재하는데 1chmod +t ./example 해당 명령어는 sticky bit 라 불리며 자신이 속한 그룹 내에서도 오직 자신만이 해당 파일의 삭제권한을 가지도록 할 수 있다. 이는 여러 사용자로 구성된 그룹에서 간편하게 자신만이 삭제권한을 가지게 할 수 있어 매우 편리하다. 참고자료 터미널 명령어 조합8080포트에 붙은 프로세스 죽임 fuser -k 8080/tcp 가상 터미널(screen의 활용)screen -S 세션명 -S 다음에 주는 세션명으로 시작합니다. screen -list -list 옵션을 주고 실행하면 이전에 작업했었던 screen 리스트가 있으면 세션명과 함께 리스트를 보여줍니다. screen -R 세션명 이전에 세션이 있을 경우 -R 다음에 오는 세션명으로 이전 작업을 불러옵니다. -R 다음에 세션명을 주지 않았을 경우에는 이전 세션이 한개만 있을 경우 그 작업을 불러옵니다. 이전 작업이 여러개 있을 경우에는 이전 작업 리스트를 보여줍니다. 세션명을 가진 세션이 없다면 새로운 세션을 만들어서 보여줌. (안만들려면 소문자 -r을 사용할 것) screen -D -r 세션명 이전 세션이 Attach 된 상태라면 Detach하고 세션을 복원해 줌. 출처","link":"/2018/01/14/linux devnote/"},{"title":"2. mongodb 데이터 마이그레이션","text":"개요 데이터 export 하기 export한 데이터 import 하기 개요몽고디비를 서버 이전시에 필요한 코드이다. 데이터 export 하기필요한 데이터베이스의 collection을 json 형태로 내보내는 코드이다.이 경우 -u를 반드시 부쳐 로그인 후에 dump를 수행하도록 하여 authentication을 해 준다.example1sudo mongoexport -h -h 127.0.0.1:27017 -d databaseName -c collectionName -u userName -o fileName.json export한 데이터 import 하기1sudo mongoimport -h 127.0.0.1:27017 -d databaseName -c collectionName --file fileName.json","link":"/2018/02/06/mongodb-데이터-마이그레이션/"},{"title":"Linux cli command cookbook","text":"psps 명령어는 현재 실행중인 프로세스의 목록을 보여준다. 12ps -ef | grep &lt;content&gt;ps -aux # 모든 그룹과 유저가 실행한 프로세스를 본다. 주요옵션이외에도 많은 옵션이 있지만 실제로는 grep명령어와 함께 사용하기 때문에 잘 사용하지 않는다. 옵션 설명 -e 모든 프로세스를 출력해 준다. -f 풀 포맷으로 보여준다.(UID, PID 등) -l 긴 포맷으로 보여준다. p, -p 특정 PID의 프로세스를 보여준다. -u 특정 사용자의 프로세스를 보여준다. 출처 lsofIf you want to quickly see the name of files that have been opened by a particular process (or all processes), the lsof command lets you do that How to list files based on their Internet address or port 12lsof -i 4 # IPv4lsof -i :3001 # Port wget12brew install wgetwget http://naver.com ifconfigconfigure or view the configuration of a network interface 1ifconfig eth0 =&gt; the first ethernet interface wlan0 =&gt; the name of the first wireless network interface on the system find1find -name \"pattern\" ln존재하는 파일에 대한 hard link 혹은 symbolic link 를 만들기 위한 명령어이다. 여기서 har link 란 같은 파일에 대해 여러 파일명을 가질 수 있게 해주며, hard link 는 특정 파일의 inode 를 가리킨다. symbolic 링크란 다른 파일을 특정 이름으로 가리키는 특별한 종류의 파일이다. hard link 의 경우 file system 을 훼손을 위험이 있으며 보통의 경우 다음과 같이 symbolic 링크를 만드는데 사용된다. 1ln -s &lt;source file&gt; &lt;link file&gt; lessLess is a terminal pager program on unix, window 1less [options] [file_name] First line: g &lt; last line: G &gt; Search: /&lt;search keyword&gt; go to line: &lt;number of the line&gt;g ddOn Unix-like operating systems, the dd command copies a file, converting the format of the data in the process, according to the operands specified. Operand description if=FILE input file iflag=FLAGS sync likewise, but also for metadata example 1dd if=blockchain/block_log iflag=nocache count=0","link":"/2019/05/15/linux-cli-command-cookbook/"},{"title":"1. mongodb 시작하기","text":"Installationinstallation on ubuntu 먼저 다음과 같이 mongodb가 설치되어 있는지 확인한다.mongod는 서버, mongo는 클라이언트 이다. 12mongod --versionmongo --version 만약 설치가 되어있지 않다면 다음 명령어로 설치를 진행한다.12345sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5echo &quot;deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu precise/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.listsudo apt-get updatesudo apt-get install -y mongodb-org 설치가 완료되었다면 아래의 명령어로 서비스를 실행시킨다.1sudo service mongod start 서비스가 정상적으로 실행되었는지 확인하기 위해 다음과 같은 명령어를 사용한다.1sudo service mongodb status 이제 다음 명령어로 mongodb에 접속한다.1mongo 접속이 완료되었다면 database를 관리하기 위한 계정을 만들어야 한다.이 계정을 통해 외부 컴퓨터에서도 본 database에 접근할 수 있게 된다.다음과 같은 admin database에 접근하여 root user를 생성한다.12use admindb.createUser(&#123;user: &quot;root&quot;, pwd: &quot;mypassword&quot;, roles: [&#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125;] &#125;); 유저를 생성하였다면 다음 명령어로 설정파일을 열어 authorization을 enabled로 해준다.1cd /etc/mongod.conf 설정이 완료되었다면 mongodb를 다시 실행시킨다.1sudo service mongod restart 다시 시작한 뒤에는 사용할 계정을 만들어 준다.12345use app #app 대신에 내가 만들 db명을 선택db.createUser( &#123; user: &quot;app&quot;, pwd: &quot;mypassword&quot;, roles: [&apos;readWrite&apos;,&apos;userAdmin&apos;] &#125; ) 생성한 아이디로 로그인 해본다.1mongo -uapp -pmypassword app connect to mongodb1mongo --port &lt;포트&gt; -u \"&lt;사용자 계정&gt;\" -p \"&lt;비밀번호&gt;\" --authenticationDatabase \"admin\" Configuration보안설정 바꾸기Vim /etc/mongod.conf https://velopert.com/457 Authoriztion 사용하기http://www.tutorialbook.co.kr/entry/MongoDB-%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%9D%B8%EC%A6%9D-authorization-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0 Basic ConceptsCollectioncreate collection 1db.createCollection(name, [options]) delete collection 1db.COLLECTION_NAME.drop() Schema일종의 데이터의 양식이다.이 스키마를 기반으로 모델을 생성한다. Model일종의 커넥션으로 다른 것들은 이 모델 객체에서 바로 수행한다.여기서 새로운 데이터를 저장하는 save를 하기 위해서는 instance를 생성하여야 하고,다른 경우는 이 모델에서 바로 수행한다. Queryupdateexample 1db.getCollection(&apos;schedule&apos;).update(&#123;&quot;email&quot;:&quot;test&quot;&#125;, &#123;$set:&#123;&quot;email&quot;:&quot;test@test.com&quot;&#125;&#125;, &#123;muti:true&#125;); 위 예제는 query를 만족하는 여러가지 데이터를 한번에 바꾸는 명령이다. 두번째 인자는 update 할 object 부분인데, {$set:{}} 을 넣어 특정 키값을 변경하고 있다. 만약 이렇게 $set 을 사용하지 않으면 해당 데이터가 통으로 교체되어 버린다. Transaction서버버전 4 이상에서 제공한다. featurecompatibility를 “4.0” 으로 해야한다. commitTransaction()은 sessionEnd 까지 포함된 개념이다. Uninstallation1234sudo service mongod stopsudo apt-get purge mongodb-org*sudo rm -r /var/log/mongodbsudo rm -r /var/lib/mongodb Cookbook위치 찾기1db.collection.createIndex( &#123; &lt;location field&gt; : \"2dsphere\" &#125; )","link":"/2018/01/23/mongodb-시작하기/"},{"title":"MYSQL ALTER statement","text":"BASIC STATEMENTCHANGE COLUMN DATA TYPE1ALTER TABLE TB_NAME CHANGE COL1 COL2 INT DELETE COLUMN1ALTER TABLE TB_NAME DROP COL_NAME RESET AUTO_INCREMENT1ALTER TABLE TB_NAME AUTO_INCREMENT=0","link":"/2018/05/08/mysql-alter-statement/"},{"title":"MYSQL CREATE STATEMENT","text":"1CREATE TABLE TB_NEW SELECT * FROM TB_OLD 위 명령어는 TB_OLD의 값과 테이블을 복사하지만 AUTO_INCREMENT가 복사되지 않고, 간혹 INDEX가 누락되는 경우가 있다. COPY STRUCTURE1CREATE TABLE TB_NEW LIKE TB_OLD 이 명령어를 사용하면 데이터는 복사하지 않지만, AUTO_INCREMENT, INDEX 등의 형식을 복사할 수 있습니다. COPY DATA1INSERT INTO TB_NEW SELECT * FROM TB_OLD COPY COLUMN DATA1INSERT INTO TB_NEW(COL_NM) SELECT COL_NAME FROM TB_OLD","link":"/2018/05/08/mysql-copy-statement/"},{"title":"5. mysql delete 문의 모든것","text":"","link":"/2018/02/06/mysql-delete-문의-모든것/"},{"title":"MYSQL INDEX","text":"BASIC STATEMENTCREATE1CREATE INDEX INDEX_NM ON TB_NAME(COL_NAME) READ1SHOW INDEX FROM TB_NAME DELETE1DROP INDEX INDEX_NM ON TB_NAME","link":"/2018/05/08/mysql-index/"},{"title":"2. mysql insert 문의 모든것","text":"AUTO_INCREMENT의 시작값 변경해 주기데이터를 정리하기 위해 시작 하는 primary 키의 AUTO_INCREMENT 값을 변경해 주어야 할 경우가 있다.다음 명령어를 통해 원하는 값부터 다시 AUTO_INCREMENT가 시작되도록 할 수 있다. 1ALTER TABLE [테이블명] AUTO_INCREMENT=[시작할려는 순서] ON DUPLICATE KEY를 이용한 중복키 관리여러개의 데이터를 한번에 입력할 때 기존에 있던 데이터는 키값은 유지하고 내용만 변경해야 할 경우가 있다.이 경우는 on duplicate key 를 활용하면 기존에 있던 데이터를 유지하면서 변경된 내용만 업데이트를 시켜줄 수 있다. example1234567891011INSERT INTO mytable (id, a, b, c)VALUES (1, &apos;a1&apos;, &apos;b1&apos;, &apos;c1&apos;),(2, &apos;a2&apos;, &apos;b2&apos;, &apos;c2&apos;),(3, &apos;a3&apos;, &apos;b3&apos;, &apos;c3&apos;),(4, &apos;a4&apos;, &apos;b4&apos;, &apos;c4&apos;),(5, &apos;a5&apos;, &apos;b5&apos;, &apos;c5&apos;),(6, &apos;a6&apos;, &apos;b6&apos;, &apos;c6&apos;)ON DUPLICATE KEY UPDATE id=VALUES(id),a=VALUES(a),b=VALUES(b),c=VALUES(c); INSERT IGNOE를 이용한 중복키 단순히 무시하기여러개의 데이터를 한번에 입력할 때 기존에 있던 정보는 아예 입력하지 않는 것이 필요한 경우가 있다.이 경우에는 다음과 같이 insert ignore 문을 활용하여 중복된 키를 가지면 입력을 시키지 않도록 할 수 있다. 아래 예제는 unique 키가 두개의 키값에 걸려있는 경우 첫번째 id 값이 입력되지 않아도 insert 문이 동작하기에 다음과 같은 예제를 사용한다.아래의 경우 가령 james라는 키값과 barkely라는 키값에 unique 키가 걸려있고 해당 데이터가 이미 존재하는 경우 아래의 insert 문은 그냥 무시된다. example12ALTER TABLE person ADD UNIQUE INDEX (first_name, last_name)INSERT IGNORE INTO person VALUES (NULL, 15, &apos;James&apos;, &apos;Barkely&apos;)","link":"/2018/02/06/mysql-insert-문의-모든것/"},{"title":"Mysql 강의 04. mysql update 문의 모든것","text":"기본 구문1UPDATE 테이블명 SET 필드명 = &quot;바꿀 값&quot; WHERE 필드명= &quot;조건 값&quot; 특정 column 값을 increase 시키기123UPDATE mytable SET logins = logins + 1 WHERE id = 12","link":"/2018/02/06/mysql-update-문의-모든것/"},{"title":"1. mysql 시작하기","text":"Mysql 시작하기개요ubuntu 서버에 mysql 서버를 설치하고 환경을 설정하고 실제 운용까지 필요한 모든 내용을 담았다. 설치window아래와 같이 mysql-server를 설치해 준다.주의 할 점은 mysql 서버에 접근하기 위해서는 3306포트가 열려있어야 하는데 만약 서버 컴퓨터를 cafe24나 aws를 통해 만드는 경우 반드시 인바운드 규칙에서 3306포트를 추가시켜 주어야 한다. 123456sudo apt-get updatesudo apt-get install mysql-server // 이 과정에서 아이디랑 비밀번호를 물어본다.mysql_secure_installation //mysql 보안 설정을 세팅한다.systemctl status mysql.service //mysql이 실행되었는지 확인한다.sudo systemctl start mysql //mysql이 실행되고 있지 않다면 실행한다.mysqladmin -p -u root version // mysql을 관리할 수 있다 이경우 버전을 확인하는 명령어이다. macOS1234brew install mysql // 서버 설치하기mysql.server start // 실행하기mysql -u root // 로그인하기ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;password&apos; // 비밀번호 재설정하기 환경설정window먼저 다음 명령어를 통해 mysql 에 접속한다. 1mysql -u 사용자_이름 -p 비밀번호 mysql에 접속한 뒤 해야 할 첫번째는 바로 외부 접속이 가능한 계정을 만드는 것이다.본 계정을 통해 다른 컴퓨터에서 workbench 등의 프로그램을 통해 연결하여 db를 세팅하기 용이하다.다음 명령어를 통해 새로운 mysql 계정을 비밀번호와 함께 만들어 준다.1create user [user명]@&apos;%&apos; identified by &apos;패스워드&apos;; 위 계정으로 다른 컴퓨터에서 접근을 하면 권한이 없다는 말이 나타날 것이다.이는 바로 mysql server의 초기 세팅이 내부 ip 에서만 접근 가능하도록 세팅되어 있기 때문인데아래와 같은 방법으로 외부에서도 접근이 가능하게 바꾸어 준다. 먼저 mysql의 mysqld.cnf라는 설정파일을 vi 에디터로 열어준다.12Cd /etc/mysql/mysql.conf.dsudo vi mysqld.cnf bind-address =127.0.0.1 부분을 주석처리 후 아래의 명령어를 통해 mysql 서버를 재시작 시켜준다. 1sudo /etc/init.d/mysql restart 위 설정을 완료하였다면 생성한 계정이 데이터베이스에 대한 모든 권한을 가지도록 권한을 설정해 준다.아래는 권한을 설정하는 예제이다. 1grant all privileges on exampledb.* to admin@&apos;%&apos; identified by &apos;password&apos; with grant option; MYSQLADMIN 을 사용한 MYSQL 조작MYSQL 콘솔이 아닌 그냥 컴퓨터 커맨드 라인에서 MSYQL 콘솔에 접근하기 위한 훌륭한 명령어인 mysqladmin이 있으며 다음과 같이 사용합니다. 1mysqladmin -u _user_name_ -p _password_ CREATE DB_NAME 명령어 사용하기1mysqladmin -u _user_name_ -p _password_ -e &quot;_statement_&quot;","link":"/2017/01/14/mysql-시작하기/"},{"title":"6. mysql trigger의 활용","text":"trigger의 생성과 삭제1234567891011121314151617DROP TRIGGER IF EXISTS `sport`.`tr_update_gameresult`;CREATE TRIGGER `sport`.`tr_update_gameresult` BEFORE UPDATE ON sport.tb_gameFOR EACH ROWBEGIN -- 게임이 종료 되었는지 판단 IF NEW.COMP_CODE = &apos;3&apos; THEN SET @exception = (select EXPECATE from tb_reg_game where GAME_NO = NEW.GAME_NO); IF @exception = NEW.VIC_CODE THEN update tb_reg_game set `HIT_RESULT` = &apos;1&apos; where GAME_NO = NEW.GAME_NO; ELSE update tb_reg_game set `HIT_RESULT` = &apos;2&apos; where GAME_NO = NEW.GAME_NO; END IF; END IF;END; 새로 들어온 데이터 선택자 new와 기존에 있던 데이터 선택자 OLD새로 들어온 데이터를 new로 지칭하여 attribute를 뽑아서 사용할 수 있다.1update tb_group set MEMBER_NUM=@memberNum where GROUP_ID = new.GM_GROUP_ID; 특정 데이터 생성 혹은 삭제시에 상위 테이블의 전체 개수 인덱스 변경하기1234567891011create trigger trx_updates_atrigafter insert on trx_updates for each row begin&lt;!-- 트리거 동작에 필요한 변수 선언 --&gt;DECLARE memverNum INT; &lt;!-- 변수에 값 넣는 sql --&gt; set @memberNum = ( select count(*) from tb_group_member where GM_GROUP_ID=new.GM_GROUP_ID ); &lt;!-- 인덱스 변경 SQL --&gt; update tb_group set MEMBER_NUM=@memberNum where GROUP_ID = new.GM_GROUP_ID;end//","link":"/2018/02/22/mysql-trigger의-활용/"},{"title":"nodejs express를 활용한 정적 파일 제공","text":"정적 파일을 제공할 폴더 설정1app.use(express.static(&apos;public&apos;)); express.static을 활용하여 public 폴더를 정적 파일을 제공하기 위한 기본 폴더로 지정한다. 정적 파일 요청 양식12345localhost:3000/images/kitten.jpglocalhost:3000/css/style.csslocalhost:3000/js/app.jslocalhost:3000/images/bg.pnglocalhost:3000/hello.html 기본 폴더명인 public은 입력하지 않아도 된다. 참조","link":"/2017/11/22/nodejs-express를-활용한-정적-파일-제공/"},{"title":"nodejs mysql join 데이터를 간편하게  json으로 정제하기","text":"array.forEach 함수의 활용 받아온 rows를 forEach 함수를 사용하여 정체 array.forEach 함수의 활용forEach()는 오름차순으로 배열에 있는 각 요소에 대해 한 번씩 callback을 실행한다.삭제 또는 비초기화된 인덱스 속성에 대해서는 호출되지 않는다. callback은 다음 세 인수와 함께 호줄된다.요소 값, 요소 인덱스, 순회될 배열 받아온 rows를 forEach 함수를 사용하여 정체정제하는 함수123456789101112131415161718192021222324252627function(err,rows)&#123; var result = []; var indexObject = &#123;&#125;; if(err)&#123; console.log(err) &#125;else&#123; rows.forEach(function(row)&#123; &lt;!-- 해당 행의 id가 indexObject의 키값에 없을때 실행 --&gt; if(!(row.id in index))&#123; index[row.id]=&#123; id: row.id, name: row.name &#125;; &lt;!-- 반환값에 추가 --&gt; result.push(index[row.id]); &#125; 해당 행이 인덱스에 있건 없건 간에 해당 인덱스의 내역을 체워줌 index[row.id].histories.push(&#123; historyId:row.historyId, historyName:row.historyName &#125;); &#125;) console.log(result); &#125;&#125;","link":"/2017/11/27/nodejs-mysql-join-데이터를-간편하게-json으로-정제하기/"},{"title":"nestjs 시작하기","text":"nestjs 시작하기Installation12345678npm i -g @nestjs/clinest new project-namenest generate module users // generate modulenest g co users // generate controllernpm installnpm run start Controllersrequest를 받아 response를 반환하는 역할을 한다. decorator 를 사용하여 해당 하는 url로 routing을 할 수 있다. 123456789import &#123; Controller, Get &#125; from '@nestjs/common';@Controller('cats') //define urlexport class CatsController &#123; @Get() findAll() &#123; return 'This action returns all cats'; &#125;&#125; controller의 request와 response는 @Req()와 @Res() 를 통해 다음과 같이 사용될 수 있다. end point decorator 1234567891011121314import &#123; Controller, Get, Post &#125; from '@nestjs/common';@Controller('cats')export class CatsController &#123; @Post() create() &#123; return 'This action adds a new cat'; &#125; @Get() findAll() &#123; return 'This action returns all cats'; &#125;&#125; 위와 같이 @Post() 와 @Get() 등의 decorator를 통해 endpoint를 설정할 수 있다. Route parameters 12345@Get(':id')findOne(@Param() params) &#123; console.log(params.id); return `This action returns a #$&#123;params.id&#125; cat`;&#125; Async123456789@Get()async findAll(): Promise&lt;any[]&gt; &#123; return [];&#125;@Get()findAll(): Observable&lt;any[]&gt; &#123; return of([]);&#125;","link":"/2018/06/30/nestjs-시작하기/"},{"title":"node.js에서 jwt 로그인 구현하기","text":"기본 개념 JWT란? 토큰 데이터의 구조 준비사항 Work Flow Process 모듈 불러오기 jasonwebtoken으로 토큰 발급하기 토큰 복호화 하기 참조 기본 개념JWT란?Jason Web Token 토큰 데이터의 구조실제 토큰=&gt;1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0MTIzMTIzNTQzNTM0NTY3ODkwIiwibmFtZSI6IkpvaDM0NTM0NTM0NW4gRG9lIiwiYWRtaW4iOnRydWV9.gUpPTlD6M3F264lbRyXa6lat7t1tqoP3MHOwFX1qies 각 부분은 .를 기준으로 3 파트로 나뉜다. 첫번째 파트 =&gt; 서명키 생성 방식에 대한 정보 (header)12345&#123; &quot;alg&quot;:&quot;HS256&quot;, &quot;type&quot;:&quot;JWT&quot;&#125;=&gt; eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 두번째 파트 =&gt; 실제 데이터 정보 (payload)123456&#123; &quot;sub&quot;: &quot;1234123123543534567890&quot;, &quot;name&quot;: &quot;Joh345345345n Doe&quot;, &quot;admin&quot;: true&#125; =&gt; eyJzdWIiOiIxMjM0MTIzMTIzNTQzNTM0NTY3ODkwIiwibmFtZSI6IkpvaDM0NTM0NTM0NW4gRG9lIiwiYWRtaW4iOnRydWV9 세번째 파트 =&gt; 데이터에 대한 무결성 / 변조 방지를 위한 HMACHMACSHA256(base64UrlEncode(header) + “.” +base64UrlEncode(payload),ServerkeyData)=&gt; gUpPTlD6M3F264lbRyXa6lat7t1tqoP3MHOwFX1qies 준비사항 jsonwebtoken 설치npm install jsonwebtoken Work Flow 회원가입 요청 =&gt; 서버에 id와 password 전달 서버에서 받은 email을 토대로 중복여부 판별 중복되지 않았다면 db에 jwt토큰을 복호화 하기 위한 secret key를 저장(random generate) 위의 secret key를 db에 저장 사용자가 로그인 시도하면 해당 secret key를 검색하여 토큰을 복호화하여 전달한 토큰과 일치하는지 확인하여 토큰을 전달한다. 받은 토큰을 사용자는 로컬에 저장한다. Process모듈 불러오기const jwt = require(&#39;jsonwebtoken&#39;) jasonwebtoken으로 토큰 발급하기jwt.sign(payload, secret, options, [callback])만약에 callback 이 전달되면 비동기적으로 작동하며, 콜백함수의 파라미터는 (err, token) 입니다.전달되지 않을시엔 동기적으로 작동하며, JWT 를 문자열 형태로 리턴합니다.payload 는 객체, buffer, 혹은 문자열형태로 전달 될 수있습니다.secret 은 서명을 만들 때 사용되는 알고리즘에서 사용되는 문자열 혹은 buffer 형태의 값 입니다.1234var token = jwt.sign(payLoad,tokenKey,&#123; algorithm : &apos;HS256&apos;, //&quot;HS256&quot;, &quot;HS384&quot;, &quot;HS512&quot;, &quot;RS256&quot;, &quot;RS384&quot;, &quot;RS512&quot; default SHA256 expiresInMinutes : 1440 //expires in 24 hours&#125;); 토큰 복호화 하기12345678910111213141516var jwt = require(&apos;jsonwebtoken&apos;);var tokenKey = &quot;TEST_KEY11&quot;; //토큰키 서버에서 보관 중요var token = &apos;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1aWQiOjE0NTU0LCJpYXQiOjE0MzUxMzA4NzMsImV4cCI6MTQzNTIxNzI3M30.EWNUjnktCWxlqAAZW2bb0KCj5ftVjpDBocgv2OiypqM&apos;;//비동기처리jwt.verify(token,tokenKey,function(err,decoded)&#123; console.log(&quot;sync : &quot;, decoded);&#125;);//동기처리try &#123; var decoded = jwt.verify(token,tokenKey); console.log(&quot;async : &quot;, decoded);&#125; catch(err)&#123; console.log(err);&#125; 참조nodejs에서 jwt를 사용하기 위한 npm package를 설치하고 이용한다. NPM 참고자료","link":"/2018/01/14/nodejs-jwt-로그인-구현하기/"},{"title":"nodejs swagger api-doc 구현하기","text":"swagger-ui-express 설치하기1npm i swagger-ui-express package.json에 swagger-ui-express 추가하기1&quot;swagger-ui-express&quot;: &quot;latest&quot; // or desired version swagger js-doc 설치하기기존에 있던 js 파일에서 api를 따오기 위해 swagger jsdoc을 설치한다.1npm install swagger-jsdoc --save swagger-jsdoc 설정1234567891011121314var swaggerJSDoc = require(&apos;swagger-jsdoc&apos;);var options = &#123; swaggerDefinition: &#123; info: &#123; title: &apos;Hello World&apos;, // Title (required) version: &apos;1.0.0&apos;, // Version (required) &#125;, &#125;, apis: [&apos;./routes.js&apos;], // Path to the API docs&#125;;// Initialize swagger-jsdoc -&gt; returns validated swagger spec in json formatvar swaggerSpec = swaggerJSDoc(options); app.js 세팅하기123456const express = require(&apos;express&apos;);const app = express();const swaggerUi = require(&apos;swagger-ui-express&apos;);const swaggerSpec = swaggerJSDoc(options)app.use(&apos;/api-docs&apos;, swaggerUi.serve, swaggerUi.setup(swaggerSpec)); document the api12345678910111213141516171819202122232425/** * @swagger * /login: * post: * description: Login to the application * produces: * - application/json * parameters: * - name: username * description: Username to use for login. * in: formData * required: true * type: string * - name: password * description: User&apos;s password. * in: formData * required: true * type: string * responses: * 200: * description: login */app.post(&apos;/login&apos;, function(req, res) &#123; res.json(req.body);&#125;); Model Definition을 통한 재사용12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * @swagger * definitions: * NewUser: * type: object * required: * - username * - password * properties: * username: * type: string * password: * type: string * format: password * User: * allOf: * - $ref: &apos;#/definitions/NewUser&apos; * - required: * - id * - properties: * id: * type: integer * format: int64 *//** * @swagger * /users: * get: * description: Returns users * produces: * - application/json * responses: * 200: * description: users * schema: * type: array * items: * $ref: &apos;#/definitions/User&apos; */ app.get(&apos;/users&apos;, function(req, res) &#123; res.json([ &#123; id: 1, username: &apos;jsmith&apos;, &#125;, &#123;1 id: 2, username: &apos;jdoe&apos;, &#125; ]); &#125;); /** * @swagger * /users: * post: * description: Returns users * produces: * - application/json * parameters: * - name: user * description: User object * in: body * required: true * type: string * schema: * $ref: &apos;#/definitions/NewUser&apos; * responses: * 200: * description: users * schema: * $ref: &apos;#/definitions/User&apos; */ app.post(&apos;/users&apos;, function(req, res) &#123; // Generate ID req.body.id = Math.floor(Math.random() * 100) * 1 res.json(req.body); &#125;); swagger-ui-express 공식 문서swagger-jsdoc 공식 문서","link":"/2017/11/22/nodejs-swagger-api-doc-구현하기/"},{"title":"nodejs 페이스북 회원가입","text":"개요클라이언트에서 웹페이지의 버튼 클릭 등으로 이미 구축해 놓은 server의 url에 페이스북 토큰과 함께 로그인 요청을 보내면, 서버는 passport 모듈을 통해 받은 토큰을 facebook에 보내어 인증을 거치고 페이스북에서 거친 인증값을 담아 서버의 callback 라우터에 요청을 보낸다.서버는 요청을 받고 accessToken을 저장하며 accessToken과 유저정보들을 jwt 암호화를 거쳐 jwt를 발급하여 클라이언트에게 다시 보내어 준다.클라이언트는 받은 jwt를 localStorage에 저장하고 앞으로 자동 로그인시에 해당 jwt 토큰을 사용한다. passport 설치12npm install --save passportnpm install --save passport-facebook 모듈 import 하기123var NaverStrategy = require(&apos;passport-naver&apos;).Strategy;var FacebookStrategy = require(&apos;passport-facebook&apos;).Strategy;var KakaoStrategy = require(&apos;passport-kakao&apos;).Strategy; 필요한 모듈을 import 해준다. 개발자 정보를 비롯한 기밀 정보들 별도 파일에 저장123456789101112131415161718192021222324252627282930module.exports = &#123; &apos;secret&apos; : &apos;&apos;, &apos;db_info&apos;: &#123; local: &#123; // localhost ... &#125;, real: &#123; // real ... &#125;, dev: &#123; // dev ... &#125; &#125;, &apos;federation&apos; : &#123; &apos;naver&apos; : &#123; &apos;client_id&apos; : &apos;&apos;, &apos;secret_id&apos; : &apos;&apos;, &apos;callback_url&apos; : &apos;/auth/login/naver/callback&apos; &#125;, &apos;facebook&apos; : &#123; &apos;client_id&apos; : &apos;&apos;, &apos;secret_id&apos; : &apos;&apos;, &apos;callback_url&apos; : &apos;/auth/login/facebook/callback&apos; &#125;, &apos;kakao&apos; : &#123; &apos;client_id&apos; : &apos;&apos;, &apos;callback_url&apos; : &apos;/auth/login/kakao/callback&apos; &#125; &#125;&#125;; federation 객체에 네이버, 카카오, 페이스북 Developers 정보를 입력한다.secret.js 민감한 정보를 갖고있는 파일들은 프로젝트 디렉토리에 포함시키지 않는 것이 바람직하다. 서버코드 작성123456789101112131415161718192021222324252627282930313233343536373839404142var secret_config = require(&apos;../commons/secret&apos;); var secret_config = require(&apos;../_commons/secret&apos;); var FacebookStrategy = require(&apos;passport-facebook&apos;).Strategy; passport.serializeUser(function(user, done) &#123; done(null, user); &#125;); passport.deserializeUser(function(user, done) &#123; done(null, user); &#125;); passport.use(new FacebookStrategy(&#123; clientID: secret_config.federation.facebook.client_id, clientSecret: secret_config.federation.facebook.secret_id, callbackURL: secret_config.federation.facebook.callback_url, profileFields: [&apos;id&apos;, &apos;emails&apos;, &apos;name&apos;] //This &#125;, function (accessToken, refreshToken, profile, done)&#123; console.log(&quot;profile&quot;, profile); console.log(&quot;accessToken:&quot;, accessToken); var _profile = profile._json; loginByThirdparty(&#123; &apos;auth_type&apos;: &apos;facebook&apos;, &apos;auth_id&apos;: _profile.id, &apos;auth_name&apos;: _profile.first_name+&quot; &quot;+_profile.last_name, &apos;auth_email&apos;: _profile.email, &apos;auth_token&apos;: accessToken &#125;, done); &#125; )); router.get(&apos;/facebook&apos;, passport.authenticate(&apos;facebook&apos;,&#123;authType: &apos;rerequest&apos;, scope: [&apos;public_profile&apos;, &apos;email&apos;]&#125;) ) // facebook 로그인 연동 콜백 router.get(&apos;/facebook/callback&apos;, passport.authenticate(&apos;facebook&apos;,&#123;failureRedirect: &apos;/login/null/null&apos;&#125;),function(req,res)&#123; console.log(&quot;REQ&quot;,req); console.log(&quot;RES&quot;,res); res.redirect(&apos;http://localhost/login/&apos;+req.user.email+&quot;/&quot;+req.user.jwt) &#125; ); passport.use를 통해 OAuth 요청을 만들어서 네이버 로그인 처리를 진행하고 요청결과를 callback url로 라우팅 시켜줌을 설정한다.먼저 auth/login/facebook으로 요청이 오면 페이스북으로 로그인 요청을 보내고 결과값을 callback url로 보내준다.callback url을 처리하는 라우터는 로그인이 성공할 경우 인덱스 페이지로 리다이렉트 시켜주고 실패할 경우에는 다시 로그인 페이지로 리다이렉트 시켜준다.앵귤러의 경우 특정 페이지에 리다이렉트 되면 컴포넌트가 생성되는 시점에서 query의 뒷부분에 붙은 email 과 jwt를 가지고 jwt는 저장하고 email로 유저의 정보를 받아와 클라이언트에서 사용한다. /auth/facebook/callback은 페이스북이 검증을 마치고 난 결과를 전송해주는 주소이다. 서버의 로그인 함수 작성12345678910111213141516171819202122232425262728293031function loginByThirdparty(info, done) &#123; console.log(&apos;process : &apos; + info.auth_type); var stmt_duplicated = &apos;select *from `user` where `user_id` = ?&apos;; connection.query(stmt_duplicated, info.auth_id, function (err, result) &#123; if (err) &#123; return done(err); &#125; else &#123; if (result.length === 0) &#123; // 신규 유저는 회원 가입 이후 로그인 처리 var stmt_thridparty_signup = &apos;insert into `user` set `user_id`= ?, `nickname`= ?&apos;; connection.query(stmt_thridparty_signup, [info.auth_id, info.auth_name], function (err, result) &#123; if(err)&#123; return done(err); &#125;else&#123; done(null, &#123; &apos;user_id&apos;: info.auth_id, &apos;nickname&apos;: info.auth_name &#125;); &#125; &#125;); &#125; else &#123; //기존유저 로그인 처리 console.log(&apos;Old User&apos;); done(null, &#123; &apos;user_id&apos;: result[0].user_id, &apos;nickname&apos;: result[0].nickname &#125;); &#125; &#125; &#125;);&#125; auth.id 기반으로 신규 회원인지 기존 회원인지 판단한다.신규 회원일 경우에는 user 테이블에 회원 정보를 저장 시키고 로그인 처리를 진행하고, 기존 유저일 경우에는 쿼리로 조회한 회원정보를 기반으로 로그인 처리를 진행합니다.간단하게 말씀드리면 신규회원이든 기존 회원이든 원클릭으로 회원 가입 절차를 진행하게 할 수 있습니다.","link":"/2018/02/01/nodejs-페이스북-회원가입/"},{"title":"nodejs sequelize 사용하기","text":"nodejs 에서 sequelize 사용하기sequelize 에서 객체를 기반으로 데이터 입출력을 하기 위해 model을 정의한다. 설치하기1npm install -- save sequelize Connection 연결하기12345678910111213141516const Sequelize = require('sequelize');const sequelize = new Sequelize('database', 'username', 'password', &#123; host: 'localhost', dialect: 'mysql'|'sqlite'|'postgres'|'mssql', operatorsAliases: false, pool: &#123; max: 5, min: 0, acquire: 30000, idle: 10000 &#125;, // SQLite only// storage: 'path/to/database.sqlite'&#125; 모델 정의하기1234567891011121314151617const User = sequelize.define('user', &#123; firstName: &#123; type: Sequelize.STRING &#125;, lastName: &#123; type: Sequelize.STRING &#125;&#125;);// force: true will drop the table if it already existsUser.sync(&#123;force: true&#125;).then(() =&gt; &#123; // Table created return User.create(&#123; firstName: 'John', lastName: 'Hancock' &#125;);&#125;); query123User.findAll().then(users =&gt; &#123; console.log(users)&#125;)","link":"/2018/07/31/nodejs-sequelize-사용하기/"},{"title":"nodejs thumbnail 만들기","text":"개요 설치 서버 코드 default options reference 개요먼저 multiparty로 req를 받아 파일과 필드값으로 나누어 준 뒤에 노드 썸네일을 통해 변환을 해 준다. 설치1npm install node-thumbnail 서버 코드12345678910111213141516171819202122232425262728293031323334353637var multiparty = require(&apos;multiparty&apos;);var thumb = require(&apos;node-thumbnail&apos;).thumb;router.post(&apos;/thumbnail&apos;,function(req,res)&#123; console.log(&quot;썸네일 변경!&quot;); var form = new multiparty.Form(); form.parse(req,function(err,fields, files)&#123; if(err)&#123; console.log(err); &#125; Object.keys(fields).forEach(function(name) &#123; console.log(&apos;got field named &apos; + name); &#125;); console.log(&quot;files:&quot;, files); var fileName=fields.fileName[0]; var oldPath = files.imageFile[0].path; console.log(fileName); // 서버에서 돌리는 부분 var newPath = &apos;/root/imageServer/public/images&apos;; thumb(&#123; basename:fileName.split(&quot;.&quot;)[0], suffix:&apos;&apos;, source: oldPath, destination: newPath, width: 300 &#125;).then(function() &#123; console.log(&apos;Success&apos;); res.sendStatus(200) &#125;).catch(function(e) &#123; console.log(&apos;Error&apos;, e.toString()); res.sendStatus(500); &#125;); &#125;)&#125;) default options123456789101112131415defaults = &#123; prefix: &apos;&apos;, suffix: &apos;_thumb&apos;, digest: false, hashingType: &apos;sha1&apos;, // &apos;sha1&apos;, &apos;md5&apos;, &apos;sha256&apos;, &apos;sha512&apos; width: 800, concurrency: &lt;num of cpus&gt;, quiet: false, // if set to &apos;true&apos;, console.log status messages will be supressed overwrite: false, basename: undefined, // basename of the thumbnail. If unset, the name of the source file is used as basename. ignore: false, // Ignore unsupported files in &quot;dest&quot; logger: function(message) &#123; console.log(message); &#125;&#125;;","link":"/2017/12/08/nodejs에서-thumbnail-만들기/"},{"title":"rabbitmq 시작하기","text":"RabbitMQ 시작하기Installation on ubuntuubuntu 에 rabbitmq 를 설치하고 실제 동작시켜 보자. 본 글에서는 실제 ubuntu 피씨가 아닌 docker ubuntu image 를 사용하도록 한다. Ubuntu image 실행아래 명령어를 통해 도커 우분투 이미지를 실행하고 콘솔에 들어가도록 하자. 12docker pull ubuntudocker run -it ubuntu sudo 및 curl 설치기본 우분투 이미지에는 sudo 와 curl 명령어가 없기 때문에 아래 명령어를 통해 sudo 와 curl 을 설치해 준다. 123apt-get update&amp;&amp;apt-get install -y sudo &amp;&amp;apt-get -y install curl Erlang/OTP 다운로드Rabbitmq 를 내부적으로 erlang/otp 를 사용하기 때문에 적합한 버젼을 설치해 주어야 한다. 하지만 현재 erlang 버전은 너무 오래되었기 때문에 rabbitmq 팀에서 별도의 erlang 을 관리하고 배포하고 있는데 이를 설치하기 위해 다음과 같은 절차를 거친다. 먼저 apt-key 에 다음 키를 추가한다. 12apt-get install -y gnupg2 &amp;&amp;apt-key adv --keyserver \"hkps.pool.sks-keyservers.net\" --recv-keys \"0x6B73A36E6026DFCA\" 데비안 계열 운영체제가 레포지토리를 등록하기 위해서 다음 파일에 레포지토리를 등록해 주어야 한다. 이를 통해 apt-get 명령어가 해당 레포지토리를 찾고 패키지를 설치할 수 있다. /etc/apt/sources.list.d/bintray.erlang.list 파일에 1deb http://dl.bintray.com/rabbitmq-erlang/debian bionic erlang 를 추가하면 되며 아래와 같은 명령어를 통해 한번에 세팅할 수 있다. 12345cd /etc/apt/sources.list.d &amp;&amp;touch bintray.erlang.list &amp;&amp;echo &quot;deb http://dl.bintray.com/rabbitmq-erlang/debian bionic erlang&quot; &gt;&gt; bintray.erlang.list &amp;&amp;echo register finished! &amp;&amp;cat bintray.erlang.list 등록한 레포지토리를 설치해준다. 1apt-get update RabbitMQ 및 rabbitmq-server 설치12curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.deb.sh | sudo bash &amp;&amp; apt-get install -y rabbitmq-server Getting started서버 시작하기 123rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl start_app 큐 비우기 1sudo rabbitmqctl purge_queue queue_name Final dockerfile123456789101112131415161718192021222324252627282930FROM ubuntu# set working directoryWORKDIR /# update apt packagesRUN rm -rf /var/lib/apt/lists/*RUN apt-get update# install sudo and curl commandRUN apt-get install -y sudo &amp;&amp; apt-get -y install curl# register key for apt third party repositoryRUN apt-get install -y gnupg2RUN apt-key adv --keyserver \"hkps.pool.sks-keyservers.net\" --recv-keys \"0x6B73A36E6026DFCA\"# register repositoryRUN cd /etc/apt/sources.list.d &amp;&amp; touch bintray.erlang.list &amp;&amp; echo \"deb http://dl.bintray.com/rabbitmq-erlang/debian bionic erlang\" &gt;&gt; bintray.erlang.list &amp;&amp; echo register finished! &amp;&amp; cat bintray.erlang.list# install repositoryRUN apt-get updateRUN curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.deb.sh | sudo bashRUN apt-get install -y rabbitmq-serverEXPOSE 3001EXPOSE 5672EXPOSE 15672CMD [ \"rabbitmq-server\",\"start\" ]","link":"/2019/01/16/rabbitmq-시작하기/"},{"title":"react 시작하기","text":"React 시작하기React Create App 설치하기1npm install -g create-react-app React Create App 을 통해 프로젝트 생성하기1create-react-app react_boot_template --scripts-version=react-scripts-ts 개발 의존 모듈 설치하기1npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react react-hot-loader webpack webpack-dev-server 글로벌 모듈 설치하기1sudo npm install -g babel-cli 필요 디렉토리 만들기1mkdir server server/routes &amp;&amp; touch public/index.html server/main.js server/routes/posts.js src/App.js src/index.js webpack.dev.config.js webpack 설정하기1234567891011121314151617181920212223242526module.exports = &#123; // 가장 처음 읽을 스크립트파일 // 여기서부터 import 되어있는 다른 스크립트를 불러온다. entry: './src/index.js', // 파일을 합치고 ./public/bundle.js 에 저장한다. output: &#123; path: __dirname + '/public', filename: 'bundle.js' &#125;, // ES6 문법과 JSX 문법을 사용한다 module: &#123; loaders: [ &#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/, query: &#123; cacheDirectory: true, presets: ['es2015', 'react'] &#125; &#125; ] &#125;&#125;;","link":"/2018/07/25/react-시작하기/"},{"title":"scss 시작하기","text":"간략한 설명 기본 개념 간략한 설명scss 란 css로 변환하기 전의 일종의 마크업 랭귀지로 컴파일러(루비 기반)에 의해 css로 변환된다. 123brew install rubysudo gem install sasssass --watch input.style.scss:output.style.css 기본 개념기본 개념","link":"/2018/01/12/scss-시작하기/"},{"title":"react의 기본 개념","text":"react의 기본 개념react 란 정적인 html 페이지를 js 라는 스크립트 언어를 통해 동적으로 redering 하기 위한 라이브러리이다.react의 핵심은 단순히 browser라는 환경이 아닌 많은 환경에서 html 페이지를 렌더링 할 수 있게 하여 보다 다양한 환경에 쉽게 rendering 될 수 있는 페이지를 만드는 것이다. js 는 일반적으로 DOM API 를 통해 화면을 렌더링 하는데 흔히 document.createElement 와 같은 명령어들이 대표적이 예이다. 우리는 react가 제공하는 함수들을 통해 렌더링을 제어하며 react 는 우리를 대신하여 효율적으로 DOM APU 를 컨트롤 하여 매우 효과적으로 렌더링을 제어한다. 우리는 react가 제공하는 virtual dom 환경을 통해 렌더링을 조작하며, 이러한 virtual dom 을 사실 단순한 javascript object에 불과하다. DOM Rendering리액트는 매우 효율적으로 DOM API 를 통해 렌더링을 수행하며, 대표적으로 페이지를 리 렌더링하는 시점에 바뀐 부분과 바뀌지 않은 부분들을 파악하여 반드시 필요한 부분에 대해서만 rerendering을 수행하게 되므로 브라우저의 한정된 자원을 효율적으로 사용하여 클라이언트 효율을 올려준다. React Elemnt and Componentreact는 DOM API 의 element에 매칭되는 독자적인 element를 가지며 이는 js object이다.이러한 element 및 component들은 직관적으로 html element 를 조작하는 것과 같은 환경을 제공해 준다. React with JSXfacebook 은 보다 직관적인 html 작성을 위해 jsx라는 독자적인 언어를 만들었으며, 이를 통해 우리는 마치 html을 작성하는 것과 같은 환경에서 react 의 virtual dom을 제어할 수 있게 되었다. Webpack Loader여기서 load란 build 과정에서 우리가 작성한 코드를 브라우저가 읽을 수 있도록 변형해주는 것을 의미한다. webpack은 다양한 환경에서 동작하기 위해 막대한 양의 loader 들을 가지고 있으며, 적절한 변환을 위해 우리는 webpack.config.js 파일을 작성하여 webpack에게 어떤 내용을 변형시켜 줄 지를 말해준다. 대표적인 loader 로는 ES6 과 React 분법을 ES5 로 변형시켜 주는 babel-loader와 scss 언어를 css 로 변형시켜주는 css-loader가 있다. webpack 설치하기webpack 설치하기 sudo npm install -g webpack loader 설치하기 npm install babel-core babel-loader babel-preset-env babel-preset-react babel-preset-stage-0 --save-dev webpack 설정하기1234567891011121314151617181920212223// Example 5-20. webpack.config.jsmodule.exports = &#123; entry: \"./src/index.js\", //define client entry file output: &#123; path: \"dist/assets\", //export bundler to the dist foler filename: \"bundle.js\" &#125;, devtool: '#source-map', // source mapping - should be after output module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /(node_modules)/, loader: ['babel-loader'], query: &#123; presets: ['env', 'stage-0', 'react'] &#125; &#125; ] &#125;, plugins: [ // uglify plugin new webpack.optimize.UglifyJsPlugin(&#123; sourceMap: true, warnings: false, mangle: true &#125;) ]&#125; uglify번들링 되는 파일의 용량을 줄이기 위해 웹팩은 띄어쓰기, 변수명 축약 등의 작업을 수행하는 플러그인을 내포하고 있으며, 이를 사용하기 위해서는 다음 명령어를 통해 webpack을 로컬로 설치해야한다. npm install webpack --save-dev create react app위와 같은 웹팩 설정 등의 여타 작업들을 수행하는 것은 상당히 성가신 일이다. facebook은 개발자들이 빠르게 설정을 완료할 수 있도록 cli 환경을 만들어 두었으며, create-react-app 을 통해 간편하게 리액트를 시작할 수 있다.create-react-app 은 transpile 과 uglify 등 webpack 이 수행하는 여타의 작업들을 모두 끝내주기 때문에 가볍게 react 개발을 시작할 수 있다.","link":"/2018/07/28/react의-기본-개념/"},{"title":"Setup Nodejs in ubuntu","text":"Setup1sudo apt-get install build-essential","link":"/2019/03/28/setup-nodejs-in-ubuntu/"},{"title":"npm 시작하기","text":"npm 시작하기package.json 의 항목들 최신버전으로 업데이트하기123npm i -g npm-check-updatesnpm-check-updates -unpm install","link":"/2018/01/22/npm-시작하기/"},{"title":"VS Code Debugging 시작하기","text":"VS Code Debugging 시작하기vs code 에서 디버깅을 함에 있어 Launch 와 Attach 모드가 존재한다. 우리는 .vscode 의 launch.json 설정파일을 수정함으로써 디버거를 attach 하시 전에 디버그 모드에서 어떻게 앱을 실행할지를 알려주는 것이다.","link":"/2019/01/15/vs-code-debugging-시작하기/"},{"title":"sql cookbook","text":"INSERT존재하지 않는 것만 추가하기12345INSERT INTO &lt;TABLE&gt; (&lt;COLUMN1&gt;, &lt;COLUMN2&gt;) VALUES (&lt;VALUE1&gt;, &lt;VALUE2&gt;) WHERE NOT EXISTS ( SELECT &lt;COLUMN&gt; FROM &lt;TABLE2&gt; WHERE id=&lt;value&gt; ) SELECTLIKE1SELECT * FROM &lt;table_name&gt; WHERE &lt;COLUMN&gt; LIKE \"%&lt;CONTENT&gt;%\"; ORDER BY1SELECT * FROM &lt;TABLE_NAME&gt; WHERE &lt;CONDITION&gt; ORDER BY &lt;COLUMN1&gt; DESC, &lt;COLUMN2&gt; ASC LIMIT1SELECT * FROM &lt;TABLE&gt; LIMIT &lt;INDEX&gt;, &lt;NUMBER&gt; GROUP BY1234SELECT u.name, MAX(c.price)FROM user u LEFT JOIN car c ON u.id = c.user_idWHERE u.id = 4;GROUP BY u.name PROBLEM SOLVINGwhere 절 없이 업데이트 실패하는 경우1SET SQL_SAFE_UPDATES = 0;","link":"/2019/05/19/sql-cookbook/"},{"title":"vue 시작하기","text":"Vue 시작하기vue 란 무엇인가vue.js 란 user interface를 구축하기 위한 혁신적인 프레임워크 입니다.다른 프론트엔드 라이브러리가 큰 규모로 매우 조직적이고 짜임새있는 프레임웍을 추구하는 반면 vue 는 기존의 프로젝트에 매우 쉽게 적용 가능한 유연성을 가진 프레임워크로 각광받고 있습니다. vue 설치하기cdnvue는 다음과 같이 cdn을 통해 가볍게 시작할 수 있습니다. 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js\"&gt;&lt;/script&gt; npm1npm install vue How does vue works?Vue instance 는 순수한 자바스크립트 객체이며 vue 에서의 데이터 바인딩은 vue instance 의 루트 프로퍼티로 할당된다. 즉, 인스턴스가 생성된 이후에 뷰에 프로퍼티를 추가하게되면 이는 트래킹 되지 않는다 그렇다면 어떻게 뷰는 데이터의 실시간 변경사항을 화면에 반영하는 것일까? Vue instance 에 등록된 데이터가 변경되면 이는 내부적으로 작업큐에 들어가고 뷰의 다음 tick에 동작하게 된다. 여기서 틱이란 뷰가 데이터의 변화를 감지하고 화면을 다시 렌더링 하는 주기로 쉽게 말하면 일정 시간 간격으로 데이터의 변화를 체크하여 화면을 다시 렌더링 하는 것이다. 때문에 매우 적은 시간간격으로 데이터가 변경되면 즉, 한번의 틱 내에 같은 데이터가 여러번 변화된다면 vue는 최종으로 변화된 것만 큐에 저장하고 다시 rendering 하기 때문에 화면은 한번만 렌더링 되게 된다. 이 경우에는 뷰 인스턴스의 nexttick같은 함수를 사용하여 바로 다음 틱에 적용되도록 할 수있다 vue 의 compile만약 vue-loader혹은 vueify를 사용한다면 *.vue 파일은 빌드 시점에 js 파일로 precompile 됩니다.다음의 webpack 의 vue loader를 통해 pre compile을 하는 방법입니다. vue 파일은 html 과 같은 문법을 사용하여 vue 컴포넌트를 작성하며 3가지 유형의 최상위 language block 인 , , 로 이루어집니다. vue-loader는 파일을 파싱하고 각 language block을 추출하며 필요한 경우 다른 로더를 통해 파이프 처리한 후 마지막으로 Module.exports가 Vue.js 컴포넌트 엘리먼트 옵션 객체인 CommonJS 모듈로 다시 조합합니다. vue-loader는 language block에 lang 속성을 지정하여 CSS 전처리기나 HTML에서 템플릿을 컴파일 하는 것과 같은 기본 언어가 아닌 것을 사용할 수 있게 합니다. 예를 들어 컴포넌트 스타일에 Sass를 사용할 수 있습니다. 123&lt;style lang=\"sass\"&gt; /* write Sass! */&lt;/style&gt; vue 싱글파일 컴포넌트 사용하기*.vue 컴포넌트를 여러개로 나누고 싶으면 src 속성을 사용해 language block을 위한 외부 파일을 가져올 수 있습니다. 123&lt;template src=\"./template.html\"&gt;&lt;/template&gt;&lt;style src=\"./style.css\"&gt;&lt;/style&gt;&lt;script src=\"./script.js\"&gt;&lt;/script&gt; component 생성시 실행되는 함수Problem SolvingVue Rendering problemSA 프로젝트를 진행하다가, 뷰의 데이터를 매우 빠르게 변화시키는 경우 뷰 인스턴스가 이 속도를 따라가지 못하고 마지막 데이터만 렌더링 하는 문제가 발생하였다. 그 원인을 파악하던 중 먼저 뷰가 데이터의 변화를 어떻게 감지하고 화면을 렌더링하는지 부터 살펴보고자 한다. Vue instance 는 순수한 자바스크립트 객체이며 vue 에서의 데이터 바인딩은 vue instance 의 루트 프로퍼티로 할당된다. 즉, 인스턴스가 생성된 이후에 뷰에 프로퍼티를 추가하게되면 이는 트래킹 되지 않는다 그렇다면 어떻게 뷰는 데이터의 실시간 변경사항을 화면에 반영하는 것일까? Vue instance 에 등록된 데이터가 변경되면 이는 내부적으로 작업큐에 들어가고 뷰의 다음 tick에 동작하게 된다. 여기서 틱이란 뷰가 데이터의 변화를 감지하고 화면을 다시 렌더링 하는 주기로 쉽게 말하면 일정 시간 간격으로 데이터의 변화를 체크하여 화면을 다시 렌더링 하는 것이다. 때문에 매우 적은 시간간격으로 데이터가 변경되면 즉, 한번의 틱 내에 같은 데이터가 여러번 변화된다면 vue는 최종으로 변화된 것만 큐에 저장하고 다시 rendering 하기 때문에 화면은 한번만 렌더링 되게 된다. 결론은 데이터가 매우 빠르게 변하여 뷰가 데이터를 체크하고 렌더링 하는 한번의 틱 내에 같은 데이터가 빠르게 여러번 바뀐다면 뷰는 작업 큐에 최종 데이터의 변화만을 기록하기 때문에 화면은 한번만 렌더링 된다. 이 경우에는 뷰 인스턴스의 nexttick같은 함수를 사용하여 데이터가 변화되면 바로 다음 틱에 적용되도록 할 수있다 좀더 직관적이고 간편한 해결방법은 특정 데이터를 변화하면 timeout 함수를 통해 약간 천천히 뷰의 데이터를 변화시키는 방법도 고려할 수 있다.","link":"/2018/08/03/vue-시작하기/"},{"title":"webpack 시작하기","text":"Webpack 시작하기설치하기npm install webpack webpack-cli --save webpack 이란 무엇이며 왜 사용하는가웹개발을 하면서 수많은 파일에 수많은 코드를 작성하게 된다. 하지만, 코드를 배포하기 위해서는 최대한 작은 용량으로 파일을 배포해야 하며 이를 위해 우리는 minify 혹은 uglify 등을 통해 파일을 작은 용량으로 압축해서 배포한다.이 과정은 상당히 번거로우며 수많은 파일들을 하나의 파일로 만들 수 없을 뿐 아니라 모든 파일마다 압축을 수행해야 하는 단점이 존재한다. 또한 단순 js 파일 뿐 아니라 css, scss, png, jpg 등 다양한 스타일링 및 static asset들을 포함하면 그 양은 매우 막대한 양이 아닐 수 없으며, compile 이 필요한 다양한 framework 이 만들어 내는 수많은 자동생성 파일들을 올바르게 배포하는 것은 여간 어려운 일이 아니다. webpack은 점차 복잡해져가는 개발 환경에서 발생하는 복잡한 상관관계를 모두 합쳐 단 하나의 파일로 bundle시켜주는 module bundler 이며 많은 framework들이 이를 차용하고 있다. 다음은 webpack 공식 홈페이지에서 제공하는 예제코드이며 몇줄의 코드를 통해 webpack이 어떤 역할을 하는지 단번에 이해할 수 있다. src/index.js 123import bar from './bar'bar(); src/bar.js 123export default function bar()&#123; //&#125; webpack 설정 파일 webpack.config.js 123456789const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125;; page.html 12345678910&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; ... &lt;/head&gt; &lt;body&gt; ... &lt;script src=\"dist/bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 위처럼 여러개의 js 파일을 하나로 bundle 하여 단 하나의 js 파일만을 import 할 수 있게 된다. 기본 개념webpack은 내부적으로 프로젝트 내의 상관 관계를 graph 로 작성하여 번들링을 진행한다. entrywebpack 이 번들링을 시작할 파일이며, 모든 상관관계가 이 파일로 부터 시작된다. 흔히 project의 index.js 파일에 비유될 수 있다. example 123module.exports = &#123; entry: './path/to/my/entry/file.js'&#125;; outputoutput 은 webpack에게 생성된 bundle 을 어디에 위치시킬 지 가르쳐 준다.초기 설정은 ./dist 로 되어 있으며 main.js 파일을 생성시킨다. loaders =&gt; moduleswebpack은 오직 js 파일만을 식별이 가능하지만, bundling을 진행하기 위해서는 다양한 파일 형식을 load 할 수 있어야 하는데 이것은 loader의 도움을 받아 처리될 수 있다.가령 babel-loader 와 같이 typescript 를 transpiling 을 담당하는 것들이 있다. 1234567891011module.exports = &#123; output: &#123; filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; ] &#125;&#125;; 여기서 test는 어떤 파일을 읽어들일지를 말해주며, use 는 어떤 loader를 사용하여 읽어들일 지를 결정한다. pluginsmodule이 특정 형식의 모듈을 변형시키는 데에 사용되는 반면, plugin은 bundling optimization 등 보다 넓은 범위의 태스크를 처리한다. 12345678910111213const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npmconst webpack = require('webpack'); //to access built-in pluginsmodule.exports = &#123; module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;; 여러개의 플러그인을 array 형태로 추가할 수 있으며, 반드시 new keyword 를 통해 인스턴스를 생성해서 넣어주어야 한다. modemode parameter 는 어떤 모드로 bundling 을 진행할지를 알려준다.develop, production 등의 모드가 있으며 기본 값은 production 이다. babel-loader 사용하기babel loader 설치하기1npm install --save-dev babel-loader babel-core webpack 설정하기webpack.config.js 123456789101112131415module: &#123; rules: [ // babel loader &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['babel-preset-env'] &#125; &#125; &#125; ]&#125;, babelrc 설정하기1sudo npm install babel-preset-env --save babelrc.js 123&#123; \"presets\": [\"env\"]&#125; vue-loader 설정하기1sudo npm i css-loader --save webpack.config.js 123456789101112131415161718192021222324252627module: &#123; rules: [ &#123; test: /\\.vue$/, use: 'vue-loader' &#125;, // this will apply to both plain `.css` files // AND `&lt;style&gt;` blocks in `.vue` files &#123; test: /\\.css$/, use: [ 'vue-style-loader', 'css-loader' ] &#125; &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['babel-preset-env'] &#125; &#125; &#125;, ],&#125;, 실행하기1webpack-cli --config webpack.config.js","link":"/2018/08/02/webpack-시작하기/"},{"title":"What is the RESTful API","text":"What is the RESTful APIRest API 란 WWW 과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식으로 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반에 대한 패턴이다. 좀 더 쉽게 말하자면, REST API 란 인터넷이라는 정보의 바다에서 정보를 주고받는 활동을 인터넷에 있는 자원과 자원의 위치를 명시 하는 일종의 방법론이자 아키텍처이다. API 설계의 핵심은 자원을 사용하는 것이고 HTTP method 를 통해 자원을 처리하는 양식을 일컷는다. Characteristics of REST API Uniform InterfaceURI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행합니다.이는 REST API 의 핵심이며, 자원과 자원에 대한 행위(HTTP method) 를 명확히 구분하고 준수합니다. StatelessREST 는 상태를 가지지 않습니다. 즉, 작업을 위한 상태 정보를 저장하고 관리하지 않기에 서버는 들어오는 요청만 단순히 처리하면 됩니다. 이를 통해 구현이 간편해 집니다. CacheableHTTP라는 기존 웹표준을 그대로 사용하기 때문에, Http가 가진 캐싱 기능을 사용할 수 있습니다. Self descriptivenessREST API uri 만 보고도 이를 쉽게 이해할 수 있는 자체 표현구조로 되어있습니다. Client-Server 구조자원을 제공자인 Server 와 사용자인 Client 가 명확히 구분되기에 의존성이 없습니다. 계층형 구조REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다. How to design RESTful APIREST API 설계시 가장 중요한 항목은 다음 두가지로 요약할 수 있습니다. URI 는 정보의 자원을 표현해야 한다. 자원에 대한 행위는 HTTP method 로 표현한다. 즉, URI 는 어떤 자원을 사용할지에 대한","link":"/2019/03/28/what-is-the-restful-api/"},{"title":"논어에서 배우다 01. 배움의 자세","text":"공자께서 말씀하셨다. “배우고 때때로 그것을 익히면 또한 기쁘지 않은가? 벗이 먼 곳에서 찾아오면 또한 즐겁지 않은가? 남이 알아주지 않아도 성내지 않는다면 또한 군자답지 않은가?” 위 글귀는 논어의 [학이]편에 나오는 글귀입니다. 요즘 세상을 살아가면서 우리는 매일매일 새로운 것을 배워야만 합니다. 기술을 빠르게 발전하고 조금이라도 주춤하면 언젠가는 세상에서 도태될 질 모른다는 두려움을 가지기도 합니다. 이런 요즘 세상에서 우리는 배움에 대한 의심을 품게 됩니다. 배움이란 세상에서 살아남기 위해 또 다른 사람과의 경쟁에서 승리하기 위해 해야만 한다는 무릇 잘못된 생각을 하게 됩니다. 공자는 배움이란 즐거움이라고 말합니다. 우리가 배우고 익힌다는 것은 즐거운 일이고 이를 즐겁게 여기는 것이 군자의 덕목이라고 말합니다. 훌륭한 사람이라면 배움을 즐길줄 알아야 한다는 것이지요. 또한, 공자는 “때때로 그것을 익힌다” 는 말에서 우리가 배운 것을 몸소 활용하고 몸에 익히고 배운것을 항상 실생활에서 적용할 기회가 있을 때마다 수시로 반복하여 익히는 것이 필요하다고 말하며 학문의 실용적 측면을 강조합니다.저는 특히 이 구절이 와닿았습니다. 20년이 넘는 세월 대학을 졸업하면서 까지 정말 하루하루 배움의 연속이었지만 사실 학교를 다니면서 배운것을 익힐 시간은 많이 없었던 것 같습니다. 시험을 위해, 남들보다 더 좋은 실력을 가지고 있음을 증명하기 위해 공부를 해왔던 제 자신을 돌아보게 되는 문단이지요. 공대생으로써 공학을 배워 새로운 제품 혹은 개선방안을 찾기위해 노력하고, 경제와 철학을 배웠다면 배운 내용을 말미암아 보다 통찰을 가지고 세상을 바라보았어야 하지 않나라는 생각이 듭니다.이 글도 또한 같은 맥락에서 적게 된 것이지요, 내가 논어를 통해 좋은 글귀를 읽고 배움을 얻었다면 이를 내 삶과 인생에 접목시켜보는 것이 반드시 필요하다라는 좋은 교훈을 얻은 것 같습니다. 위 글의 마지막 문장은 요즘 우리 세상 또 저 자신에게 큰 교훈을 줍니다. 항상 시험을 보면 좋은 학점을 받았다는 사실을 과시하고 싶고, 내가 공부를 열심히 했는데도 낮은 학점을 받으면 나는 더 나은 사람인데 이정도 밖에 인정받지 못했다고 혼자 주제넘는 생각을 하기도 한 옛날을 제 모습을 많이 반성합니다. 이 글을 읽는 독자분들은 배움에 어떤 태도를 지니고 계신가요? 혹 배움을 살아남기 위한 수단으로 남에게 인정받기 위한 수단으로 생각된 적은 없으셨나요? 이 글을 통해 좀 더 넉넉한 마음으로 배움에 임할 수 있는 하루가 되었으면 합니다 ^^","link":"/2018/05/09/z_논어에서-배우다-01/"},{"title":"What is the object oriented programming","text":"What is the object oriented programming객체지향 프로그래밍 이란 그 이전의 프로그래밍이 컴퓨터가 하는 동작 즉, 명령 단위의 프로그래밍을 벗어나 인간이 사고하는 방식 그대로를 표현할 수 있는 방식으로 프로그래밍을 하는 프로그래밍 패러다임을 의미한다. 객체지향 프로그래밍 에서는 실제 생활의 행동과 사물 그대로를 프로그램 상에서 표현하며 모든 프로그래밍은 이러한 ‘객체’ 를 기반으로 움직이게 된다. 여기서 객체라 하면 속성(attributes) 과 행위(method)를 가지는 일종의 데이터이다. 이러한 객체지향 프로그래밍에서는 코드 재사용성과 확장성을 위해 상속(inheritance) 이라는 개념이 존재하는데, 이는 class 와 prototype 의 형태로 나타난다. 먼저 class based language 에서는 object 보다 항상 class 가 먼저 정의되어야 하며, object 는 이러한 class 를 통해 생성된다. Class 를 통해 instantiate 된 객체를 instance 라고 하며, 이렇게 생성된 instance 는 class 의 속성에 따라 일관된 방식으로 통제될 수 있다. 이러한 class based language 에서는 특정 class 를 inherit 하여 코드 재사용성과 확장성을 늘릴 수 있는데, 이렇게 상위 class 를 inherit 받아 새로운 class 가 생성되면, 상위 class 를 super class 상속받은 클래스를 subclass 라고 부른다. prototype-based language 에서는 class 라는 개념이 없으며, prototype 이라는 개념을 통해 object 자체를 복사하고 확장한다. 가령 javascript 와 같은 언어들이 이러한 갈래에 속하지만 시간이 지남에 따라 javascript 에서도 class 를 지원하면서 그 성격이 변화하고 있다. 이러한 객체지향 프로그래밍의 장점은 재사용성이 매우 높다는 것이다, 특정 객체가 수행하는 역할과 특성을 명확하게 규정해 놓으면 다른 개발자들은 해당 객체를 간편하게 가져다 쓸 수 있다. 이는 프로그램의 기능인 도메인 단위로 객체들이 잘 나뉘어 있기 때문이며, 가령 함수의 이름이나 클래스의 이름만으로도 해당 객체의 특성을 손쉽게 유추하고 사용할 수 있는 특성이 있다. 하지만, 이러한 OOP 에도 단점이 존재하는데, 아는 procedural program 에 비해 코드라인이 길고 특정 기능을 수행하기 위해 많은 명령어가 수행되기 때문에 상대적으로 성능이 좋지 않은 부분이 있다. 또한, 각 개체가 저마다의 상태를 가지기 때문에, 예상치 못한 상태의 불일치로 예측할 수 없는 상태를 가지게 되는 경우가 있어 어플리케이션 내부에서 버그를 가지는 경우가 있다. 이를 해결하기 위한 방안으로 functional programming 이 대두되고 있는데, 그 핵심은 바로 모든 기능을 수학적 함수로 계산하는 것으로 취급하여 최대한 상태변화 혹은 mutable data 를 변경하지 않는 것을 원칙으로 한다. 가령, 함수형 프로그래밍 에서는 pure function 이란 개념을 매우 중요하게 여기는 데 이는 같은 입력값을 주면 항상 같은 결과가 나오는 함수로 전역 변수나 혹은 특정 시스템의 상태에 좌우되지 않는 pure 한 함수를 의미하고 이러한 pure function 은 시스템의 안정성을 높여주는 핵심적인 역할을 한다.","link":"/2019/03/28/what-is-the-object-oriented-programming/"},{"title":"typescript 시작하기","text":"##","link":"/2019/01/18/typescript-시작하기/"},{"title":"루소의 사회계약론, 사회의 권위는 어떻게 생겨나는가?","text":"루소의 [사회계약론]은 밖으로 표출된 정치 현실의 차원에서 문제를 제기하는 대신 정치적 질서의 기반, 다시 말해 그것의 배후의 메커니즘에 대한 원리적 접근을 시도하며, 나아가 정치적 권력 또는 권위의 정당성은 어떻게 획득되는가를 다루고 있다. 루소는 ‘폭력’이 최초의 노예를 만들어 내었고, 그 노예들의 비열함이 노예상태를 영속시킨다고 보았다.사람은 사실 인간이기 이전에 동물로써 힘에 굴복하는 것은 어떻게 보면 불가피한 행위이기에 강한자가 약한자를 노예로 삼는 것을 막을 방법 따위는 없었다. 그것이 ‘자연의 법칙’ 이었고, 모든 생물학적 생태계의 ‘약육강식’의 법칙을 따르는 자연스러운 일이었다. 또, 약한자가 비열함을 벗어내는 방법은 목숨을 담보로한 도전 밖에 없었으며, 대부분의 경우는 죽음으로 귀결되었기에 노예상태는 영속되었다. 하지만, ‘힘과 권위’ 라는 것은 사실 시간이 지나면 사라지게 되는 것이고, 과거의 강한 힘을 가진 사람들도 늙고 노쇠해짐에 따라 과거의 모든 영광은 뒤로하고 냉혹한 자연의 질서에 굴복되어 버리기에, 대부분의 사람들은 대체로 좋은 결말을 맞이할 수 없는것이 현실이었다. 이렇게 시간이 지남에 따라 사람들은 이렇게 무자비한 ‘동물의 법칙’을 벗어나 상호간의 약속을 통해 삶의 질을 올릴 수 있는 방법을 찾게 되었고, 여기서 최초의 ‘사회 계약’ 이 이루어 지게 되었고, 공동체 라는 개념이 생겨나게 되었다. 공동체를 구성하는 각 구성원의 신체와 재산을 방어하고 ‘인간다운 삶’을 보장받기 위해 서로와 서로 사이에 계약을 하게 되고, 이를 통해 ‘공공의 힘’을 가지게 되어 각 개인은 그러한 ‘공공의 힘’으로 부터 보호 받고 자기 자신의 의지에 따라 한 ‘계약’ 에게만 복종함으로써 각 개인은 타인에게 복종을 하지 않는 자유로운 삶을 보장받을 수 있게 되었다. 즉, 과거처럼 ‘힘’에 의해 누군가의 노예가 되지 않을 수 있고, 자신이 혼자서 생존하기 어려운 많은 제약 속에서도 최소한의 인간적인 삶을 보장받게 되었으며, 이러한 공동체의 구성원들의 집합적인 의미로 국민, 주권에 참여하는 개인이라는 뜻에서 시민, 국가의 법률에 종속된다는 의미로 신민 이라는 용어들이 생겨나게 되었다. 사회의 계약이 강화됨에 따라 개인적인 인격은 사라지고, 이 결합행위는 하나의 집합적인 법인체 즉, 도시국가, 공화국을 만들게 된다.이렇게 다수가 결합하여 한 단체를 이루면 누구도 그 단체를 공격하기 전에는 한 사람의 구성원도 해칠 수 없기에 각 구성원은 완벽한 동맹을 이루게 되고, 이런 굳건한 동맹관계가 원활히 수행되기 위해서는 각 개인이 지켜야할 많은 것들이 있었으며, 이에 따라 각 개인의 ‘자연적 신분’에서 ‘시민’ 으로 이행되었다. 이 과정에서 과거에는 볼 수 없었던 도덕성 을 부여되었고, 이는 사회적으로 큰 변화의 시작이었다. 오늘날 대부분의 사람들이 인간이라면 태어날 때 부터 당연하게 여겨질 것이라 생각되는 이 도덕성 은 사실 인류가 모두 비극적인 결말을 맞이하지 않기 위한 서로간의 약속이자 비자연적이고 인위적인 단지 하나의 규약 에 불과하였으나, 오늘날에는 사회의 탄탄한 기반으로 거듭났고, 이는 사회 계약 의 기본적인 토대로써 다음과 같은 목적성을 가지게 된다. 자연적 평등을 파괴하는 것이 아니라 반대로 인간들 사이에 자연적으로 생겨날 수 있는 육체적 불평등을 도덕적이고 합법적인 평등으로 대치한다는 것,그리고 인간은 체력 또는 재능에 있어 불평등할 수 있는 만큼 계약에 의해 그리고 법으로써 모두가 평등하게 된다. 이렇게 사회 계약론은 모두에게 이득이 되는 최고의 계약이라 생각될 수 있지만, 그 이면에는 다양한 문제들이 존재한다. 사실 과거의 생태계에서 가진자와 가지지 못한 자의는 그렇게 크지 않았으며, 그 이유는 역설적이게도 ‘약육강식’의 법칙이 존재했기 때문이다.동물은 시간이 지나면 자연스럽게 쇠퇴하게 되고 과거 가지지 못했던 자는 ‘무력’을 통해 때로는 ‘약탈’ 과 ‘살해’를 통해 가진자의 재산을 빼앗아 올 수 있었다.또, 무리에서 도태되거나 약자인 개체는 때로는 무리에 의해 강제로 살해되기도 하고 스스로 경쟁력이 가지지 못하는 개체를 과감히 제거함으로써 사회 전체의 생산성을 유지하고 살벌한 긴장속에서 살아 나갔다. 하지만, 현대 사회의 ‘사회 계약’을 대변하는 ‘법’은 실제로 항상 유산자에게는 유익하고 무산자에게는 해로울 수 밖에 없다.애초에 이 계약이란 개인이 가진 재산을 타인으로 부터 보호하기 위함이며 누군가의 범법행위가 이루어지지 않는 이상 개인이 가진 재산은 그 사람의 힘과 재능에 관계없이 오랜 시간이 지나도 유지될 수 있다. 이 재산은 세습이라는 형태로 계속해서 누적될 수 있지만, 가진게 없고 지킬게 없는 사람들에게 ‘약탈’ 과 ‘탈취’ 를 막는 ‘법률’은 사실 큰 도움이 되지 못하는 것이 현실이기 때문이다. 오늘날 민주 사회에서 이런 ‘사회 계약’의 이면은 충분히 극복될 수 있으며, 이는 무산자에게 유산자가 될 수 있는 동등한 기회를 제공함과, 사회 계약을 유지하기 위한 유산자의 사회적 기여를 강화함으로써 실현되고 있다. ‘유산자’ 는 우리의 공동체가 자신의 재산을 지켜주고 과거 야생에서 시간이 지남에 따라 잔혹한 결말을 맞이하지 않게 해 주는 것에 대한 감사와 시민으로써의 책임감을 가져야 하며, 누구보다 체제를 지켜나가고 무산자와의 합의점에 이르기 위해 체제를 지키기 위한 경제적 사회적 비용을 제공해야 할 의무가 있음을 의식해야 하며, 무산자라면 우리 공동체가 제공하는 무궁한 기회를 통해 성장해 나가고 훗날 공동체의 훌륭한 시민이 되기 위해 정진해 나가야 할 것이다.","link":"/2018/05/20/z_루소의-사회계약론-사회의-권위는-어떻게-생겨나는가/"},{"title":"비즈니스 모델 설계하기","text":"비즈니스 모델 설계하기비즈니스 모델이란비즈니스 모델이란 기업이 수익을 내며 생존해 나가기 위한 목적으로 사업을 수행하는 방식을 의미하며 기업이 가치사슬상에서 어느 위치에 속하는가를 명시함으로써 매출을 발생시킬 수 있는 방법을 보여줄 수가 있다.비즈니스 모델에는 사업 참여자들 사이의 역할 및 관계(기업의 고객들과 협력사들과 공급사들 간의 역할 및 관계), 제품과 정보와 자금의 주요 흐름, 그리고 참여자들에게 제공되는 주요 효익의 내용이 담겨야 한다.비즈니스 모델이란 압축적이고 상세한 내용을 담을 필요가 없으며, 만약 문서 형태로 작성이 된다면 대표와 직원들이 머리로 기억할 수 있을 정도로 충분히 작은 개념으로 존재해야 한다.이는 한 페이지면 족하며, 여러 마디의 말보다는 하나의 그림으로 표현되는 것이 적합할 것이다. 비즈니스 모델은 가치명제, 제품/서비스, 자원 시스템, 수익 모델 의 네 가지 구성요소로 이루어진다. 가치명제(Value Proposition)가치명제란 타겟 고객군과 주요 경쟁기업이 누구인지, 그리고 회사 제품이 경쟁사 제품과 어떤 점이 고유하게 다른지와 그 근거를 보여주는 요약문이다. 가치 명제 선택을 위해 가장 먼저 해야 할 일은 타겟 고객계층 을 선택하는 것 인데, 여기서 핵심적인 두가지는 바로 시장 매력도 와 시장 내 경쟁력 이다. 먼저 시장의 매력도 란 시장의 규모 및 성장률을 분석하고, 아직 충족되지 못한 고객의 니즈가 있는지를 파악하며, 만약 시장에 경쟁자가 있는지 또 그 경쟁사의 역량이 출중한지 혹은 그렇지 않은지에 관한 문제를 고려하여 측정할 수 있다. 기업의 시장 내 경쟁능력 은 고객 가치를 뒷받침할 만한 기업의 비즈니스 핵심능력이 경쟁사에 비해 얼마나 우수한지를 고려함으로써 평가할 수 있다. 다음은 주요 고객 가치 를 선택하는 것이다.일반적으로 오프라인 마케팅 에서는 한 두 개의 핵심 고객가치를 제공하는 데 주력해야 한다.예를 들어 ‘볼보 자동차’는 ‘안전’이라는 가치를 내세우고 있으며, ‘사우스웨스트 항공사’는 ‘편의성과 저가’의 가치를 내걸고 있다.만약 위 두 회사가 이러한 고유한 가치를 어필하는 대신에 상충되는 두 가치 예를 들면 ‘최고급 저가 항공’ 등의 가치를 내세우게 되면 두 가지 모두를 충족시키기가 어려워 결국 두 부문에서 중간에 머무르게 되어 훌륭한 비즈니스가 될 수 없을 것이다. 다음은 독특한 차별적 능력 을 선택하는 것이다.이것은 하나 혹은 여러개의 고객가치를 경쟁사보다 훨씬 더 탁월하게 제공할 수 있는 방법의 개발인데, 이는 기업의 외부 보다는 기업 내부 및 협력사 관련 요인들과 관련이 깊다.회사가 정말 할 수 잘 하는 분야 그리고 약한 분야를 정확히 파악하고 기업의 핵심 능력 이 무엇이며 이것을 어떻게 활용할 것인지를 고민해야 한다.여기서 가장 중요한 점은 핵심능력이 가치명제를 구성하는 주요 고객가치와 직접적으로 연관이 되어있는지의 여부이다. 주요 고객가치를 제공하는 데 기여를 하지 못하는 핵심 능력은 쓸모가 없다 수익 모델수익 모델이란 기업이 비즈니스를 통해 수입을 발생시키고, 이윤을 내며, 또 투자자본에 대해 높은 수익을 낼 수 있는 방법을 뜻하며 다음과 같은 종류의 수익모델이 존재한다. 광고 수익모델트래픽이 많은 특정 사이트에서 배너 등 광고를 게재하거나 사이트 후원업체 지정을 통해 광고수입을 발생시킬 수 있는 모델 판매 수익모델웹사이트에 온라인 카탈로그를 구축하고 주문을 온라인으로 받아 판매ex) 아마존 닷컴, 롯데 닷컴, 인터파크몰 거래 수수료 수익모델고객-판매자 간의 거래를 촉진시키는 대가로 수수료 부과ex) 이베이 온라인 구독료 수익모델온라인 컨텐츠를 구매한 고객으로부터 받는 구독료 제휴관계 수익모델트래픽이 많이 몰리는 사이트를 방문한 고객들이 제휴관계에 있는 제3자 업체 사이트에서 구매하도록 유인하고 소개 수수료를 받는 모델로 일반적으로 매출이 실제로 발생한 경우에 한해서만 거래금액의 일정 퍼센티지에 해당하는 수수료를 받게 된다. 이비즈니스 모델의 분류 틀","link":"/2017/12/18/z_비즈니스-모델-설계하기/"},{"title":"어떻게 상사를 대할 것인가?","text":"오늘은 조직생활과 관련하여 많은 사람들이 겪고 있는 직장 상사와의 갈등에 대해 생각해보고자 한다. 많은 사람들이 직장생활의 가장 큰 어려움으로 상사와의 갈등을 꼽고 있다. 과연 세상의 모든 상사들은 다 나쁜 사람인가? 라는 생각이 든다. 본 글은 어디까지나 사회생활에 대한 필자의 주관적인 생각만을 적어보는 것으로 본 글이 직장 내 상사와의 갈등에 대한 일반적인 해안은 결코 되지 못하는 것을 인지하고 있음을 먼저 밝히고 글을 시작한다. 직장 상사를 대하는 태도 대한 일반적인 관념은 어떠한가 부터 생각해 보자. 흔히 직장상사를 이야기 할때 ‘모신다’ 혹은 ‘사수’, ‘배운다’ 등의 단어가 일반적이다. 사실 이런 단어는 벌써부터 직장 상사와 나의 관계가 상/하 관계 혹은 갑/을 관계, 선임자/후임자의 수직적인 관계라고 화자 스스로가 생각하는 경우 사용된다. 따라서 후임자는 직장 상사의 말에 최대한 맞추려고 하고, 직장 상사가 나를 한 없이 착하고, 성실한 그런 ‘직원’ 이자 ‘후임자’로 보여지기를 원한다. 하지만, 이런 태도는 과연 현명한 처신일까? 과연 직장 상사는 ‘후임자’, ‘하급자’ 를 필요로 하고 훌륭한 ‘을’이 필요한 것일까? 이에 대한 필자의 생각은 ‘아니다’ 이다. 기업은 더 이상 학교이자 가정이 아니며 ‘하급자’, ‘직원’ 보다는 비즈니스 파트너 가 필요한 것이다. 착하고 말잘듣는 직원보다는, 좀 쌀쌀 맞더라도 잘난 나 와 그래도 잘 합을 맞출 수 있는 파트너 가 되어 주기를 원한다. 선임자가 상대방을 후임자 가 아닌 파트너 로 인정하게 되는 순간 선임자는 선임으로써의 버팀목 이 되어주어야 한다는 책임감을 덜어내고 인간 대 인간으로써 함께 협력하여 일을 해 나갈 수 있기 때문이다. 사실 남자라면 누구나 공감하겠지만 수직문화의 끝을 보여주는 군대에서는 이런 장면들을 많이 보아왔을 것이다. 항상 착하기만 하고 저 친구 정말 고생하는구나 하는 후임과 동기들은 어디까지나 보호해야할 대상이며 나의 아랫사람으로 많은 경우 힘든일은 혼자 다하면서도 정작 인정은 받지 못하는 많은 병사들이 있는 반면, 좀 뺀질거리더라도 눈치 빠르고 소신있는 병사들은 전우 로써 인정을 받는 경우는 아주 흔한 일이다. 인생을 살아가면서 언제나 우리는 조직의 한 가운데에 놓여있게 된다. 필자를 비롯한 이 글을 읽는 독자들도 당돌하고 일 좀 하는 비즈니스 파트너 로써 상급자의 도움이 필요없는 믿을만한 파트너로 거듭나 훌륭한 사회의 조직원으로 거듭난다면 더할나위 없이 좋은 일일 것이다.","link":"/2018/05/14/z_어떻게-상사를-대할-것인가/"},{"title":"불평을 경계하라","text":"불평을 경계하라우리는 살면서 너무도 많은 ‘불평’을 한다. 미용실에서 자른 머리가 내 마음에 들지 않을때, 직장에서 상사가 내게 터무니 없는 요구를 하는 것 같을때, 우연히 들른 식당이 맛이 없을 때, 원하던 시험에서 떨어졌을 때 처럼 많은 사소하고 큰 일에서 우리는 불평을 늘어 놓는다. 이런 불평의 대상은 대게는 나 스스로 이지만 때로는 내가 아닌 다른 사람이 되기도 한다. 많은 훌륭한 사람들, 좋은 책들에 하나 같이 우리에게 불평을 하지 말라고 가르치지만, 그 말만 듣고 이것을 실천하기에는 너무 사소하고 무턱대고 그 말들에 따르기에는 구체적인 이유도 사실 알지 못한다. 이번 포스트에서는 우리가 불평을 하는 이유, 또 불평이 우리에게 미치는 영향에 대한 나의 주관적인 생각을 담아보고자 한다. 우리는 왜 불평을 하는가?우리가 불평을 하는 이유는 지금 벌어지고 있는 일에 대한 책임을 나에게로 돌리기 위함이다.시험에서 떨어지거나 직장에서 질책을 받거나 하던 사업이 안되는 경우 우리는 불평이라는 간편하고 달콤한 해결책을 찾는다. 시험을 준비한 시간이 짧아서 떨어졌다거나 혹은 직장 동료가 내 의도를 정확히 이해하지 못했다거나 시장이 너무 불황이어서 사업이 망했다는 불평처럼 우리는 우리의 실패를 우리가 통제하지 못하는 상황 에 대해 불평함으로써 우리 주변사람들에게 “나를 공격 하지 마시오!” 라는 선전포고를 하는 것이다. 때문에 많은 경우 우리가 하는 불평들은 제 3자가 볼 때 논리적으로 반박하기 어려운 경우가 많고, 스스로도 과거의 많은 일들이 어쩔 수 없는 결과로 귀결되었음에 안도 아닌 안도, 위안 아닌 위안을 얻고는 한다. 때로 많은 사람들은 사실 불평을 하는 그 사실에 대한 정확한 이유와 원인을 마음 속 깊은 곳에 이해하면서도 다른 사람에게 다른 불평을 하곤 하는데, 이를 통해 그들은 주변 사람들로 부터 스스로를 방어할 수 있게 된다. 불평의 마법짧은 순간이지만 불평은 우리의 마음을 편안하게 해 준다. 답답했던 마음도 불평한마디 툭 던지고 잘못된 상황 탓이거니 하면 마음이 편해지고 잘못된 것은 전부 바깥 세상 탓인것만 같다. 불평의 마법은 이때부터 시작된다. 사실 불평이란 한낱 단어들의 조합이자 생각없이 내뱉는 달콤한 담배 한모금과 같은 것이지만 지속적인 불평은 어느덧 우리 마음을 심각하게 손상시킨다. 우리가 통제하지 못하는 상황 에게 모든 책임을 돌려버린 탓에 우리 스스로 우리가 불평을 한 대상에 우리가 할 수 있는 것은 없다고 선언해 버린 것이다. 이 선언은 마음속 깊은 곳에 잠식하고 우리 스스로 만들어 낸 통제하지 못하는 상황속에 우리를 가두어 버린다. 가령 사법고시에 떨어진 뒤 ‘사법고시는 정말 말도안되. 천재가 아니면 붙을 수 없다니까?’ 라는 한마디의 말은 시간이 지남에 따라 내 머릿속의 확고한 진실로 자리잡는 것이다. 이것이 바로 불평의 마법이다. 한 마디의 불평의 우리의 무한한 가능성을 서서히 잠식해 나간다. 불평의 마법에서 벗어나기흔히 ‘사람의 그릇’ 이라는 말을 하고는 한다. 필자는 이 단어를 너무도 싫어하고 허세가 가득한 단어임에 분명하다고 생각하지만, 필자가 생각하는 그 ‘사람의 그릇’ 이란 불평의 정도 정도로 해석될 수 있다고 생각한다. 불평의 마법 을 통해 우리 스스로를 통제하지 못하는 상황속에 가두고 책임감을 털어낼 수 있지만, 그만큼 세상을 향한 가능성을 담는 우리의 그릇을 점점 작아지게 함이 그 까닭이다. 그래서, 필자가 생각하는 불평의 마법에서 벗어나는 방법은 조금 답답하게 살아가는 것이다. 때로는 한마디 툭 뱉고 싶은 불평을 참고 침착하게 정말 불평의 원인을 탐색해 나가야 한다. “왜 나는 지금 불만이 있는 것일까? 어떻게 하면 앞으로는 내가 이런 불만을 가지지 않을 수 있을까?” 라는 생각을 계속 하는 것은 그 순간은 정말 답답한 순간이 아닐 수 없지만, 이렇게 조금 묵직한 어깨를 가지고 불평의 순간들을 마주하게 된다면 멀지 않은 미래에 우리는 세상의 모든 가능성을 담을 넉넉한 그릇을 가지게 될 것임을 믿어 의심치 않는다. 묵직한 어깨를 가진 사람이 되기 위하여늘 그렇듯이 오늘의 포스팅도 필자 자신에 대한 성찰이 많이 반영된 글이다.하루 하루 열심히 살아나가고, 하루 하루 부족한 부분을 체워가고 있지만 가끔은 이렇게 불평한마디 툭 던지고 책임감을 내려놓고 홀가분한 마음으로 살아가고 싶을 때가 있고, 또 자주 그래온 것이 사실이다. 하지만, 매번 툭 던져온 이 불평이란 것이 스스로를 좀 먹이고 있음을 느끼고 다시한번 마음을 다잡고자 이렇게 글을 써내려 간다. 이 글을 읽는 독자들도 필자와 같이 불평의 달콤함에 빠져든 기억이 있다면, 불평의 달콤함 보다는 묵직한 책임감의 어깨를 가지고 세상의 모든 가능성을 한껏 받아들여 성장해 나가길 기원한다.","link":"/2018/06/10/z_불평을-경계하라/"},{"title":"어떻게 원하는 바를 얻어낼 것인가, 설득의 마법","text":"살아가면서 누군가를 설득하여 원하는 바를 이루어 내는 것은 정말 중요하다. 특히 요즘 사회에는 정보의 홍수와 수많은 미디어의 출현으로 역설적이게도 절대적 진리에 대한 탐구는 점점 더 어려워만 가고있으며, 특정 목적을 가진 많은 기업 및 단체들이 더욱 교묘하게 매체와 심리를 활용하여 상대방을 기술적으로 설득시키는 모습을 흔히 볼 수 있다. 사실 우리가 알지 못하는 사이 대부분의 정당들은 사람들의 심리를 기술적으로 활용하여 정치적 우호감을 확산시키고 있으며, 수많은 기업들의 상업 광고는 우리의 소비 심리를 교란시키고 소비의 마법 앞에 굴복시키고 있다. 이런 사회적 현실 속에서 냉철한 판단을 잃지 않기 위해 우리는 그들이 사용하는 설득의 심리를 이해할 필요가 있으며, 이는 인류가 반드시 추구해야할 진리에의 탐구에 한걸음 더 다가갈 수 있는 유용한 수단이 될 수 있다. 이번 포스트에서는 ‘로버트 치알디니’ 의 저서 ‘설득의 심리학’ 을 기반으로 설득의 심리와 기술에 대해 알아보고 보다 냉철한 현대인으로 거듭나고 한다. 설득의 무기문명의 발전은 인간이 무의식적인 사고 없이 자동적으로 수행할 수 있는 작업이 늘면서 이루어 졌다. 대부분의 사람들은 문명의 발전과 복잡한 사회 구조가 현대인을 보다 합리적이고 논리적으로 진화시켰다고 생각하지만, 역설적이게도 복잡한 사회는 수백년간의 사회적 통념이란 비 논리적 허점을 낳았고, 우리는 복잡한 사회를 사회적 통념으로 부터의 추상화를 거쳐 이해하게 되었다. 즉, 너무나 많은 정보를 처리하기 위한 판단근거로 절대적 진리를 통한 냉철한 판단은 점차 어려워 지고 인습적 통념에 의존하여 판단을 내리게 된 것이다. 이러한 사실은 인간 뿐만 아니라 동물의 세계에서도 쉽게 찾아볼 수 있다. 가령 칠면조는 새끼가 내는 ‘칩칩’ 거리는 소리로만 자식의 유무를 판단하는 데 이는 사실 절대적 진실과 근거에 의거한 것이 아닌 수십 수백년간 새끼는 ‘칩칩’ 거리며 운다라는 사회적 동물적 통념을 근거로 하여 판단을 하는 것이고, 특정 목적을 가진 누군가가 이를 악용할 수 있는 것이다. 이러한 예는 현실 사회에서도 다양한 형태로 나타난다.비싼 것이 좋은 것이라는 자본주의 사회의 통념, 무언가 이유를 말하면 그 타당성에 관계없이 논리적으로 더 옳아보이는 인습적 통념, 전문가의 말은 진실일 확률이 높다는 전문가에 대한 의존이 바로 그 예이다. 수많은 미디어는 이를 광고에 활용하고 수많은 전문가와 고부가가치 상품들에 대한 프리미엄 전략 등의 모태가 되었다. 이러한 현상을 좀 더 일반화 하면 사람의 행동에는 자동화된 패턴이 존재한다. 라는 결론이 나오게 되는데, 특정 전문가 집단과 사회적 관습에 의존하는 것을 넘어서 전혀 연관이 없어 보이는 특정한 자동화된 패턴이 있음을 알 수 있다. 가령, 비싼 물건을 구매하고 난 뒤에 보여주는 물건은 상대적으로 아주 저렴하게 느껴지는 대비 효과 의 경우 등도 오랜 시장 거래의 관습에서 얻어진 비논리적 통념의 예로 볼 수 있다. 설득의 원칙앞의 문단에서 우리는 설득의 기본적인 원리에 대해 알아보았다.이번에는 보다 구체적으로 두 가지의 설득의 원칙에 대해 알아보고자 한다. 첫번째 원칙은 상호성의 원칙 이다.우리는 누군가에게 호의를 받으면 항상 갚으려고 하는 습성이 있는데 이것은 상호성의 원칙 의 근간이 된다.이러한 상호성의 원칙은 수많은 판촉의 모델로써 활용되고 있다. 특정 온라인 쇼핑몰에서 회원 가입을 하면 포인트를 준다거나, 값비싼 물건을 50% 파격적으로 할인한다는 점을 강조하여 상대적으로 양보를 하는 포지션을 취하는 것이 그 예이다. 또한, 상인들이 물건을 흥정시 처음에 값비싼 가격을 부르고 차츰 차츰 가격을 내려 원래 팔고자 했던 가격에 매매하는 기법도 이러한 상호성의 원칙을 활용한 설득의 원리라 볼 수 있다. 두번째 원칙은 일관성의 원칙 이다.이를 쉽게 표현하면 우리는 한번 내린 판단을 유지하려 하는 습성이 있다는 것이다.이 원칙 또한 삶의 너무나 많은 부분에 퍼져 있지만 우리는 이것을 알지 못한다.가령, 헬스장을 등록하고 가지 않더라도 우리는 헬스장 등록이라는 선택은 내가 내린 선택이므로 헬스장을 거의 가지 않더라도 이것은 아주 바람직한 선택이었다고 합리화 하는 경향이 매우 강하다. 때문에 헬스장에서는 고객이 오던 오지 않던 최초 결제일 한번만 잘 구스르고 설득하면 남은 기간동안 서비스가 조금 떨어지더라도 기간이 지나면 지날때마다 고객들의 충성도는 올라가게 된다. 또 다른 예로 자동 결제를 하면 파격적으로 상품의 가격을 깍아주는 많은 서비스들이 있는데, 이것은 최초의 한번의 선택이 어렵지 한번 선택을 내린 뒤에는 사람들이 가급적 결정을 유지하려고 하는 습성을 잘 이용한 것이다. 특히 음악 이용권의 경우 최초의 한 두달의 경우 무료에 가까운 가격으로 음악을 들을 수 있는 경우가 많은데, 이는 사람들의 일관성의 원칙 을 잘 활용한 예라고 볼 수 있다. 이러한 일관성의 원칙 의 또다른 확장은 사람들의 자아이미지를 바꾸어 그들이 자신이 스스로 만들어낸 이미지를 지키기 위해 노력하게 할 수 있다 는 것이다. 이는 어떤 의미에서 브랜딩 그 자체의 목적이라고 보아도 무방하다. 유명한 스포츠 브랜드인 ‘나이키’ 의 경우를 생각해 보자. 그들은 운동화를 구매하는 소비자가 자기 스스로 경쟁을 즐기고 열정이 넘치며 활력적인 사람이라는 자아 이미지를 내도록 끊임없이 부추기게 되고, 그들은 그들 스스로가 만들어낸 이미지의 연속성에서 지속적인 구매를 하도록 유도한다. 어디를 향해 나아가는가?위의 두가지 원칙 말고도 우리 사회에서는 기술적으로 끊임없이 우리의 심리를 이용하고 활용하는 설득의 기술을 사용하고 있다. 자본주의의 충실한 소비자로써 기존 정치 세력의 충직한 지지자로써 대중을 설득한다. 수세기가 지나면서 사회 경제적 우위에 서있는 기업과 단체 소수자들은 자신들의 권력을 유지하기 위해 대중을 설득해 왔으며, 미디어의 홍수인 오늘날 이런 현상은 더욱 더 위험하다. 하지만, 인류의 역사를 생각해보자. 인류의 위대한 변혁은 기존의 관습에서 벗어나 절대적 진리와 논리적인 이성에 입각하고 과감히 이를 부수는 것에서 시작되었으며, 오늘날 모든 현대인은 더욱 발전된 미래를 위해 절대로 통념에 대한 관성으로 인해 절대적 진리에 대한 추구를 멈추어서는 안되는 것이라 생각한다. 필자를 비롯한 오늘날 모든 사람들이 설득의 기술을 이해하고 정의를 설득하고 통념에 설득당하지 않을 수 있었으면 하는 바램이다. 참조 문헌로버트 치알디니, 설득의 심리학","link":"/2018/06/14/z_어떻게-원하는-바를-얻어낼-것인가-설득의-마법/"},{"title":"이룰수 없는 꿈은 헛된 것인가요?","text":"오늘은 노벨상, 퓰리처 상 수상자인 미국의 극작가 유진 오닐 이 남긴 “꿈”에 관한 이야기를 하고자 합니다. 꿈을 실현시키지 못하고 실패하는 것이우리에게 주어진 어쩔수 없는 운명이지만그래도 희망이 없는 곳에는 생명도 없다그러므로 우리들은 마지막 순간까지꿈을 계속 찾는 것이다. 우리들은 항상 꿈을 이루기 위해 노력하며 하루를 살아갑니다.누군가는 꿈을 이루지만, 다른 누군가는 삶이 끝나는 그 날까지 꿈을 이루지 못하기도 합니다. 당신은 어떤 사람인가요?혹시 지금, 꿈을 이루셨나요? 아마도 대부분의 사람들은 그렇지 않을겁니다.만약 가지고 있던 꿈을 몇개 쯤 이루었을 수 있지만 수천 수만개의 새로움 꿈들을 우리는 매일 좇으며 평생을 살아갑니다.이렇게 우리가 꿈을 말할때는 언제나 현재 진행형이지요. 극작가 유진 오닐은 이런 우리들의 모습을 정말 잘 표현해 줍니다.바로, 꿈의 실현에 대해 꿈을 실현시키지 못하고 실패하는 것이 우리에게 주어진 운명이라고요. 꿈을 실현시키지 못하고 실패하는 것이 운명이라니, 어차피 이루지도 못할 꿈을 더 이상 좇을 의미가 있는 것일까요? 많은 사람들이 이런 생각을 합니다. “내가 가진 꿈을 이루기는 너무 힘들어요.”“꿈은 어렸을 때나 가지는 거죠”“저는 현실적인 사람이에요.” 그리고 더 이상 꿈을 꾸는 의미가 없다고 말을 합니다. 이룰수 없는 꿈을 꾸는 것은 정말 헛된 일일까요? 그래도 희망이 없는 곳에는 생명도 없다그러므로 우리들은 마지막 순간까지꿈을 계속 찾는 것이다. 유진 오닐의 한마디는 우리에게 깊은 인상을 줍니다.꿈은 이루기 위해 꾸는 것이지만, 꿈을 좇는 것은 그 결과가 아닌 과정에 참된 의미가 있다고 우리에게 말해주는 것이지요. 우리는 살아있기 때문에 또, 앞으로 살아갈 용기를 얻기 위해 꿈을 꿉니다.설사 꿈을 이루는 것을 결국 실패했다고 하더라도 낙담하거나 좌절할 필요는 없는 것이지요. 매일 매일 꿈을 좇는 과정 그 자체 만으로 우리는 살아있음을 느끼고 또 앞으로 살아갈 용기를 얻을 수 있습니다. 이 글을 읽는 많은 독자분들도 오늘 하루 자신이 가진 원대한 꿈을 의심하고 걱정하지 말고 있는 그 자체로 추구하며 살아있음을 느낄 수 있는 하루가 되셨으면 합니다. 감사합니다.","link":"/2018/04/03/극작가-유진-오닐-이-말하는-꿈에-관하여/"},{"title":"가치투자, 독점형 기업 발굴 레포트","text":"독점 기업을 발굴하라독점기업은 정부의 입장에서 보면 사회 전체의 이익에 반하는 행동을 할 수 있다는 점에서 제재의 대상이 될 수 있지만, 투자자의 입장에서 보면 상당히 매력적인 기업이다. 이런 기업은 마케팅 비용을 줄여 영업 이익을 극대화 할 수 있으면, 다른 대안이 없고 다른 모든 사람이 사용하기 때문에 가격 인상을 통해 추가적인 영업이익 확보도 가능하다. 독점기업을 찾는 방법은 상당히 단순한데, 주변에서 그 제품을 좋아하지 않음에도 불구하고 어쩔수없이 구매해야 하는 제품들을 찾는 것이다. 가령 내가 ms 의 워드 프로그램을 사용하기 싫더라도 다른 모든 사람들이 문서 프로그램으로 워드를 사용하기 때문에 어쩔수 없이 구매해야 한다. 자연 독점형 기업먼저 독점 기업 중에서 인위적으로 독점기업이 된 경우가 아닌 자연적으로 독점 지위를 누리게 된 ‘자연 독점형 기업’ 으로 기 범위를 제한한다. 가령, 한전과 같이 정부차원에서 라이센스를 부과한다던가 하는 사유로 독점적 지위를 누리게 된 기업은 정부나 혹은 경제 상황에 따라 그 독점 지위가 존속 가능하지 않을 수 있기 때문에, 이는 배제한다. 이러한 자연독점형 기업들은 몇가지 종류로 나눌수가 있는데, 그 종류는 표준화로 인한 독점, 기술적 독점, 마케팅 독점, 규모의 독점, 경쟁사 몰락으로 인한 독점의 경우가 있다. 표준화먼저 표준화 독점이란, 특정 제품이 이미 그 서비스의 표준이 되어 내가 사용하고 싶지 않아도 다른 많은 사람들이 사용하기 때문에 어쩔 수 없이 사용해야 하는 제품을 의미한다. 가령 마이크로 소프트의 워드, 엑셀과 같은 프로그램은 내가 아무리 다른 문서 에디터를 사용하고 싶다 하더라도 그 문서를 함께 공유하는 모든 사람들이 이미 마이크로소프트의 제품을 사용하기 때문에, 어쩔 수 없이 사용해야 하는데, 이것이 가장 대표적인 표준화 독점의 사례이다. 필자가 생각하는 국내의 표준화 독과점 기업 중 하나는 리디북스 이다. 리디북스 는 이미 전자책 시장의 60% 를 장악하고 있으며, 필자 또한 리디북스 전자책 단말기의 사용자이다. 리디북스는 다른 전자책 플랫폼과 다르게 타 서비스의 기기에 호환되지 않고, 독자적인 DRM 이 들어가기 때문에, 한번 리디북스 책을 구매했다면, 그 유저는 큰 문제가 있지 않는 한, 계속해서 리디북스에서 전자책을 구매하게 된다. 또한 리디는 도서 정액제 서비스등 유저를 묶어들 많은 서비스들을 내놓고 있으며, 이는 그 독과점 지위를 유지할 수 있는 큰 해자가 된다. 또한, 리디북스의 단말기는 현 유저들에게 많은 사랑을 받고 있으며, 기존에 전자책을 보급하던 많은 업체들(YES24 를 비롯한 대형 서점들) 의 경우 전자책을 판매하고 있지만, 전자책을 읽을 수 있는 디바이스나 어플리케이션들이 비교적 열악하기에 많은 고객이 이탈하여 리디북스로 올 것이라 예상한다. 현재 리디북스의 재무현황의 경우 아직까지 매년 영업 손실을 내고 있지만, 향후 전자책 시장이 성장할 경우 점유율 60% 를 점유중인 리디북스의 영업이익은 꾸준히 성장할 것으로 판단되며, 전자책 공급업의 특성상 연구 개발비를 비롯한 각종 판관비를 매출 증가량에 비해 다소 낮은 비율로 증가할 것으로 예상되기에 영업 성과가 개선될 것으로 판단된다. 하지만, 현재 리디북스는 비상장 기업 으로 주식시장에서 거래가 불가능하여, 주식을 구매하기 위해서는 장외주식을 구매하거나 상장할 때까지 기다리는 것 외에는 매수가 불가능 하다. 기술적 독점기술적 독점은 기업의 뛰어난 기술을 기반으로한 특허 등의 장치로 말미암아 다른 기업이 따라올 수 없는 기술력을 가지는 경우이다. 예로는 비아그라나 퀄컴의 CDMA 칩 등이 있다. 이러한 제품들은 다른 기업이 만들고자 해도 기술력 부족과 특허 문제로 제작이 불가능 하기 때문에, 해당 제품을 독점할 수 있다. 마케팅 독점마케팅 독점이란 넓은 유통망을 기반으로한 브랜드 효과로 독점을 누리고 있는 기업이다. 가령 코카콜라나 맥도날드 등의 기업들은 전 세계적인 유통망으로 원가절감을 비롯한 규모의 경제를 누릴 뿐 아니라, 그 브랜드 파워로 인해 소비자들과 좋은 관계를 유지합니다. 이러한 마케팅 파워는 그 자체로 막대한 독점적 지위를 가지게 됩니다. 국내에 이런 마케팅 파워를 통한 브랜드가 있다면, 바로 백종원씨의 더본 코리아가 아닐까 싶습니다. 더본 코리아는 수십개의 프랜차이즈를 운영하고 있으며, 각 프랜차이즈는 백종원의 브랜드를 달고 소비자에게 다가가며, 소비자는 ‘백종원’ 이라는 이름을 믿고 매장에 방문하게 됩니다. 또, 백종원씨가 최근 많은 TV 프로그램에 나오면서, 소비자들에 대한 마케팅 파워를 강화했으며, 그 효과는 그대로 영업 실적에 반영되어 매년 영업이익이 폭발적으로 성장하고 있습니다. 백종원씨의 더본 코리아는 현재 요식업 뿐만이 아니라 호텔 사업등 다양한 라이프 스타일 브랜드를 운영하고 수익을 낼 것으로 보이며, 더본 코리아의 상장 유무에 많은 투자자들의 관심이 집중되고 있습니다. 규모의 독점막대한 설비 투자처럼 큰 자본을 들여서 생산 환경을 구축해야 하는 사업의 경우 다른 기업이 참여하기 힘들다. 가령 삼성의 반도체라인의 경우 막대한 반도체 공정을 위한 설비투자가 선행되어야 하며, 이는 다른 기업이 들어오지 못하는 큰 독점적 지위를 발생시킨다. 현재 중국의 경우처럼 국가 단위로 설비 투자에 자금을 투입하는 등의 막대한 투자가 뒷바침 되지 않는 이상 삼성전자의 반도체를 꺾는 것은 매우 어렵다. 경쟁사 몰락지역 독점형 기업일류 제품형 기업###","link":"/2019/06/06/가치투자-독점형-기업-발굴-레포트/"},{"title":"나만의 발자국을 남겨라","text":"나는 벤저민 프랭클린을 참 좋아한다. 철저한 자기관리와 건국의 아버지로 알려진 프랭클린, 나는 그의 자기 관리를 위한 노력이나 훌륭한 일을 하려 하는 긍지보다 다른 부분에 집중하고자 한다. 그것은 바로 그는 변치않는 신념과 스스로에 대한 믿음으로 묵묵히 자신의 길을 걸었다는 것이다. 주변의 시선과 자신이 처한 환경, 미래에 대한 불안에 대해 그는 거의 언급하지 않았다. 그저 자신이 처한 환경에서 조금 더 나아질 수 있는 방법을 찾았고, 끊임없이 내가 필요하고 더 나은 사람이 되기위해 정진해 나갔다. 인생을 살아가는 정도라는 것이 무의미해 지고, 한치앞을 내다 볼 수 없는 오늘의 사회에는 더욱더 가장 본받아야 할 점이 아닌가 생각된다. 흔히 인생을 살아나가는 것은 눈덮힌 산을 오르는 것에 비유된다. 가장 연륜있고, 실력있는 선구자는 우리를 앞서 오르고 대부분의 우리는 선구자가 남긴 발자국을 따라 오르며 끊임없이 내가 올바른 발걸음을 디뎠는지 생각한다. 내 눈앞의 수많은 발자국을 보며 어느 길이 가장 쉽고 효과적인 길인지를 가늠하려 하고, 내가 걸어온 발자국을 보며 산턱 언저리에서 후회와 불안에 이따금 뒤돌아 우두커니 서있는 것이다. 하지만, 정말 산을 잘 오르는 사람들은 오로지 정상만을 바라보고 오를 뿐이다. 우리 앞을 지나간 선구자는 물론 도움이 될 수 있지만, 그 사람이 어떤 상황에 있었는지 그때의 날씨는 어땠는지 우리는 알지 못하며, 가장 올바른 선택은 목적지에 시선을 던져두고 나를 믿고 신중하게 한걸음 한걸음을 옮기는 것인 것을 그들은 잘 아는 것이다. 요즘 세상을 무한 경쟁사회라고 한다. 주변을 달려가는 수많은 주자들을 바라보며 조바심을 느끼게 만드는 사회에서 많은 사람들이 고작 한치 앞에 있는 사람을 꽁무니 만을 쫓게도 되고, 한발작 뒤에 있는 주자들을 보며 가끔은 안도하기도 할 것이다. 이 글을 쓰는 필자도 또 마음을 다잡고자 이런글을 쓰는지 모른다. 오늘 하루도 앞서나가는 자에대한 조바심을 뒤따라 오는 자에 대한 오만함을 내려놓고 정상만을 바라보며 누구의 발자국도 아닌 나의 발자국을 남길 수 있는 하루, 내면의 단단함이 더해지는 하루가 되기를 바란다.","link":"/2018/05/22/나만의-발자국을-남겨라/"},{"title":"가치투자, 시장의 왜곡에서 기회를 잡아라.","text":"시장의 왜곡에서 기회를 잡아라시장에 대한 대중의 잘못된 판단으로 오평가된 기업을 찾아라 시장은 합리적인 사람들이 모여있는 곳이 아니다. 가령 특정 기사로 인해 잘못된 관념으로 주가가 폭락, 폭등 할 수 있다. 하나의 좋은 예는 바로 월드 트레이드 테러가 일어난 2001년 전 세계 보험 주식은 보상금에 대한 우려로 폭락하였고 이는 우리나라도 마찬가지 였다. 우리 나라의 ‘대한재보험’의 경우 테러 이후 주가가 하한가를 찍을만큼 주가가 폭등하였는데, 이는 미국 보험사와 국내 보험사에 관계가 있지 않을까 하는 대중의 막연한 추측 때문이었고, 실제로는 아무 관계가 없었다. 오히려 국내 보험시장은 해외의 테러 사테를 본 뒤 보험의 필요성을 느껴 보험을 가입하는 많은 사람들 때문에 수익성이 개선되었다. 머지 않아 해당 보험사의 주가를 원래 가격을 되찾았으며, 시장의 왜곡을 눈치챈 사람들은 저평가된 주식을 매수하여 큰 수익을 올렸다. 폭락하는 주식을 눈여겨 보라, 대중의 오해로 인한 시장의 왜곡이 존재하지 않는가? 재정의형 기업사업을 재정의 한다는 것은 그 기업이 하고 있는 사업은 변함이 없지만 그 기업의 경쟁우위와 본질을 파악하여 재정의 하는 것이다. 가령 나이키의 경우 대부분의 사람들은 그저 그런 신발 가게라고 생각했을 것이다. 하지만 나이키의 운영방식을 잘 알아본 사람들은 나이키는 오히려 신발의 생산에는 거의 관여하지 않고 브랜드와 디자인만을 담당하는 마케팅 기업이라는 사실을 눈치챘을 것이다. 이런 가치를 알아본 사람들은 나이키에 투자했고, 막대한 투자수익을 거둘 수 있었을 것이다. 과거 ‘동양제과’ 의 사례를 살펴보면 ‘동양제과’ 는 대형 미디어 그룹의 지주회사로 재평가 되어야 한다. ‘동양제과’ 는 바둑 TV 와 OCN, 투니버스 등 방송사의 지주회사이며, 해당 업체들을 흑자로 잘 운영되고 있다. 이 경우 투자자들은 기존 ‘동양제과’ 가 하던 사업을 넘어서 소속 기업들의 영업실적이 지주회사인 ‘동양제과’ 에 어떤 영향을 미칠지 잘 판단해야 한다. 이러한 재정의 기업들을 물색하기 위해서는 어떻게 해야 할까? 사실 이런 재정의형 기업의 경우 기업이 행보에 관심을 가지지 않으면, 이를 잘 알기 어렵다. 이 경우 각종 기사를 통해 경영 성과에 긍정적인 변화가 있는 기업들의 모회사를 조사하거나, 어떤 회사가 기존에 하지 않던 새로운 신사업을 시작한다던가 하는 기업의 중대한 경영 방침들을 지속적으로 트래킹 해야 한다. 만약 관심가는 산업분야가 있다면, 해당 산업의 주요 기업들의 사업의 방향을 잘 따라가다 보면 좋은 기회를 얻을 수 있다. 업계의 경기는 개별 기업의 경기와 다를 수 있다.또한 산업 자체가 사양산업이라 불리는 경우 많은 투자자들은 사양산업에 속한 기업들의 주식을 팔아치우는 현상이 생기게 된다. 하지만, 산업군과 기업은 엄연히 다르다. 특히 성장형 산업의 경우 수많은 업체들이 들어오는 반면 사양산업은 새로운 업체가 들어오지 않을 확률이 높고 특정 제품군이 나머지 업체를 흡수하여 winner takes all 구조를 보이는 경우가 많다. 요즘 시대의 경우 대부분의 신사업들을 AI 와 블록체인들 소프트웨어 기반의 지식산업으로 그 무게가 이동하고 있기에, 기존의 중공업과 같은 업계는 이제 한물 갔다는 풍조가 강해지고 있다. 또, 국내 반도체 실적 전망과 부품업계의 소식을 접한다면 해당 업계의 모든 기업들에 대한 부정적인 이미지를 가지기 쉽다. 때문에 이러한 업계의 불황은 대부분의 투자자들이 거짓 위험을 감지하게 만들고 훌륭한 펀더멘탈을 가진 기업들이 저평가되게 만들며, 훌륭한 투자자라면 옥석을 가려 매수할 기회를 보아야 할 것이다. =&gt; 사양산업 군에서 독보적으로 영업이익률을 높여가는 기업의 원인을 분석하라. 경기침체는 많은 사람들의 오해를 산다.경기침체가 오고 경기가 불황이면 사람들은 많은 주식을 팔아치운다. 이 경우 그 기업의 영업성적과는 관계없이 비정상적인 주가하락이 발생하는데 이 시기야 말로 매수시기이다. 가령 1998년 IMF 시기에도 현대백화점의 영업이익은 꾸준히 전년대비 2배 이상 늘었으나, 주가는 폭락했다. 합리적인 투자자라면 이 기회를 잘 활용했을 것이다. 영업성적이 좋은데도 PER 가 그대로라면?주식을 누가 들고 있는가는 매우 중요하다. 가령 어떤 회사의 영업이익이 아무리 좋아도, PER 가 늘지 않는다면 그 주식의 보유자와 거래량을 체크하라. 만약 대부분의 주식이 전문 투자사나 특수지분으로 편성되어 있다면, 주식의 거래량이 크게 변할 수 없고, 그만큼 PER 의 변동성도 작다. 하지만 이 경우 장기간에 걸쳐 주가가 반영되지 않을수는 없다. 이런 기업은 어느 순간 거래량이 발생하고 그 잠재력을 발산할 것이다. 갑자기 오는 주가 상승의 기회를 포착해야 한다.","link":"/2019/06/06/가치투자-시장의-왜곡에서-기회를-잡아라/"},{"title":"논어에서 배우다 02","text":"공자께서 말씀하셨다. “남이 자신을 알아주지 못할까 걱정하지 말고 내가 남을 제대로 알지 못함을 걱정해야 한다.” 우리는 사회생활을 하면서 이런 생각을 참 많이도 합니다. “아 저건 너무한거 아니야?” “어떻게 저럴 수 있지?” “배려가 너무 부족해” 이런 많은 상황들을 친구에게 이야기 하면 대부분은 이런식을 대답을 해 주곤 합니다. “정말 너무하네!” “그건 아니지!” 이런 태도는 단 한가지의 결론만을 가져다 줍니다. “그 사람은 이상한 사람이다.” 하지만, 이런식의 사고를 통한다면 이 세상에는 얼마나 많은 이상한 사람들이 있는 것일까요? 우리의 이런 삶은 공자가 본다면 아마도 이렇게 말하지 않을까 싶습니다. “상대방의 마음을 잘 헤아려 보았는가?” 우리가 나와 다른 사람을 둘러싼 상황에서 상대방을 마음을 제대로 헤아리는 경우는 얼마나 될까요? 이런식의 사고는 사실 단순한 인간 관계를 넘어 국제 외교, 사업 협상 테이블 등 많은 경우에 적용할 수 있는 사고인 것 같아 보입니다. 누군가를 대할 때 냉철한 판단을 할 수 있는 가장 효과적인 방법은 내가 제안한 훌륭한 제안을 상대방이 이해하지 못하는 것을 탓하는 것이 아니라 바로 상대방을 올바로 아는 것이기 때문이지요 누군가가 나를 알아주지 않을 때 내가 혹시 상대방을 제대로 알지 못하는 것은 아닐까라고 생각해 볼 수 있는 하루가 되었으면 합니다.","link":"/2018/05/09/논어에서-배우다-02/"},{"title":"논어에서 배우다 03","text":"공자께서 말씀하셨다. “백성들을 정치로 인도하고 형벌로 다스리면, 백성들은 형벌을 면하고도 부끄러워함이 없다. 그러나 덕으로 인도하고 예로써 다스리면, 백성들은 부끄러워할 줄도 알고 또한 잘못을 바로잡게 된다.”-논어 [위정] 현대의 대부분의 정치체제는 제도로 하여금 사람들의 사회적 행동을 이끌어 내고자 노력합니다. 잘못을 한 사람들을 감옥에 가두고 벌금을 메기고, 사회적으로 필요한 질서에 관한 법령을 제정하여 사람들에게 법령을 지키도록 강요합니다. 기업도 마찬가지 입니다. 좋은 실적을 낸 직원에게는 상을 주고 근무 태도가 좋지 않은 직원에게는 불이익을 주는 등 규율을 세우고 이를 지키도록 함으로써 조직을 운영해 나갑니다. 이렇게 훌륭한 제도와 법규로 조직을 개선하려는 노력은 어떻게 보면 규모가 매우 큰 조직을 통제하기에는 유일한 수단으로 보입니다. 공자의 이런 말은 오늘날에 많은 생각할 거리를 줍니다. 조직의 질서와 개인의 변화를 제도와 상벌만으로 다스린다면 개인은 행동의 변화시킬 이유를 찾지 못하고 되려 제도를 회피하고자하는 행동을 촉발할 수 있습니다.하지만, 국가가 시민에게 덕을 바탕으로 한 시민의식을 심어주고 또, 회사가 개인에게 기업의 비전과 기업 문화를 배양해 준다면 개인은 자발적으로 일의 의미를 가지고 보다 주도적으로 일을 해 나갈 수 있다는 것은 참 실현하기 힘들고 번거로운 일이지만 어쩌면 조직을 이끌어 나가는 핵심이자 리더의 자질이 아닐까 생각합니다. 이 글을 읽는 독자분들도 덕과 예로써 주변 사람들을 대하는 리더가 되기를 기원합니다.","link":"/2018/05/10/논어에서-배우다-03/"},{"title":"라즈베리 파이 시작하기","text":"초기 세팅 Noobs를 다운로드 하여 설치를 한다. 라즈베리 파이에 Noobs insert apt-get 패키지 매니저 설치sudo apt-get update java jdk 및 jre 설치. MVN 설치apt-cache search mavensudo apt-get install maven tesseract-ocr설치sudo apt-get install tesseract-ocr JNA Wrapper for tesseract-ocrJAR 파일로 설치.JNA Wrapper","link":"/2018/01/14/라즈베리-파이-시작하기/"},{"title":"머신러닝강의 01. 머신러닝의 기본 개념","text":"explicit programming 의 한계와 인공지능의 대두 supervised learning unsupervised learning tensorflow 설치 data flow graph explicit programming 의 한계와 인공지능의 대두흔히 말하는 explicit programming 이란 사람이 생각한 다양한 방법들을 단순히 프로그램으로 옮기는 작업이다.예를 들어 주식 시장의 주식을 판매를 할것인가의 하는 문제를 프로그램 적으로 해결을 할 때에, 국가의 GDP가 높아지면 주식의 판매하는 것이 바람직하다는 가정을 토대로 프로그램을 만들 수 있다. 이러한 판단이 옳을 수도 있지만 주식시장이라는 거대한 복합체를 판단하기에는 너무나 많은 다양한 변수들이 존재하기 때문에 이것을 프로그램화 시키는 것은 불가능한 수준에 가까웠다.즉, 흔한 일상 생활에도 상당히 복잡한 상황들이 많이 발생하고 이것을 논리를 기반으로 한 프로그램으로 만들기 어려운 문제가 발생하게 되었고, 과학자들은 사람들이 정보를 학습할때 입력과 결과의 합, 즉 경험을 통해 학습을 진행하는 것을 모티브로 컴퓨터돠 수많은 입력과 출력의 쌍으로 어떤 상황에 대한 판단능력을 기를 수 있고, 또 보다 지능적인 프로그램을 만들 수 있지 않을 까 하는 생각을 하게 되었고, 그것이 인공 지능의 시초이다. 인공지능을 위해서는 다양한 입력과 결과를 토대로 학습을 진행하여야 하는데, 데이터의 종류를 알고 학습을 하는가 혹은 모르고 학습을 하는가에 따라 supervised learning 과 unsupervised learning으로 나누어 지게 된다. supervised learning데이터가 무엇인지 가르쳐 주고 학습을 진행한다. 즉 labeled data를 가지고 학습을 하는 학습방법이며 결과값의 범위에 따라 다음과 같은 종류가 있다. regression예를들어 시험 성적의 값을 알고 싶은 경우 예를 들어 범위가 매우 넓은 경우 binary classification결과가 둘중 하나인 경우 multi-label classification 결과가 몇가지 케이스가 있는 경우 unsupervised learningun-labeled data를 가지고 학습한다.그룹핑이나 클러스터링을 주로 한다. tensorflow 설치1pip install upgrade tensorflow 예제123456789101112import tensorflow as tfhello = tf.constant(&apos;Hello, TensorFlow!&apos;)//여기서 constant는 하나의 노드, 오퍼레이션을 의미한다//예를 들어 print(hello)를 출력하면 이상한 값이 나온다.sess = tf.Session()print sess.run(hello) //실행을 시키는 부분이다. placeholder12345678910//a와 b의 자료형을 지정해 주어 뒤에서 사용할 수 있게 한다.a = tf.placeholder(tf.int16)b = tf.placeholder(tf.int16)add = tf.add(a,b)mul = tf.mul(a,b)with tf.Session() ass sess: print &quot;Addition with variables: %i&quot; % sess.run(add, feed_dict=&#123;a: 2, b:3&#125;) //a와 b에 값을 넘겨줄 수 있다. print &quot;Multiplication with variables: %i&quot; % sess.run(mul, feed_dict=&#123;a: 2, b:3&#125;) //a와 b에 값을 넘겨줄 수 있다. data flow graphedge와 node 로 구성된 data flow graph는 다음과 같은 의미를 가진다. node는 수학적 계산을 하는 operation의 의미를 가지며 edge는 데이터가 흘러들어감을 보여주는 연결선이다.이러한 데이터는 data array와 같은 형태를 가지는데 이를 다른 말로는 tensor 라는 말로도 부른다.tensorflow란 말은 이러한 데이터의 흐름을 의미한다. 이러한 node들은 꼭 동일한 cpu 혹은 gpu안에 존재하지 않아도 되고 분산되어 존재하면서 병렬연산이 가능하기에 매우 강력하다.많은 컴퓨터들을 컴퓨터 자원을 통합해서 계산이 가능해진 것이다","link":"/2017/12/16/머신러닝강의 1강 - 머신러닝의 기본 개념/"},{"title":"머신러닝강의 2강 - Linear Regression","text":"linear regressionlinear regression 이란 말은 입력값이 변할때 출력값이 linear하다는 가설을 기반으로 한 regression 이다.가령 공부를 오래하면 공부를 잘한다와 같은 명제는 사실일 확률이 높은데, 이렇든 linear한 모델을 의미한다. linear regression에서는 training data를 받아 학습을 하며 결과적으로 다음과 같이 적당한 직선을 찾는 것이 주 목적이다. 위의 cost function은 W와 b에 관한 함수인데, 이 cost function을 최소로 하는 w와 b를 찾는것이 linear regression의 핵심 목표이다. Gradient Descent Algorithmlinear regression에서의 핵심은 cost function을 최소값을 찾아내는 것이며, 대부분의 convex function에서는경사로 타고 내려가는 알고리즘을 의미하는 gradient descent algorithm을 많이 사용한다.이 알고리즘은 마치 산을 내려갈 때 경사가 아래인 방향으로 계속 이동하는 것 처럼 미분값을 기준으로 아래 방향으로 이동하는 알고리즘이다.cost가 최소인 지점을 찾기 위해 수행하는 알고리즘으로 최소값이 유일해야 하므로 convex function에서만 적용이 가능하다. multi variable regressionweight와 x가 vector의 형태를 가진다. 파이썬에서 array를 선언할 때1A=[[x1(1), x2(2)], [x1(1), x2(2)], ...] 이런식으로 나열을 하면 이는 실제로는 다음과 같다. load data from file example123456import tensorflow as tfimport numpy as npxy = np.loadtxt(&apos;train.txt&apos;, unpack=True, dtype=&apos;float32&apos;)x_data = xy[0:-1]y_data = xy[]","link":"/2018/01/16/머신러닝강의 2강 - linear regression/"},{"title":"머신러닝강의 3강 - logistic classification","text":"logistic classificationLogistic Classification이란 무엇인가logistic classification이란 학습을 통해 특정 상황에 대한 선택지를 고르는 것이다.이 중에서 true or false 중 하나를 고르는 것을 binary classification 이라고 하는데, 본 글에서는 이러한 binary classification을 기준으로 학습한다.이러한 binary classification의 활용범위는 매우 넓은데, 가령 수신함의 메일이 스팸인지 아닌지를 구분한다던가, 페이스북과 같은 SNS 매체에서 특정 사용자의 타임라인에 어떤 게시물을 show 할것인지 혹은 hide 할 것인지를 결정하는 것은 이러한 binary classification을 활용한 것이라 할 수 있다. 이러한 binary classification의 활용도는 점차 높아지고 있으며, 신용카드 사용패턴을 분석하여 사기 거래인지 아닌지를 판단하거나 혹은 주식시장에서 특정 주식을 매입할 것인가 매도할 것인가를 결정짓는 중요한 역할을 담당할 수도 있다. 사실 이미 많은 사람들이 주식시장에 머신러닝을 활용하여 큰 수익을 내고 있는 사례가 있다. 이전 글에서의 linear regression과 같은 모델에서는 어떤 입력값의 정도에 따라 출력값을 정도가 변화하는 일종의 선형적인 관계를 나타내는 반면 이러한 의사결정 모델에서는 특정 임계치를 넘기는 순간 결과는 true로 그 정도가 달라지지 않기 때문에 linear regression 모델을 사용할 경우 많은 오차가 발생할 확률이 높아지게 된다. 아래 그림은 linear regression을 이러한 classification에 활용하였을 때 나타날 수 있는 문제를 보여준다.아래 그림과 같이 다양한 사례들을 통해 학습을 지속하면 어떤 임계치보다 상당히 큰 값이 입력으로 들어갈 경우 weight에 큰 영향을 주기 때문에 적당한 W 값을 찾는데에 큰 어려움이 발생하게 된다.가령 공부를 5시간만 해도 시험에 합격할 수 있는데, 어떤 학생이 공부를 100시간을 하고서 시험에 합격한 사례가 있을 경우 합격에 필요한 시험의 절대적인 공부시간이 실제보다 상당히 크게 예상할 수 있는 상황이 나타난다. logistic classification의 cost functionlinear regression과 마찬가지로 logistic classification의 경우에도 적합한 hypothesis가 필요해졌다.앞에서 설명한 바와 같이 linear regression에 도입된 hypothesis의 경우에 도입된 수식이 아닌 0~1 사이에서 좁게 움직일 수 있는 새로운 hypothesis를 위해 새로운 function이 필요하게 되었고, 이에 가장 적합한 sigmoid 함수로 이를 표현하기로 했다.sigmoid 함수의 경우 0을 기준으로 기울기가 급변하기 때문에 이러한 classification의 표현에 아주 적합한 모델이다. 아래는 sigmoid함수와 logistic classification에서의 hypothesis function 을 나타낸다. logistic classification에서의 hypothesis를 도출하기 위한 과정은 다음과 같다 이러한 sigmoid 기반의 hyphthesis의 cost를 구할 때에 기존처럼 차의 제곱을 도입하면 다음과 같은 문제가 생기게 된다.sigmoid의 exponential 부분에 의해 다음과 같이 그래프가 출러이게 되고, 각 부분마다 local minimum 값이 나오게 되어 gradient descent algorithm을 적용하면 cost의 최소값이 어디부터 시작하느냐에 따라 전체 함수의 최소값은 global minimum값이 아니라 local minimum으로 수렴할 가능성이 높아진다.아래 그림은 차의 제곱을 기반으로 한 linear regression 에서의 cost function 모델의 도입했을 때의 그래프 이다. 따라서 cost 함수도 바뀌어야 할 필요가 생기게 되었고 다음과 같은 새로운 cost function이 제시되었다. 이러한 새로운 cost function에서는 local minimum은 존재하지 않고 global minimum 값만 있기 때문에 gradient descent algorithm을 적용할 수 있게 된다.하지만 위와 같은 식에서는 python으로 코드를 만들 때 if 문을 계속해서 돌려줘야 하기 때문에 다음과 같은 식으로 변형한다.","link":"/2018/01/17/머신러닝강의 3강 - logistic-classification/"},{"title":"머신러닝강의 4강 - multinomial classification","text":"multinomial classification이란?저번 포스트에서는 logistic classification 중에서 binary classification에 대해서만 다루었으나, 오늘은 보다 많은 변수값을 기준으로 보다 많은 종류의 결과값들 중에서 선택을 하는 알고리즘인 multinomial classification에 대해 학습한다.가령 학생들의 시험성적의 경우 각 과목의 점수를 종합하여 전체 평점이 A~D 사이로 결정이 되는데, 이러한 복수의 결과값 중 하나를 선택하는 학습 알고리즘이다.다음 그림은 각 결과값을 위한 다양한 Weight 값을 종합으로 판단을 하는 것을 그림을 통해 보여주고 있다.각 결과값이 true이냐 혹은 false이냐를 결정짓는 Weight를 종합하여 hypothesis function을 만들어 낼 수 있다. 위 내용을 식과 다이어그램으로 표현하면 다음과 같다. 이는 matrix를 이용하여 간략하게 표현될 수 있다. 위와 같이 결과값의 예측값을 구하면 그 범위는 0에서 1사이의 구간이 아니라 많은 편차를 나타내게 된다.하지만, multinomial classification에서의 최대 관심사는 특정 입력값이 들어갔을 때에 결과적은 어떤 결과값이 선택되는 가에 대한 것이기 때문에, 특정 결과값이 나올 확률에 대한 궁금증을 가지기 시작했고 softmax 를 통해 결과값을 확률값으로 변환시켰다.softmax 함수와 그 방식은 다음과 같다. multinomial classification에서의 cost function / cross entry cost function위와 같은 softmax 함수를 통해 나온 값의 cost function을 구해 이를 최소화 시키는 gradient descent 알고리즘을 적용시키기 위해서 정확한 cost function을 구해야 할 필요가 생기게 되었고, 그 식은 일명 cross entry cost function이라 불리는 다음의 식을 따른다. 위 사례를 통해 위 식은 cost function가 충족해야 할 조건인 참인 경우 0 참이 아닌경우 무한대라는 조건을 훌륭하게 만족시키며, 비록 형태는 다르지만 binary classification에서의 cost function과 비교해 볼 때 특정 결과값의 요소만 반영하는 방식에 있어서 결국은 같은 형태의 식이다.","link":"/2018/01/18/머신러닝강의 4강 - multinomial-classification/"},{"title":"머신러닝강의 5강 - 머신러닝 테스트 및 정확도 향상의 방법론","text":"머신러닝의 정확도 적당한 learning rate의 선택 정확도 향상을 위한 data preprocessing overfitting 머신러닝의 정확도머신러닝에서의 정확도는 다양한 변인들에 의하여 판가름 난다.그 중 제일 큰 부분을 차지하는 변수는 바로 learning rate, data preprocessing, overfitting 이며 본 강의에서는 각 요소들이 어떻게 영향을 미치고 정확도를 개선 할 방법에 대해 알아본다. 적당한 learning rate의 선택learning rate는 gradient descent algorithm을 사용할 때에 학습이 진행됨에 따라 학습의 속도 혹은 변화도를 통제하는 변수이다.만약 learning rate이 너무 크다면 최저점을 찾을 때 1회 이동의 정도가 너무 크기 때문에 발산할 가능성 즉 overshooting의 위험이 있으며, 너무 작으면 속도가 매우 느린 단점이 있다. 정확도 향상을 위한 data preprocessing만약 입력받은 두 종류의 변수의 크기 차이가 심한 경우 이는 학습에 큰 영향을 미칠 수 있기 때문에 학습 전에 data preprocessing을 거쳐 정확도를 높일 수 있으며, 흔히 normalize라고 불리는 정규화 작업을 거친 뒤 학습을 하게 된다. 이러한 standardize를 위한 수식은 다음과 같다. overfittingoverfitting이란 학습된 결과가 학습을 위한 데이터에 너무 맞추어져 있는 것을 의미한다.이는 주로 적은 수의 학습데이터가 주어져 있을 경우 발생하기 쉬운데, 넓은 범위의 학습데이터가 아니기 때문에 해당 학습데이터에 치우친 결과값이 나와 정확도가 떨어지는 측면이 있다.이러한 overfitting을 해결하기 위해서는 먼저 충분한 양의 학습데이터를 확보를 하고, 학습하는 feature의 수를 줄이는 것, 또 regularization을 하는 것이 도움이 된다.","link":"/2018/01/24/머신러닝강의 5강 - 머신러닝-테스트-및-정확도-향상의-방법론/"},{"title":"스타트업 초기 마케팅","text":"스타트업 초기 마케팅서비스 초기의 스타트업에게 가장 어려운 부분 중 하나는 바로 효과적인 마케팅을 하는 것이다.최근의 마케팅 트렌드는 SNS를 활용한 컨텐츠 유포를 통한 바이럴 마케팅 인데, 충분하지 못한 자금과 인력을 가진 스타트업에게는 이러한 콘텐츠 하나를 제작하는 것 마저 큰 부담이 된다.이렇듯 충분치 못한 자금과 인력으로도 운영 가능한 훌륭한 여러가지 마케팅 방법들을 소개한다. 1. 블로그 마케팅블로그를 활용한 마케팅은 이미 활성화되어 있는 플랫폼의 블로그 기능을 이용하여 사용자들의 유입을 도모하는 것이다.이러한 블로그 마케팅을 해 나감에 있어 핵심적인 요소는 바로 훌륭한 컨텐츠의 생산이다.아무리 블로그 운영에 비용이 들지 않는다고 하더라고 훌륭한 컨텐츠가 제작되지 않는다면 유입률이 보장되지 않으며, 블로그의 경우 사람들이 쉽게 구독을 하지 않으므로 오히려 SNS 채널에 비해 손도 많이가고 지속적인 유입도 확보하기 힘들다. 대부분의 블로그 방문의 경우 유입 경로는 검색포털에서의 검색으로 사람들이 많이 검색을 하는 키워드가 포함된 글의 경우 유입이 높을 수 있다.판매하는 제품이 온라인에서 많이 검색되는 키워드인 경우 이러한 블로그 마케팅이 효과를 볼 수 있다. 검색을 통한 유입을 위해 반드시 핫한 키워드를 텍스트에 담는 것 이 매우 중요하다. 블로그의 경우 네이버, 다음 등에서 상위 5개 노출이 핵심이며 그 외의 글들을 사실상 노출되지 않기 때문에 블로그를 활용한 마케팅을 위해서는 지속적으로 포스트를 하며 상위 노출을 시켜야 한다.이처럼 블로그는 검색을 기반으로 하여 유입이 이루어 지기 때문에 최대한 핫한 키워드를 잘 캐치하여 이를 제목 및 본문에 잘 녹여내어야 높은 노출효과를 볼 수 있다.많은 스타트업들의 경우 자신들의 제품을 알리기 위해 정말 제품과 서비스에 대한 상세한 정보를 담으려고 노력하지만 이런식의 포스팅은 검색량이 매우 적기 때문에 높은 노출효과를 보기는 어렵다. 즉, 블로그 마케팅의 핵심은 검색량이 많은 주요 키워드를 잘 선정하는 것이다.이를 위해 네이버 광고, M-자비스 등의 서비스를 이용하여 광고 키워드를 선별한 뒤에 검색하여 나온 컨텐츠를 면밀히 살펴본 뒤 사람들이 흥미를 느끼는 핵심 키워드를 찾아 정리한 뒤에 이 키워드를 기반으로 포스팅을 하면 높은 노출효과를 얻을 수 있다. 2. 커뮤니티를 통한 마케팅판매하는 제품과 관련이 있는 커뮤니티 그룹에 홍보 글을 올리는 것이다.블로그와 마찬가지로 돈이 들지 않고 일정 정도 이상의 유입이 반드시 보장되지만, 계속 홍보성 글을 올리는 경우 커뮤니티 원들 사이에 좋지 않은 이미지가 확산 될 수 있고, 장기적으로 보면 브랜드 이미지를 해칠 수 있기 때문에 해당 커뮤니티의 분위기에 맞게 간접적으로 홍보할 수 있는 글을 지속적으로 올리는 것이 바람직하다. 커뮤니티 목록클리앙SLR 클럽루리웹뽐뿌네이트판디시인사이드리뷰리퍼블릭 참고 - 벤처스퀘어참고 - 브런치 / 초기 스타트업의 무료 마케팅 채널","link":"/2018/01/31/스타트업-초기-마케팅/"},{"title":"시장 분석 방법론","text":"거시 환경 분석 미시 환경 분석 거시 환경 분석사업계획서를 작성하거나 혹은 마케팅 전략을 수립함에 있어 중요한 절차 중 하나는 바로 시장 분석이다.시장의 정치 경제 사회적 상황을 분석하는 것은 비즈니스에 대한 직관을 심어주고 성공의 유무를 판가름 하는 핵심적인 요소이다. 가령 AirBnb의 경우는 사업 초기에 법적인 문제를 겪었는데, 거주지 공유 서비스가 불법 임대업에 해당한다는 국가의 규제가 있었기 때문이다.하지만 AirBnb의 사업이 확장하면서 대부분의 국가에서는 자신의 아파트는 연 90일 이하로 임대할 수 있는 규정 등 다양한 완화 법규를 통과시키면서 AirBnb는 법적 대응에 맞설 수 있었다. 경제적인 요소에 있어서 2008년의 경제위기로 인해 많은 사람들이 여행에 적은 돈을 지출하는 현상이 나타났는데, 서비스업을 포함하여 대부분의 사람들이 더 저렴한 숙소를 원하게 되었는데, AirBnb는 공유업에 기반한 숙소를 제공하기 때문에 비교적 매우 저렴한 숙소를 공급할 수 있었기에 이러한 수요를 잘 만족시켰다.만약, AirBnb가 출범할 때의 경기가 매우 호황이었고, 각종 서비스업이 각광받는 시기였다면, AirBnb의 사업성공은 그리 쉬운 일이 아니었을 수도 있다. 경제위기라는 상황에서 저렴한 숙소를 찾아다니는 고객들이 있었고, 자연스레 이런 수요를 만족시키면서 사업을 성장시킬 수 있었다. 또, 이러한 경제위기는 ‘공유 경제’라는 새로운 개념을 탄생시켰는데, 요즘 시대에는 개인이 자신의 자신을 다른 사람에게 아주 저렴한 가격으로 임대해 주는 현상이 점점 더 많이 나타나고 있으며, AirBnb는 이러한 사회적 분위기에 편승하여 빠르게 성장할 수 있었다.공유경제에 기반한 많은 서비들이 아직도 새롭게 생겨나고 있으며, 그 시장은 빠르게 성장하고 있다. 사회적 요소에 있어서는 소셜 네트워크가 사람들의 삶에 아주 큰 영향을 미치는 현상이다. 수많은 사람들이 SNS에서 활동하며 공유경제 트렌드에 힘입어 사람들은 SNS를 통해서 수익을 창출하고 자신의 독자적인 비즈니스를 수행할 수 있기를 원했고, AirBnb는 좋은 창구가 되어 주었다. 과거 사람과 비즈니스가 구분이 되었다면 요즘 시대에는 사람 자체가 비즈니스가 되는 사회에서 살고 있다고 창립주 브라이언 체스키는 말한다. 기술적 요소에 있어서 스마트폰과 태블릿이라는 새로운 플랫폼이 급부상 하여 언제 어디에서든지 새로운 숙소를 예약할 수 있는 환경을 만들어 주었다. 미시 환경 분석_공급자의 교섭력플랫폼에 있어서 AirBnb는 공급자를 먼저 끌어들였으므로, 공급자들을 일종의 교섭력을 가진다.공급자에게 있어서도 AirBnb는 자신의 비즈니스를 홍보할 최고의 플랫폼이기에 공급자들은 계속해서 모여들며, 자신들이 플랫폼 내의 다른 공급자들과 경쟁하며 가격을 책정하기 때문에 좋은 선순환이 일어날 수 있다. 소비자 교섭력비즈니스의 성공과 평판이 고객으로 부터 나오는 만큼 고객의 권위는 막강하다. 많은 사용자들이 SNS나 포럼에서 고객경험을 공유하고 평판에 기여를 하기 때문에 고객은 아주 중요하다. 하짐나 점점 고객의 영향력은 낮아질 수 밖에 없는데 브랜드가 성장함에 따라 최고의 공급자들은 자연스럽게 AirBnb 플랫폼에 참여할 수 밖에 없고, 대부분의 사용자들도 이에 따라 플랫폼에 귀착될 수 밖에 없다. 진입장벽AirBnb가 만든 진입장벽의 핵심 요인은 높은 시장 점유율을 기반으로 한 막강한 마케팅 리소스를 가진것이다.last mover effect가 막강하다. 경쟁자경쟁자에 대해 분석한다.","link":"/2018/01/06/시장-분석-방법론/"},{"title":"여행산업의 모바일화가 우리에게 시사하는 점","text":"여행 산업의 모바일화가 우리에게 시사하는 점여행 상품, 이제는 모바일에서 더 많이 구매한다인터파크 투어는 최근 모바일 거래 비중이 60%를 넘어서며 오프라인 시장을 역전했다.뿐만 아니라 여행 전 꼭 거치는 환전 역시 이미 오프라인을 넘어서고 있다. 전통적인 오프라인 비즈니스의 대명사인 여행산업 마저 모바일 시대의 흐름에 변혁이 일어나고 있는 것이다. 또, 여행을 가서도 모든 일정과 맛집, 여행지 정보를 스마트폰을 통해 얻고 있으니 가히 ‘모바일 여행 시대’가 열렸다고 해도 무방할 것이다. SNS를 통한 여행지 공유, 관광상품 마케팅의 최전선으로 부상많은 사람들이 오프라인이 아닌 온라인 상에서 여행 상품을 검색하고 항공권, 숙박 시설, 환전까지 모든 부분을 모바일에서 해결하고 있다.이에따라 많은 항공사와 여행사들은 기존의 TV광고, 지하철 내 광고보다 SNS를 통한 활발한 마케팅에 열을 올리고 있다. 이렇게 SNS 상에서 인기가 높은 여행지들은 폭발적인 매출의 증가로 이루어 지는데한 예로 인스타그램 해시태그 4만개를 돌파한 인천 네스트 호텔과 2만 5000개를 넘긴 제주 히든 클리프 호텔의 경우 예약률이 평균 17~31%까지 치솟았다. 모바일 시대를 대비한 여행사의 새로운 패키지 상품대부분의 사람들이 SNS 등의 매체를 통해 여행지를 결정하고 있으므로, 많은 여행사들은 아예 이런 SNS 마니아 층을 겨냥한 새로운 패키지 상품을 출시하고 있다.실제로 이러한 패키지 상품은 태그, 댓글 등 자발적인 바이럴 마케팅 효과를 거두고 있으며, 매출도 상당히 높은 편이다. SNS의 핵심은 무엇인가SNS의 핵심은 무엇인가에 대한 질문에 두가지 답을 내놓는다.첫째는 허영심, 둘째는 과시욕이다.원래 SNS의 시초는 나와 내 주변 사람들의 소식을 듣고 소통하는 용도였으나, 이는 오프라인과 마찬가지로 각종 허례허식을 만들어 내었다.사실 우리가 일상의 살면서 만나는 다양한 사람들과의 관계에는 기본적으로 ‘잘보이고자 하는 욕망’을 내재한다.오랜만에 보는 동창회에는 가장 예쁘고 멋진 옷을 입고, 잘 빠진 차를 타고 가고 싶어하는 것이 인간의 허영이다.이러한 인간의 욕망은 ‘온라인 세계’라는 가상의 세계에서 그 빛을 발하고 있다.온라인 세계에서는 손쉽게 나의 ‘페르소나’를 바꿀 수 있고, 온라인 상에서 만나는 모든 사람들에게 나의 매력적이고 ‘잘 나가는’ 모습을 보여주고자 한다. 이러한 욕망을 기반으로 다양한 서비스가 성행하게 되었는데, ‘아프리카 TV의 별풍선’, ‘잘나가는 헬스 트레이너 에게 트레이닝 받기’ 처럼 남들에게 인정받는 셀럽들에게 관심을 주고, 그 사람과 온라인 상에서 관계를 맺게 도됨으로써 온라인에서의 자신의 사회적 입지를 올리고자 하는 열망을 반영한다. 이러한 SNS의 특성을 이해한다면, 우리는 사용자들의 공감을 살 수 있고, 새로운 비즈니스 기회를 발견할 수 있다. 우리는 어떻게 해야 하는가이러한 SNS 를 통한 여행사들의 마케팅 방향에 대해서는 생각할 점이 많다.여행사들이 꼼꼼히 정보를 수집하고 각종 여행 자료를 바탕으로 선정하는 여행지 보다 SNS 상에 유포되는 핫한 여행지들이 더욱 신빙성을 가지고 큰 영향력을 가진다는 사실을 우리는 인정해야 한다.한켠으로는 정말 제대로된 정보에 기반하지 않고 단지 SNS상의 이슈화를 통해 매출 증대를 노리려는 약은 여행사들이 대거로 출현할 것인가 하는 우려도 있지만, SNS 시대에서 사람들의 마음을 울릴 다양한 컨텐츠를 개발하고 SNS라는 누구나 접근 가능한 매체를 통해 큰 영향력을 발휘할 수 있게 됨으로써 작은 여행사들은 거대 여행사들에 대항할 힘을 가지게 되었다. 이러한 풍조는 ‘인터넷’이 추구하는 방향과 그 행로가 일치하는데, 모든 개개인들이 거대 권력에 대항할 큰 힘을 가지게 되었다는 점에서 그러하다.앞으로의 모바일 사회에서 우리는 SNS 를 기반으로 하는 새로운 시장의 원리를 받아들이고 대중을 공감할 훌륭한 SNS 컨텐츠의 개발을 바탕으로 경쟁력을 갖추어 나간다면, 거대 자본을 기반으로 하는 여행산업에서 새로운 비즈니스의 기회를 포착할 수 있을 것이다.","link":"/2017/11/22/여행산업의-모바일화가-우리에게-시사하는-점/"},{"title":"영화 인썸니아(Insomnia)","text":"살면서 누구나 한번쯤은 돌이킬 수 없는 잘못된 결정으로 인한 실수를 진실을 왜곡함으로써 해결하고 싶은 강한 욕망에 휩싸이는 순간이 있다.가장 사소한 예로, 학창시절 선생님이 교실에서 어떤 잘못을 저지른 사람에게 자백을 요구하는 훈계를 듣는 경우는 사실 누구나 한번쯤은 있었던 경험일 것이다. 나는 항상 그 상황에서 진짜 잘못을 저지른 사람은 어떤 마음일까 하는 생각을 하고 했다. 그 상황이 나에게는 그저 귀찮은 일인 반면 그 당사자에게는 얼마나 큰 마음의 짐이 될까를 생각해보면 생각만으로도 암담한 일이 아닐 수 없었다. 인간은 누구나 실수를 하기에 많은 사람들이 이런 욕망에 휩싸일 수 있고, 두가지 선택지만을 가진다. 진실을 밝히는가 혹은 진실을 숨기는가. 많은 경우에 전자의 선택지는 너무도 큰 희생이 필요할 수 있다. 내가 일생동안 살아온 나의 신념을 배반하는 감당할 수 없는 실수로 내 인생을 송두리 째 바꾸어 놓을 것만 같고, 다시는 회생할 수 없을 것 같은 암담한 미래가 그려진다. 반면, 두번째 선택지는 너무도 달콤하다. 나의 실수를 없던 것으로 하는것. 그것은 마치 시간을 되돌리는 것처럼 단 한번만 진실을 감추면 모든 문제가 해결 될 것만 같다. 사실 이런 이야기는 영화나 책속에나 나올법 한 일이라고 생각할 수 있지만, 사실 사회의 많은 곳들에서 흔히 일어나는 일중 하나이다. 대부분의 부패한 정치인 혹은 기업가, 범죄자들도 많은 경우 선량하고 옳바른 선택을 할 수 있었던 시절이 있었을 것이라 생각하고 또 누군가는 과거의 단 한번의 잘못된 처신을 평생을 후회하며 열심히 살아가고 있을지도 모른다. 이 영화는 그런 감당할수 없을 것 같은 실수에 대처하는 한 잘나가던 경찰의 이야기를 다룬다.평생을 신념에 입각해서 살았고, 훌륭한 경찰로 살았지만, 단 한번의 선택으로 최악의 상황으로 치닫게 되며, 그러한 심적 부담과 ‘백야’ 라는 극중 설정으로 인해 불면증을 않아 점점 더 판단력을 잃어간다.이러한 설정은 현실의 상황을 너무도 잘 반영한다. 진실을 은닉한 것에 대한 엄청난 마음의 부담은 그 사람에게 제대로된 판단을 할 힘을 앗아가고 결국 거짓의 구렁텅이로 빠져버리게 되는 것이다. 결국 영화는 우리가 살면서 겪을 이런 상황들에 대한 가장 쉽고 유일한 선택지를 제시하고 있다. 그것은 바로 “모든 진실을 밝히고 실수를 감내하는 것” 그리고 “최악의 상황에서도 옳바르게 행동할 판단력을 잃지 않는것”이다. 그 어떤 순간에서도 한치앞의 달콤한 유혹을 뿌리치고 진실로 삶을대하는 것이 남은 인생을 위한 최고의 선택지이며, 실수를 할 수 밖에 없는 인간으로써 모든 결정적인 실수에 대한 책임을 감내하고 살아야 하는 것은 인간의 숙명이기에 최악의 상황에서도 판단력을 잃지않고 올바른 선택을 할 수 있는 용기와 힘을 가지도록 노력해야 할 것이다.","link":"/2018/05/13/영화-인썸니아-insomnia/"},{"title":"운영체제 | 파일 시스템 구현","text":"파일 시스템 구현 디렉터리 구현 선형 리스트 해시 테이블 디스크 할당 연속 할당 연결 할당 색인 할당 파일 시스템 구현운영체제는 파일 내용에 대한 접근을 요청하는 프로세스를 위해 open()과 close() 시스템 호출을 구현합니다.본 장에서는 파일 시스템 연산을 구현하는데 사용되는 구조와 연산에 대해 알아봅시다. 다음 그림은 파일 시스템에서 디스크 와 메모리 에 어떤 정보들이 들어있는지를 나타내 줍니다. 디렉터리 구현선형 리스트 해시 테이블 디스크 할당연속 할당 연결 할당 색인 할당","link":"/2018/04/23/운영체제-파일-시스템-구현/"},{"title":"운영체제 | 파일 시스템 인터페이스","text":"디렉터리 구조 Single Level Directory Two Level Directory Tree Structured Directory 디렉터리 구조Single Level Directory Two Level Directory Tree Structured Directory","link":"/2018/04/23/운영체제-파일-시스템-인터페이스/"},{"title":"웹 어플리케이션 제작에 필요한 기본 DB 구성","text":"기본 db 세팅123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960create database angular;use angular;CREATE TABLE `tb_airport` ( `AIRPORT_ID` int(11) NOT NULL AUTO_INCREMENT, `AIRPORT_NM` varchar(45) DEFAULT NULL, `CONTINENT` varchar(45) DEFAULT NULL, `NATION` varchar(45) DEFAULT NULL, `CITY` varchar(45) DEFAULT NULL, PRIMARY KEY (`AIRPORT_ID`)) ENGINE=InnoDB AUTO_INCREMENT=70 DEFAULT CHARSET=utf8;CREATE TABLE `tb_ticket` ( `TICKET_ID` int(11) NOT NULL AUTO_INCREMENT, `TICKET_NM` varchar(100) DEFAULT NULL, `TICKET_PRICE` int(11) DEFAULT NULL, `TICKET_DEPARTURE` varchar(45) DEFAULT NULL, `TICKET_ARRIVAL` varchar(45) DEFAULT NULL, `TICKET_DEPARTURE_TIME` varchar(45) DEFAULT NULL, `TICKET_ARRIVAL_TIME` varchar(45) DEFAULT NULL, `TICKET_DEPARTURE_DT` varchar(45) DEFAULT NULL, `TICKET_ARRIVAL_DT` varchar(45) DEFAULT NULL, `CRE_DT` varchar(45) DEFAULT NULL, PRIMARY KEY (`TICKET_ID`)) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8;CREATE TABLE `tb_usage` ( `USAGE_ID` int(11) NOT NULL AUTO_INCREMENT, `USER_EMAIL` varchar(45) DEFAULT NULL, `USER_NM` varchar(45) DEFAULT NULL, `USER_ENG_NM` varchar(45) DEFAULT NULL, `USAGE_PHONE` varchar(45) DEFAULT NULL, `USAGE_ENTITY` int(11) DEFAULT NULL, `USAGE_STATUS` varchar(6) DEFAULT NULL COMMENT &apos;003001 신청완료(입금대기)\\n003002 입금완료\\n003003 환불대기\\n003004 환불완료\\n003005 종료&apos;, `USAGE_NATION` varchar(45) DEFAULT NULL COMMENT &apos;도착 국가&apos;, `USAGE_CITY` varchar(45) DEFAULT NULL, `USAGE_DEPARTURE_CITY` varchar(45) DEFAULT NULL COMMENT &apos;출발 도시&apos;, `USAGE_DEPARTURE_DT` varchar(45) DEFAULT NULL, `USAGE_ARRIVAL_DT` varchar(45) DEFAULT NULL COMMENT &apos;도착일&apos;, `USAGE_MEMO` text, `CRE_DT` varchar(45) DEFAULT NULL, PRIMARY KEY (`USAGE_ID`)) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;CREATE TABLE `tb_wishlist` ( `WL_ID` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=latin1;CREATE TABLE `tb_user` ( `USER_EMAIL` varchar(100) CHARACTER SET latin1 NOT NULL, `USER_PWD` varchar(100) DEFAULT NULL, `USER_TYPE` varchar(6) DEFAULT NULL COMMENT &apos;002001 일반 회원\\n002002 어드민\\n&apos;, `USER_NM` varchar(45) DEFAULT NULL, `USER_ENG_NM` varchar(45) DEFAULT NULL, `USER_GENDER` varchar(45) DEFAULT NULL, `USER_BIRTHDAY` varchar(100) DEFAULT NULL, `USER_PHONE` varchar(45) DEFAULT NULL, `USER_USING_FREQ` int(11) DEFAULT NULL, `CRE_DT` varchar(45) DEFAULT NULL, PRIMARY KEY (`USER_EMAIL`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","link":"/2017/11/17/웹-어플리케이션-제작에-필요한-기본-DB-구성/"},{"title":"이더리움 crowd sale","text":"토큰 생성123456789101112131415161718192021222324252627pragma solidity ^0.4.20;contract MyToken &#123; event Transfer(address indexed from, address indexed to, uint256 value); /* This creates an array with all balances */ mapping (address =&gt; uint256) public balanceOf; string public name; string public symbol; uint8 public decimals; /* Initializes contract with initial supply tokens to the creator of the contract */ function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public &#123; balanceOf[msg.sender] = initialSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes decimals = decimalUnits; // Amount of decimals for display purposes &#125; /* Send coins */ function transfer(address _to, uint256 _value) public &#123; require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // Check for overflows balanceOf[msg.sender] -= _value; // Subtract from the sender balanceOf[_to] += _value; // Add the same to the recipient /* Notify anyone listening that this transfer took place */ emit Transfer(msg.sender, _to, _value); &#125;&#125; 먼저 crowd sale을 진행하기 전에 crowd sale에서 사용할 토큰을 생성하고, crowd sale의 shares address에 등록해 준다. crowd sale contract123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899pragma solidity ^0.4.16;interface token &#123; function transfer(address receiver, uint amount) external;&#125;contract Crowdsale &#123; address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; //마감 기한 uint public price; token public tokenReward; mapping(address =&gt; uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); /** * Constructor function * * Setup the owner */ function Crowdsale( address ifSuccessfulSendTo, // uint fundingGoalInEthers, //이더 단위의 모금 목표액 uint durationInMinutes, //분 단위의 모금 기간 uint etherCostOfEachToken, //각 토큰 당 단위 가격(이더 기준) address addressOfTokenUsedAsReward //모금의 보상으로 주어질 위에서 만든 토큰의 주소 ) public &#123; beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = etherCostOfEachToken * 1 ether; tokenReward = token(addressOfTokenUsedAsReward); &#125; /** * Fallback function * * The function without name is the default function that is called whenever anyone sends funds to a contract */ function () payable public &#123; require(!crowdsaleClosed); uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; tokenReward.transfer(msg.sender, amount / price); emit FundTransfer(msg.sender, amount, true); &#125; modifier afterDeadline() &#123; if (now &gt;= deadline) _; &#125; /** * Check if goal was reached * * Checks if the goal or time limit has been reached and ends the campaign */ function checkGoalReached() afterDeadline public &#123; if (amountRaised &gt;= fundingGoal)&#123; fundingGoalReached = true; emit GoalReached(beneficiary, amountRaised); &#125; crowdsaleClosed = true; &#125; /** * Withdraw the funds * * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached, * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw * the amount they contributed. */ function safeWithdrawal() afterDeadline public &#123; if (!fundingGoalReached) &#123; uint amount = balanceOf[msg.sender]; balanceOf[msg.sender] = 0; if (amount &gt; 0) &#123; if (msg.sender.send(amount)) &#123; emit FundTransfer(msg.sender, amount, false); &#125; else &#123; balanceOf[msg.sender] = amount; &#125; &#125; &#125; if (fundingGoalReached &amp;&amp; beneficiary == msg.sender) &#123; if (beneficiary.send(amountRaised)) &#123; emit FundTransfer(beneficiary, amountRaised, false); &#125; else &#123; //If we fail to send the funds to beneficiary, unlock funders balance fundingGoalReached = false; &#125; &#125; &#125;&#125;","link":"/2018/05/11/이더리움-crowd-sale/"},{"title":"이더리움 Greeter 만들기","text":"Greeter Contract 만들기Greeter.sol 12345678910111213141516171819202122232425contract Mortal &#123; /* Define variable owner of the type address */ address owner; /* This function is executed at initialization and sets the owner of the contract */ function Mortal() &#123; owner = msg.sender; &#125; /* Function to recover the funds on the contract */ function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125;&#125;contract Greeter is Mortal &#123; /* Define variable greeting of the type string */ string greeting; /* This runs when the contract is executed */ function Greeter(string _greeting) public &#123; greeting = _greeting; &#125; /* Main function */ function greet() constant returns (string) &#123; return greeting; &#125;&#125; solidity compiler 설치 및 컴파일 하기solcjs 설치하기1npm install -g solc 컴파일 하기1solcjs -o target --bin --abi Greeter.sol js 스크립트 작성main.js1234567891011121314151617181920var greeterFactory = eth.contract(&lt;contents of the file Greeter.abi&gt;)var greeterCompiled = &quot;0x&quot; + &quot;&lt;contents of the file Greeter.bin&gt;&quot;var _greeting = &quot;Hello World!&quot;var greeter = greeterFactory.new(_greeting,&#123;from:eth.accounts[0],data:greeterCompiled,gas:47000000&#125;, function(e, contract)&#123; if(e) &#123; console.error(e); // If something goes wrong, at least we&apos;ll know. return; &#125; if(!contract.address) &#123; console.log(&quot;Contract transaction send: TransactionHash: &quot; + contract.transactionHash + &quot; waiting to be mined...&quot;); &#125; else &#123; console.log(&quot;Contract mined! Address: &quot; + contract.address); console.log(contract); &#125;&#125;) geth console 에서 스크립트 실행1loadScript(&quot;main.js&quot;) 채굴 시작 및 greeter 실행1miner.start() 채굴이 완료되면 contract에 address가 부여되고 계약이 발행된다. 이제는 블록체인 상에 greeter라는 봇이 생성되었으므로 다음과 같이 자유롭게 호출하여 사용이 가능하다. 1greeter.greet();","link":"/2018/05/09/이더리움-greeter-만들기/"},{"title":"자료구조 강의 01. 기본 개념","text":"개요: 시스템 생명 주기 포인터와 동적 메모리 할당 알고리즘 명세 데이터 추상화 성능 분석 공간 복잡도 시간 복잡도 개요: 시스템 생명 주기포인터와 동적 메모리 할당알고리즘 명세데이터 추상화성능 분석본 강의의 목적 중 하나는 프로그램에 대한 평가 능력을 향상시키는 것이다.프로그램의 판단함에 있어서 다양한 기준이 있지만, 크게는 컴퓨터와 상관 없이 시공간의 추산에 초점을 두는 성능 분석(performance analysis) 과 컴퓨터에 의존적인 실행 시간을 얻어내는 성능 측정(performance measurement) 이 있다. 이번 강의 에서는 성능 측정은 배제하고 성능 분석에 초점을 두어 강의를 진행하며 성능 분석은 다음의 두 복잡도로 분석을 진행한다. 공간 복잡도 시간 복잡도 공간 복잡도공간 복잡도의 정의는 프로그램을 실행시켜 완료하는 데 필요로 하는 공간의 양으로, 실제 메모리를 차지하는 양을 나타낸다. 각 각의 변수가 얼마나 많은 메모리를 차지하는 지 등을 다루며 이러한 공간 복잡도는 고정 공간 요구 및 가변 공간 요구 로 나뉘게 된다. 고정 공간 요구프로그램 입출력의 횟수나 크기에 관계없는 공간 요구를 의미한다.가령 명렁어 공간, 단순 변수, 상수 고정 크기의 구조화 변수 등을 포함한다. 가변 공간 요구해결하고자 하는 문제의 특정 인스턴스 I에 의존하는 크기를 가진 구조화 변수들을 위해 필요로 하는 공간이다. 시간 복잡도컴파일 시간과 실행 시간을 합한 것이다.","link":"/2018/03/27/자료구조-강의-01-기본-개념/"},{"title":"이더리움 시작하기","text":"블록체인이란?블록체인이란 수정 불가능한 분산형 원장을 의미하며, 특정 정보의 목록이 다수의 컴퓨터에 동시에 저장되고 수정될 수 있는 시스템을 의미합니다.기존의 시스템은 단일 서버에 모든 정보가 저장되기 때문에 서비스 사용자들이 정보를 알 수 없고, 기업이나 혹은 악한 의도를 가진 사용자에 의해 플랫폼이 훼손될 수 있어 안전하지 못했다면, 블록체인은 수정이 불가능하기 때문에 신뢰할 수 있는 특징이 있습니다. 이러한 블록체인은 반드시 BFT를 가져야 하는데 기본 개념이더리움에서의 기본 단위는 account 이며 이러한 account는 다음과 같이 두 종류로 나뉘게 됩니다. EOA(External Owned Account) Countract Account 여기서 EOA란 계정정보를 포함한 계약을 의미하며 외부 사용자가 private key 를 통해 제어합니다.이러한 EOA 는 Contract Account의 내부 함수들을 사용할 수 있으며 Contract Account의 내부 함수들은 오직 EOA에 의해서만 호출될 수 있습니다. Install ethereum command line interface (Ethereum CLI) 윈도우 go-ethereum(geth) 다운로드다운로드 geth 실행 1geth console 테스트 네트워크 구축하기 genesis.json 생성하기 12345678910111213141516&#123; &quot;config&quot;: &#123; &quot;chainId&quot;: 15, &quot;homesteadBlock&quot;: 0, &quot;eip155Block&quot;: 0, &quot;eip158Block&quot;: 0 &#125;, &quot;difficulty&quot;: &quot;20&quot;, &quot;gasLimit&quot;: &quot;2100000&quot;, &quot;alloc&quot;: &#123; &quot;7df9a875a174b3bc565e6424a0050ebc1b2d1d82&quot;: &#123; &quot;balance&quot;: &quot;300000&quot; &#125;, &quot;f41c74c9ae680c1aa78f42e5647a62f353b7bdde&quot;: &#123; &quot;balance&quot;: &quot;400000&quot; &#125; &#125;&#125; 블록체인 초기화 하기 1geth init genesis.json --datadir ethereum_private geth console 로 geth 노드 열기 1geth --networkid 123 --datadir ethereum_private console account 만들기 1personal.newAccount(&quot;testuser1&quot;) mining 시작하기 1miner.start() 자신이 위치한 노드 확인하기 1admin.nodeInfo.enode 다른 노드 연결하기위에서 받은 nodeurl을 받아 다른 클라이언트에서 다음 명령어를 실행한다. 1admin.addPeer(&quot;_nodeurl_&quot;) 이를 통해 노드와 노드가 연결될 수 있다. 다른 클라이언트들의 로그 확인1geth console 2&gt;&gt;geth.log 참조 블로그 이더리움 공식 가이드 geth 명령어geth 가동 123geth --datadir ~/.ethereum_private init ~/dev/genesis.jsongeth --fast --cache 512 --ipcpath ~/Library/Ethereum/geth.ipc --networkid 1234 --datadir ~/.ethereum_private console 계좌 생성12personal.newAccount(&quot;testuser1&quot;)personal.newAccount(&quot;testuser2&quot;) 계좌 확인1eth.accounts 잔고 확인1eth.getBalance(eth.accounts[0]) 블록 수 확인1eth.blockNumber 채굴 시작하기1miner.start() 채굴 정지1miner.stop() 트랜잭션 발행12345678eth.sendTransaction(&#123;from: &apos;id&apos;, to:&apos;id&apos;, value:web3.toWei(1,&quot;ether&quot;)&#125;)please unlocak account idoreth.sendTransaction(&#123;from:eth.accounts[0], to:eth.accounts[1], value:web3.toWei(1,&quot;ether&quot;)&#125;)트랜잭션 발행하는 계좌의 암호를 입력 geth 기동12mkdir eth_datageth --networkid &quot;123&quot; --rpc --rpcaddr &quot;222.239.251.75&quot; --rpcport 8545 --rpccorsdomain &quot;*&quot; --rpcapi &quot;net,eth,web3,personal&quot; --datadir &quot;eth_data&quot; --olympic console 기본 원리proof of work -&gt; 어려운 문제를 푼 사람이 토큰을 가져간다.풀기는 어렵지만 증명은 쉬운 해쉬를 사용한다. 컴퓨터는 nonce에 무작위값을 계속 대입하여 해쉬를 풀고 이를 mining 이라고 한다.mine이 된 이후에는 점점 난이도가 올라간다. 이더리움의 활용이더리움은 개인과 개인간의 약속에 기반한 모든 경제적 모델을 온라인 상에서 도입하는 것을 매우 간편하게 만들어 준다.가령 국가가 특정 공약을 내세우고 이를 위한 자금을 이더리움에서 모금한다고 하면, 해당 공약이 이루어지지 않을 경우 스마트 계약에 따라 참여자에게 돈이 재분배 되게 되는 방식을 사용하는 예처럼 스스로에게 약속 불이행시 제약을 둠으로써 신뢰도 높은 거래를 할 수 있다. 즉, 이더리움은 실제 경제모델과 정치모델을 모두 온라인 상에서 신뢰도있게 구현이 가능하다는 측면에서 그 가치가 높다.","link":"/2018/05/06/이더리움-시작하기/"},{"title":"자료구조 | B-트리","text":"m-원 탐색트리란 무엇인가?B-트리를 배우기 전에 그 근본 개념이 되는 m-원 탐색트리에 대해 알아봅시다.기존의 이진 탐색트리 에서 균형 이진 탐색트리인 AVL 트리의 경우 n 개의 노드에 대해서 깊이가 최소 logn에 가깝기 때문에, 실제 시스템에서 AVL 구조로 저장된 데이터에 접근하기 위해서는 만약 모든 노드가 다른 메모리 안에 들어 있다면 최악의 경우 logn번 만큼 메모리 혹은 디스크에 접근을 해야 했습니다. 이렇게 수 차례에 걸쳐 메모리 혹은 디스크에 접근하는 것은 치명적인 탐색 시간 상승을 야기했고, 이에 탐색 트리의 높이를 줄여 탐색시간을 줄이기 위한 많은 노력들이 있었고, 이를 위해서는 필수적으로 트리의 차수가 증가 해야 했습니다. m-원 탐색트리는 m개의 차수를 가지는 노드들로 구성된 트리이며, 실제로는 트리 노드들이 하나의 캐시 블록이나 디스크 블록을 체울 수 있는 가장 큰 차수를 사용하고 있습니다. m-원 탐색트리의 정의는 다음과 같습니다. m-원 탐색트리의 정의 m-원 탐색트리의 예시 B-트리란?B-트리는 이러한 m-원 탐색트리의 일종이며 다음과 같이 정의됩니다. 차수가 m인 B-트리의 정의 B-트리의 예시 B-트리의 삽입 B-트리의 삭제키가 x인 노드를 삭제하려고 할 때, x가 리프가 아닌 노드 z에서 발견될 경우, z에서 x가 차지하던 자리는 B-트리의 리프 노드로 부터 적당한 키로 채워진다. 가령 x가 그의 i번째 키라고 하면, E_i는 서브트리 A_i 내의 가장 작은 원소 혹은 서브트리 A_(i-1)의 가장 큰 원소로 채워질 수 있습니다. 여기서 삭제되는 리프노드 p에 대해 다음의 4가지 경우가 존재합니다. CASE1p 또한 루트노드인 경우삭제 후 리프에 적어도 키가 하나 남아있다면 삭제 후 저장하고, 없다면 공백트리가 됩니다. CASE2삭제 후 p가 적어도 [m/2]-1 개의 원소를 가지고 있는 경우 즉, 최소 원소 개수가 만족되는 경우그대로 삭제를 진행 CASE3 회전p가 [m/2]-2개의 원소를 가지며, 인접한 형제노드 q가 적어도 [m/2]개 원소를 가지는 경우. 즉, p가 삭제 후 최소 키보다 적은 키를 가지고 있고 형제 노드는 최소 키 이상의 키를 가지고 있는 경우다음과 같이 회전 을 진행합니다. CASE4 병합p가 [m/2]-2개의 원소를 가지고 있고, 가장 가까운 형제노드 q가 [m/2]-1개의 원소를 가지고 있는 경우. 즉, p가 삭제 후 최소 키보다 적은 키를 가지고 있고 형제 노드도 딱 최소 키만을 가지고 있는 경우p,q와 p,q 중간 원소 E_i를 하나의 노드로 병합 합니다.","link":"/2018/04/07/자료구조-b-트리/"},{"title":"자료구조 강의 09. 우선순위 큐","text":"1. 한쪽 끝과 양쪽 끝 우선순위 큐 좌향 트리 이항히프(B-Heap) 1. 한쪽 끝과 양쪽 끝 우선순위 큐우선순위 큐(priority queue) 는 각 원소가 연관된 우선순위를 갖고 있는 원소들의 모임이다.가령 시스템의 작업 우선도를 설정해 줄 때에는 작업들을 우선 순위에 따라 분류해야 하며, 2개의 서버로 이루어진 시스템의 경우에 하나의 시스템이 사고로 인해 종료되는 경우 반대쪽 서버로 그 작업 내역들이 병합되어야 하는데 이러한 경우 우선순위 큐를 통해 두 작업 리스트를 병합해야 한다. 이러한 우선순위 큐 한쪽 끝 우선순위 큐 와 양쪽 끝 우선순위 큐 가 있으며, 한쪽 끝 우선순위 큐는 최대 우선순위 큐 와 최소 우선순위 큐 로 나뉜다. 최소 우선순위 큐 에 의해 지원되는 연산은 다음과 같다.SP1. 최소 우선순위를 가진 원소의 반환SP2. 임의 우선순위를 가진 원소의 삽입SP3. 최소 우선순위를 가진 원소의 삭제 이러한 우선순위 큐를 잘 표현하기 위한 고전적인 자료 구조로써 히프(heap) 를 사용한다. 양쪽 끝 우선순위 큐는 최소 우선순위 큐와 최대 우선순위 큐가 하나로 합해진 최소-최대 우선순위 큐이다. 실제 활용도 측면에서, 양쪽 끝 우선순위 큐는 네트워크 버퍼를 구현하는 데 사용되는데 네트워크 링크를 통해 전송되기를 원하는 패킷들을 가지고 있는 경우 가장 높은 우선순위를 가진 패킷이 전송되고 삭제 되는 최대 삭제 가 행해지는 반면, 네트워크 내의 다른 곳으로 부터 새로운 패킷이 도착하였는데 버퍼가 가득 차 있다면 우선 순위가 가장 낮은 패킷을 지우는 최소 삭제 가 일어나게 된다. 이처럼 작업 큐의 양쪽에서 삽입과 삭제가 가능한 큐를 양쪽 끝 우선순위 큐라고 부른다. 좌향 트리좌향트리는 합병성 우선순위 큐의 효율적 구현을 제공한다.좌향 트리의 종류에는 HBLT(Height Biased Leftist Tree)와 WBLT(Weight Biased Leftist Tree)가 있는데, 일반적으로 HBLT를 좌향트리하고 부른다. 이항히프(B-Heap)좌향 트리에서 지원되는 것과 같은 기능을 수행한다. 개별적인 연산을 수행하는 데 걸리는 시간보다 우선순위 큐의 순차를 수행하는데 걸리는 시점에 관심이 있다.이항 히프란 최소 트리의 집합이며, 최소 트리 가운데 최소값을 갖는 트리를 가리키는 하나의 포인터가 가르키게 된다.","link":"/2018/03/27/자료구조-강의-09-우선순위-큐/"},{"title":"자료구조 | 스택과 큐","text":"스택을 활용한 수식의 계산모든 프로그래밍 언어는 연산 순위를 결정해야한다.일반적으로 실생활 에서는 x+y 와 같이 연산자를 피연산자 사이에 작성하는 중위 표기법(infix notation) 을 사용하지만, 컴퓨터의 컴파일러는 후위 표기법(postfix notation) 으로 코드를 변환하기에 컴퓨터의 연산과정을 이해하기 위해서 후기 표현법 에 대해 익숙해질 필요가 있습니다. 후위 표기식 연산법 연산자를 만날때까지 피연산자를 스택에 저장 연산자를 만나면 연산에 필요한 만큼만 스택에서 가져와 실행하여 연산결과를 다시 스택에 저장 중위 표기식을 후위 표기식으로 고치는 법 식을 모두 괄호식으로 고침 연산자를 모두 해당하는 오른 괄호랑 대체 모들 괄호를 삭제","link":"/2018/04/24/자료구조-스택과-큐/"},{"title":"자료구조 | 그래프","text":"그래프 추상 데이타 타입 그래프 표현법 그래프의 기본 연산 깊이 우선 탐색(DFS) 너비 우선 탐색(BFS) 신장 트리(spanning tree) 최소 비용 신장 트리 Kruskal 알고리즘 Prim 알고리즘 최단 경로와 이행적 폐쇄 Dijkstra 알고리즘, 하나의 출발점에서 모든 목표점: 음이 아닌 간선 비용의 경우 그래프 추상 데이타 타입가령 여러 지점과 그 지점들을 잊는 길들 처럼 현실 세계의 많은 문제들은 그래프 라는 개념을 통해 해결될 수 있습니다. 그래프 G 는 2개의 집합 V와 E로 구성됩니다. V는 공집합이 아닌 정점(Vertice) 들의 유한 집합이며, G는 정점 쌍들의 집합으로 이러한 쌍을 간선 이라 합니다. V(G) 와 E(G)는 각 각 정점과 간선들의 집합을 의미합니다. 그래프는 정점에서 특정 정점으로 가는데에 방향의 개념이 존재하는 경우와 존재하지 않는 경우로 나눌 수 있으며, 이렇게 정점에서 정점으로 이동시 방향이 있는 경우를 방향 그래프(directed graph) 라고 하며, 방향이 없는 경우 무방향 그래프(undirected graph) 라고 합니다. 여기서 정점에 연결된 간선의 수를 차수 라고 하며, Euler는 각 정점의 차수가 짝수 인 경우에만 임의의 정점에서 출발하여 각 간선을 단 한 번씩만 거치고 출발한 정점으로 되돌아오는 길이 있음을 보였으며, 이를 오일러 행로(Eulerian Walk) 라 부릅니다. 그래프 표현법무방향 그래프의 간선 (u, v)방향 그래프의 간선 &lt;u, v&gt; 그래프의 기본 연산 깊이 우선 탐색(DFS) 위처럼 인접 리스트 표현법의 경우 간선의 횟수 만큼만 탐색이 진행되므로, O(e) 의 복잡도를 가진다.하지만 인접 매트릭스 표현으로 표현한 경우 각 정점마다 다른 정점들과 비교해야 하므로 O(n^2) 의 복잡도를 가진다. 너비 우선 탐색(BFS) 시간 복잡도: O(n^2) 신장 트리(spanning tree)신장 트리란 G의 간선들로만 구성되고 G의 모든 정점을 포함하는 트리를 말합니다.신장 트리를 만들기 위해서는 DFS 혹은 BFS를 모두 이용할 수 있으며, DFS를 이용하여 만들어진 신장트리를 깊이 우선 신장 트리(depth first spanning tree) 라 하고, BFS를 이용하여 만들어진 신장 트리를 너비 우선 신장 트리(breath first spanning tree) 라 부릅니다. 최소 비용 신장 트리가중치가 부여된 무방향 그래프의 신장 트리의 비용은 신장 트리를 구성하는 간선들의 비용의 합이 됩니다. 여기서 최소 비용 신장 트리 란 최저의 비용을 갖는 신장트리를 의미합니다. 이 경우 다음의 조건을 만족해야 합니다. 그래프 내에 있는 간선만을 사용해야 한다. 정확히 n-1개의 간선만을 사용해야 한다. 사이클을 생성하는 간선은 사용하면 안된다. Kruskal 알고리즘 Prim 알고리즘 최단 경로와 이행적 폐쇄현대의 많은 지도 시스템들은 임의의 두 특정 지점 사이의 경로를 탐색하는 많은 시스템 중의 일부입니다. 경로 탐색 시스템은 일반적으로 주나 전국의 도로 시스템을 표현하기 위하여 그래프를 이용합니다. 이러한 문제에서 도시 A에서 도시 B로 가려는 운전자는 다음과 같은 사항들이 궁금할 것입니다. A로 부터 B로 가는 길이 있는가? A로부터 B로 가는 길이 2갱 이상이라면, 어느 길이 최단으로 가는 길인가? Dijkstra 알고리즘, 하나의 출발점에서 모든 목표점: 음이 아닌 간선 비용의 경우다이크스트라 알고리즘","link":"/2018/04/24/자료구조-그래프/"},{"title":"자료구조 | 해시","text":"해시란?해시란 탐색, 삽입, 삭제를 모두 O(1) 기대 시간에 수행할 수 있도록 해 주는 기법입니다.해시는 해시 테이블을 통해 구현되며 해시 테이블은 b개의 버킷 과 버킷 내에 s개의 사전쌍들로 이루어 집니다.여기서 해시함수 h는 키 값을 특정 홈 주소로 사상 시키는 함수로써 주로 제산 함수 등이 사용됩니다. h(k) = 0 ~ (b-1) 위 식에서 h(k)를 해시 혹은 홈 주소 라고 부릅니다. 이상적인 조건 하에서 모든 사전쌍들이 모두 홈 버킷에 저장됩니다. 이런 해시 테이블에 있는 쌍의 수를 n 개라 하고, 가능한 전체 키의 총 개수를 T라 할때 키 밀도 = n/T 위 식이 성립합니다. 이러한 해시 함수는 여러 개의 키를 하나의 버킷에 사상시키게 되기 때문에h(k1) = h(k2) 가 되는 k1과 k2가 존재하게 되고 이 경우 k1과 k2를 h에 대한 동거자라고 부릅니다. 오버플로우 란 어떤 쌍을 삽입 시 홈 버킷이 넘치는 경우를 말합니다. 정적 해싱오버플로우 처리방법에는 개방 주소법과 체인법 이 있으며, 개방 주소법 에는 선형 조사법, 이차 조사법, 재해싱, 임의 조사법이 있습니다. 오버플로우 처리법개방 주소법선형 조사법 체인법선형 조사법을 비롯한 개방 주소법에서는 키를 탐색 할 때 서로 다른 해시 값을 가진 키들과 일일히 비교를 수행하기 때문에 효율이 매우 떨어집니다.이와 달리 체인법 에서는 ht[i] 가 버킷 i에 연결된 체인들 중 첫번째 블록을 가리키고 있기 때문에, 연결된 체인 내에서만 탐색을 수행하면 되어 속도가 빠릅니다. 동적 해싱재조정을 한 번 할 때마다 오직 하나의 버킷만 재조정함 디렉터리 사용 동적 해싱디렉터리 미사용 동적 해싱","link":"/2018/04/24/자료구조-해시/"},{"title":"자료구조 | 히프 구조","text":"히프(heap)란?히프는 우선순위 큐를 구현하는 데 자주 사용된다. 우선순위 큐에서는 우선순위가 가장 높은(또는 낮은) 원소를 먼저 삭제한다.히프에 대한 설명을 하기 전에 최대 트리와 최소 트리에 대한 설명을 먼저 진행한다. 최대 트리 란 각 노드의 키 값이 그 자식의 키 값보다 작지 않은 트리이며,최소 트리 란 각 노드의 키 값이 그 자식의 키 값보다 크지 않은 트리를 말한다. 여기서 최대 히프 란 최대 트리이면서 완전 이진트리이며, 최소 히프 란 최소 트리이면서 완전 이진트리를 의미한다. 이러한 최대 히프 및 최소 히프에서는 부모를 쉽게 찾아 삽입이 가능하다. 히프의 생성은 C를 통하여 다음과 같이 구현한다.123456789#define MAX_ELEMENTS 200#define HEAP_FULL(n) (n==MAX_ELEMENTS-1)#define HEAP_EMPTY(n) (!n)typedef struct&#123; int key; &#125; element;element heap[MAX_ELEMENTS];int n=0; 최대 히프에서의 삽입최대 히프에서 원소를 삽입하는 경우 추가되는 원소가 가장 아래부터 루트 쪽으로 올라가는 bubbling up 기법이 사용된다.다음은 최대 히프에서의 원소의 삽입을 구현한 C 프로그램이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX_ELEMENTS 200 /*최대 히프 크기 +1*/#define HEAP_FULL(n) (n == MAX_ELEMENTS-1)#define HEAP_EMPTY(n) (!n)typedef struct element&#123; int key;&#125;element;element heap[MAX_ELEMENTS];int n=0;void push(element item, int *n)&#123; int i; if(HEAP_FULL(*n))&#123; fprintf(stderr, &quot;The heap is full. \\n&quot;); exit(EXIT_FAILURE); &#125; i = ++(*n); while ((i != 1) &amp;&amp; (item.key &gt; heap[i/2].key))&#123; heap[i] = heap[i/2]; i /= 2; &#125; heap[i] = item;&#125;int main()&#123; struct element node1 = &#123;7&#125;; struct element node2 = &#123;16&#125;; struct element node3 = &#123;49&#125;; struct element node4 = &#123;82&#125;; struct element node5 = &#123;5&#125;; struct element node6 = &#123;31&#125;; struct element node7 = &#123;6&#125;; struct element node8 = &#123;2&#125;; struct element node9 = &#123;44&#125;; push(node1, &amp;n); push(node2, &amp;n); push(node3, &amp;n); push(node4, &amp;n); push(node5, &amp;n); push(node6, &amp;n); push(node7, &amp;n); push(node8, &amp;n); push(node9, &amp;n); for(int k=1;k&lt;10;k++)&#123; printf(&quot;%d &quot;,heap[k].key); &#125; return 0;&#125; 최대 히프에서의 삭제최대 히프에서 원소의 삭제는 제일 위에서 이루어 진다.먼저, 키값이 가장 큰 원소를 삭제하고 마지막 원소를 제거하고 두 자식 노드중 큰 값이 위로 올라가고 아래를 메꾸는 방식으로 진행된다.최대 히프의 삭제를 구현한 프로그램은 다음과 같다.123456789101112131415161718192021222324element pop(int *n)&#123; int parent, child; element item, temp; if(HEAP_EMPTY(*n))&#123; fprintf(stderr, &quot;The heap is empty\\n&quot;); exit(EXIT_FAILURE); &#125; item=heap[1]; temp = heap[(*n)--]; parent = 1; child = 2; while(child &lt;= *n)&#123; if((child &lt; *n) &amp;&amp; (heap[child].key &lt; heap[child+1].key)) child++; if(temp.key &gt; heap[child].key) break; heap[parent] = heap[child]; parent = child; child *= 2; &#125; heap[parent] = temp; return item;&#125; B - 히프B - 히프란 최소 트리의 집합이다.","link":"/2018/03/27/자료구조-히프(Heap)/"},{"title":"주식 차트 분석의 기본","text":"주식을 함에 있어 가장 기본적인 차트 분석 방법에 대해 알아본다. 주식 차트는 그 모양이 촛볼 모양이라 하여 캔들차트라는 이름으로 불리는데, 캔들차트는 직사각형의 박대를 수직으로 관통하는 선이 있는 촛불모양의 막대로 구성된 차트이다. 이 차트에서 막대를 관통하는 선은 그날 주식의 상한가 와 하한가 를 나타내며 그날 하루 주식의 최고 가격과 최저 가격을 나타낸다. 여기서 막대의 위와 아래는 시가와 종가로 그날 시작한 가격과 장이 마감한 시점에서의 가격을 나타낸다. 여기서 시가가 종가보다 낮다면, 가격이 올랐으므로 양봉 이라고 하며, 시가가 종가보다 높으면, 가격이 내렸으므로 음봉 이라고 한다. 여기서 매우 중요한 지표가 하나 있는데 그것은 바로 주가 상승시의 거래량이다. 만약 주가가 주가가 상승하고 있는데 거래량이 많다면 그것은 사람들이 물건을 잘 팔려고 하지 않는다는 것으로 즉 매도세가 약하다 라고 볼 수 있다. 주가가 상승하는데 이를 팔려고 하는 사람이 적기 때문에 주가는 계속 올라가는 것으로 해석하면 된다. 만약, 주가가 상승하고 있는데 거래량이 적다면 그것은 사람들이 계속해서 주식을 사려고만 하여 거래량은 없는데 주식이 상승한다고 볼 수 있으며 이 경우 사려고 하는 사람의 세력이 강하다는 뜻으로 매수세가 강하다 라고 볼 수 있다. 만약 반대의 경우는 어떨까? 가령 주가가 하락하고 있는데 거래량이 많다 면 이것은 파는 사람이 매우 많은것에 비해 사려고 하는 사람들이 적기에 가격이 계속 내려가는 것으로 해석 할 수 있으며, 매수세가 약하다 라고 해석할 수 있다. 또 주가가 하락하고 있는데 거래량이 적다면 사람들이 주식을 팔려고 하는데 사는 사람은 많이 없는 것으로 매도세가 강하다 라고 해석할 수 있다. 언제 주식이 오를 것인가?가장 대표적인 주식 상승의 조짐은 바로 장대 양봉 이다. 이러한 장대양봉이란, 그날의 종가가 상한가로 마감하는 경우를 말하는데, 이는 즉 장이 마감하는 시점끝까지 사람들이 계속해서 주식을 사들였다는 의미이며 이는 상당히 좋은 조짐이다. 여기서 그 날의 종가보다 다음날의 시가가 높은 경우를 상승갭이 있다 라고 하는데 이는 전날 마지막으로 팔린 가격보다 높은 가격에 주식이 거래되기 시작하는 것으로 사람들이 주식이 오를 것을 전망하고 있기에 상당히 좋은 매수신호이다. 언제 주식이 내릴 것인가?","link":"/2018/11/27/주식-차트-분석의-기본/"},{"title":"자료구조 | 정렬(sorting)","text":"개요컴퓨터 안에는 수십 수만가지의 데이터 들이 있으며, 이러한 수많은 데이터들을 잘 정리하고 보관하는 것은 빠른 데이터 찾기와 데이터 추가 및 삭제 등의 작업의 효율에 매우 큰 영향을 미친다. 때문에 컴퓨터의 많은 자료들을 효율적으로 분류하고 원하는 자료를 찾고 추가 하기 위해서는 ‘정렬’에 대해 알아야 할 필요가 있다. 본 강의에서 리스트 란 하나 이상의 필드로 된 레코드의 집합이라는 의미로 사용하며, 이때 코드를 서로 구별하기 위해 사용되는 필드를 키 라고 한다. 일반적인 자료의 탐색 방법흔히 리스트를 탐색하는 가장 직관적인 방법은 앞에서 부터 차례대로 비교하면서 자료를 분류하는 것이다.프로그래밍에서 for 문을 사용하여 리스트의 제일 앞에서 부터 뒤까지 훑어 가면서 equal 문을 통해 데이터를 찾는 작업은 매우 흔한 프로그래밍의 구현이다. 이렇게 어떤 리스트의 왼편에서 오른편으로 차례대로 데이터를 찾는 것을 순차 탐색 이라고 한다. 다음 C 언어로 순차탐색 프로그램을 구현한 코드이다.123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;struct Element&#123; public: string key;&#125;;int seqSearch(Element elements[], string key)&#123; int i; int count = sizeof(*elements) / sizeof(elements[0]); cout &lt;&lt; \"address of the elements: \" &lt;&lt; elements &lt;&lt; endl; cout &lt;&lt; \"count is: \" &lt;&lt; count &lt;&lt; endl; for (i = 0; i &lt; count; i++) &#123; if (elements[i].key == key) &#123; return i; &#125;; &#125;; return 0;&#125;;int main(void)&#123; Element element1 = &#123;\"123\"&#125;; Element element2 = &#123;\"namhoon\"&#125;; Element elements[] = &#123;element1, element2&#125;; int result = seqSearch(elements, \"namhoon\"); cout &lt;&lt; result;&#125; 위 프로그램을 살펴보면 for 문을 돌면서 n 개의 레코드를 탐색하는 평균은 (n+1)/2 이므로, O(n)의 시간복잡도를 가진다. 만약 어떤 리스트가 정렬된 순차 리스트라면 이런 순차 탐색 말고 이원 탐색 을 사용하여 자료를 찾을 수 있으며 이 경우 시간 복잡도는 O(logn) 이다. 정렬의 종류삽입 정렬i 개의 정렬된 레코드에 새로운 레코드를 끼워넣어 i+1 개의 정렬된 레코드 리스트를 만드는 정렬 방법이다. 아래 프로그램은 C로 구현한 insert 함수이다. 정렬된 리스트 a[1:i] 에 e 원소를 집어넣어 a[1:i+1]의 리스트를 만들어 내는 함수이다. index 역할을 하는 i가 점차 작아지면서 a[i].key가 e.key 보다 큰 경우 한칸씩 우측으로 밀어내고, a[i].key가 e.key 보다 작아지는 i 값에서 a[i+1]에 e를 넣어준다.123456789void insert(element e, element a[], int i)&#123; a[0]=e; while(e.key&lt;a[i].key)&#123; a[i+1] = a[i]; i--; &#125; a[i+1] = e;&#125; 아래 함수는 insert 함수를 활용하여 삽입정렬을 하는 프로그램이다. 1234567void insertionSort(element a[], int n)&#123; int j; for(j=2;j&lt;=n;j++)&#123; element temp = a[j]; insert(temp, a, j-1); &#125;&#125; 병합정렬(Merge Sort)병합정렬은 입력 리스트를 길이가 1인 n 개의 정렬될 서브트리로 간주하는 것으로 시작합니다. 아래 merge 함수는 두개의 서로 다른 리스트를 병합하는 것을 보여줍니다. merge sort 의 각 단계는 O(n) 의 시간이 걸리고 logn 번의 단계가 적용되므로 O(nlogn) 의 복잡도를 가집니다. Time Complexity: O(nlogn) 또한 각 병합과정에서 새로운 배열이 필요하므로 inplace sort가 아니다. 퀵 정렬(Quick Sort)퀵 정렬은 앞서 살펴본 정렬법 중에서 가장 좋은 평균 성능을 가지고 있다.퀵 정렬의 순서는 먼저 피벗 레코드를 선택하여 피벗의 왼쪽에는 레코드 키들이 피벗의 키보다 작거나 같고 피벗의 오른쪽에는 레코드 키들이 피벗의 키보다 크거나 같도록 하는 방법을 사용한다. 최종적으로는 피벗의 왼쪽에 있는 레코드들과 피벗의 오른쪽에 있는 레코드들이 서로 독립적으로 정렬이 된다. 다음은 퀵 정렬을 수행하는 프로그램이다.i와 j가 각각 왼쪽과 오른쪽에서 가운데 방향으로 진행하며, a[i].key는 pivot 보다 커질 때까지 a[j].key는 pivot 보다 작아질 때 까지12345678void quickSort(element a[], int left, int right)&#123; int pivot,i,j; pivot = a[left].key; do&#123; do j++;while(a[i].key&lt;pivot); do j--;while(a[j].key&gt;pivot); &#125;&#125; 히프정렬 히프 정렬에서는 최대 길이 [log_2(n+1)] 을 가지고 adjust를 n-1번 호출한다. 즉, O(nlogn) 이다. 버블 정렬 선택 정렬","link":"/2018/03/27/자료구조-정렬-sorting/"},{"title":"아름다움이란 단어가 빛바랜 오늘, 진정한 아름다움이란 무엇인가?","text":"진정한 아름다움이란 무엇인가?요즘 시대에 ‘아름다움’이란 너무도 상업적인 목적 또 하나의 유희이자 쾌락으로써 소비되고 있습니다.하지만, 예로부터 ‘아름다움’ 이란 많은 철학자들이 하나의 ‘이상’ 으로 추구해 왔던 개념이었고 인간이 추구해야 할 숭고한 가치로 고려되어 왔습니다.오늘 글에서는 ‘아름다움’이란 의미가 점차 가벼워 지고 퇴색되어 가는 요즘 시대에 진정한 ‘아름다움’ 이란 무엇이며 올바른 아름다움의 추구란 무엇인가에 대해 생각해 보도록 하겠습니다. ‘아름다움’이란 무엇일까요?고대의 피타고라스 학파는 아름다움이란 비례와 조화, 균형이며, 수적으로 표현이 가능한 대상으로 보았습니다. 완벽한 굴곡을 자랑하는 도자기 혹은 이상적인 신체 비율의 가진 사람의 신체처럼 사물 혹은 사람이 가지는 그 고유의 비례와 조화의 미 그 자체를 ‘아름다움’이라 이야기 했습니다. 요즘 말하는 ‘8등신 황금비율’과 같은 말들도 어느정도는 고대 시대의 아름다움의 척도에 부합한다고 볼 수 있습니다. 이처럼 옛날 사람들은 오늘날 우리가 생각하는 것 보다는 훨씬 객관적인 하나의 성질로써 ‘아름다움’을 보았습니다. 중세에 들어서도 사물 혹은 사람의 성질 로서의 ‘아름다움’의 개념은 연장되어 왔습니다. 참된 아름다움 이란 감각기관이나 상상에 의한 것이 아니라 이성에 의해 파악되는 정신적인 것으로 규정하고, ‘아름다움’ 이란 철저히 객관적인 성질로써 이해되었습니다. 하지만, 근대에 들어서면서 이러한 ‘객관적인 성질’로서의 아름다움에 대한 인식에 큰 변화가 생기게 됩니다. ‘아름다움’ 이란 대상의 성질일 수 있지만, 이것은 대상을 인식하는 우리의 주관이 느끼는 것이라는 생각이 널리 퍼지게 되었습니다. 고대의 미가 단순히 균형, 조화를 추구했다면, 근대의 아름다움 에서는 이를 특정짓는 것이 없이 오로지 우리가 주관적으로 느끼는 것 이라는 것이지요. 가령 아무리 완벽한 자태를 뽐내는 도자기가 있더라도 우리가 이 도자기를 보고 감동을 느끼고 아름답다고 느끼지 않는다면 그 도자기는 더 이상 우리에게 아름다운 것이 아닙니다. 수천년이 지나 칠이 벗겨지고 부수어진 도자기가 우리에게 옛 선조들의 아름다움을 알 수 있게 해주고 우리 마음 속에 아름답다는 감정을 불러 일으킨다면 그 도자기는 그 외관에 상관없이 우리에게 아름다울 수 있는 것이지요. 철학자 칸트는 이러한 근대의 아름다움에 대한 개념을 다음과 같이 얘기합니다. “미란 결코 객관적인 것이 아니며, 인식적 의미를 지니지 않는다. 우리의 마음 속에 미적 즐거움을 일으키는 대상들의 형식은 객관적이나, 그것은 개념적으로 파악될 수 없다. 그것이 객관적 성질을 지니는 것이 아니라 우리의 마음 속에 미적 즐거움을 환기시킬 수 있도록 구성된 것을 뿐이다. 하지만 미를 일으키는 과정에서 일련의 공통점을 가진다.” 이러한 근대의 아름다움의 개념의 현재 우리 삶의 많은 부분에 녹아 있습니다. 오랜 기간 훈련을 통해 짓 무르고 갈라진 ‘김연아’ 선수의 발을 보면서 많은 사람들이 아름다움을 느끼는 것도 이러한 주관적 의미에서의 아름다움이라고 볼 수 있습니다. 아름다움이란 가질 수 있는 것일까?현대의 많은 사람들은 ‘아름다움’을 가지기 위해 많은 활동을 합니다. 외적인 아름다움을 가꾸기 위해 성형수술을 하기도 하고 헬스장을 다니고 운동을 하며 다이어트를 하기도 하면서 ‘아름다움’을 소유하기 위해 많은 노력을 기울입니다. 하지만, 이런 많은 활동이 궁극적으로 우리 모두에게 ‘아름다움’을 가지게 해 줄까요?근대 이후의 많은 철학자들이 말하는 결론은 ‘아니오’입니다. 왜 우리는 아무리 노력해도 아름다움을 소유할 수 없을까요?위에서 말했듯이 ‘아름다움’이란 객관적인 성질이 아닌 우리 마음 속에 미적 즐거움을 환기시킬 수 있어야 합니다. 즉, 진정한 아름다움이란 모든 사람들이 많은 다양한 의미로 나에게 아름다운 감정을 느껴야 이루어 지는 것이지요. 그것이 외적인 아름다움이던 혹은 내적인 아름다움일 수 있고, 몇몇 사람들이 나의 외적 혹은 내적 아름다움에 공감할 수 있을 지 모르지만 궁극적인 ‘아름다움’을 소유하는 것에는 한계가 있을 수 밖에 없습니다. 아름다움은 소유하는 것이 아니라 추구하는 것 그렇다면 우리는 아름다워 질 수 없는 것일까요? 아름다움을 소유하지 못한다면 우리에게 무슨 낙이 있을까요? 위의 질문에 현대의 많은 철학자들은 이렇게 말합니다.“아름다움을 얻을 수 있는 최고의 지름길은 미를 소유하는 것이 아닌 추구하는 것에 목적을 두는 것이다.” 아름 다움 자체를 소유하기 위해 노력한다면 돌아오는 것은 실패 뿐을 것입니다. 모든 형태의 아름다움 모든 사람들이 공감할 수 있는 궁극적 아름다움을 가지는 것은 사실상 불가능 하기 때문이지요. 이런 노력은 모두 실패로 귀결될 수 밖에 없습니다. 아름다움이 주는 즐거움을 누릴 수 있는 최고의 방법은 ‘아름다움을 추구’하는 것입니다.오늘 보다 나은 나를 만들기 위해 노력하고, 누군가를 가슴속 깊이 사랑하고, 나의 주권 또 내 주변 사람들의 자유와 주권에 대한 관심, 즉 나와 이 세계를 아름답게 하고자 하는 노력과 그런 아름다움에 대한 추구를 통해 아름다움이 주는 진정한 즐거움을 알 수 있을 것이라 믿습니다. 이 글을 읽는 독자님도 오늘 하루 ‘아름다움’을 가지지 못한 나를 채찍질 하기 보다 하루 하루 나와 내 주변 사람들의 아름다움을 추구하는 멋진 인생을 살아가 아름다움이 주는 진정한 즐거움을 향유할 수 있기를 기원합니다.","link":"/2018/03/29/진정한-아름다움이란-무엇인가/"},{"title":"천재란 누구인가?","text":"‘천재’란 누구인가?천재란 일반적으로 일반적인 인간에 비해 압도적으로 강력한 능력을 타고난 자로 여겨지고, 다르게 말하면 일반적인 사람과는 ‘경쟁’ 자체가 무의미한 특별한 사람이라고 우리에게 여겨지기도 한다. 수영 천재, 피겨 스케이팅 천재, 컴퓨터 천재 등등 우리는 살면서 ‘천재’ 라는 말을 너무도 자주 듣게되고 가끔은 이 세상엔 왜 이렇게 천재들이 많을까 하는 무력감을 느끼며 ‘경쟁 할 수 없는 일반인’ 이라는 굴레 안에 스스로 들어가 버리기도 한다. 하지만, 필자는 모든 사람은 누구나 자신의 분야에서 천재가 될 수 있다고 생각하며 철저히 주관적으로 ‘천재’에 대해 재해석 해 보고자 한다. 필자가 생각하는 ‘천재’란 다음과 같이 요약할 수 있겠다. 1천재란 자신의 운명을 걸머쥐고 모든 것을 쏟아 부을 지향점을 가지고 실천하며, 그에 따른 결과에 책임을 질 수 있는 용기를 가진 사람이다. 사실 이렇게 천재에 대한 단편적으로 정의는 너무 추상적이고 비현실적이라는 생각이 들 수 있다. 또 어떻게 보면’천재’를 너무 과소평가 하는 것이 아닌가 생각이 들 수도 있다. 가령 예를 들어보자. 상대방에 대한 사랑에 인생을 불사른 로미오와 줄리엣, 필자는 무언가 ‘특별한’ 두뇌 혹은 재능을 가지는 사람들의 존재는 인정하지만 우리가 흔히 말하는 많은 천재들 즉, 영화 속 주인공, 예술가, 기업가 들은 사실상 일반인과 크게 다르지 않은 똑같은 인간이라고 생각하어쩌면 영화 속의 주인공들, 희대의 로맨티스트, 예술가, 기업가 들은 모두 ‘천재’라는 한가지의 범주로 요약 될는지도 모른다. 사회적 책임, 도덕적 관념, 모든 나를 구속한다고 핑계대는 제약들이 없어진 상태 내게 아무런 의무도 지워지지 않고 금전적 제약도 심지어 법의 제약도 없어진 그런 상태로 내일을 맞이한다면 나에게 무엇을 하고 싶은 지를 묻는 다면 나는 무어라고 대답한단 말인가. “무언가 큰 일을 하고싶다. 수억 명의 사람들을 기쁘게 하고 내 주변 사람들이 행복해 하고, 어떤 완벽한 이상사회로 이 사회와 세계가 진행중이라면 그 사회의 도래에 공헌 할 수 있는 그런 세계 변화의 흐름을 잡고 흔들 수 있는 그런 위대한 일을 하고싶다.” 이 따위 대답에 내가 부응하기 위해서는 그러기 위해서는 지금 당장 나는 어떤 일을 하고 있다고 말해야 하나. 그저 그 일을 찾는 것? 절박함이 없다. 반드시 대의를 이루겠다는 나는 하루하루 매시간 매초 온 힘을 다해 이를 고민해야 한다.","link":"/2018/06/03/천재란-과연-무엇인가/"},{"title":"컴퓨터 구조 | Amdahl의 법칙이란?","text":"컴퓨터를 설계함에 있어 위대한 아이디어인 자주 생기는 일을 빠르게(make common cae fast) 를 추구함에 있어 하드웨어 및 소프트웨어 설계자들이 필연적으로 고민하게 된느 문제 중의 하나는 “성능을 개선하려는 나의 노력이 얼마나 효과가 있는지 어떻게 평가할 수 있는가?” 이다. 열심히 성능을 개선하려는 노력을 했다면 그것이 얼마나 효과가 있는지 궁금해 하는 것은 당연하다.이러한 질문들에 대한 정석적인 해답은 다음과 같다. “성능을 개선하려는 노력이 얼마나 효과가 있는지는 그 사건이 얼마나 많이 발생하는지와 관련이 있다.” 이러한 법칙은 얼핏 보면 당연해 보이지만 많은 경우 우리에게 명확한 직관을 줄 수 있다. 간단한 예를 통해 Amdahl의 법칙 의 활용을 알아보자.가령 프로그램의 실행 시간이 100초가 걸리는 데 그 중 80초는 곱하기 계산에 소요된다고 하자. 이 프로그램이 5배 빠르게 실행되기 위해서 곱셈 속도는 얼마나 개선되어야 하는지에 대한 문제가 있다고 하자. 이는 Amdahl 의 법칙 에 의해 다음과 같이 표현된다. 개선 후 실행시간= (개선에 의해 영향을 받는 실행 시간)/개선의 크기 + 영향을 받지 않는 실행 시간 이 문제의 경우는 개선 후 실행시간 = 20초 = 80초 / n + (100-80)초 즉, 0=80초 / n 이라는 식을 얻을 수 있다. 이는 바로 곱셈의 성능을 백날 개선해 보아도 시스템의 성능을 5배로 올리는 것은 불가능 하다는 깨우침을 우리에게 준다.이는 일상생활에서 수확체감의 법칙과도 연관되어 있다. 이처럼 Amdahl의 법칙을 통해 어떤 개선안이 전체 성능에 얼마만큼의 성능 개선을 가져다 줄 지를 예측 할 수 있다.이 법칙은 CPU 성능식과 함께 잠재적 성능 개선율을 평가하는 편리한 도구이다.","link":"/2018/04/19/컴퓨터-구조-amdahl의-법칙이란/"},{"title":"철학 개론","text":"정치의 혁명과 철학의 혁명 - 18C 계몽주의의 배경과 발전 프랑스에서 꽃핀 계몽주의 프랑스의 계몽철학 볼테르 몽테스키외 루소 [사회계약론] 비판 철학 - 칸트 피히테 - 자아의 형이상학 독일 관념철학의 완성, 헤겔 정치의 혁명과 철학의 혁명 - 18C계몽주의의 배경과 발전인간의 이성을 통해 사유하는 자세로 더 이상 신의 은총이나 보살핌에 의존하는 것이 아니라 오로지 인간 스스로 노력하여 지식과 자유를 얻고 행복으로 나아갈 수 있다고 믿었다. 프랑스에서 꽃핀 계몽주의백과전서, 디드로, 볼테르, 루소, 몽테스키외 등 참여 프랑스의 계몽철학볼테르철학을 실천한 사상가 몽테스키외삼권분립의 이론을 제시하여 사회학적 방법의 선구자이다. 인간의 자유란, 국가 권력이 행정, 입법, 사법으로 나뉘어 서로 견제함으로써만 가능한 것 전제정치는 ‘공포’의 원리가 지배하는 체제군주정치는 ‘명예’의 원리가 지배하며공화정치는 ‘덕’의 원리가 지배한다. 루소 [사회계약론]사람은 자유로운 몸으로 태어났으나 그는 어디에서나 사슬에 매여 있다.인민주권, 민주주의의 외침 비판 철학 - 칸트[순수이성비판]: 우리는 무엇을 알 수 있는가? [실천이성비판]: 우리는 무엇을 해야 하는가 [판단력 비판]: 미와 예술에 대한 문제 인식이란 사물과 ‘나’, 즉 인식의 대상과 인식의 주체 사이의 상호작용이다.대상은 ‘정신의 작용’을 거치는 경험을 통해서만 파악이 되는 것이다. 피히테 - 자아의 형이상학독일 관념철학의 완성, 헤겔칸트에게 사물 자체는 현상의 세계와는 다른 ‘실재’라고 말할 수 있으나 헤겔에게는 사물 자체가 의미하는 실재의 세계는 현상과 동떨어진 것이 아니었다. 우리가 무엇을 인식했다고 할 때 그것은 경험을 통해 형성된 여러 보편적 관념들을 종합한 것이다. =&gt; 객관적 관념론이 핵심최고의 합리성은 시간이란느 절대적인 경험을 통하여 발전하는, 우주를 가득체운 구체성에 있다. =&gt; 절대정신현상 속에 있는 실재는 끝없는 과정속에 있다.그러므로 실재에 대한 인식 역시 끝없는 ‘과정’이 될 것이다.실재에 대한 정확한 인식은 절대정신을 통해서만 가능하다.결국 절대정신이 드러나는 것은 자연의 과정이나 사유의 과정을 통해서이고 그 과정은 변화와 발전이 지속적으로 드러나는 ‘변증법적인’과정이다. 헤겔은 인간사회의 형이상학을 즉 절대정신을 통해 본 인간사회를 역사라고 부른다.이러한 세계는 하나의 목적인 ‘자유’를 향해 나아가고 결국 세계의 역사는 자유를 실현시키는 과정이다.그 발전의 정도는 ‘인간의 의지와 자유의 표현’인 각가를 통해 표현된다.","link":"/2018/01/14/철학-개론/"},{"title":"컴퓨터 구조 | RISC 와 CISC 구조","text":"RISC(Reduced Instruction Set Computer) 란?RISC 란 Reduce Instruction Set Computer 의 약자로 말 그대로 축소 명령어 세트 컴퓨터를 의미합니다.여기서 명령어 세트가 축소되었다는 말은 말 그대로 명령어의 개수가 적은 것을 말합니다. 핵심적인 명령어를 기반으로 최소한의 명령어 세트를 구성함으로써 파이프라이닝 이라는 획기적인 기술을 도입할 수 있어 빠른 동작 속도와 하드웨어의 단순화와 효율화를 시킬 수 있었고, 가격 경쟁력에서도 우위를 점했습니다. 즉, RISC란 CISC의 길고 복잡한 명령어들을 짧고 처리가 가능한 여러개의 명령어로 체계적으로 바꾼 것입니다. RISC의 특징 적은 명령어 세트 간단한 명령어로 빠른 실행속도 고정적인 명령어 길이 워드, 데이터 버스 크기가 동일하고 실행 사이클도 모두 동일 회로 구성이 단순함 프로그램을 구성할 때 상대적으로 많은 명령어가 필요 파이프 라이닝을 사용함 명령어 개수가 적어서 컴파일러가 단순하게 구현됨 CISC(Complex Instruction Set Computer) 란?연산을 처리하는 복잡한 명령어들을 수백개 이상 탑재하고 있는 프로세서입니다. CISC는 명령어 개수 증가에 따라 프로세서 내부구조가 매우 복잡해 지고, 고속으로 적동되는 플세서를 만들기 힘듭니다. 여기서 명령어가 복잡하다는 것의 의미는 하나의 명령어가 할 수 있는 일의 양이 RISC 대비하여 많다는 것을 의미합니다. 명령어 마다 길이가 다르고, 실행에 필요한 사이클 수도 다르기 때문에 pipelining 설계가 어려우며 한 바이트 명령어 부터 100바이트 이상되는 명령어 들도 있습니다. 이렇게 CISC는 RISC에 비해 성능이 많이 떨어지지만 다음과 같은 이유 때문에 아직도 쓰이고 있습니다. CISC의 특징 명령어의 개수가 많음 명령어 길이가 다양하며, 실행 사이클도 명령어 마다 다름 회로구성이 복잡함 프로그램을 만들 때 적은 명령어로 구현 가능 다양한 명령어를 사용하기 때문에 컴파일러가 복잡함 CISC를 사용하는 이유 아직 너무도 많은 프로세서가 CISC 모델로 구축되어 있고, 이것을 전부 바꾸는 것은 너무 큰 비용이 든다. CISC 성능의 취약점은 RISC와 같은 파이프라인을 일부 사용하고 집적도는 더 높임으로써 부분적으로 보완이 가능하다. RISC에 비해 호환성이 좋다.","link":"/2018/04/17/컴퓨터-구조-risc-와-cisc-구조/"},{"title":"컴퓨터 구조 강의 01. 컴퓨터 추상화 및 관련 기술","text":"서론1940년 전자식 컴퓨터가 등장한 이래로 컴퓨터는 정보 혁명을 주도하며 컴퓨터와 관련 사업을 빠르게 발전시켰다.스마트 가전제품 부터 슈퍼 컴퓨터 까지 삶의 다양한 분야에서 컴퓨터가 활용되고 있으며 크게 다음과 같은 세가지 응용분야에서 사용된다. 개인용 컴퓨터 서버 임베디드 컴퓨터 개인용 컴퓨터는 많은 사람들이 잘 알고있듯이 가정 내에 보급된 pc를 말하며, 가정 및 비즈니스에서 산업용으로도 사용되고 있다.서버는 과거 대형 컴퓨터로 불리던 것의 현대적 형태로써 보통 네트워크를 통해 접근되며 소규모 비즈니스 서버 등 주로 산업에서 인터넷을 통한 서비스 공급의 목적으로 사용되고 있다.가장 많이 사용되는 임베디드 컴퓨터는 한 가지 응용을 수행하거나 서로 연관된 일련의 프로그램을 실행하도록 설계된 컴퓨터로 많은 가전기기 및 제품들에 탑재되어 있다. 단순 컴퓨터의 출생이 가지는 의미를 넘어 컴퓨터의 영향으로 세계 IT 산업은 송두리째 뒤흔들리고 있는 분야가 있는데, 그것은 바로 개인 휴대용 기기(PMD) 와 클라우드 컴퓨팅 을 기반으로 한 sass 이다. 개인 휴대용 기기를 통해 사람들은 어디에서나 인터넷에 연결되어 진정한 초연결 사회로 거듭나게 되었으며, 엄청난 컴퓨팅 파워가 기반이 되어야 사용 가능했던 많은 컴퓨터 기반의 서비스들이 창고 규모의 컴퓨팅(WSC: Warehouse Scale Computing)으로 알려진 클라우드 컴퓨팅을 통해 서비스 로서의 소프트웨어(sass)로 제공되고 있다. 본 강의는 David A. Patterson과 John L. Hennessy의 책을 토대로 공부한 내용을 정리하며, 다음과 같은 내용을 배운다. 상위 수준으로 작성된 프로그램이 어떻게 하드웨어로 번역되고 동작하는가? 소프트웨어와 하드웨어 사이의 인터페이스는 무엇이며, 소프트웨어는 어떻게 필요한 일을 하드웨어에게 지시하는가? 프로그램의 성능을 결정하는 요소는 무엇이며, 프로그래머는 어떻게 성능을 개선하는가? 성능 개선을 위해 하드웨어 설계자는 어떤 기술을 사용하는가? 에너지 효율성을 개선하기 위해 하드웨어 설계자는 어떤 기술을 사용할 수 있는가? 최근 순차처리에서 병렬처리로 넘어가는 이유는 무엇이며 결과는 어떠한가? 컴퓨터 구조 분야의 어떤 위대한 아이디어들이 컴퓨팅의 기초를 닦았는가? 컴퓨터를 조작하는 명령어는 어떻게 작동하는가?컴퓨터 하드웨어는 아주 단순한 명령을 실행 할 수 있도록 설계되어 있으며, 많은 현대 프로그래머들이 작성하는 복잡한 코드는 적절한 변환을 통해 컴퓨터가 알기 쉬운 언어로 번역되어 하드웨어를 동작한다. 프로그래머는 코드를 작성하면서 하드웨어의 구체적인 동작은 배제하고 프로그램을 작성이 가능한데, 이는 인간의 상위 언어인 프로그램 언어를 하드웨어와 무관하게 자유롭게 작성할 수 있도록 하는 추상화 의 일환이다.즉, 프로그래머는 추상화된 언어인 상위 언어들을 사용함으로써 컴퓨터 내의 복잡한 일들을 신경쓰지 않고 더욱 정교한 시스템을 만들어 갈 수 있다. 소프트웨어와 하드웨어의 상호작용은 다음과 같이 일어난다. _1. 상위 수준 언어로 코드를 작성 컴파일러가 상위수준 언어를 하위 언어인 어셈블리어로 변환시켜 줌 어셈블러가 어셈블리어를 컴퓨터가 알아들을 수 있는 이진수 체계로 변환시켜 줌_ 컴퓨터 구조 분야의 8가지 위대한 아이디어 무어의 법칙을 고려한 설계 설계를 단순화하는 추상화 자주 생기는 일을 빠르게 병렬 처리 파이프라이닝을 통한 성능 개선 예측을 통한 성능 개선 메모리 계층구조최상위 계층에는 비트당 가격이 제일 바싸지만 작고 빠른 메모리를 사용하고, 최하위 계층에는 느리지만 크고 비트당 가격이 제일 싼 메모리를 사용한다. 여유분을 이용한 신용도 개선 컴퓨터의 구성과 기본 기능컴퓨터는 기본적으로 다음과 같은 5가지 항목으로 구성된다. 입력 유닛 출력 유닛 메모리 유닛 데이터패스 유닛 제어 유닛 출력컴퓨터의 출력은 주로 그래픽 디스플레이를 통해 이루어 진다.오늘날의 LCD 디스플레이는 수만개의 화상으로 이루어져 있으며, 각 화상마다 작은 트랜지스터가 배치되어 있어 전류를 정밀하게 제어하는 능동 행렬을 사용한다.각 화상은 화소의 행렬로 구성되며, 이것을 비트맵이라 부르는 비트들의 행렬로 포현한다.컬러 디스플레이는 각각마다 8비트씩, 모두 24비트를 사용하여 수백만 가지의 색을 표시할 수 있다. 그래픽을 지원하는 하드웨어의 중심이 되는 것은 비트맵을 기억하는 프레임 버퍼 라고 하는 부분이며, 스크린에 표시될 화상을 프레임 버퍼에 자장하였다가, 기억된 각 화소들의 비트 패턴을 재생 속도에 맞추어 그래픽 디스플레이로 보낸다. 프로세서디바이스 안에는 집적회로라 불리는 장치들이 있는데, 이는 프로그램의 지시대로 일을 하며, 데이터패스와 제어 유닛으로 나뉜다.또한 프로세서 내에서 처리할 데이터를 잠깐 보관하기 위해 이를 캐시 메모리 라고 한다. 성능컴퓨터의 성능이란 두 컴퓨터에서 같은 프로그램을 실행시키는 경우에 먼저 끝나는 쪽이 더 빠른 컴퓨터라고 할 수 있을 것이다.하지만 사용하는 사람과 컴퓨터의 목적에 따라 다른 성능 척도가 필요 하다.가령, 개인의 입장에서는 작업 개에서 종료까지의 시간인 응답시간 이 성능의 중요한 척도일 것이고, 데이터 센터 관리자에게는 일정 시간동안 처리하는 작업의 양인 처리량 혹은 대역폭 이 더 중요한 성능의 척도일 것이다. 다양한 성능 인자들_프로그램의 CPU 실행 시간 프로그램의 CPU 클럭 사이클 수 * 단위 클럭 사이클 시간 = 프로그램의 CPU 클럭 사이클 수 / 클럭 속도 명령어당 클럭 사이클 수(CPI)명령어 수 * 명령어당 평균 클럭 사이클 수 CPU 시간명령어 개수 CPI 클럭 사이클 시간 IPC(Instructions Per clock Cycle)클럭 사이클 당 명령어 수 MIPS(Million Instructions Per Second)명령어 개수 / (실행시간*10^6) 예제다음은 명령어당 클럭 사이클 수를 통한 성능 비교를 보여주는 표이다. 시스템 이름 명령어 수 CPI 소요 시간 A 5 2 250ps B 6 1.2 500ps","link":"/2018/03/18/컴퓨터-구조-강의-01-컴퓨터-추상화-및-관련-기술/"},{"title":"컴퓨터 구조 | 명령어, 컴퓨터 언어","text":"서론컴퓨터 하드웨어에게 일을 시키려면 하드웨어가 알아들을 수 있는 언어로 말을 해야하며, 컴퓨터 언어에서의 단어를 명령어 라고 하며 그 집합을 명령어 집합 이라고 한다.본 강의에서는 명령어 집합의 하드웨어 표현방식 및 상위 수준 언어와의 관계를 보이며, 이를 통해 내장 프로그램의 개념을 이해한다. 하드웨어 연산기본적으로 컴퓨터는 산술연산을 할 수 있으며 다음과 같은 명령어를 사용한다. 1add a, b, c 위의 명령어는 b+c를 한 결과값을 a에 담는 식이다. 3. 피연산자레지스터 라고 하는 하드웨어로 직접 구현된 특수 위치 몇 곳에 있는 것만 사용할 수 있다.MIPS 구조에서 이러한 레지스터의 크기는 32비트(4 byte) 이며 총 32개로 레지스터의 갯수가 제한 되어 있으며 본 강의에서는 각 레지스터 마다의 성질을 보여주기 위해 $뒤의 숫자 가령 $t0와 같은 방식으로 레지스터를 표기한다.레지스터의 수가 제한된 이유는 레지스터가 아주 많아지면 전기 신호가 더 멀리까지 전달되어야 하므로 클럭 사이클이 길어지기 때문이다. 레지스터 안에는 변수, 명령어 등이 저장될 수 있는데,프로그래밍 언어에는 단순한 변수 이외에도 레지스터 개수보다 훨씬 많은 데이터 원소수가 있을 수 있다.산술연산은 레지스터에 의해서만 실행되므로 메모리의 값을 레지스터에 옮겨오기 위해서는 이들 사이에 데이터를 주고받기 위한 명령어가 필요한데, 이를 데이터 전송 명령어 라고 한다. 메모리에서 레지스터로 데이터를 옮기는 실제 명령어는 다음과 같다. 1lw t0, 8($s3) 한 주소블록은 32비트(즉, 4byte)를 기준으로 하기 때문에위 명령은 t0에 $s3에서부터 8번째 데이터를 담는 것이다.즉 실제 주소는: $s3 + 8*4byte에 위치한다. 레지스터 연산을 할때 상수를 더하는 경우가 있는데, 이 경우에는 상수만을 위한 명령어 addi 등을 사용한다.이 경우 상수값을 메모리에서 가져오는 것이 아니라 프로세서 내에서 바로 더해 줌으로써 훨씬 빠르게 처리를 할 수 있다. 상수 덧셈의 예1addi $s3, $s3, 4 어셈블리어의 기계어 표현레즈스터 내의 기계어 명령어 필드 R타입 op rs rt rd shamt funct 연산자 피연산자 피연산자2 목적지 자리이동 양 기능 6bit 5bit 5bit 5bit 5bit 6bit I 타입| op | rs | rt | constant+address ||:—- |:—- | —- | —————- || 6bit | 5bit | 5bit |21bit| 하드웨어의 프로시저 지원프로시저는 일종의 함수 역할을 하는 것으로 전달인수 레지스터4개와 반환 레지스터 2개, 복귀주소 1개로 이루어져 있다.","link":"/2018/03/20/컴퓨터-구조-강의-02-명령어-컴퓨터-언어/"},{"title":"컴퓨터 구조 | 프로세서","text":"파이프라이닝에 대한 개관 명령어 집합 구조가 구현의 여러 가지 측면을 어떻게 결정 하는지, 또 여러가지 구현 전략이 클럭 속도와 CPI에 어떻게 영향을 미치는지 살펴볼 기회를 갖게 될 것이다.명령어 종류에 관계없이 어떤 명령어 던지 처음 두 단계는 다음과 같이 동일하다. 프로그램 카운터(PC)를 프로그램이 저장된 메모리로 보내어 메모리로부터 명령어를 가져온다. 읽은 레지스터를 선택하는 명령어 필드를 사용하여 하나 또는 두 개의 레지스터를 읽는다. 파이프라이닝에 대한 개관파이프라이닝이란 여러 명령어가 중첩되어 실행되는 구현기술로써 기존의 단일 사이클 구조에서는 ALU 등 여러 장치가 다른 명령어를 실행하는 동안에는 동작하지 않는 것이 효율이 매우 떨어지기에 각 명령어를 처리할 수 있는 자원이 존재한다면 이를 병렬로 실행시켜 처리량을 올리는 기술이다.","link":"/2018/03/27/컴퓨터-구조-강의-프로세서/"},{"title":"컴퓨터 구조 | 메모리 계층구조란 무엇인가?","text":"왜 메모리 계층구조가 필요한가? 메모리의 종류에는 어떤 것들이 있나요? 왜 메모리 계층구조가 필요한가?컴퓨터 내에서 프로그램이 동작하기 위해서는 프로그램이 메모리 위에 적재되어야 하고, 이상적으로 모든 프로그램이 메모리 위해 적재 될 수 있는것을 많은 프로그래머들은 바래왔습니다.즉, 무제한의 크기를 가지는 빠른 메모리는 모든 프로그래머들을 꿈 이라고 볼 수 있습니다. 하지만, 메인 메모리는 메우 비싸기 때문에 이러한 무제한의 크기를 가지는 메인 메모리는 사실상 구현 불가능 하기에 메모리 계층 구조를 통해 한정된 메모리를 가지고 최대한 큰 크기의 메모리를 사용하는 것 처럼 컴퓨터가 행동하도록 노력했고, 그 결과 메모리 계층 구조가 도입되게 되었습니다. 메모리 계층 구조를 이해할 때에 흔히 도서관에서 공부를 하는 상황에 대입하여 생각해 볼 수 있습니다. 도서관에는 수많은 책들이 꽂혀 있고 언제든지 가져와서 책을 볼 수 있지만, 한번 책을 가져올 때 마다 상당히 귀찮고 오랜 시간이 소요되게 됩니다. 컴퓨터의 경우도 마찬가지 입니다. 여기서 도서관에 해당하는 것이 컴퓨터의 자기 디스크 입니다. 자기 디스크는 아주 크기가 크고 막대한 양의 자료가 들어갈 수 있지만 한번 접근하려면 오랜 시간이 걸리게 됩니다. 이 문제를 어떻게 해결해야 할까요?보통 도서관에서 공부를 할 때 우리는 필요한 책들을 쭉 뽑아서 책상위에 쌓아두고 공부를 시작합니다. 이렇게 하면 우리가 필요한 대부분의 정보들은 책상 위에서 빠르게 얻을 수 있고, 사실 도서관 전체에는 나와 관련이 없는 많은 자료들이 있는 것에 반해 책상 위에 뽑아 놓은 책에는 내게 필요한 정보들이 존재하게 됩니다. 이렇게 필요한 책을 뽑아 우리가 필요할 만한 정보들을 주변에 배치해 놓는 것처럼 컴퓨터 에서도 우리가 자주 사용할 만한 정보들을 가까운 곳에 복사해 놓게 되고 이것을 우리는 캐시 라고 합니다. 캐시에 들어갈 정보들은 어떤 식으로 선별이 될까요?이는 마치 도서관에서 책을 뽑아오는 것과 같은 논리이며 지역성의 원칙 에 따라 선별됩니다. 도서관에는 필요한 책들이 종류별로 분류되어 있고, 아마 내게 필요한 정보는 주변에 붙어 있을 확률이 높습니다. 내가 A라는 책을 가져오면서 혹시 몰라서 A 책 주변의 다양한 책들을 가져오는 것이 이러한 지역성의 원칙 을 따른 캐싱이라고 볼 수 있습니다. 또는, 내가 예전에 한번 봤던 책들에 내가 필요한 정보가 담겨있을 확률도 높습니다.위처럼 내가 필요한 정보 주변의 책에 필요한 정보가 있을 확률이 높은 것을 공간적 지역성 이라 하고, 또 예전에 내가 사용했던 책에 필요한 정보가 있을 확률이 높은 것을 시간적 지역성 이라고 합니다. 이러한 두가지 지역성을 원칙에 따라 우리는 책을 가져오고 컴퓨터 에서는 캐싱 을 통해 이러한 작업을 수행합니다. 도서관에서 책 무더기를 가져오듯이 한번에 가져오는 정보의 최소 단위를 블록 이라고 합니다. 컴퓨터가 어떤 정보가 필요하다면 그 정보가 담긴 블록을 통으로 가져와서 작업을 수행하게 됩니다. 만약 필요한 정보가 이렇게 한번 가져온 블럭 중에 있는 경우를 적중(hit) 했다고 하고, 그 확률을 적중률 이라고 하며, 그 시간을 적중 시간 이라고 합니다. 만약 가져온 블록 중에 필요한 정보가 없는 경우는 어떨까요?이 경우를 컴퓨터에서는 실패 라고 하며, 그 확률을 실패율 이라고 합니다. 이렇게 실패에 따른 손실은 실패 손실 이라고 하며 이는 하위 계층에서 블록을 가져와서 상위 계층 블록과 교체하는 시간에 그 블록을 프로세서에 보내는 데 걸리는 시간을 더한 값입니다. 이처럼 컴퓨터는 사용할 확률이 높은 정보들을 CPU에 가까지 적재하고 다른 정보들을 메모리 계층의 아래쪽에 위치시킴으로써 보다 빠르게 정보를 탐색할 수 있도록 하며, 때문에 메모리는 계층 구조 로 이루어져 있습니다. 메모리의 종류에는 어떤 것들이 있나요?메모리 계층 구조에서 프로세서와 가장 가까운 캐시 는 SRAM이 사용되며, 메인 메모리 에는 DRAM 이 사용됩니다. SRAM은 어떤 데이터든지 접근 시간이 같고 리프레시가 필요없어 DRAM에 비해 아주 빠릅니다. DRAM 은 SRAM에 비해 아주 느립니다.","link":"/2018/04/03/컴퓨터-구조-메모리-계층구조란-무엇인가/"},{"title":"퍼스트 클래스 승객은 펜을 빌리지 않는다","text":"실천적 행동에 매우 도움이 되는 책이다. 역사책을 읽어라 / 전기와 역사소설은 진정한 멘토를 찾아준다.신문읽기는 모든 독서에 앞서 필수이다. 펜과 메모는 언제 어디라도 함께한다. 아침은 생산적인 일에 쓰라 경계를 풀지않고 대화에 거리를 두는 스타일이 아닌 지나가는 사람에게도 스스럼 없이 말을 건네는 붙임성을 가지라.말을 할 때에는 중저음의 차분한 목소리로 침착하게 말하라.“따라하기 대화법” 항상 질문조의 어투를 유지하라 / 칭찬을 하라완충어구의 사용 “죄송하지만” “미안하지만” “고마워요” 인사의 힘! / 퍼스트 클래스는 승무원에게도 먼저 적극적으로 인사를 건넨다. 성공한 사람들은 자세가 다르다.당당하게 정면을 그리고 바로 앞이 아니라 먼 곳까지 내다보는 시선","link":"/2018/01/14/퍼스트-클래스-승객은-펜을-빌리지-않는다/"},{"title":"플랫폼사업자를 위한 stripe","text":"플랫폼사업자를 위한 stripeOverviewstripe의 connect는 사업자가 사용자에게 과금을 하고 과금된 금액을 다시 서비스 공급자에게 제공하기 위한 플랫폼 서비스에 매우 적합한 기술이다. connect를 통해 과금, 인증, 서비스 공급자에게 대금 지불 등의 많은 일들을 한번에 처리 가능하다. striped의 connect는 다음과 같은 일련의 작업을 처리한다. 고객으로 부터 플랫폼으로 얼마의 돈이 유입되고 최종적으로 플랫폼의 서비스 공급자에게 어떻게 흘러가는 지를 정의한다. 플랫폼의 수수료를 책정한다. 결제 스케줄과 방법을 결정한다. 여러 종류의 stripe계정을 지원한다. 이를 위해 플랫폼 사용자는 stripe 계정을 연동하여야 한다. 프로세스의 흐름 고객으로 부터 결제를 진행 charges! 플랫폼에서 연결된 계정(서비스 공급자)으로 돈을 전달 서비스 공급자에게 대금을 지급(stripe 내의 asset을 실제 현금으로 전환, payout) payout! 활용현황connect는 킥스타터와 같은 크라우드 펀딩 서비스와 shopify 등의 e commerce 플랫폼 등에서 사용되고 있다. Creating chargesconnected accound 에 대금 결제를 요청하는 세가지 프로세스이다. connected account에 직접 과금 특정 connected account에 전달이 되도록 과금 create the charge on your platform account and separately transfer funds to the connected account 첫번째 방식은 connected account에 직접 과금을 수행하는 방식으로 유저와 마켓 사이의 단순 과금의 경우이며, 두번째 경우는 우버와 같이 고객이 서비스 공급자에게 대금을 지불하는 직접 지불 방식이다. 마지막으로 세번째 방식은 고객에게 부과한 대금을 자체적으로 보관 한 뒤에 훗날 서비스 공급자에게 일괄로 지급하는 방식이다. 여기서 세번째 방식이 플랫폼 사업자에게는 가장 적합하지만, 현재는 플랫폼 사업자와 서비스 공급자가 미국 혹은 유럽 내에서 같은 지역 내에 위치한 경우에만 가능하기 때문에 글로벌한 서비스나 혹은 아시아권에서 사용하기에는 무리가 있다. Getting Started - third methodstripe 의 connect를 사용하기위한 절차는 다음과 같다. register your platform create a connected account process a payment 플랫폼 등록 및 accout 만들기stripe에 플랫폼을 등록하고 accout를 만들고 연결하고 payment를 진행해 볼 수 있다. accout에 연결한 뒤에는 반드시 finalize 해주어야 한다. payment 실행하기아래와 같은 curl 명령을 통해 특정 account에 payment를 실행해 볼 수 있다. 123456curl https://api.stripe.com/v1/charges \\ -u sk_test_XuTtHvVjbiOgT9aCFsFTsZTA: \\ -d amount=1000 \\ -d currency=usd \\ -d source=tok_visa \\ -d destination[account]=&quot;&#123;CONNECTED_STRIPE_ACCOUNT_ID&#125;&quot;","link":"/2018/07/02/플랫폼사업자를-위한-stripe/"},{"title":"트렌드 분석","text":"1차 산업혁명 / 농업 혁명을 통한 정착생활 도입 2차 산업혁명 / 증기기관과 공장의 확산 3차 산업혁명 / 인터넷을 통한 전 세계의 연결을 통해 시공간이 무너진 산업 구도의 형성 4차 산업혁명 / 시공간이 무너진 Bit World와 Atom World의 합치 Intelligent AI and Machine Learning Intelligent Apps 개요 Jake’s Idea Intelligent Things 개요 Digital VR and AR BlockChain Mesh Conversational Systems Digital Technology Platforms Adaptive Security Architecture 1차 산업혁명 / 농업 혁명을 통한 정착생활 도입2차 산업혁명 / 증기기관과 공장의 확산2차 산업혁명에서는 자본을 가진 자본가들이 막대한 규모의 자본을 투자하여 공장을 만들어 막대한 양의 재화를 빨리 만들어 내어 판매함으로써 인간은 그 공장을 돌리기 위한 기계로 전락해 버리게 되었다. 이러한 시대적 분위기에 반해 인간 본연의 존엄성을 살리고 모든 인간은 평등하며, 인간의 자율성을 추구하는 집단들이 나타나게 되었는데 ‘히피 문화’가 바로 그것이다. 3차 산업혁명 / 인터넷을 통한 전 세계의 연결을 통해 시공간이 무너진 산업 구도의 형성2차 산업 혁명 당시의 ‘히피’들은 인터넷을 통해 인간의 자율성을 한껏 발휘하여 테크토피아를 꿈꾸었고, 인터넷은 한 개인이 소프트웨어를 통해 전 세계에 영향력을 발휘할 수 있다는 점에서 그들에게 막대한 힘을 실어주게 된다. 많은 사람들이 인터넷이 주는 연결의 힘의 가능성을 믿었고, 산업의 많은 부분을 전자화 시켜 시공간을 무너뜨는 사업들을 벌여왔다. 서점에서 팔던 책을 전자화 시키고, 주변의 많은 사람들을 만나 교류하던 것을 인터넷 상에서 가능하게 하는 다양한 SNS 서비스들이 출몰하게 되었다. 이런 비즈니스는 당시로써는 아주 혁신적인 것이었고 만은 사람들이 이를 통해 막대한 부를 축적하게 된다. 4차 산업혁명 / 시공간이 무너진 Bit World와 Atom World의 합치4차 산업혁명에서는 IntelligentAI and Machine Learningdeep learing과 neural network로 어떤 현상을 이해하고, 배우고, 예상하고 적용하는 기능을 하는 시스템을 구축할 수 있다.이는 과거에 소수의 전문가 집단에 이루어 졌지만, 그 마저도 정확하지 않은 가설을 기반으로 한 경우가 대부분이었다. 데이터를 활용한다면 이러한 불확실성이 현저하게 줄어든다. Intelligent Apps개요인간의 업무를 보다 편리하게 도와줄 수 있는 다양한 지능 소프트웨어들이 출몰할 것이다.단순한 비서의 역할부터, ERP나 보안시스템 등 고차원적이고 복잡한 회사의 업무를 처리할 시스템이 나올 것이다. Jake’s Idea회사의 업무방식을 면밀히 살펴보고 각 회사에 맞는 커스터마이징된 제품이 나와야 시장의 사랑을 받을 수 있다.기존의 많은 소프트웨어들은 다수의 사용자에게 동일한 서비스를 제공한다는 점에서 한계가 있다. Intelligent Things개요로봇과 드론 자동화된 탈것들이 차지한다.다양한 iot 디바이스의 출몰 DigitalVR and ARVR을 이용해 현장에서 할 수 없었던 트레이닝이나 먼 장소에 대한 가상 탐험이 가능하고 AR을 통해 현실 세계에서 인간을 보조하여 편한 작업과 다양한 활동이 가능하다. BlockChain거래 정보를 모든 사람들이 공유하는 시스템으로 보안이 매우 높다.이러한 distributed ledger 방식은 산업의 운영방식을 획기적으로 바꿀 수 있는 경쟁력을 가지고 있다.믿을 수 없는 환경에 투명한 접근을 하게 됨으로써 안정적인 환경을 만들어 준다.이러한 블록체인은 음악 산업, 인증 서비스 등에서 그 가능성이 있다. MeshMesh란 사람, 프로세스, 사물, 서비스 들의 역동적인 연결을 말한다.이러한 메쉬효과로 사용자의 경험이 본질적으로 변화하고 이를 지원하기 위해 다양한 기술과 보안 구조와 플랫폼들이 변혁하고 있다. Conversational Systems단순히 문자나 목소리로 소통하는 것이아니라 상황과 문맥 등을 통해 다양한 정보를 유추하는 것이다.예를 들어 목격자의 진술을 통해 용의자의 스케치를 그려내거나 하는 등에서 단순히 진술 뿐 아니라 다양한 맥락을 통해 실제에 가까운 용의자 사진을 그려낸다. 단순히 사람들의 목소리와 글자를 인식하는 것이 아니라 다양한 정보를 종합적으로 받아들임으로써 새로운 정보를 얻게 된다. Digital Technology Platforms정보 시스템, 고객 경험, 분석과 지성, 사물인터넷이 비즈니스의 환경이 될 것이며 기업들은 산업의 플랫폼이 어떻게 변화할 것인가를 알고 이에 변화해야 한다. Adaptive Security Architecture보안이 상당히 유동적이고 적응성이 높은 형태로 발전해야 한다.","link":"/2018/01/14/트렌드-분석/"},{"title":"학습의 방법","text":"내가 배운 지식과 결합하여 새롭게 구조화 하라 지식의 인출과정을 거쳐야 한다. 데드라인을 설정하라 예제를 풀거나 혹은 예를 들어 쉽게 설명해 보라 인생의 배움의 연속이라 할 수 있다.첨예한 비즈니스 세계에서 살아나가던지 혹은 엔지니어 로써 기술을 배우던지 어떤 업을 가진 사람이라도 매일 매일을 배움이 없이 살아간다면 언제든지 침몰 할 수 있으며, 그만큼 인생에서 배움이란 큰 역할을 차지한다. 본 글에서는 ‘학습’에 있어서의 몇가지 원칙을 제시하며 이를 통해 효과적인 학습을 할 수 있도록 하는 것에 그 목적이 있다. 내가 배운 지식과 결합하여 새롭게 구조화 하라학습, 즉 새로운 것을 배울 때에는 내가 알고있는 개념들에 대한 구조화를 먼저 끝낸 뒤에 그 구조에서 사고를 심화시켜 지식을 확장해야 한다. 내가 아는것과 모르는 것이 무엇인지 또 내가 알고 있는 어떤 지식을 더 심화시키는 것인지를 명확히 이해해야 지식을 체계적이고 효과적으로 습득할 수 있다. 가령 로마사를 공부한다고 하자.내가 로마에 대해 아는 것이 무엇이며 지금 학습하는 내용이 내가 알고 있는 부분들고 어떤 연관관계가 지어지는 지를 이해하는 것이 학습의 기초이다. 배움을 시작하기에 앞서 배우고자 하는 내용에 대해 내가 아는것이 무엇인지를 글 혹은 다이어 그램을 통해 체계적으로 구조화 시켜 보고 내가 배우고자 하는 내용이 여기서 어느 부분에 속하는 지를 아는 것이 학습의 첫 단추이다. 지식의 인출과정을 거쳐야 한다.책을 보거나 혹은 강의를 듣는 등 수동적으로 지식을 두뇌에 주입하였다면 그 지식이 정말 나의 것이 되었는지 알 수 없다. 이 단계에서 계속해서 내용을 복습하는 것은 의미가 없다. 반드시 책을 덮고 혼자만의 시간을 가져 백지에 배운 내용을 스스로 떠올리고 지식을 머릿속에서 인출 하는 과정을 거쳐야 내가 아는것과 모르는 것을 정확히 알 수 있고, 또 더 오래 기억에 남게 된다. 가능하다면 다른 사람에게 내가 배운 내용을 가르치거나 이를 다른사람에게 주기 위한 블로그 형태로 게재하는 것이 큰 도움이 될 수 있다. 반드시, 배운 내용을 아무 도움 없이 떠올려 보아야 한다. 만약 블로그를 작성한다면 먼저 대 목차를 쓴 뒤에 책이나 참고자료를 보지 않고 설명하듯이 작성해 본다.이렇게 참고자료나 책을 보지 않고 머릿속에서 지식을 인출하는 과정이 매우 중요하다. 데드라인을 설정하라공부의 시작과 끝에는 반드시 휴식시간을 두고 정해진 시간 내에 끝내도록 하여야 한다.이를 통해 집중력을 올릴 수 있게 되고 특정 시간대에 특정 주제에 대해 완벽히 집중하여 번잡스러운 공부를 피할 수 있게 된다. 가령 새로운 정보를 습득할 때에는 공부 중에 모르는 내용이 나오게 되고 해당 부분을 선행한 뒤에 그 공부를 다시 시작하여야 할 필요가 생길때가 있을 것이다.그런 경우는 선행되는 공부를 먼저 끝낸 뒤 다음 공부를 진행하여야 하는데 이것의 순서를 차곡차곡 쌓아두어야 순서에 맞추어 차근차근 효율적으로 공부를 진행할 수 있다. 예제를 풀거나 혹은 예를 들어 쉽게 설명해 보라만약 어떤 개념을 글로만 배웠다면 이 지식을 절대 활용할 수 없다.반드시 예제와 연습문제 혹은 예를 들어 설명해 봄으로써 익혀야 아는 것이 된다. #","link":"/2018/04/13/학습의-방법/"},{"title":"Blockchain trend","text":"Blockchain technology for enterprise service 건강 보험 등 이력에 대한 불변의 상태기록을 원하는 비즈니스에서는 상당히 유용하게 사용될 수 있다. 인센티브의 경우 네트워크 망을 유지하고 서비스에서 인센티브를 제공하는 기능을 어떻게 활용 가능한가? Case1 분산 원장으로써의 블록체인 롯데카드 -&gt; 블록체인 기반 생체 인증 삼성페이에서 로그인 정보를 다른 쪽에도 유지하기 위해 사용 =&gt; Case2 스마트 컨트랙트로써의 블록체인 현대카드 포인트 페이먼트를 스마트 컨트랙트로 구성 제일 큰 문제는 성능문제. =&gt; 추가로 컨센서스를 만드는 작업 등 신한금융 =&gt; 인증서 발급 로직을 스마트 컨트랙트로 구성 금융보안원, 금융 결제원 =&gt; 폰뱅킹 및 은행 송금 시스템 은행 송금 시스템을 블록체인화, 기존에는 중앙 시스템이 모든 은행의 거래 내역을 다 처리하고 매일 한번씩 정산하여 데이터베이스를 맞추는 식으로 햇었음 이 경우 스마트 컨트랙을 통해 했는데 역시 성능문제가 생겼음 여기서 가장 중요한 점은 고객 데이터는 데이터베이스에 올라갈 수 없음 때문에 블록체인과 외부 디비가 어떤 식으로 연동하는 것이 매우 중요한 포인트임 고객의 주요 쟁점 퍼포먼스 컨트랙트 내부 병렬화에 대한 요구가 나온다. 보통 컨트랙트 내에서 락을 걸어서 처리를 하는데 이 경우 처리가 빠르게 일어나지 못함 privacy개인정보를 올리려면 어떻게? =&gt; 난스 만들어라 Multi chain 익명 기술 파이널리티 가령 블록이 생성되어 트랜잭션이 만들어 지더라도 블럭이 폐기되면 다시 뒤로 돌아가기 때문에 고객의 지갑이 변동되는 문제가 생기며 이는 매우 큰 이슈이다, 블록체인 비즈니스 활용 Tip 사이드 체인을 유지하고 퍼블릭 네트워크와 연동하는 형태로 많이 서비스를 하게 된다. 이렇게 하면 기존 서비스의 품질을 해치지 않으면서도 블록체인을 적용할 수 있다. 가령 포인트를 적립시킨다고 하면 별도 사이드 체인을 만들어서 포인트를 등록하고 해당 체인을 다른 퍼블릭체인과 연동하여 포인트를 유통시킬 수 있다. 즉 이더 송금 수수료를 한번만 이용하지만 여러 거래를 별도 사이드체인에서 동작시키고 퍼블릭체인과 연동함으로써 해결이 가능하다. Ex) aergo =&gt; 블록체인 sass 서비스 업그레이드 가능한 스마트 컨트랙트 투명성, 위변조 불가성 왜 업그레이드 가능한 스마트 컨트랙트가 필요한가? 배포 후 취약점이 발견되면 수정이 가능하다. 비즈니스 로직이 수정 불가하기 때문에 겪게 되는 불편함이 있다. Delegate call 특정 컨트랙트를 통해 다른 컨트랙트를 실행시킴 조건 업그레이드로 스마트 컨트랙트 주소 안변함데이터 마이그레이션 없이 데이터보존여러 스마트 컨트랙을 한번에 배포 Proxy contract 를 만들어 버전관리를 하고 유저는 proxy contract 로 전달하고 proxy contract는 최신버전의 contract로 명령을 전달한다. Registry contract upgrade Earl =&gt; 업그레이드하고자 하는 proxy contract의 주소를 받아온다. registry contract 모두를 업그레이드 하기 위해 registry contract를 실행시킨다. 스마트 컨트랙트 버전관리 툴 deploy Registry contract 가 없으면 registry contract 배포 업그레이 가능한 스마트 컨트랙트의 이점 유저 입장에서는 스마트 컨트랙트 주소가 고정됨, 버전 정볼르 생각하지 않고 특정 호출만 계속 함개발자 입장에서는 모든 데이터가 그대로 유지되고 재사용 되게 됨업그레이드가 매우 편리함. Token Model Design Process 토큰 모델이랑 탈중앙화 네트워크의 보이지 않는 손이다. 토큰이라는 인센티브를 가지고 경제가 어떻게 굴러가는지를 설계한다. 게임 이론 주어진 게임의 규칙에서 최선의 전략을 찾는 이론 메커니즘 디자인 모든 플레이어가 게임에 충실하게 참여를 했을 때 이를 원하는 방향으로 굴러가게 하기 위한 메커니즘에 대한 디자인 어떻게 기존의 경제 시장에서 토큰 모델을 적용시킬 것인가? 메커니즘 디자인의 기초 Agent 행동 주체 Type agent의 사적인 정보 Decision 가능한 사회적 결과의 집합 Utility function 에이전트가 특정 결과에 대해 얻는 효용 Decision function agent의 각 행동을 종합한 결정 규칙 Transfer function agent의 행동에 따라서 받거나 내야하는 돈 Social choice function 가령 마을에 쓰레기 처리장을 짓는 문제를 생각해 보자. 제일 쉬운 방법은 누군가가 모든 사람들에게 의견을 물어보는 것이다. 여기서 transfer function 은 agent의 type 에따라서 받거나 내야하는 돈의 규칙이다. 메커니즘의 특성 Efficiency 최대 다수의 최대 행복 trustfulness 모든 에이전트의 균형 전략이 자신의 type을 솔직하게 보고하는 것일때 Budget balanced agent의 type이 바뀌더라도 메커니즘이 transfer function으로 얻는 수입이 일정할 때 메커니즘을 최적화 문제로 정의할 수 있다!! 메커니즘 최적화 적용 가령 서울의 평균 기온을 블록체인에 기록하는 메커니즘을 만든다고 해보자 오라클 선출 =&gt; 신뢰할 수 있는 외부 데이터를 선정한다. Shelling coin 많은 사람들이 준 값들의 중간값을 실제값으로 정한다. 계속해서 decision function 과 transfer function 을 바꾸어 보면서 실 데이터를 분석하여 효율적인 메커니즘을 도출해 내야 한다. 토큰 모델 디자인 프로세스 agents와 목표 행동 정의최적화 문제 설정반복메커니즘 규칙 설정규칙 변경결과 추론제약조건 변경 예시 - steemit Object =&gt; 좋은 글의 공급을 극대화 Constraint =&gt; 초보 작가들이 글을 쓰기가 쉬워야 함, 독자들은 글을 쓸 때 돈을 내지 않아야 함 등 Decision =&gt; 추천수에 스팀 파워 가중치를 계산해 퀄리티로 인정함 Transfer =&gt; 더 나은 설계를 위해 필요한 것들 좋은 규칙의 집합, 패턴실제 돌아가는 프로젝트에서 나오는 실증 데이터복잡한 메커니즘의 정량적 추론을 위한 시뮬레이션 툴 토큰 디자인 패턴 Incentive, curation , judgement, governance 메커니즘 디자인의 한계 닫힌 시스템을 가정한 설계이기 때문에 경쟁 프로토콜, 암호화폐 시장 등 외부 요소는 고려하지 못하기에 블록체인과 같은 완벽하게 공개된 플랫폼 내에서 어떤 사이드 이펙트가 나올지 알 수 없다. 토큰 디자이너를 위한 팁 플레이어가 아니라 디자이너처럼 생각하라. 목적과 제약조건 정의만 잘해도 반은 먹고 들어간다. =&gt; 토큰 가치 상승이 목적인가 이중 지불 방지가 목적인가, 목적과 제약조건만 확실하다면 솔루션은 얼마든지 바꿀 수 있음 솔루션을 decision function 과 transfer function 으로 바꾼다. 알고 있는 패턴이 풍부해야 문제를 잘 풀어나갈 수 있다. 화폐가치와 메커니즘 디자인은 어떻게 결합될 것인가 IOT에서의 블록체인 오프라인 데이터의 위변조를 막기 위해 가량 씨씨티비의 경우 해당 영상의 해시값을 저장하여 블록체인에 저장하고 추후 검증이 필요한 경우 해당 해시와 비교를 통해 할 수 있따. Digital forensic =&gt; 영상 데이터의 법정에서 신뢰를 얻을 수 있음 가령 자율주행차의 경우 수동으로 운전을 했는가 혹은 자동으로 운동을 했는가가 과실에 매우 중요하다. 이를 블록체인에 실시간으로 저장하면 이를 막을 수 있다. DAICO 모델 - 블록체인 위에서 ico 플랫폼 메커니즘 하스켈","link":"/2018/03/28/blockchain-trend/"},{"title":"Getting started with elastic stack","text":"Why elastic stack?기업의 서비스의 복잡도가 올라감에 따라 프록시 서버, 인증서버, 데이터베이스, api 서버 등 수많은 서비스들이 동작하고, 각자 다른 배포환경에서 관리되게 되었다. 이에 따라 하나의 서비스를 운영하더라도 여러 도메인에 걸쳐 많은 문제들이 생기게 되고, 여러 서버에 걸쳐 로그 및 데이터 분석의 필요성이 생겼고, 데이터를 관리하고 활용하기 위한 통합 솔루션의 필요성이 대두되었다. Elastic Stack 은 기업이 서비스를 운영함에 따라 나오는 모든 데이터를 한 곳에서 관리하고, 사용자가 직관적으로 이해할 수 있도록 시각화 시켜 가공하고, 수많은 데이터에서 원하는 데이터를 검색 및 분류해주는 플랫폼이다. 쉽게 이야기 하면, 기업이 운영하는 수십대의 서버 및 데이터베이스에서 나오는 모든 데이터를 한곳으로 모으고, 가공하고, 시각화해주는 통합 솔루션이라 할 수 있다. 이러한 기능을 수행하기 위해 elastic stack 을 구성하는 여러 서비스가 있는데, 대표적으로 각 서버에서 생기는 데이터를 한 곳으로 모으는 shipping 을 담당하는 beats(beat 에는 file beat 등 여러 종류의 beat 가 있으며, 기본적으로 file beat 를 사용하면 기업의 데이터 파일을 한곳으로 간편하게 이동시킬 수 있다.)와 데이터를 저장하고 분류하는 일종의 데이터 검색 엔진인 elastic search , 또, 이러한 사용자에게 가시적으로 보여주기 위한 kibana 등이 있다. 본 포스트에서는 이러한 elastic stack 의 다양한 기술을 활용하여 여러 서버의 로그 정보를 한 곳에 모으고 이를 모니터링 하기 위한 환경을 구축해 보도록 하겠다. File beat먼저 각 서버에서 나오는 로그들을 한곳으로 shipping 하기 위해서, 각 서버에 file beat 를 설치하고 운영해야 한다. 본 포스트에서는 각 서버와 filebeat 를 하나의 docker-compose 로 관리하여 하나의 서버에서 filefbeat 와 application 서버를 구축하고 이를 elastic search 서버로 전달해 보도록 한다. 어플리케이션 서버와 file beat 를 구성하는 docker-compose 파일은 다음과 같다. docker-compose.yaml 12345678910111213141516171819202122232425262728293031version: '3'services: filebeat: image: docker.elastic.co/beats/filebeat:$&#123;ELASTIC_VERSION:-6.5.0&#125; hostname: '&#123;&#123;.Node.Hostname&#125;&#125;-filebeat' user: root networks: - default volumes: - /var/run/docker.sock:/var/run/docker.sock - /var/lib/docker/containers/:/var/lib/docker/containers/:ro - ./log/application:/var/log/application command: ['--strict.perms=false'] deploy: mode: global server: image: 'example-server' build: './example-server' volumes: - ./log:/app/log networks: - default ports: - '3001:3001'networks: default: driver: bridge 파일비트가 수집할 로그가 있는 디렉토리를 docker volume 으로 지정하고 application server 를 3001 번에서 동작시켰다. 또한, filebeat 의 설정을 담당하는 filebeat.yml 파일을 docker 내에 볼륨으로 지정하였으며, 그 내용은 다음과 같다. filebeat.yaml 123456789101112name: example filebeatfilebeat.inputs: - type: log enabled: true paths: - /var/log/application/*.logoutput.elasticsearch: hosts: ['host.docker.internal:9200']setup.kibana: host: 'host.docker.internal:5601' 위처럼 9200번 포트에서 동작하는 elastic search 서버와 5601번에서 동작하는 kibana가 세팅된다. deploy with beanstalkBeanstalk 에서 multidocker deploy를 위한 Dockerrun.aws.json 파일을 작성하여 다음과 같이 배포할 수 있다. 여기서 중요한 점은 image 를 배포함에 있어 반드시 사용자id.dkr.ecr.ap-northeast-2.amazonaws.com/레포이름:latest 의 형태로 이미지 경로를 지정해 주어야 한다는 것이다. 즉, 멀티 도커를 사용할 때 필요한 이미지들을 미리 아마존의 repository 에 배포해 놓아야 한다. 이 과정에서 반드시 아마존에 로그인이 되어야 하며, 다음과 같은 명령어를 통해 ecr 에 별도로 로그인을 수행한다. 아래 명령어는 기본 aws 유저가 아닌 eb cli 접근이 가능한 프로그램 유저를 설정해 두고 해당 유저의 정보로 로그인을 함을 의미한다. 아래 명령어를 입력하면 AWS 에서 로그인을 하기 위한 명령어를 output 으로 제공하는데 해당 문자열을 복사하여 다시 cli에 입력하면 로그인이 완료된다. 1aws ecr get-login --no-include-email --profile eb-cli 여기서 memory 는 매우 중요한데, 만약 memory 가 부족하다면 도커 컨테이너가 아무런 에러도 출력하지 않고 종료되어 버리니 이점에 유의해야 한다. Dockerrun.aws.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; \"AWSEBDockerrunVersion\": 2, \"volumes\": [ &#123; \"name\": \"log\", \"host\": &#123; \"sourcePath\": \"/var/log\" &#125; &#125; ], \"containerDefinitions\": [ &#123; \"name\": \"filebeat\", \"image\": \"docker.elastic.co/beats/filebeat:6.5.0\", \"essential\": true, \"memory\": 128, \"mountPoints\": [ &#123; \"sourceVolume\": \"log\", \"containerPath\": \"/var/log\" &#125; ], \"command\": [\"--strict.perms=false\"], \"links\": [\"server\"] &#125;, &#123; \"name\": \"server\", \"image\": \"사용자id.dkr.ecr.ap-northeast-2.amazonaws.com/레포이름:latest\", \"essential\": true, \"memory\": 512, \"mountPoints\": [ &#123; \"sourceVolume\": \"log\", \"containerPath\": \"/app/log\" &#125; ], \"portMappings\": [ &#123; \"containerPort\": 3001, \"hostPort\": 80 &#125; ] &#125; ]&#125; how does it works?File beat 에는 input 과 harvest 라는 두가지 큰 개념이 있다. 먼저 input 이란 filebeat 가 데이터를 읽어오는 리소스를 찾고, 이를 실제로 읽어들이는 harvestor 를 관리하는 역할을 수행한다. 인풋으로 type 이 log 인 인풋이 들어오면 해당하는 패스에서 모든 파일을 찾아 각각에 harvestor 를 작동시킨다. 각 input 은 각자 독자적인 go routine 을 통해 돌아간다. 파일비트는 다음과 같은 종류의 여러 type 의 인풋을 제공한다. log, stdin, redis, udp, docker, tcp, syslog example 12345filebeat.inputs:- type: log paths: - /var/log/*.log - /var/path2/*.log harvestor 란 파일을 하나하나 읽어서 수집하는 harvest 를 수행한다. harvestor는 각 파일을 라인바이 라인으로 읽어서 아웃풋으로 보내며, 파일을 열고 닫으면서 계속 수집을 수행한다. harvestor 가 로그를 수집하는 동안 file을 계속 열어놓는다. harvestor 를 닫으면 리소스를 할당 해제한다. 파일의 상태관리는 어떻게 하나?파일 비트는 각 파일의 읽기 상태를 레지스트리 파일 디스크에 기록해 두고 계속 트레킹한다. 이를 통해 어디까지 읽었는지 파악하고 output server 와의 연결상태가 불안정하다면 이를 계속 트레킹 하고 빠짐없이 보내준다. 파일비트는 무조건 최소한 한번은 정보가 전달되는 것을 보장하는 대신 대신에 두번 갈수는 있다. 이는 레지스트리에 저장된 값 덕분이다. 데이터가 두번 전송되는 문제는 shutdown_timeout 옵션을 통해 조절 할 수 있다. 가령, 파일비트가 종료되기 전에 시간을 두고 데이터를 전송을 완료하는 등의 동작을 수행하는 것이다. 또한, output으로의 연결 상태가 좋지 않은데 파일이 삭제된다면 이는 유실될 수 있다. logstashlogstash 는 data flow engine 으로써 filebeat, dbms, message que 등 여러 데이터 소스로 부터 데이터를 받아 데이터를 가공하고 정제하는 역할을 수행한다. Logstash 에는 pipeline 이라는 개념이 있으며, 여러 데이터들에 대해 일련의 작업을 수행하는 pipeline의 합집합으로써 동작한다. elastic stack 내에서 일반적인 활용도는 각 서버의 filebeat 가 보낸 로그 데이터를 받아 각종 메타 정보를 기입하고 분류하고 정제하여 elastic search 서버로 보내주는 역할을 수행한다. logstash의 기능은 크게 3가지로 이야기 될 수 있는데 바로 input, filter, output 이다. 먼저 input 은 데이터가 유입되는 근원지를 설정함으로 파일, 데이터베이스, 메세지 큐, 파일비트 등 데이터 유입 경로를 지정하고 주기적으로 데이터를 받는다. filter 단계에서는 받은 데이터를 필터링하고 정제하여 메타데이터를 입히고 데이터를 전처리하는 등을 수행한다. output 단계에서는 정제된 데이터를 목적으로 되는 서버로 전달하며 주로 검색엔진인 elastic search 등으로 데이터를 전달한다. logstash 는 데이터를 정제하는 과정에서 codec 을 사용하는데, codec 이란 특정 데이터 소스의 형식에 맞는 데이터를 우리가 원하는 형태로 가공해 주는 역할을 하는 encode decode 를 수행한다고 보면 된다. 가령, nginx 서버에서 생성된 각종 nginx 서버 양식의 로그 데이터를 nginx codec 으로 decode 하여 다시 우리가 원하는 데이터 모델로 재생성 하는 것을 생각하면 된다. 이렇게 재가공된 데이터는 다시 filter 를 통해 분류되어 목적지 output 으로 전달된다. installation1docker pull docker.elastic.co/logstash/logstash:6.6.0 run1docker run --rm -it -v ~/pipeline/:/usr/share/logstash/pipeline/ docker.elastic.co/logstash/logstash:6.6.0 여기서 logstash 는 파일비트로 부터 여러번 데이터를 받아 batch size 만큼을 체운 뒤에 elastic search 에 데이터를 전달하기 때문에 즉각적으로 데이터가 전송되지 않아 동작을 확인하기 어려울 수 있다. 가급적 input 에 tcp 를 추가하여 실시간으로 데이터를 확인할 수 있도록 설정해 놓으면 비교적 편리하게 테스트를 진행할 수 있다. logstash.yml 12345678910111213141516# 파이프라인 수를 의미한다.# 더 많은 CPU 를 사용하기 위해 설정한다.pipeline.workers: 2# 배치 사이즈를 설정한다.pipeline.bath.size: 125# 배치 딜레이는 어떤 간격으로 요청하는지 한다.pipeline.batch.delay: 5# config 옵션이 변경되면 보고 감지하는 옵션이다.config.reload.automatic: false# config 변경을 감지하는 주기이다.# 현재 설정에서는 5초에 한번 감지하는 것으로 되어있다.config.reload.interval: 5s Elastic SearchElastic search 는 filebeat 가 수집해온 데이터를 분류하고 서치하는 검색 엔진이다. installactio on dockerelastic search server 를 설치하고 실행한다. 1docker pull docker.elastic.co/elasticsearch/elasticsearch:6.5.4 1docker run -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" docker.elastic.co/elasticsearch/elasticsearch:6.5.4 docker 를 사용하여 구성을 할때 max virtual memory areas vm.max_map_count [65530] is too low, increase to at least 와 같은 에러가 나올 수 있다. 이는 도커에서 할당하는 최대 가상 메모리가 모자라서 생기는 문제로, 다음과 같은 명령어를 통해 이를 늘려주면 해결된다. 1sudo sysctl -w vm.max_map_count=262144 Kibana키바나는 내부적으로 노드서버를 띄우며, 사용자가 수집한 정보를 사용자에게 보여주기 위해 시각화 시켜주며, 사용자를 위한 관리자 대쉬보드를 제공한다. 또한, kibana 는 elastic search 를 조작하기 위한 dev console 또한 제공한다. 1docker pull docker.elastic.co/kibana/kibana:6.5.4 123456version: '2'services: kibana: image: docker.elastic.co/kibana/kibana:6.5.4 volumes: - ./kibana.yml:/usr/share/kibana/config/kibana.yml 다운로드를 받았다면 설치를 풀어주고 exconfig/kibana.yml 의 설정을 해준다. 키바나를 실행하면 Localhost:5601 로 키바나가 붙는다. Kibana query123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168POST /inspections/_doc&#123; \"business_address\":\"kwan ak goo\", \"coordinates\":&#123; \"lat\":21, \"lon\":-123 &#125;, \"score\":12&#125;POST /inspections/_doc/_bulk&#123; \"index\" :&#123; \"_id\" : 1 &#125; &#125;&#123;\"business_address\":\"kwan ak goo\"&#125;&#123;\"index\":&#123;\"_id\":2&#125;&#125;&#123;\"business_address\":\"kwan ak goo\"&#125;GET _search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;&#125;GET /inspections/_mapping/_docPUT /inspections/_mapping&#123; \"properties\": &#123; \"business_address\":&#123; \"type\":\"test\", \"fields\" : &#123; \"keyword\" : &#123; \"type\" : \"keyword\", \"ignore_above\" : 256 &#125; &#125; &#125;, \"coordinates\":&#123; \"type\":\"geo_point\" &#125; &#125;&#125;GET /inspections/_doc/_search&#123; \"query\": &#123; \"range\":&#123; \"score\":&#123; \"gte\":11 &#125; &#125; &#125;, \"aggregations\":&#123; \"inspection_score\":&#123; \"range\":&#123; \"field\":\"score\", \"ranges\":[ &#123; \"key\":\"0-80\", \"from\":0, \"to\":80 &#125; ] &#125; &#125; &#125;, \"sort\":[ &#123; \"_geo_distance\":&#123; \"coordinates\":&#123; \"lat\":34.322345, \"lon\":-122.234234 &#125; &#125;, \"order\":\"asc\", \"unit\":\"km\" &#125; ]&#125;GET /inspections/_doc/_search&#123; \"query\": &#123; \"match\":&#123; \"business_address\":\"modified\" &#125; &#125;&#125;GET /inspections/_doc/_search&#123; \"query\": &#123; \"match_phrase\":&#123; \"business_address\":\"kwan\" &#125; &#125;, \"highlight\":&#123; \"fields\":&#123; \"business_address\":&#123;&#125; &#125; &#125;&#125;GET /inspections/_doc/_search&#123; \"query\": &#123; \"bool\":&#123; \"must\":[ &#123; \"match_phrase\":&#123; \"business_address\":\"kwan\" &#125; &#125;, &#123; \"match_phrase\":&#123; \"business_address\":\"ak\" &#125; &#125; ], \"must_not\":[ &#123; \"match_phrase\":&#123; \"business_address\":\"goo\" &#125; &#125; ] &#125; &#125;&#125;PUT /inspections/_doc/t061gmgBoJ5OaX9VzeS8&#123; \"settings\":&#123; \"index.number_of_shards\":1, \"index.number_of_replicas\":0 &#125;, \"business_address\":\"modified\"&#125;PUT /inspections/_doc/t061gmgBoJ5OaX9VzeS8&#123; \"settings\":&#123; \"index.number_of_shards\":1, \"index.number_of_replicas\":0 &#125;, \"business_address\":\"modified\"&#125;POST /inspections/_doc/0k6Ug2gBoJ5OaX9VzuR6/_update&#123; \"settings\":&#123; \"index.number_of_shards\":1, \"index.number_of_replicas\":0 &#125;, \"business_address\":\"modified\"&#125;GET /inspections/_analyze&#123; \"tokenizer\": \"standard\", \"text\":\"my email address test1234@example.com\"&#125;GET /inspections/_analyze&#123; \"tokenizer\": \"standard\", \"filter\": [\"lowercase\", \"unique\"], \"text\":\"My my email address test1234@example.com\"&#125;","link":"/2019/01/25/getting-started-with-elastic-stack/"},{"title":"Getting started with NGINX","text":"What is NGINX일반적으로 webserver라 하면 http 요청이 들어오면 필요한 작업을 수행하는 서버를 의미합니다. 즉, 브라우저에서 읽을 수 있는 html 파일 등을 전달해 주는 역할을 합니다. 하지만 단순한 정적파일의 제공으로는 동적 파일 렌더링등을 수행할 수 없기 때문에 webserver는 요청을 받으면 웹서버에서 요청을 받아 그 요청을 외부 프로그램에 넘겨주면, 외부 프로그램이 프로그램 파일을 읽어 html로 반환하는 단계를 거치게 되며, 이것을 CGI 라고 합니다. 대표적인 CGI 로는 php fpm 등이 있습니다. * FAST CGI(Common Gateway Interface) 란 무엇인가? FastCGI는 상호 작용 프로그램을 웹 서버와 통신하기 위한 바이너리 프로토콜이다. FastCGI는 초기 공용 게이트웨이 인터페이스(CGI)의 변형이다. FastCGI의 주 목적은 웹 서버와 CGI 프로그램 간 통신 시 발생되는 부하를 줄임으로써 서버가 한 번에 더 많은 웹 페이지 요청을 관리할 수 있게 하는 것이다. * php-fpm nginx가 요청을 받아 php인 경우 cgi 인 php fpm에게 요청을 전달하고 거기서 php 코드를 실행한 뒤에 요청을 다시 받아온다. Forward Proxy &amp; Reverse ProxyNGINX 는 Web Server 로써 일반적으로 기업에서 서비스를 배포할 때 reverse proxy server의 역할을 수행한다. Nginx 에 대해 설명하기 전에 먼저 forward proxy 와 reverse proxy의 개념부터 설명하고자 한다. 먼저, forward proxy server란 사용자가 원하는 정보를 좀 더 빨리 받게 하기 위해 중간에 요청을 가로채는 것이라 볼 수 있다. 가령 target.com 이라는 주소로 어떤 정보를 받아오고 싶은 유저가 있다고 생각해 보자. 이 유저는 주소창에 target.com 을 입력하고 데이터를 받아올 것이며, 이 유저는 자신이 보고 있는 정보가 target.com 에서 보낸 정보라고 생각할 것이다. 하지만 대부분의 경우 유저가 받아온 정보는 실제로 target.com에 있는 정보가 아닌 중간의 프록시 서버에서 이전에 받아놓은 target.com 의 정보를 전달해 주는 것이다. 이러한 proxy server 는 많은 이점을 제공해 주는데, 가령 우리가 목적으로 하는 target.com 의 경우 우리의 ip 주소에 대해서는 알수가 없고, 우리가 사용하는 proxy 서버의 url 에 대해서만 알 수 있다.(하지만 대부분의 경우 browser가 우리의 정보를 제공하기 때문에 사실상은 다 알수 있다..!) 또한, proxy server 는 이미 알고 있는 정보에 대해서 해당 데이터를 cache 하기 때문에 추가적인 요청 없이 바로 우리에게 원하는 정보를 전달해주기 때문제 네트워크 속도의 관점에서도 더욱 빠르게 동작한다. NGINX 는 이러한 forward proxy 의 기능도 수행할 수 있지만, 대부분의 경우 reverse proxy 의 용도로 사용되는데, 이는 http server 의 보안 문제 해결과 로그 수집 등 여러 이점을 가지기 때문에 사용된다. 가령, 사용자는 proxy.com 이라는 url 로 요청을 주고 실제 서버의 위치인 target.com url 을 유저로 부터 접근을 불가능 하게 막고, 해당 서버를 VPN 에 구성함으로써 보안을 높일 수 있다. How does it works?NGINX 서버는 nginx 그룹의 nginx 라는 유저로 모든 프로세스를 실행한다. 요청이 들어오면 nginx 는 해당 요청의 hostname 을 보고 설정된 서버들 중 어떤 서버를 사용할지 선택한다. NGINX 에는 다양한 서버 설정을 할 수 있으며 이는 /etc/nginx/conf.d/ 디렉토리에 수많은 conf 파일의 설정들 중에 어떤 서버 설정을 사용할지 결정하는데 있어 hostname 을 사용한다. 여기서 일치하는 hostname이 있다면 해당 설정대로 serving 하되, 만약 일치하는 hostname 이 없다면 default server 를 사용하며 이는 다음과 같이 server 에서 listen 하는 설정에 default_server 태그가 붙어있는 서버를 선택한다. 1234server &#123; listen 80 default_server; server_name example.net www.example.net;&#125; 어떤 서버로 부터 serving 할지 결정되었다면, nginx 는 url 패스를 읽어들이고 이를 location 과 비교하여 일치하는 리소스를 찾는 작업을 거치게 된다. 때문에, nginx 에는 여러개의 location 을 설정할 수 있으며, 이 중에서 가장 긴 location path를 우선적으로 선택하게 된다. 1234567server &#123; server_name localhost location /path &#123; root /var/www/example; &#125;&#125; Where to save resources서버란 특정 리소스를 제공해주는 역할을 하며, 때문에 서버가 제공할 리소스를 저장하는 공간이 필요하다. nginx 는 기본적으로 /usr/share/nginx 디렉토리 내에 기본적이 리소스들을 보관한다. 하지만, 해당 디렉토리의 리소스들은 nginx 가 전역적으로 사용하기 위한 50x.html 과 같은 에러 페이지 리소스 등을 비롯한 nginx 어플리케이션 레벨에서의 리소스를 저장하는 공간이므로 실제 서버의 리소스는 이곳에 보관하지 않도록 한다. 대신, /var/www/example.com/ 디렉토리를 컨벤션으로 사용한다. Basic ConfigurationNGINX 의 세부 설정은 /etc/nginx/nginx.conf 파일에서 관리된다. 하지만, 이 설정파일은 NGINX 서버 자체에 대한 설정파일로써 웹서비스를 서비스한다면 이 환경 설정은 반드시 etc/nginx/conf.d/example.com.conf 과 같은 파일에 설정을 해야 한다. nginx.conf 파일에서는 nginx 에서 발생하는 error 및 access log 의 저장 위치를 설정하고, 설정파일들의 위치를 명시하여 다른 설정파일을 적용하는 등, 특정 server에 종속된 것이 아니라 nginx 어플리케이션 자체의 설정을 해 준다. 간혹 apache 서버를 사용하던 유저들은 아파치 서버 양식인 /etc/apache/sites-available 와 유사하게 etc/nginx/sites-available 에 서버 설정을 하는 경우가 있는데 이는 좋지 않은 패턴이니 지양하도록 한다. nginx.conf 123456789101112131415161718192021222324252627282930313233user nginx;worker_processes auto;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; server_tokens off;&#125; 기본적으로 nginx 는 /etc/nginx/conf.d/default.conf 에서 최초의 웹 서버 설정을 해주는데, 별도의 설정파일을 추가한 이후에는 default.conf 파일을 제거하거나 중복된 설정을 없애 주어야 한다. 그렇지 않으면 해당 파일이 default configuration 으로 동작하여 사용자가 한 설정을 덮어써서 설정 내용이 반영이 되지 않게 된다. 개발자는 다음과 같이 example.com.conf 와 같은 설정파일을 작성할 수 있으며 여러 개의 서버와 location 을 지정하고, error page 및 proxy 등 다양한 설정을 할 수 있다. /etc/nginx/conf.d/example.com.conf 12345678910111213141516171819202122server &#123; error_page 500 502 503 504 /50x.html; location / &#123; proxy_pass localhost:80 proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &apos;upgrade&apos;; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; &#125; location /50x.html &#123; root /usr/share/nginx/html; &#125; gzip on; gzip_comp_level 3; gzip_types text/plain text/css application/javascript image/*;&#125; Serving static file and access to local file system다음과 같이 특정 url 에 파일 시스템 경로를 mapping 함으로써 특정 url 이 정적 파일들을 서빙하게 할 수 있다. 12345server &#123; location /images &#123; root /var/data/images &#125;&#125; 위 코드는 /image 로 오는 요청을 file system 에 매핑하여 요청자가 직접 file system 경로를 통해 리소스를 받아올 수 있게 해준다. 만약 특정 파일 형태만 정적 파일 시스템에 접근하도록 하고 싶은 경우 다음과 같이 regular expression 을 통해 해결 할 수 있다. 12345server &#123; location ~\\.(gif|jpg|png) &#123; root /var/data/images &#125;&#125; Reverse ProxyNGINX 서버는 간편하게 Reverse Proxing 을 할 수 있게 해 주며, 다음과 같은 간단한 설정을 통해 reverse proxy 서버를 구축할 수 있다. 123456789101112server &#123; server_name localhost default_server; location /example1/proxy &#123; proxy_pass http://naver.com; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &apos;upgrade&apos;; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; &#125;&#125; 위 예제는 localhost/example1/proxy 로 들어온 요청을 http://naver.com/example1 로 proxing 해주는 설정파일이다. Subdomain서비스를 출시할때 흔히 다음과 같은 서브 도메인 양식을 가지고 리소스에 접근할 필요가 있게 된다. 가령 관리자 페이지를 위한 admin.example.com 이라던가 혹은 개발서버를 위한 dev.example.com 과 같이 여러 subdomain 이 필요하게 된다. nginx 는 host name 을 인식하여 간편하게 subdomain 을 reverse proxing 해주며 다음과 같은 세팅을 통해 간편하게 이를 적용할 수 있다. 다음 예제는 localhost 환경에서 앞에 example1 이라는 prefix 를 주고, 이를 reverse proxing 해주는 설정파일이다. 12345678server &#123; server_name example.localhost location / &#123; root /var/www/example2.com; &#125;&#125; SSL많은 서비스들은 http 프로토콜의 보안을 위해 https 프로토콜을 사용하며 이를 위해서는 443 port 를 통한 SSL 레벨에서의 통신이 필요하다. 이러한 요청을 처리하기 위해서는 다음과 같이 443 port 를 ssl 레벨에서 listen 해야 한다. 1234server&#123; listen [::]:80; listen [::]:443 ssl;&#125; GZIPNGINX 는 통신시에 데이터를 줄이기 위해 gzip 압축을 통한 리소스 압축을 제공한다. 이는 다음과 같은 설정을 통해 할 수 있다. 123456server &#123; ... gzip on; gzip_comp_level 3; gzip_types text/plain text/css application/javascript image/*;&#125;","link":"/2019/02/08/getting-started-with-nginx/"},{"title":"it-chain 01","text":"[ Opensource Blockchain Engine, IT-CHAIN] 01. Peer To Peer Network현재 블록체인 기술은 가장 빠르게 확산되고 있는 유망한 기술 중 하나이며, Bitcoin, Ethereum, EOS 등 수많은 외산 블록체인 엔진들이 입지를 굳혀가는 가운데 국내에서도 블록체인 코어 기술을 위한 많은 연구가 진행이 되고 있습니다. 이번 글에서는 수많은 블록체인 엔진들 중에서도 Lightweight Customizable Chain을 목표로 활발하게 개발이 진행중인 국내 오픈소스 블록체인 엔진인 IT-CHAIN에 대해 살펴보고자 합니다. 본 포스트는 연재 형식으로 IT-CHAIN의 핵심적인 component인 p2p, consensus, blockchain, authentication, txpool, iCode 를 다루는 총 4~6편의 포스트로 이루어 질 예정이며, 오늘은 it-chain의 전체적인 구조와 더불어 그 첫번째 component 인 p2p component에 대한 소개를 하고자 합니다. What is it-chain?많은 블록체인 엔진들 중에서 it-chain을 소개하게 된 계기는 무엇보다 구조적으로 매우 직관적이고 이해하기 쉽게 설계되어 있기 때문입니다. 가령, ethereum과 hyperledger처럼 당장 상용화를 목적으로 개발이 진행중인 엔진들은 실용적 문제들에 봉착하여 다양한 기법과 최신 기술을 도입하여 코드를 당장 이해하기 어려움이 있기에 블록체인을 처음 접하는 사람들의 경우 전체 코드를 한눈에 이해하는 것은 매우 어려운 일이 아닐 수 없습니다. 하지만, it-chain은 전체 설계 및 핵심적인 컴포넌트들이 비교적 상세하게 문서화가 되어 있고, 블록체인의 핵심이 되는 기본적인 기능만을 구현하였기 때문에, 블록체인 엔진이 움직이는 큰 그림을 보다 직관적이고 쉽게 이해할 수 있는 장점이 있습니다. 만약 블록체인 엔진 개발에 관심이 있는 엔지니어라면 그 시작으로 it-chain 의 구현을 살펴보는 것을 추천합니다. (it-chain의 github 주소, https://github.com/it-chain/engine) it-chain이 지향하는 바는 블록체인을 개발하는 누구든지 쉽고 가볍게 커스터마이징이 가능한 엔진을 만드는 것 입니다. 만약 누군가가 ethereum의 코드를 가져다가 자신만의 블록체인 엔진을 만든다고 한다면 그것은 매우 어려운 일일 것 입니다. 합의 알고리즘 하나를 변경하더도 관련된 모든 코드에 대한 이해가 필요하며 얼기설기 얽혀있는 수많은 코드들을 재정리 해야 합니다. 하지만, it-chain 은 event-sourcing을 기반으로 모든 동작이 event를 기반으로 이루어 지기에 다른 구성요소들의 동작에 구애받지 않고 원하는 파트만 손쉽게 변형하여 자신만의 engine을 만들 수 있습니다. it-chain의 전체 구조 it-chain은 6개의 독립적으로 동작하는 핵심 컴포넌트들로 구현되며, 각각은 AMQP(Asynchronous Message Queue Protocol) 를 통해 커뮤니케이션을 합니다. AMQP는 이벤트 버스로서 각 컴포넌트들에서 일어난 모든 일들은 이벤트 형태로 전파되어 다른 컴포넌트들이 해당 이벤트에 맞는 동작을 수행함으로써 전체 기능이 동작하는 방식입니다. 다음은 it-chain의 각 컴포넌트의 간단한 역할을 보여줍니다. TxPool 컴포넌트: 트랜잭션을 임시로 저장하고 관리하는 컴포넌트로, 합의되어 블록에 저장되지 않은 트랜잭션들을 모아둡니다. Consensus 컴포넌트: 합의를 담당하는 컴포넌트이며, 현재는 PBFT(Practical Byzantine Fault Tolerance) 알고리즘을 따릅니다. BlockChain 컴포넌트: 블록을 생성하고 관리하는 컴포넌트입니다. P2P 컴포넌트: 네트워크의 참여하는 Peer들을 찾고, 유지하는 컴포넌트입니다. Auth 컴포넌트: 각종 인증을 담당합니다. iCode 컴포넌트: it-chain의 스마트 컨트랙트인 iCode 관련 기능을 담당합니다. It-chain의 Peer to Peer 네트워크이번 포스트에서는 it-chain에서 여러 노드들 사이의 네트워크 정보를 동기화하고 커넥션을 관리하는 p2p component와 노드 사이의 합의를 이루는 consensus 컴포넌트에 대해 알아보고자 합니다. 먼저, P2p 컴포넌트가 하는 일은 다음과 같습니다. 블록체인 네트워크 내의 다른 노드들의 존재를 인지하고 저장합니다. 네트워크 내의 노드들 사이의 connection정보와 ip 주소 정보를 Peer 라는 이름으로 저장하고 여러 Peer 들의 집합인 PeerTable 을 형성합니다. 모든 노드들이 네트워크 내의 모든 노드들에 대한 정보인 PeerTable 을 공유하고 동기화 합니다. 예를 들어 현재 블록체인 네트워크가 A, B, C 노드로 이루어져있다고 가정해 봅시다. 여기서 D라는 새로운 노드가 A라는 노드에게 접속을 요청을 하게 된다면 D 노드는 A 노드의 정보만을 알고 있게 될 것이며, 마찬가지로 B, C 노드도 D노드에 대한 정보를 알지 못할 것입니다. 하지만 private 블록체인에서는 모든 노드들이 계속해서 서로 통신을 위해 연결되어 있어야 하기 때문에 새롭게 연결된 노드의 정보를 다른 노드들에게 전파해 주어야 하며 각 노드들은 전체 네트워크에 대한 일관된 정보를 공유해야 합니다. 네트워크 정보는 어떻게 저장되나요? p2p 컴포넌트 내의 연결 정보는 Peer 라는 이름으로 저장이 되며, 그 안에는 특정 노드와의 연결에 대한 고유값인 connectionId와 상대 노드의 ip 주소 를 저장합니다. 가령 A, B, C 노드로 구성된 네트워크가 있다면 A 노드는 B, C 노드와 연결됨에 따른 고유한 connection과 B, C 노드의 ip 주소를 Peer A, Peer B 라는 이름으로 저장하며 모든 노드는 이러한 peer들의 정보를 peer 들의 정보의 집합인 PeerTable 에 저장합니다. 네트워크 정보는 어떻게 공유되나요? 블록체인 네트워크에 새로운 노드가 접속하는 것은 네트워크 내의 특정 노드에게 연결을 요청하는 것에서 시작됩니다. 노드 A, B, C 로 구성된 네트워크에서 D라는 노드가 접속되는 상황을 가정해 봅시다. 노드 D는 A, B, C 노드 중 임의의 노드인 A 노드에게 연결을 요청하고 만약 연결이 이루어 진다면 노드 D의 정보는 노드 A의 PeerTable 에 저장되고, 노드 A 는 새롭게 바뀐 PeerTable 을 노드 D에게 전달해 줍니다. 노드 D는 A에게 받은 PeerTable을 살펴보고 아직 자신이 연결하지 않은 노드인 B와 C 노드에 대해 알게되고 해당 노드의 ip 주소로 연결을 요청하게 됩니다. B, C 노드가 새로 접근한 노드인 D 노드에게 연결을 요청받고 승인하는 것으로 네트워크 내의 모든 노드는 새로 접근한 노드인 D 노드와 연결이 이루어지게 됩니다. It-chain의 Consensus 컴포넌트블록체인에서 핵심은 바로 consensus 입니다. consensus 컴포넌트는 특정 블록을 생성하기 위해 다른 노드들에게 해당 블록을 생성해도 되는지 검증을 요구하고 네트워크 구성원들의 합의가 이루어지면 새로운 블록을 생성합니다. It-chain 에서 이러한 합의 알고리즘은 설정을 통해 간편하게 교체할 수 있으며 기본적으로 pbft 알고리즘에 따라 합의가 이루어 지게 됩니다. pbft 합의 알고리즘 기본적인 PBFT 알고리즘은 다음과 같은 순서로 이루어지게 됩니다. 클라이언트가 네트워크 구성원에게 어떤 합의문에 대해 합의할 것을 요청합니다. 합의 요청을 받은 노드들 중 리더 노드는 네트워크 내의 모든 구성원에게 특정 합의에 대한 합의를 시작할 것을 알리는 preprepare message 를 전달합니다. preprepare message 를 전달받은 모든 노드는 다시 모든 노드에게 prepare message 를 전달합니다. 전체 네트워크 구성원들 중 정족수(2/3) 이상의 노드에게 받은 preparemessage 인 commit message 를 모든 노드들에게 전달합니다. 위 과정이 끝나면 모든 노드들은 정족수이상이 합의한 결과를 가지게 됩니다. 하지만 It-chain 에서는 오직 리더만이 새롭게 생성될 블록을 제안하고 실제로 생성할 수 있으므로 위 과정에서 클라이언트 및 요청 응답이 존재하지 않습니다. It-chain에서 pbft 알고리즘의 구현It-chain에서는 위와 같은 pfft 알고리즘 구현을 위해 다음과 같은 몇가지 개념을 도입합니다. Parliament: 의회, 즉, 합의에 참여할 노드들의 집합을 의미합니다. Representative: 대표자, 즉 합의에 참여할 실제 노드 구성원을 의미합니다. Leader: 의장, 즉 의회 구성원의 대표인 리더를 의미합니다. pbft의 목적은 어디까지나 합의하고자 하는 블록에 대한 합의이기에 다음과 같은 과정에 따라 pbft 기반의 합의 알고리즘이 동작됩니다. 리더 노드의 consensus 컴포넌트가 블록 생성을 담당하는 blockchain 컴포넌트로 부터 합의하고자 하는 블록을 제안받습니다. 리더 노드는 해당 블록에 대한 합의를 진행하기 위해 현재 네트워크를 구성하고 있는 정보를 담고 있는 PeerTable 에서 전부 혹은 부분적인 노드를 선출하여 Parliament 를 구성합니다. 리더 노드가 Parliament 에 속한 모든 Representative 들에게 preprepare message 를 전달합니다. preprepare message 를 받은 모든 representative 들은 받은 정보를 통해 각자의 Parliament 를 구축하고 다른 Representative 들에게 prepare message 를 전달합니다. 각 Representative 들은 정족수 이상의 prepare 메세지를 받기 까지 받은 모든 prepare message 를 prepare message pool 에 저장하고 정족수 이상이 넘으면 commit message 를 전파합니다. 전체 의회 구성원의 1/3 이상에게 commit message를 받은 각 Representative 들은 Commit message 내의 Proposed Block 에 대한 승인을 하는 이벤트를 발생시키고 블록체인 컴포넌트는 해당 블록에 대한 검증을 시작합니다.Proposed Block 이 confirm 되기 까지 Commit message 들은 Commit message pool 에 저장됩니다. It-chain에서 리더의 선출it-chain 에서의 리더 선출은 RAFT 라는 알고리즘을 통해 진행되며 consensus 컴포넌트에 구현되어 있습니다. 다음은 RAFT 알고리즘의 간단한 프로세스입니다. 리더가 사라지면 노드는 의회를 구성합니다. 150ms ~ 300ms 사이의 랜덤 값으로 모든 노드가 타이머를 동작시킵니다. 노드의 타이머가 다 되면 그 노드는 자신의 상태를 Candidate 으로 바꾸고 RequestVoteProtocol을 통해 의회 내의 다른 노드에게 투표 요청 message 를 전달합니다. RequestVoteProtocol 로 메세지를 받은 노드는 아직 타이머가 다 되지 않은 경우 타이머를 리셋하고, 송신한 노드에게 VoteLeaderProtocol을 통해 메세지를 전달하여 리더로 투표합니다. 만약 상태가 CANDIDATE 인 노드가VoteLeaderProtocol를 통해 다른 모든 노드에게 투표 메세지를 받는다면 그 노드는 스스로 리더가 되고 다른 모든 노드들에게 리더가 됨을 선포합니다. 위와 같은 과정을 통해 물리적으로 떨어져 있는 여러 개의 노드들이 서로 합의를 이루고 리더를 선출 할 수 있게 됩니다. 이번 포스트에서는 국내 블록체인 엔진인 it-chain 의 p2p network 와 consensus 알고리즘, 그리고 리더 선출에 대해 알아보았습니다. 다음 포스트에서는 it-chain에서 블록을 합의하는 컴포넌트인 Blockchain 컴포넌트에 대해 알아보겠습니다. LNH","link":"/2018/06/30/it-chain01/"},{"title":"kubernetes 시작하기","text":"쿠버네티스 시작하기최근에는 컨테이너 기술인 도커 등을 이용하여 어플리케이션을 컨테이너 형태로 배포하는 추세이다. kubernetes는 이렇게 많은 컨테이너들의 배포 프로세스를 관리하고 컨테이너 들을 클러스터링 하여 체계적이로 관리, 배포할 수 있게 해주는 툴이다. 클러스터를 생성하고 각 어플리케이션을 노드 단위가 아니라 클러스터 단위로 배포함으로써 특정 컨테이너에 문제가 생기면 kubernetes가 컨테이너를 재시작 하는 등 다양한 기능을 제공하여 보다 안정적으로 서비스를 운영할 수 있게 해준다. 또한 여러 컨테이너들 사이에서 Load Balancing 등을 활용한 라우팅 기능을 사용하여 분산처리도 가능하게 해주는 장점이 있다. Kind of Objects in kubernetesKubernetes에는 다음과 같이 크게 4가지 종류의 Object 가 존재한다. Cluster Service Pod Create kubernetes cluster먼저 쿠버네티스를 시작하기 위해서는 클러스터를 생성하여 그 위에 컨테이너화된 어플리케이션을 배포할 수 있다. 쿠버네티스 디플로이먼트 설정을 만들어야 한다. 디플로이먼트는 쿠버네티스가 애플리케이션의 인스턴스를 어떻게 생성하고 업데이트해야 하는지를 지시한다. 디플로이먼트가 만들어지면, 쿠버네티스 마스터가 해당 애플리케이션 인스턴스를 클러스터의 개별 노드에 스케줄한다. 디플로이먼트는 애플리케이션 인스턴스를 생성하고 업데이트하는 역할을 담당한다. 미니쿠베를 통해 로컬에서 간단하게 쿠버네티스를 실행시킬 수 있다. 12minikube startminikube stop 새로운 deployment를 실행한다. 아래 명령어에서 deployment의 이름과 app의 이미지 주소를 입력해 준다. We want to run the app on a specific port so we add the –port parameter: 123kubectl run kubernetes-bootcamp --image=[gcr.io/google-samples/kubernetes-bootcamp:v1](&lt;http://gcr.io/google-samples/kubernetes-bootcamp:v1&gt;) --port=8080kubectl get deployments 기본적으로 쿠버네티스의 팟들은 해당 클러스터 내에서 서로 ip를 알고 있지만 클러스터 밖은 클러스터 내의 팟의 아이피를 알지 못한다. The kubectl command can create a proxy that will forward communications into the cluster-wide, private network. 이러한 클러스터에 접근하기 위해 proxy 서버를 돌릴 수 있는데, 다음과 같다. undefined 위처럼 환경변수를 설정하면 다음과 같이 접근이 가능하다. 1curl [&lt;http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/&gt;](&lt;http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/&gt;) 파드는 쿠버네티스 플랫폼 상에서 최소 단위가 된다. 우리가 쿠버네티스에서 배포를 생성할 때, 그 배포는 컨테이너 내부에서 컨테이너와 함께 파드를 생성한다 파드는 하나 또는 그 이상의 애플리케이션 컨테이너 (도커 또는 rkt와 같은)들의 그룹이고 공유 스토리지 (볼륨), IP 주소 그리고 그것을 동작시키는 방식에 대한 정보를 포함하고 있다. kubectl get - 자원을 나열한다 kubectl describe - 자원에 대해 상세한 정보를 보여준다. kubectl logs - 파드 내 컨테이너의 로그들을 출력한다 kubectl exec - 파드 내 컨테이너에 대한 명령을 실행한다. 노드는 쿠버네티스에 있어서 워커 머신이며 클러스터에 따라 VM 또는 물리 머신이 될 수 있다. 여러개의 파드는 하나의 노드 위에서 동작할 수 있다. We can execute commands directly on the container once the Pod is up and running. For this, we use the exec command and use the name of the Pod as a parameter. Let’s list the environment variables: 특정 팟에서 명령어를 실행할 수 있따. 가령 kubectl exec -it \\$POD_NAME bash cat server.js Service쿠버네티스에서 서비스는 하나의 논리적인 파드 셋과 그 파드들에 접근할 수 있는 정책을 정의하는 추상적 개념이다 서비스는 종속적인 파드들 사이를 느슨하게 결합되도록 해준다. 서비스는 모든 쿠버네티스 오브젝트들과 같이 YAML 또는 JSON을 이용하여 정의된다. 쿠버네티스 클러스터 내 각 파드는 유일한 IP 주소를 가지며, 여러분의 애플리케이션들이 지속적으로 기능할 수 있도록 파드들 속에서 발생하는 변화에 대해 자동으로 조정해 줄 방법이 있어야 한다. 비록 각 파드들이 고유의 IP를 갖고 있기는 하지만, 그 IP들은 서비스의 도움없이 클러스터 외부로 노출되어질 수 없다. 서비스들은 여러분의 애플리케이션들에게 트래픽이 실릴 수 있도록 허용해준다. 서비스들은 ServiceSpec에서 type을 지정함으로써 다양한 방식들로 노출시킬 수 있다: 서비스는 쿠버네티스의 객체들에 대해 논리 연산을 허용해주는 기본 그룹핑 단위인, 레이블과 셀렉터를 이용하여 파드 셋과 매치시킨다. 레이블은 오브젝트들에 붙여진 키/밸류 쌍으로 다양한 방식으로 이용 가능하다: 개발, 테스트, 그리고 상용환경에 대한 객체들의 지정 임베디드된 버전 태그들 태그들을 이용하는 객체들에 대한 분류 여러분은 kubectl 명령에--expose 옵션을 사용함으로써 디플로이먼트 생성과 동일 시점에 서비스를 생성할 수 있다. how to expose Kubernetes applications outside the cluster using the kubectl expose command 12노드 포트 타입으로 클러스터를 외부로 노출시킴kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080 열린 포트를 확인하기 위해 다음 명령어를 실행시킴 kubectl describe services/kubernetes-bootcamp curl $(minikube ip):$NODE_PORT 라벨 사용하기 12아래 커맨드의 -l 은 라벨을 의미한다.kubectl get pods -l run=kubernetes-bootcamp 다음과 같이 라벨링을 한다. kubectl label pod \\$POD_NAME app=v1 kubectl describe pods \\$POD_NAME 를 실행시켜 보면 라벨링이 바뀐 것을 볼 수 있다. 다음과 같이 새로운 라벨로 쿼링을 할 수 있다 kubectl get pods -l app=v1 다음과 같이 서비스를 삭제하면 요청이 오지 않는데 그것은 외부로 열려있지 않기 때문이다. kubectl delete service -l run=kubernetes-bootcamp 드플로이먼트의 복제수를 변경하면 스케일링이 수행된다. 스케일링 명령어 1kubectl scale deployments/kubernetes-bootcamp --replicas=4 다음 명령어로 확인하면 서로 다른 ip를 가진 여러 개의 팟이 생긴것을 볼 수 있다. 1kubectl describe deployments/kubernetes-bootcamp 앱 업데이트 하기 1kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2 위 명령어는 특정 deployment의 팟의 이미지를 교체해준다. kubectl get pods 를 통해 확인해 본다. 롤아웃 kubectl rollout status deployments/kubernetes-bootcamp 롤백 kubectl rollout undo deployments/kubernetes-bootcamp 클러스터 밖에서 팟을 바라보기 The hostNetwork setting applies to the Kubernetes pods. When a pod is configured with hostNetwork: true, the applications running in such a pod can directly see the network interfaces of the host machine where the pod was started. 123456789apiVersion: v1kind: Podmetadata: name: influxdbspec: hostNetwork: true containers: - name: influxdb image: influxdb 컨테이너에 hostPort 옵션 The hostPort feature allows to expose a single container port on the host IP. 1234567891011apiVersion: v1kind: Podmetadata: name: influxdbspec: containers: - name: influxdb image: influxdb ports: - containerPort: 8086 hostPort: 8086 To make the service accessible from outside of the cluster a user can create a service of type NodePort. each Kubernetes node will proxy that port to the pods selected by the service. 1234567891011kind: ServiceapiVersion: v1metadata: name: influxdbspec: type: NodePort ports: - port: 8086 nodePort: 30000 selector: name: influxdb kubernetes DNSServicesA records“Normal” (not headless) Services are assigned a DNS A record for a name of the form my-svc.my-namespace.svc.cluster.local. This resolves to the cluster IP of the Service. “Headless” (without a cluster IP) Services are also assigned a DNS A record for a name of the form my-svc.my-namespace.svc.cluster.local. Unlike normal Services, this resolves to the set of IPs of the pods selected by the Service. Clients are expected to consume the set or else use standard round-robin selection from the set. SRV recordsSRV Records are created for named ports that are part of normal or Headless Services. For each named port, the SRV record would have the form _my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster.local. For a regular service, this resolves to the port number and the domain name: my-svc.my-namespace.svc.cluster.local. For a headless service, this resolves to multiple answers, one for each pod that is backing the service, and contains the port number and the domain name of the pod of the form auto-generated-name.my-svc.my-namespace.svc.cluster.local. Kube dns https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ minikube start kubectl cluster-info kubectl get nodes","link":"/2018/10/30/kubernetes-시작하기/"},{"title":"사토시 나카모토의 Bitcoin 논문","text":"사토시 나카모토의 Bitcoin 논문이번 포스트에서는 현대의 블록체인 기술의 근간이 된 사토시 나카모토의 bitcoin 논문을 설명하고, 블록체인의 핵심 개념에 대해 적어보고자 합니다. 우리가 흔하게 오프라인상에서의 금전을 거래할때와는 다르게 인터넷상에서의 거래에는 기술적으로 해결할 수 없는 문제가 존재하는데 그것은 바로 특정 거래가 두번 일어나게 되어 존재하지 않던 재화가 전산상에 생겨나게 되는 것입니다. 이것이 어떻게 가능하냐고 할 수 있지만, 인터넷에서의 거래란 사실 데이터베이스라는 정보의 창고에 새로운 기록을 작성하고 있던 수치를 줄이거나 올리는 단순한 작업이기 때문에 전산상의 오류나 혹은 해커의 공격에 의해 내가 하지 않은 거래가 두번 기록이 될 수 있게됩니다. 이러한 문제를 double spending problem 이라고 하며, 궁극적으로 사토시는 이 double spending problem 을 해결하기 위한 연구를 시작합니다. 사토시는 이를 해결하기 위해 매 시간의 timestamp를 기반으로 하는 p2p네트워크를 기반으로 모든 거래 정보는 블록화 되어 체인 구조로 연결되고 동기화되는 일종의 온라인 체인 시스템을 고안하게 됩니다. 즉, 온라인 상에서 일어나는 모든 거래에 그 시간을 ms 단위의 정밀도로 기록을 한 뒤에 온라인 상에서 모든 사람들이 합의를 하여 각 거래의 신뢰성을 판단하고 그 거래기록을 한데 모아 블록으로 만들어 이어붙인다면 모두가 인정할 수 있는 분산 원장을 만들 수 있지 않을까 라는 생각을 하게 된 것입니다. 이렇게 체인을 연결해 가는 과정에는 많은 컴퓨팅 파워가 필요하게 되었고, 가장 많은 CPU 파워를 가진 컴퓨터 집단이 가장 긴 체인을 생성할 수 있을 것이며 이를 신회하는 네트워크 구조가 바로 블록체인 네트워크 입니다. 즉, 사토시 나카모토가 제안한 bitcoin의 궁극적이고 본질적인 목표는 제 3 기관의 개입 없이 화폐를 주고 받는 것이었습니다. 블록체인 내에서의 거래 기록비트코인에에서 거래는 UTXO(Unspent Transaction Output) state model 에 따라 기록됩니다. 이는 이름 그대로 하나의 거래 내역에서 사용되지 않은 양을 통해서 자금의 상태를 기록함을 의미합니다. 즉, 비트코인에서 Transaction 이란 사용되고 남은 Bitcoint 의 양을 가지는 일종의 화폐 자체로 이해할 수 있습니다. 가령 5BTC 짜리 Transaction, 1BTC 짜리 트랜잭션처럼 각 Transaction 은 누군가에게 소유된 화폐로 이해할 수 있고, 그 화폐가 이미 소진되었다면 해당 화폐를 소진한 주체가 output 에 기록되고 아직 소진되지 않았다면 그 화폐를 소진할 수 있는 사용자의 주소가 명시되어 있다고 보면 됩니다. 다음은 실제 비트코인에서 Transaction Model 의 일부입니다. 12345678910111213class CTransaction&#123;public: const std::vector&lt;CTxIn&gt; vin; const std::vector&lt;CTxOut&gt; vout; ...private: const uint256 hash; ...&#125; 위에서 알 수 있듯이 비트코인에서 하나의 Transaction 에는 Vin 과 Vout 이라는 값이 존재하며, 각 model 의 구조는 다음과 같습니다. 1234567891011121314class CTxIn&#123;public: COutPoint prevout; CScript scriptSig;&#125;class CTxOut&#123;public: CAmount nValue; CScript scriptPubKey;&#125; 각 속성을 하나씩 살펴보면, 거래를 이루는 것은 CTxIn 과 CTxOut 두가지로 구성되고, CTxIn 에는 해당 Transaction 이 어떤 Transaction 의 몇번째 output 을 기준으로 거래가 시작되는지를 나타내며 COutPoint 는 실제로 특정 Transaction 의 hash 값과 output 의 index 값을 통해 생성된 값입니다. ScriptSig 는 해당 화폐를 사용한 사용자의 서명으로 어떤 사용자가 해당 화폐를 사용하였는지를 나타내며, 이는 이전 Transaction CTxOut 의 scriptPubKey 의 소유자가 서명한 서명입니다. CTxOut 의 nValue 속성은 실제 BTC 의 양이 명시되며 1억 분의 1 BTC 인 Satoshi 를 기준화폐로 사용합니다. scriptPubKey 는 해당 화폐를 사용할 수 있는 사용자의 address 이며, 해당 사용자가 이 Transaction 에 서명하여 다음 Transaction 에 기록함으로써 화폐를 사용할 수 있습니다. 여기서 중요한 사실을 알 수 있는데, 그것은 바로 블록체인 내에서 거래(transaction) 는 이전 거래의 정보(이전 transaction’has value) 를 포함하기 때문에 모든 거래는 시간 순으로 동기화 될 수 있다는 것입니다. 이렇게 모든 거래의 내역들을 한데 모아 블록으로 저장하며, 특정 시간을 주기로 그 시간동안 일어난 모든 거래를 한데 모아 새롭게 블록을 생성하는 작업을 거치는데, 이는 각 거래를 일종의 트리 형태로 나열하고 이를 해쉬라고 불리는 암호화 과정을 거쳐 해시를 만들어 내는 것입니다. 그리고 새로운 블록을 생성함이란 이렇게 복잡하게 암호화된 해쉬값을 먼저 풀어낸 컴퓨터가 그 보상을 가지는 방식으로 기여를 하게 됩니다. 여기서 컴퓨터가 해쉬값을 풀어내는 것은 아주 단순하게 생각하면 무수히 많은 숫자와 문자열(nonce)을 계속해서 대입하면서 맞는 값이 나올때까지 대입해 보는 것이라 볼 수 있습니다.각 블록의 해쉬값을 먼저 풀어낸 노드가 새롭게 블록을 생성합니다. 이를 위해서는 엄청난 컴퓨팅 파워가 필요하며, 이를 통해 상대적으로 더 많은 컴퓨팅 파워를 가지는 믿을 수 있는 노드들의 컴퓨팅 파워를 통해 올바른 블록을 생성하게 됩니다. 네트워크의 동작블록체인 네트워크는 다음과 같은 순서에 따라 이루어 집니다. 모든 transactions 는 모든 노드에 전파된다. 모든 노드는 각 트랜잭션을 모아서 블럭을 구성한다. 각 노드는 만든 블럭의 해시를 풀어낼 nonce 값을 찾기 위해 연산을 시작한다. 어떤 노드가 nonce를 찾아냈다면 다른 모든 노드에게 자신이 가진 블록을 전파한다. 블록을 받은 노드들은 받은 블록 안의 모든 트랜잭션들이 유효하고 이미 지불된 것이 아닐 때에만 블록을 받는다. 블록을 받은 노드들은 받은 블록의 해쉬값을 previous hash로 하는 새로운 블록은 만드는 것에 착수함으로써 다른 노드들에게 해당 블록을 승인하였음을 알린다. 만약 노드가 동시에 두개의 블록을 받는다면 처음 받은 블록을 기준으로 작업을 시작하지만 이후로 받은 블록들도 저장해 둔다. 이렇게 여러 블록들은 개별적인 브랜치를 형성하고 특정 브랜치가 길어지면 가장 긴 브랜치의 블록들을 승인하여 체인을 이어간다. 만약 노드가 다음 블록을 받지 못했다 하더라도 문제가 되지 않는데, 이는 그 다음 블록을 받게 되면 노드 자체가 자신이 받지 못한 블록을 인지하고 다른 노드들에게 이를 요청하기 때문이다. 또한 모든 트랜잭션들을 매우 많아서 빠트리면 트랜잭션이 있더라도 블록들은 계속 생성되기 때문에 빠트린 transaction들은 무시되고 넘어간다. 보상의 원리블록체인 시스템의 참여자들을 컴퓨팅 파워를 통해 그 신뢰가 유지되는 시스템이므로, 모든 참여자들이 계속해서 컴퓨팅 파워를 제공하도록 동기 부여 하기 위해 인센티브를 부여하며, 이는 바로 블록을 생성한 노드에게 최초의 트랜잭션을 발행하도록 하는 것으로 이것이 우리가 일반적으로 알고있는 코인의 채굴하는 과정이 됩니다. 화폐가치의 분할위 내용에서와 같이 우리는 모든 코인은 그 전의 소유자들의 정보를 가진다고 알아보았으며, 이는 현실 세계에서 특정 1달러 지폐에 이제까지의 소유자들이 적혀있는 것에 비유될 수 있다고 하였습니다. 하지만 좀 더 작은 단위 혹은 더 큰 단위의 돈을 송금하는 경우를 생각해 보면, 1달러 지폐 하나를 다른 누군가 혹은 수십명의 다른 사람들과 공유하는 것을 생각할 수 있습니다. 이것은 하나의 transaction이 여러 개의 input 및 output value를 가짐으로써 해결 될 수 있는데, 하나의 transaction은 다른 여러 사람들에게 지불될 수 있으며 모든 내용이 하나의 transaction에 작성되어 있도록 하는 것입니다. 쉽게 말하면 1달러 지폐를 현재 가지고 있는 사람이 복수 명이 되어도 괜찮다는 것으로 생각될 수 있습니다. 이번 포스트에서는 사토시 나카모토의 논물을 쉽게 요약하여 블록체인의 핵심 원리에 대해 알아보았습니다. 가상화폐 시장의 열기가 죽어가는 현 시점이지만, 블록체인의 효용과 사토시 나카모토가 만들고자 했던 새로운 화폐경제 시스템의 가치는 보존되었으면 하는 바람으로 글을 마칩니다. LNH","link":"/2019/01/12/medium-사토시-나카모토의-bitcoin-논문/"},{"title":"Nuxt.js 시작하기","text":"Installation Next CLI Vuex Global CSS Setup Vuetify Nuxt 에서 axios 사용하기 기본 사용법 http helper plugin 적용 Plugin 사용하기 플러그인 만들기 플러그인 등록하기 Vue instance, Contextk, Store 에서 사용가능하게 등록하기 Reverse proxy Global Modal Environment variables Problem solving layout 사용하기 Unexpected token import cannot find module Query string nested object Custom Component 의 click 이벤트를 자식 요소로 넘기는 법 다른 vuex 모듈에서 다른 vuex 모듈에 있는 액션을 호출하는 법 Installation12345678vue init nuxt-community/typescript-template [프로젝트 명];yarn add nuxt-property-decorator &amp;&amp; # property decorator installationyarn add tsconfig-paths-webpack-plugin &amp;&amp;# webpack 에서 typescript 를 사용하기 위한 세팅yarn add ts-loader &amp;&amp; # typescript 사용을 위한 ts-loader 설치yarn add vuex-class &amp;&amp; # Vuex 를 class 타입으로 사용하기 위해 설치yarn add nuxt-sass-resources-loader &amp;&amp; # For using sassyarn add sass-loader # for using sass 타입스크립트를 트랜스파일링 하기 위해 webpack configuration을 바꾸어 주어야 한다. 이는 nuxt.config.js 에서 webpack configuration 을 overriding 함으로써 구현한다. nuxt.config.js 123456789101112131415161718192021222324252627282930build: &#123; /* ** You can extend webpack config here */ extend(config, ctx) &#123; config.resolve.extensions.push('.ts'); const tsLoader = &#123; loader: 'ts-loader', options: &#123; appendTsSuffixTo: [/\\.vue$/], transpileOnly: true &#125;, exclude: [/vendor/, /\\.nuxt/] &#125;; config.module.rules.push(&#123; test: /.tsx?$/, ...tsLoader &#125;); for (let rule of config.module.rules) &#123; if (rule.loader === 'vue-loader') &#123; rule.options.loaders = &#123; ts: tsLoader &#125;; &#125; &#125; let plugin = new TsconfigPathsPlugin(&#123; configFile: 'tsconfig.json' // setup tsconfig path &#125;); config.resolve['plugins'] = [plugin]; &#125;&#125; Next CLI1234567891011121314151617# install dependencies$ npm install # Or yarn install# serve with hot reload at localhost:3000$ npm run dev# build for production and launch server$ npm run build$ npm start# generate static project$ npm run generate Vuexstore 디렉토리는 어플리케이션에서 사용하는 도메인 객체들의 저장소이다. 초기 프로젝트는 Vuex 가 disable 된 상태이나 다음과 같이 store/index.js 파일을 작성하면, Vuex 를 사용할 수 있다. store/index.js 12345678910111213141516import Vuex from 'vuex';const createStore = () =&gt; &#123; return new Vuex.Store(&#123; state: () =&gt; (&#123; counter: 0 &#125;), mutations: &#123; increment(state) &#123; state.counter++; &#125; &#125; &#125;);&#125;;export default createStore; Vuex state 의 경우 nested 된 object 의 경우 내부 값만 바뀌면 store 가 업데이트 되지 않는 현상이 있다. 이를 위한 해결법으로 state.prop[key] ={} 와 같은 연산이 있다면 이를 state.prop={[key]:{}} 와 같이 수정하는 트릭을 쓸 수 있다. Global CSSnuxt.config.js 에서 head 에 추가한다. Setup Vuetify1yarn add @nuxtjs/vuetify 1234import Vuetify from 'vuetify';Vue.use(Vuetify);import 'vuetify/dist/vuetify.min.css'; // Ensure you are using css-loader nuxt.config.js 12345678910&#123; modules: [ '@nuxtjs/vuetify' ], // Vuetify options vuetify: &#123; // theme: &#123; &#125; &#125;&#125; Nuxt 에서 axios 사용하기기본 사용법Nuxt 에서는 기본적으로 다음과 같은 방법을 통해 axios 모듈을 사용할 수 있다. 여기서, 왜 그냥 axios 를 동적으로 import 해서 사용하지 않고 nuxt 가 제공하는 axios 를 사용해야 하는지 궁금할 수 있다. 바로 그 이유는, nuxt 는 기본적으로 server redering 방식으로 동작하기 때문에, browser cookie 와 jwt 토큰 등의 중앙적인 데이터에 접근하기가 힘들기 때문이다. nuxt 가 제공하는 axios 는 withCredential 등을 통해 간편하게 cookie 데이터에 접근할 수 있는 장점이 있다. axios 설치 1npm install @nuxtjs/axios axios 모듈 등록 nuxt.config.ts 12345678module.exports = &#123; modules: [ '@nuxtjs/axios', ], axios: &#123; // proxyHeaders: false &#125;&#125; 이를 통해 각 component 의 this.$axios 와 context 의 $axios 를 통해 axios를 사용할 수 있다. 하지만, 여기서는 범용 logger 혹은 http request 에 있어서 일관된 에러 핸들링 등을 할 수 없기 때문에 이 함수를 사용하는 httpHelper 플러그인을 구현하여 이를 가능하도록 한다. http helper plugin 적용여기서 httpHelper의 경우 get, post, put, delete 등의 메소드를 wrapping 하는 다양한 함수들이 존재하며 여기서는 구현을 생략하겠다. 중요한 점은 이런 HttpHelper 클래스가 plugin 에서 $axios 를 주입받아 새로운 메소드를 구현하며, 이를 inject 함수를 통해 vue instance, store, context 에 바인딩 하여 어느 곳에서나 사용 가능하게 해준다는 것이다. plugins/httpHelper.ts 123456789import &#123; HttpHelper &#125; from 'utils/httpHelper';export default function(context, inject) &#123; let &#123; $axios &#125; = context; let httpHelper = new HttpHelper($axios); context.$httpHelper = httpHelper; inject('httpHelper', httpHelper);&#125; Plugin 사용하기Vue.js 의 자체 기능 뿐 아니라 다양한 외부 라이브러리 혹은 사용자의 external util function 등을 활용하기 위해서 nuxt 는 plugin 이라는 기능을 제공한다. 이러한 plugin 을 통해서 사용자는 사용하고자 하는 함수 혹은 instance 를 vue root application 혹은 context 에 binding 할 수 있다. 플러그인 만들기plugins/sample.ts 12345export default (context, inject) =&gt; &#123; context.$sample = a =&gt; &#123; console.log(a); &#125;;&#125;; 플러그인 등록하기플러그인을 사용하기 위해 nuxt configuration 에 등록시켜 주어야 한다.nuxt.config.ts 123export default &#123; plugins: ['~/plugins/sample.ts']&#125;; Vue instance, Contextk, Store 에서 사용가능하게 등록하기기본적으로 plugin 을 등록하면 오직 context 혹은 vue instance 내에서만 사용 가능하다.하지만 store 혹은 여러 곳에서 이 함수 혹은 인스턴스에 접근하고자 한다면 inject 함수를 이용하여 전역에서 사용가능하게 등록시켜 주어야 한다. 아래처럼 &#39;sample&#39; 과 같이 $ 기호를 생략하고 등록해 주면 $sample 과 같이 변형되어 바인딩 된다. 123456789101112export default (context, inject) =&gt; &#123; let sample = a =&gt; &#123; console.log(a); &#125;; let sample2 = &#123; b: x =&gt; &#123; console.log(x); &#125; &#125;; inject('sample', sample); inject('sample2', sample2);&#125;; 이를 통해 context, Vue 인스턴스 내에서의 this 등 어디에서는 이곳에 접근할 수 있게 된다. Reverse proxy클라이언트가 서버를 호출하는 경우 cors(cross origin resource sharing 문제로 브라우저 내에 렌더링 된 페이지를 준 호스트가 아닌 다른 곳으로의 요청은 기본적으로 막혀있다. 사실 이는 nuxt.js 뿐만이 아니라 대부분의 웹 어플리케이션 배포 과정에서 나타나는 문제인데, nuxt.js 에서는 그 해결과정이 조금 다르기 때문에 작성한다. 다른 어플리케이션 배포과정의 경우 일반적으로 nginx 와 같은 web server 를 사용하여 reverse proxy 를 통해 클라이언트 내의 서버 요청 url 을 같은 호스트로 설정하고, 같은 호스트로 오는 요청의 url 을 분석하여 같은 호스트 내의 다른 포트로 리다이렉팅 시켜주는 등의 해결법을 제시하지만, nuxt.js 의 경우 server rendering 프레임워크로 독자적으로 hosing 을 하는 만큼, 자체적으로 reverse proxy 를 제공하며, nuxt.config.js 파일에 다음과 같이 reverse proxy 설정을 주어 해결할 수 있다. nuxt.config.js 1234567const serverUrl = \"localhost:3002\";module.exports = &#123; proxy: &#123; '/api/': serverUrl &#125;,&#125; Global Modal전역으로 alert와 dialog를 사용하기 위해 layout 레이어에서 해당 모듈을 구현하였으며, 이는 page store 를 통해 접근이 가능하다. Environment variablesnode.js 서버와는 달리 nuxt 의 경우는 동작환경이 브라우저 이므로, 서버에서 하듯이 process.env 와 같이 환경변수에 접근해도 브라우저의 환경변수이기 때문에 접근이 되지 않는다. 이는 매우 기본적인 사실이지만 서버렌더링을 하는 과정에서 혼동될 수 있다. 즉, nuxt.js 에서 process.env 를 사용한다면, 이는 빌드시점에 주입되어야 할 것이다. Problem solvinglayout 사용하기vue component class 를 사용함에 있어 layout 옵션이 설정되지 않았다면 다음 코드를 index.d.ts 에 추가한다. 123456789declare module 'vue/types/options' &#123; interface ComponentOptions&lt;V extends Vue&gt; &#123; layout?: string; &#125;&#125; Unexpected token import모든 기능이 정산인데 갑자기 Unexpected token import 에러가 났다. 이 경우 최종 문제의 원인은 nuxt.config.js에서 modules 에 bootstrap-vue 를 import 함에 있어 bootstrap-vue/nuxt 가 아니라 @nuxtjs/bootstrap-vue 를 import 하여 생기는 문제였다. bootstrap-vue 공식 홈페이지에도 bootstrap-vue/nuxt 를 import 하라고 하고 있는데, 이를 매우 주의하여야 한다. cannot find modulenuxt property decorator 를 사용할때 1&#123;components:&#123;&#125;&#125; 속성을 추가하지 않으면 모듈을 찾지 못하는 문제가 생긴다. Query string nested object기존에는 querystring 라이브러리를 사용하여 nested object 를 처리하지 못하였으나, qs 라이브러리를 사용하면 해결 가능하다. Custom Component 의 click 이벤트를 자식 요소로 넘기는 법1@click.native 다른 vuex 모듈에서 다른 vuex 모듈에 있는 액션을 호출하는 법","link":"/2019/03/16/nuxt-js-시작하기/"},{"title":"supertest 를 활용한 typescript 기반 node.js e2e 테스트","text":"What is supertestNode.js 에서 express 를 이용하여 서버를 개발함에 있어, rest api 를 테스트 하기 위해서는 실제로 서버에 요청을 보내고 클라이언트에 원하는 데이터가 전송되는 것을 확인해야 한다. 이러한 e2e 테스트를 위해서는 실제 서버를 띄운 뒤에 해당 서버로 요청을 날려 보면서 테스트를 진행해야 하며, 이렇게 가상의 서버를 띄워주고 express web server 에 대해 e2e 테스트를 가능하게 해주는 것이 바로 supertest 이다. 본 포스트에서는 그 중에서도 일반 javascript가 아닌 typescript 환경에서의 e2e 테스트 코드 작성법에 대해 알아보고자 하며, 테스트를 위해서는 페이스북에서 만든 잘나가는 프레임웍인 jest와 typescript 배포판인 ts-jest 를 사용한다. Prerequisition먼저 타입스크립트로 작성된 프로그램은 javascript 기반의 테스트 환경인 jest 로는 테스트를 작동시킬 수가 없기 때문에, ts-jest 패키지를 dev 환경에 설치해 주어야 jest 가 typescript 코드를 읽고 실행할 수 있다. 다음과 같이 ts-ject, supertest, @types/supertest를 설치해 준다. 123npm install --save-dev ts-jestnpm install --save-dev supertestnpm install --save-dev @types/supertest 여기서 한가지 문제가 있는데, 아직 typescript supertest 의 경우 여러 패키지들과의 문제를 보이고 있다. 단편적인 예로 XMLHttpRequest 를 찾지 못하는 현상이 있는데, 이는 다음 설정을 tsconfig.json 에 해줌으로써 해결된다.다음과 같이 dom 을 앞에다 추가해 주자. 반드시 첫번째로 해야한다. 12345&#123; compilerOptions:&#123; &quot;lib&quot;:[&quot;dom&quot;,&quot;es2015] &#125;&#125; 위처럼 ts-jest를 설치했다면 이제 typescript 코드를 jest 에서 돌릴수 있게 된다. 본 프로젝트에서는 ts-jest 는 내부적으로 js 의 es6 문법을 컴파일 하기 위해 babel loader 를 사용하기 때문에 다음과 같이 babel env 를 설치하고 babel configuration 을 다음과 같이 해주어야 한다. 1npm install --save-dev babel-preset-env .babelrc 123&#123; presets:[\"env\"]&#125; Setup jest configurationJest 세팅은 tsconfig.json 에서도 할 수 있고 jest.config.js 파일에서도 할 수 있다. 이 경우 반드시 한쪽에서만 해야 문제가 발생하지 않기때문에 유념한다. Jest 는 typescript 를 컴파일 하지 않고 파일별로 컴파일과 실행을 동시에 처리하기 때문에, module alias 를 사용하였다면, 해당 파일이 어디에 있는지를 가르쳐 주어야 한다. 아래 코드에서는 moduleNameMapper 를 통해 module alias 를 발견하면 어디에서 해당 파일을 찾을 수 있는지 jest 에게 가르쳐 준다. 또한 ts-jest preset 를 사용한다는 것을 명시하고 있다. jest.config.js 12345678910111213141516171819module.exports = &#123; preset: 'ts-jest', testEnvironment: 'node', moduleNameMapper: &#123; '^@domain/(.*)$': '&lt;rootDir&gt;/src/server/domain/$1', '^@common/(.*)$': '&lt;rootDir&gt;/src/server/common/$1', '^@utils/(.*)$': '&lt;rootDir&gt;/src/server/utils/$1', '^@infra/(.*)$': '&lt;rootDir&gt;/src/server/infra/$1', '^@api/(.*)$': '&lt;rootDir&gt;/src/server/api/$1', '^@interfaces/(.*)$': '&lt;rootDir/src/server/interfaces/$1', '^@root/(.*)$': '&lt;rootDir&gt;/src/server/$1' &#125;, transform: &#123; '^.+\\\\.jsx?$': 'babel-jest', '^.+\\\\.(ts|tsx)$': 'ts-jest' &#125;, moduleFileExtensions: ['ts', 'tsx', 'js', 'node', 'json'], testMatch: ['**/*.test.+(ts|tsx|js)']&#125;; 여기서 moduleFileExtensions의 경우 typescript 테스트만을 진행하는 경우에는 tx, tsx, js 만 명시해주어도 되지만, 기본적인 node 가 제공하는 확장자인 json, node 등도 추가하여야 여러 패키지를 사용함에 있어 문제가 없다. Getting startedhow to setup express applicationSupertest 는 express application 객체를 받아서 내부적으로 서버를 listen 하기 때문에 supertest를 할 때마다 이런 express application을 주입시켜 주어야 한다. 어찌보면 단순한 일이지만 사실 실제 서버의 경우 express application 을 초기화하는 일련의 과정이 존재하기 때문에 이 작업을 해주는 것이 다소 까다로울 수 있다. 또한, 대부분의 REST API 테스트의 경우 인증된 사용자에 대해서만 요청을 처리하는 authentication 기능이 있기 때문에, 테스트를 진행하기 전에 jwt 토큰 발급 및 회원가입 등 authentication 관련 문제들을 해결해야 한다. 때문에, 본 문서에서는 이런 기본적인 express application initializing 과 authentication 을 도와주는 helper 클래스인 TestHelper 클래스를 먼저 구현하여 supertest 를 하도록 한다. app.ts 12345678class App &#123; public async setup(): Promise&lt;express.Express&gt; &#123; let app = express(); app.use(); return app; &#125;&#125; testHelper.ts 123456789101112131415161718192021222324252627282930313233343536373839404142class TestHelper &#123; /** * 테스트에 필요한 유저를 만들어 주는 함수이다. * * @param id 유저의 아이디 * @param password 유저의 비밀번호 */ public async generateTestUser( id: string, password: string ): Promise&lt;User&gt; &#123; /** * 필자는 일련의 회원가입을 담당하는 userService 에서 * 회원가입을 처리하고 있다. * 이 부분은 독자가 임의적으로 회원가입 로직을 구현하면 된다. */ let user = await userService.createUser( id, password ); return user; &#125; /** * * @param id 유저의 아이디 */ public async generateJwt(id) &#123; let jwtPayload = new JwtPayload(id); return encodeJwt(jwtPayload); &#125; public async getApp(): Promise&lt;express.Express&gt; &#123; let APP = new App(); let app = await APP.setup(); return app; &#125;&#125;export const testHelper = new TestHelper(); 위처럼 express appilcation 을 비동기적으로 세팅해주는 helper 함수들을 구현하였다면 아래와 같이 모든 테스트 코드를 작성하기 전에 위의 app을 초기화 해준다. 모든 테스트 이전에 다양한 환경을 세팅해주기 위해 beforeAll() 를 이용하는데, 이는 모든 테스트 전에 해야할 일들을 명시하고 세팅해 준다. 만약, 비동기적인 작업을 beforeAll 에서 해야 할 필요가 있다면 다음과 같은 방법이 있다. Promise 를 return 해주는 방법 Async/Await 을 사용하는 방법 Done 인자를 받아 사용하는 방법 아래 코드에서before all 부분에서 바로 promise 를 리턴하는 방식과 Async/Await 방식을 보여주고 있다. 12345678910111213141516171819202122232425describe('return promise',()=&gt;&#123; let app; beforeAll(()=&gt;&#123; return testHelper.getApp().then(_app=&gt;&#123; app = _app; &#125;) &#125;) describe('POST: /users',()=&gt;&#123; let res = await request(app).post('api/v1/users'); &#125;)&#125;)describe('example test',()=&gt;&#123; let app; beforeAll(async()=&gt;&#123; app = await testHelper.getApp() &#125;) describe('POST: /users',async()=&gt;&#123; let res = await request(app).post('api/v1/users'); &#125;)&#125;) 이렇게 테스트를 돌리게 되면, 테스트는 끝이 났는데 프로세스는 계속해서 동작하고 있다는 에러를 볼 수 있다. 이는 데이터베이스 등처럼 connection 객체가 살아있는 경우 해당 프로세스가 종료되지 않기 때문인데, 이 때문에 다음과 같이 테스트가 끝난 이후에 application 내의 데이터베이스 커넥션을 끊어주면 해당 경고가 없어진다. 123456789101112describe('',()=&gt;&#123; let app; beforeAll(async()=&gt;&#123; app = await testHelper.getApp() &#125;) afterAll(async()=&gt;&#123; app.closeApp() &#125;) &#125;) 여러 파일에서의 beforeAll 작업위처럼 모든 테스트파일에서 setup 을 진행하면, 각 setup 은 jest 의 특성상 비동기적으로 동작하게 되기 때문에, 만약 db 등을 조작한다면 confict 이 날 수 있다. 즉, 만약 모든 테스트를 통틀어 한번 데이터를 세팅하고자 한다면 다음과 같이 별도의 setup.js 파일을 만들어 전체 테스트 실행 전에 돌려주는 것이 좋다. setup.ts 123456789101112131415var mysql = require('mysql');console.log(mysql);var connection = mysql.createConnection(&#123; host: 'localhost', user: 'root', password: 'test1234', database: 'test'&#125;);connection.connect();connection.query('DELETE FROM user;', function(error, results, fields) &#123; if (error) throw error;&#125;);connection.end(); 위 스크립트 파일을 시작하도록 package.json 에 등록해준다. 12345&#123; \"scripts\":&#123; \"test\":\"node ./setup.js &amp;&amp; jest\" &#125;&#125;","link":"/2019/01/18/supertest-를-활용한-typescript-기반-node-js-e2e-테스트/"},{"title":"Signing and verifying in ethereum","text":"Signing and verifying in ethereum이더리움에서 eth 를 송금하거나 스마트 컨트랙을 부르는 등의 transaction 을 일으키기 위해서는 signing 이 필요하며, 블록체인 상에서 사용자를 인증하거나 메세지의 유효성을 검증하기 위해 signing 과 validation 이 사용된다. 가령, Alice 가 Bob 에게 어떤 메세지를 보내는 상황을 전제해 보자. 여기서 Bob 이 메세지를 받았다면, 인터넷 네트워크에서는 누구든지 메세지를 보낼 수 있고, 나쁜 의도를 가진 다수의 사용자들이 존재하기 때문에, 진짜 그 메세지가 Alice 로 부터 온 것인지 또, 메세지의 내용이 Alice 가 보낸 그 내용이 맞는지에 대해 의문을 품을 것이다. 이 때문에 블록체인 에서는 signing 의 개념이 존재하며 여기서 그 유효성을 검증하고자 하는 대상을 message 라고 한다. 그렇다면 이제 어떻게 signging 과 validation 이 진행되는 지를 알아보자. 먼저 위 사례에서 Alice 는 자신의 Private Key 로 해당 메세지에 서명을 한다. 이더리움에서 제공하는 web3 를 통해 다음과 같은 간략한 명령을 통해 이런 signing 이 진행되게 된다. 1web3.eth.accounts.sign(message, privateKey); 위 에서 message 는 유효성을 검증하기 위한 메세지로 String 타입이다. 위 과정을 거치면 사용자가 서명을 한 메세지를 의미하는 Signature Object 가 나오게 되는데 그 형식은 다음과 같다. 123456789&#123; message: 'Some data', messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655', v: '0x1c', r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd', s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029', signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f\\ 5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'&#125; 위에서 알 수 있듯이 Signature 에는 사용자의 원래 메세지 뿐만 아니라 messageHash 라는 &quot;\\x19Ethereum Signed Message:\\n&quot; + message.length + message 의 양식으로 포맷팅된 후 keccak256(SHA3) 으로 해쉬된 해시값을 비롯하여 signature 를 구성하는 v, r, s 와 실제 서명인 Signature 가 포함된다. 여기서 r 과 s 는 각각 Signature의 첫 32byte 와 뒤 32byte 를 나타낸다. * 위의 MessageHash 는 web3 가 제공하는 hashMessage(message) 함수 호출을 통해서도 얻을 수 있다. 위처럼 sign 을 완료했다면, 해당 Signature 를 받은 사용자는 다음과 같은 recover 함수 호출을 통해 올바른 사용자인지를 판별 할 수 있다. example 12345678910111213141516171819web3.eth.accounts.recover(signatureObject);web3.eth.accounts.recover(message, signature [, preFixed]);web3.eth.accounts.recover(message, v, r, s [, preFixed]);web3.eth.accounts.recover(&#123; messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655', v: '0x1c', r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd', s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029'&#125;)&gt; \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\"// message, signatureweb3.eth.accounts.recover('Some data', '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c');&gt; \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\"// message, v, r, sweb3.eth.accounts.recover('Some data', '0x1c', '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd', '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029');&gt; \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\" EIP712What is EIP712EIP 712 란 Ethereum Improvement Proposals 712 의 약어로 이더리움에서 향후 지원하게 될 다양한 제안들중 하나이다. 과거 사용자가 어떤 거래를 함에 있어 sign 을 할때에는 sign 의 대상이 되는 message 가 hash 화 되어 존재하기 때문에, 서명을 하는 사용자가 자신이 서명하는 내용에 대해 잘 알기 힘든 문제가 있었으며, 가령 유사한 해시값을 가진 피싱 사이트로 유도하여 사이닝을 유도한다던가 하는 다양한 위험에 노출되어 있었다. 이를 해결하기 위해 안전하고 값이 변조되지 않는 해싱을 보장하면서도 readability 를 가질 수 있는 서명방법을 고안하게 되었으며 그 제안내용이 EIP712 에 제안되었다. EIP712 를 통해 사용자는 자신이 서명하는 정보에 대해 명확하게 인지할 수 있게 된다고 볼 수 있다. 가령, 위에서처럼 일반적인 signing의 과정에서는 sign 을 요청하는 사람이 제공하는 message값(주로 hash값) 만을 보고 사용자가 sign 을 진행하지만 EIP712 에서는 json 데이터를 보고 자신이 서명하는 데이터를 명확히 알 수 있다. 다음은 EIP712 를 통해 수행되는 서명의 방법을 나타낸다. 먼저 서명을 하고자 하는 데이터의 형태를 정의하는데 이러한 typed structured data 를 먼저 정의하는 것으로 서명이 시작된다. 아래와 같이 서명을 하고자 하는 메세지를 json 형태로 정의를 한다. 서명자는 아래와 같은 데이터를 통해 어떤 내용에 자신이 서명을 하는지 알 수 있다.(아래의 메세지는 meta mask 등의 지갑 어플리케이션에서 파싱되어 보여지며, EIP712 는 이러한 지갑 어플리케이션에서 제공하는 기능을 말미암에 제공된다.) 컨트랙트 도메인 타입의 정의 1234567891011121314151617const domain = [ &#123; name: \"name\", type: \"string\" &#125;, &#123; name: \"version\", type: \"string\" &#125;, &#123; name: \"chainId\", type: \"uint256\" &#125;, &#123; name: \"verifyingContract\", type: \"address\" &#125;, &#123; name: \"salt\", type: \"bytes32\" &#125;,];const bid = [ &#123; name: \"amount\", type: \"uint256\" &#125;, &#123; name: \"bidder\", type: \"Identity\" &#125;,];const identity = [ &#123; name: \"userId\", type: \"uint256\" &#125;, &#123; name: \"wallet\", type: \"address\" &#125;,]; 1234567var message = &#123; amount: 100, bidder: &#123; userId: 323, wallet: \"0x3333333333333333333333333333333333333333\" &#125;&#125;; 위처럼 서명하고자 하는 message 를 정의하였다면, 해당 메세지가 어떤 도메인 사업자(즉 DAPP 사업자로 이해할 수 있다) 에서부터 온 메세지인지를 나타내는 구분자인 Domain Separator 를 정의해 준다. 1234567const domainData = &#123; name: \"My amazing dApp\", version: \"2\", chainId: parseInt(web3.version.network, 10), verifyingContract: \"0x1C56346CD2A2Bf3202F771f50d3D14a367B48070\", salt: \"0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a558\"&#125;; name: DAPP 혹은 Protocol 의 이름 version: DAPP 혹은 Platform version chainId: 테스트 넷인지 메인넷인지 등을 구분하는 chain id 로 EIP155 에서 제안되었다. verifyingContract: 해당 signature 를 verify 할 스마트 컨트랙트의 주소 salt: 32 바이트의 hard code 된 유니크한 값으로 컨트랙트와 DAPP 사이에 공유되어 다른 DAPP 과 구분되는 최후의 보루이다. message type 과 Domain separator 가 정의되었다면 다음과 같이 Json 형태의 data 를 만들고 이를 stringily 시켜 sign 을 요청한다. 12345678910111213141516171819202122232425262728const data = JSON.stringify(&#123; types: &#123; EIP712Domain: domain, Bid: bid, Identity: identity, &#125;, domain: domainData, primaryType: \"Bid\", message: message&#125;);web3.currentProvider.sendAsync(&#123; method: \"eth_signTypedData_v3\", params: [signer, data], from: signer&#125;,function(err, result) &#123; if (err) &#123; return console.error(err); &#125; const signature = result.result.substring(2); const r = \"0x\" + signature.substring(0, 64); const s = \"0x\" + signature.substring(64, 128); const v = parseInt(signature.substring(128, 130), 16); // The signature is now comprised of r, s, and v. &#125;); data 내의 types 필드는 스마트 컨트랙트 내에서의 데이터 구조를 나타내며 반드시 struct name 과 정확히 일치해야한다. 또한 PrimaryType 은 데이터 구조에서의 최상위 자료 구조형이 무엇인지 명시한다. Validation in Smart contract클라이언트에서 signing 을 위해 formatting 과 hashing 을 거친 것처럼 같은 내용의 코드가 Smart Contract 에도 포함되어야 한다. 이 과정을 통해 ecrecover 함수를 통해 해당 서명에 사인한 account 의 address 를 알 수 있다. 인증을 위한 Contract 를 위해 제일 먼저 EIP712 에서 앞서 정의한 data type 을 struct 로 정의해야 한다. 123456789struct Identity &#123; uint256 userId; address wallet;&#125;struct Bid &#123; uint256 amount; Identity bidder;&#125; 그 다음으로는 위 data structure 에 맞는 type hash 를 정의해야 하며 그 코드는 다음과 같다. 12string private constant IDENTITY_TYPE = &quot;Identity(uint256 userId,address wallet)&quot;;string private constant BID_TYPE = &quot;Bid(uint256 amount,Identity bidder)Identity(uint256 userId,address wallet)&quot;; 여기서 comma 와 bracket 사이에 공백이 들어가지 않는것을 유념하자. 또한, parameter 의 이름과 자료형이 클라이언트의 자료형과 변수명과 완벽하게 일치해야 한다. 또한 다음과 같이 Domain Separator 도 다음과 같이 hashify 되어야 한다. 123456789101112uint256 constant chainId = 1;address constant verifyingContract = 0x1C56346CD2A2Bf3202F771f50d3D14a367B48070;bytes32 constant salt = 0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a558;string private constant EIP712_DOMAIN = &quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)&quot;;bytes32 private constant DOMAIN_SEPARATOR = keccak256(abi.encode( EIP712_DOMAIN_TYPEHASH, keccak256(&quot;My amazing dApp&quot;), keccak256(&quot;2&quot;), chainId, verifyingContract, salt)); 아래와 같이 각 data 를 hashify 한다. 12345678910111213141516171819function hashIdentity(Identity identity) private pure returns (bytes32) &#123; return keccak256(abi.encode( IDENTITY_TYPEHASH, identity.userId, identity.wallet ));&#125;function hashBid(Bid memory bid) private pure returns (bytes32)&#123; return keccak256(abi.encodePacked( &quot;\\\\x19\\\\x01&quot;, DOMAIN_SEPARATOR, keccak256(abi.encode( BID_TYPEHASH, bid.amount, hashIdentity(bid.bidder) )) ));&#125; 마지막으로 다음과 같이 signature 를 verify 하는 함수를 작성해 준다. 123function verify(address signer, Bid memory bid, sigR, sigS, sigV) public pure returns (bool) &#123; return signer == ecrecover(hashBid(bid), sigV, sigR, sigS);&#125; Keccak256 hashing이더리움에서는 SHA3 해싱을 위해 keccak256 을 사용한다.","link":"/2019/02/28/signing-and-verifying-in-ethereum/"},{"title":"What is the blockchain technology","text":"블록체인 ‘기술’은 무엇인가요가상화폐에 대한 관심이 높아지면서 많은 사람들이 블록체인 기술에 대해 이야기합니다. 누군가는 새로운 화폐경제의 도래에서 블록체인의 의미에 대해 열변을 토하며 진정한 의미의 경제의 민주화를 이야기하고, 누군가는 단순한 투기의 대상으로써 일확천금을 기대하며 인생역전의 기회에 대해 이야기 합니다. 하지만, 가상화폐는 블록체인 기술의 막대한 활용처 중 일부에 불과하며, 진정한 의미에서 블록체인 기술이 가지는 사회 경제적 의미를 알기 위해서는 블록체인의 ‘기술’ 그 자체로서의 의미와 역사에 대한 이해가 반드시 수반되어야 할 것입니다. 이번 글에서는 ‘가상화폐’를 넘어 블록체인 ‘’기술’ 자체에 주목하여, 기본적인 기술 철학과 개념에 대해 이야기해 보고자 합니다. 블록체인 기술은 무엇을 해결하고자 하는가현대 사회에서 일어나는 모든 일들은 사실 개인과 개인 사이의 약속과 합의에 관한 문제를 다룬다고 보아도 무방할 것입니다. 인간은 사회적 동물로써 최대 다수의 최대 행복을 추구하기 위한 수많은 사회적 계약을 체결하였고, 현대 사회의 윤리와 법 비즈니스는 이런 사소한 약속들의 집합체에 불과한 것입니다. 이렇게 인간 사회에서 약속과 계약, 거래라는 것이 중요해 짐에 따라 이를 보다 효율적으로 수행하기 위한 수많은 방법들이 도입되었는데, 과거 조개 껍데기가 화폐로 쓰이던 시절부터 오늘날의 주주 명세서에 이르기까지 개인과 개인부터 국가 단체 사이의 거래까지 모든 계약의 신뢰를 보장하고 많은 사람들이 합의를 이루기 위한 각종 형태의 매개물이 생겨나게 되었습니다. 블록체인 기술이 본질적으로 해결하고자 하는 문제도 이와 같은 사회적 의미를 가지며, 그 본질적인 원리는 고대 그리스에서 사회적 합의를 도자기 조각에 적어서 투표를 하던 것 그 이상도 이하도 아닙니다. 다만 물리적인 한계로 과거에는 소수의 사람들만이 도자기에 의사를 적어 선별된 소수끼리만 합의를 이룰 수 있었던 반면, 현대에는 분산 컴퓨팅과 네트워크 속도의 향상 등의 기술적 진보를 통해 이 과정이 과거에 비교할 수 없이 빨라졌으며, 이를 통해 일부의 선별된 집단의 구성원만이 아니라 모든 사람들의 의사를 효과적으로 반영할 수 있는 합의 시스템이 만들어 지게되었는데, 그것이 바로 블록체인 기술이 주는 핵심적인 의미입니다. 즉, 기술의 발전으로 수천 수만의 사람들이 서로간에 완벽하게 투명하게 의사를 교환하고 수렴에 이를 수 있게 된 것입니다. 하지만, 막대한 컴퓨팅 기반으로 수많은 거래와 계약을 모두가 인정하는 합의를 이루는 데에는 과거에는 없던 새로운 문제가 발생하게 되었는데 그것은 바로 모든 거래와 계약의 순서를 올바르게 지키는 것입니다. 수억대의 컴퓨터가 각각의 계약과 거래를 체결하고 이를 모든 컴퓨터와 공유함에 따라 어떤 계약이 먼저 일어났는지를 올바르게 유지하는 것은 매우 어려운 일이며 이를 해결하기 위한 다양한 시도들이 진행되었습니다. 이처럼 블록체인 에서는 위에서 수많은 거래, 계약들이 발생하게 되고, 그 모든 활동을 트랜잭션(transaction) 이라고 부르며, 그 순서와 신뢰도를 보장하여 수많은 컴퓨터들이 합의에 이르도록 해 주는 합의 알고리즘을 필요로 합니다. 합의 알고리즘블록체인 내에서 일어나는 트랜잭션의 진실여부와 올바른 순서로 일어났는지에 대한 합의를 이루는 방법을 합의 알고리즘 이라고 합니다. 사실 블록체인이 생겨나기 전에는 이러한 모든 합의를 거대한 중앙기관(가령 은행이라는 통화 거래의 중심점) 에게 위임하고 그들이 판단하는 것을 진실로 약속하여 문제를 해결해 왔지만, 블록체인은 이러한 거대 기관이 아닌 진정한 의미에서의 민주주의라는 철학적 관점으로 모든 사람들의 합의를 진실로 규정하고자 하기에 이를 수행하기 위한 합의 알고리즘의 중요성이 강조됩니다. 블록체인의 성능그렇다면 어떤 블록체인이 우수한 블록체인이라고 불릴 수 있을까요? 블록체인의 성능을 이야기 함에 있어 우리는 TPS(초당 트랜잭션 처리량) 에 대해 이야기 하며, 구체적으로 보자면 블록체인에서 하나의 블록에 속하는 트랜잭션의 수를 그 블록이 생성되는데 걸리는 시간으로 나눈 값으로 이해하면 됩니다. 하지만 이것은 불확실한 정의이며, 가령 특정 블럭이 생성된 이후에 블록이 폐기된다면 해당 트랜잭션은 무효처리 되는데 이 빈도가 많고 적음에 따라 실질적인 TPS를 따지는 데 영향을 미치게 됩니다. 얼핏 생각하면 블록은 어차피 컴퓨터가 만드는 것이고 단순히 임의로 블록을 빠르게 만들어 내도록 하면 더 빠르게 거래가 이루어 질 수 있다고 생각될 수 있습니다. 하지만, 여기서 생각해보아야 할 문제가 있는데 그것은 바로 컴퓨터 사이의 통신 속도입니다. 가령 1억대의 컴퓨터가 있고, 어떤 컴퓨터에서 거래가 일어나 그 거래가 가장 멀리 떨어진 노드에 전파되는 속도가 블록이 생성되는 속도에 비해 너무 길다고 생각해 봅시다. 그렇다면 어떤 거래에 대한 내용을 모든 네트워크 구성원이 인지하기도 전에 거래가 승인되고 그런 거래는 그 신뢰도에 문제가 생기게 될 것입니다. 때문에 전체 네트워크를 구성하는 노드들 사이에서 신뢰를 획득할 수 있을만큼 트랜잭션의 전달(propagation)하는 시간이 주어져야 하며 그 시간보다 블럭이 생성되는데 걸리는 시간이 길어야 신뢰할 수 있는 블럭을 생성할 수 있습니다. 어떻게 블록체인의 성능을 향상시킬 것인가?그렇다면 어떻게 블록체인의 성능을 향상시킬 수 있을까요? 블록체인의 성능을 향상시키는 방법에는 다음과 같이 크게 3가지 방법이 있습니다. 샤딩 사이드 체인 스테이트 채널 먼저 전체 네트워크에서 특정 거래가 전파되는 속도를 향상시키기 위해서 네트워크를 작게 나누는 방법을 생각할 수 있습니다. 가령 어떤 학교에서 합의를 이루어야 하는 내용을 각 반별로 합의를 이루는 것으로 축약하고, 각 반의 구성원을 특정 숫자 이상으로 유지한다면 어느정도 믿을만한 합의가 이루어질 것인데, 이것을 블록체인에서는 샤딩 이라고 합니다. 현재 이더리움 재단에서 이러한 샤딩을 추진하고 있으며, 누구나 합의 과정에 참여 가능하도록 하자라는 철학을 가지고, stateless client(full state를 들고 있지 않고, state root 및 트랜잭션 정보만을 가진 노드) 도 검증을 수행할 수 있게 하였으며, 트랜잭션에 witness라는 값을 두어서 어떤 노드가 변경이 일어나는지를 추가합니다. 즉, 샤딩은 블록체인 네트워크를 쪼게어 각각 순서를 정하여 합의를 이루고 나중에 합치는 방식으로 네트워크 속도를 향상시킵니다. 다른 방법으로는 어떤 대규모 블록체인 안에서 소규모의 체인을 독자적으로 형성하고 그들사이의 합의 내용을 대규모 블록체인에 전달하는 방식이 있는데 이것을 사이드 체인 이라과 합니다. 이는 마치 중앙 정부와 시민 자치단체의 예로써 설명될 수 있는데, 시민 자치단체의 일정 수 이상의 구성원들이 완벽하게 합의를 이룬 사항에 대해 중앙 정부에 전달하고 이에대한 합의를 진행한다면, 전체 사회 내에서 시민단체에 속한 사람들 사이의 완벽한 합의를 도출하고 그 결과를 중앙정부에 합리적이고 투명하게 전달할 수 있게 될 것입니다. 세번째 방식인 스테이트 채널은 거래 당사자들끼리 합의를 이루고 그 정보를 전체 체인에 올리는 방식입니다. 이처럼 위 방법들은 네트워크를 쪼개어 순서 문제를 해결하고 propagation 속도를 높여 성능을 증가시키고자 하지만, 이 경우 전체 네트워크를 구성하는 노드가 적어지기 때문에 거대 네트워크일 때보다 그 신뢰도가 내려가고 여러가지 문제가 발생할 수 있는 단점이 있습니다. 블록체인에서 거래는 언제 확정되는가흔히 사람들이 블록체인은 안전하지만 아직 너무 느리다는 이야기를 듣고는 하는데, 일반적으로 거래는 일어나는 즉시 블록체인에 기록하고 합의를 진행하는데 그것이 그렇게 오래 걸리나 하는 의문이 드는 것은 매우 당연한 일입니다. 과거 은행들이 개인의 거래를 누군가와의 합의 없이 자신들의 내부 DB의 정보만을 바꾸는 것으로 거래를 수행하던 것과는 달리 블록체인은 모든 사람의 거래 내역을 하나의 거대한 줄기인 블록들의 체인에 기록하는 것으로 합의가 올바르게 이루어 지지 않는 경우 하나의 줄기가 계속해서 여러 갈래로 나뉘고 다시 합쳐지는 것을 반복합니다. 즉, 이미 일어난 거래라도 블록이 나뉘고 합쳐지는 과정에서 소실될 수 있는 확률이 생기는데, 이는 화폐의 거래에는 매우 큰 이슈입니다. 때문에 블록체인을 통해 화폐를 거래하는 현대의 많은 체인들의 경우 여러 특정 거래가 나뉘지 않고 큰 하나의 줄기로 이어질 확률인 finality 라는 개념을 사용하며 finality 가 낮을 수록 거래가 확정될 확률이 높다고 보며, 비트코인에서는 이러한 finality를 위해 블록이 현재 거래가 발생한 시점부터 6개 이상이 생겨나게 되면 finality가 0.02 이하이기 때문에 확정된 거래로 보고 있습니다. 잘 생각해 보면 이러한 finality는 TPS 속도에 무관함을 알 수 있는데, 거래가 아무리 빨리 일어난다고 하더라도 그만큼 믿을만한 블록들이 생겨나는것은 다른 문제이기 때문입니다. 가령 TPS가 아주 높은 블록체인에서 거래를 하더라도 거래가 빠른 만큼 블록들이 많이 생겨야 finality가 특정 수치 이상으로 낮아질 것이고, TPS가 낮은 블록체인에 비해 더 많은 블록들이 생겨나야 거래가 확정될 수 있습니다. 이러한 finality 를 빨리 단축시키는 방법, 즉 이상적으로 즉시 결제가 일어나기 위해서 많은 방법들이 시도되고 있으며 그 활용 현황은 다음과 같습니다. finality를 확보하지 않고 거래를 승인 DAG 알고리즘블록이 아닌 트랜잭션의 유효성과 순서를 승인 받음 갈라진 두개의 블록을 병합하는 방식 -&gt; 연구중 첫번째 방식을 사용하는 대표적인 사례는 비트코인 캐시가 있습니다. 비트코인 캐시는 트랜잭션을 받자마자 바로 순서를 인정하며 사용자의 지갑의 값을 변경하는 것으로 즉, finality가 확보되지 않은 상태에서 거래가 진행이 되며 추후 이것이 바뀌면 지갑에서 값이 바뀔 수 있는 문제가 있습니다. 두번째 방식은 DAG 알고리즘을 활용하는 것입니다. DAG 알고리즘에서는 블록단위로 거래를 기록하는 것이 아닌 트랜잭션 단위로 거래를 기록하기 때문에 사실상 실시간으로 거래가 일어날 수 있습니다. 블록체인이 하나의 큰 줄기를 만들어 역사를 기록하는 반면 DAG는 복잡한 거래를 DAG 그래프의 확장으로 보고 모든 노드는 자신에게 관련이 있는 거래만을 가지고 거래를 직접 검증하며, 이경우 블록의 합의 라던가 하는 부분이 이루어 지지 않기 때문에 사실 블록체인으로 보기는 힘든 측면이 있습니다. 세번째 방식은 갈라진 두개의 블록을 병합하여 하나의 블록의 만드는 방식으로 국내 decipher라는 블록체인 학회에서 연구가 진행중에 있습니다. 블록체인의 트랜잭션이 다루는 정보블록체인이란 기본적으로 transaction으로 인해 변경되는 state를 기록하는 state machine입니다. 여기서 state의 종류에 따라 다양한 state model이 있는데, 다음과 같이 3가지 종류로 구분이 가능합니다. UTXO(Unspent Transaction Output) Account Memory 먼저 UTXO state model은 비트코인이 쓰고 있는 모델로 트랜잭션의 아웃풋 자체가 토큰이고 토큰을 사용하였는가 안하였는가를 현재의 상태로 보고, 이것이 다른 트랜잭션의 인풋으로 들어가면 소비가 된 것으로 봅니다. Account 모델에서 모든 state는 account에 종속되어 있습니다. 각 account는 자신만의 고유의 nonce 를 가지며, 해당 account의 public key가 키값으로 사용된다. 즉 트랜잭션의 내용은 어떤 account가 가진 잔고에 대한 정보가 되며 이러한 수많은 계정 내역으로 블록체인이 이루어 진다. 이 경우 누가 얼마를 가졌는지를 바로 알 수 있기 때문에 편리한 점이 있지만, 프라이버시 부분에서 좋지 못한 부분이 있습니다. 마지막 모델은 memory 모델인데, 이 경우 트랜잭션은 256비트 짜리 address를 다루며, 각 컨트랙트는 특정 주소값을 할당받고, 여기서 트랜잭션이란 해당 주소값을 변경하는 내용을 기록합니다. 여기서의 키는 각 컨트랙트의 주소가 되며 현재 이더리움 재단에서 이러한 memory 모델과 account 모델을 차용하여 사용하고 있습니다. 블록체인은 어떻게 정보를 저장하는가블록체인은 사실 블록들의 연결에 불과하고 모든 블록은 컴퓨터에 저장됩니다. 그렇다면 블록체인은 우리 컴퓨터에 어떤 정보들을 어떻게 저장하고 있을까요? 블록체인은 크게 다음과 같은 3가지 정보를 저장하고 있습니다. state transaction result of transaction 위에서 알아본 바와 같이 블록체인은 상태값을 기본으로 저장합니다. 비트코인의 경우 트랜잭션만 저장하고 읽기 작업은 알아서 수행하는 반면 이더리움의 경우는 트랜잭션이 완료된 후의 현재 상태도 저장을 하여 보다 빠르게 데이터를 읽어 올 수 있게 합니다. 위와같은 정보는 대부분의 블록체인에서 키와 밸류 쌍으로 저장되며, 복잡한 쿼리문을 통해 정보를 읽는 등의 기능이 필요하지 않고 단순히 정보를 저장하고 꺼내오는 역할만 수행하므로 가벼운 데이터베이스인 키밸류 db를 사용하며, 흔히 leveldb 를 사용하고 있습니다 LNH 이 저작물은 크리에이티브 커먼즈 저작자표시-비영리-변경금지 4.0 국제 라이선스에 따라 이용할 수 있습니다.","link":"/2018/08/12/what is the blockchain technology/"},{"title":"Domain Driven Design 이란 무엇인가?","text":"Domain Driven Design 이란 무엇인가What is domain?도메인의 사전적 의미는 “정보와 활동의 영역” 을 말하며, 흔히 프로그래머들에게는 어플리케이션 내의 로직들이 관여하는 정보와 활동의 영역이라고 받아들여 집니다.가령, 어떤 웹 서비스를 만들 때 회원을 가입하고, 회원을 탈퇴하는 일련의 작업은 “회원” 과 관련된 일련의 작업들이며 여기서 “회원” 이라는 도메인이 있다고 볼 수 있습니다. 또 다른 용어로써 “domain layer” 와 “domain login” 이라는 용어가 있습니다. 이는 개발자들에게 일종의 “business logic” 과 동등한 것으로 받아들여져 왔습니다. 이러한 business login 은 비즈니스 주체들(가령 회원, 결제 등) 이 어떤 모델링 된 데이터를 생성하거나 변경하기 위해 서로간에 약속한 높은 수준의 규칙들을 의미합니다. DDD(Domain Driven Desing)도메인 주도 디자인이란 개발을 함에 있어 위에서 설명한 도메인이 중심이 되는 개발 방식을 말하며, 그 목적은 소프트웨어의 연관된 부분들을 연결하여 계속 해서 진화하는 새로운 모델을 만들어 나가 복잡한 어플리케이션을 만드는 것을 쉽게 해 주는 것에 있습니다.DDD의 핵심적인 목표는 Loose Coupling, High Cohesion 으로 각 도메인이 연결성이 적고 높은 정도로 연관되어 보다 가벼운 설계를 위해 탄생하였습니다. 다음은 DDD의 세가지 주요 원리입니다. 핵심 도메인과 그 기능에 집중하라. 도메인의 모델의 정교하게 구축하라. 어플리케이션 모델을 발전시키고 새롭게 생기는 도메인 관련 이슈를 해결하기 위해 도메인 전문가와 끊임없이 협력하라. Strategic Design소프트웨어를 디자인 할 때 객체를 기준으로 디자인을 진행하는 것은 Object Oriented Design 이라고 하는데, 이러한 관점에서 볼 때 Strategic Design은 OOD가 잘 이루어진 것으로 볼 수 있습니다. Strategic Design이란 Context 에 대해 생각하고 이를 기준으로 디자인을 하는 것을 말합니다. 여기서 Context란 무엇일까요? Context 란 특정 객체 혹은 상황이 벌어지는 주변 환경을 말합니다. 가장 쉬운 예로 가게 안에 접시에 담긴 피자와 혹은 길에 버려진 피자를 생각해 봅시다. 같은 피자이지만 피자가 매장 안의 접시에 있는지 혹은 길에 있는지에 따라 유료, 무료의 차이가 생기게 되고 사실상 다른 것으로 간주될 수 있습니다. 이처럼 같은 사물이나 행동 양상이 벌어지는 상황에 집중하여 디자인을 하는 것이 Strategic Design 의 핵심이라고 할 수 있다. Strategic Design을 이해하기 위해 간단한 예로 주택을 짓는 경우를 생각해 봅시다. 우리가 원하는 집을 짓기 위해서 우리가 하는 행동 절차는 다음과 같습니다. 어떤 주택을 지을지 생각을 해 본다. 그런 뒤에 우리는 Domain Expert 즉, 이 경우 집 전문가와 상의를 한다. 주택을 지을 때 어떤 핵심적인 가치에 집중하여 집을 지을지를 선택합니다. 가령 헛간이 넓어야 한다던가, 수영장이 커야 한다던가 중점적인 사항을 명시합니다. 그 뒤 우리는 이미 지어진 다른 집들을 최대한 많이 조사하여 마음속에서 원하는 집의 형상을 떠올려 봅니다. 그런 뒤에 우리는 그 형상을 실제 집으로 만들어 내기 위해 모델링을 하고 이를 토대로 구체적인 설계도를 그려 나갑니다. 이 설계도에는 집의 아주 구체적인 부분들이 명시되게 됩니다. 이렇게 DDD를 통한 설계 과정에서 사용되는 용어는 다음과 같습니다. 먼저 집 전체에 대한 설계의 전체를 우리는 domain 이라고 부르며, 커다란 집의 각각의 부분 집합인 헛간, 농장, 수영장 등 큰 파트들을 subdomain 이라고 부릅니다. 또 각각의 subdomain에 대해 각 subdomain의 문맥적 상황을 bounded context 라고 부르며, 실제 subdomain의 구체적인 형상을 나타내는 것을 domain model 이라고 부릅니다. 여기서 bounded context 가 가지는 의미는 바로 특정 모델이 어떤 bounded context 에 속하는 가에 따라서 다른 의미를 가지기 때문입니다.가령, 주택 건축시에 정문에서 caretaker라는 모델이 있다면 이는 바로 경비원을 말하는 것일 겁니다. 하지만 caretaker라는 단어가 메인 주거 건물 안에서 가지는 의미는 이와 다를 수 있습니다. 이 내용을 간단히 정리하면 다음과 같습니다. Context의미를 결정하는 것 처럼 보이는 단어 나 문장이 나타나는 설정으로, 모델에 관한 문장은 context 안에서만 이해될 수 있다.주택을 구성하는 각 부분 구간들에 대한 환경을 말한다. Model도메인의 특정 양상을 묘사한느 추상화 시스템으로 도메인과 관련된 문제를 해결하는 데 사용된다. Ubiquitous Language소프트웨어를 만들기 위해서는 많은 사람들이 원활히 소통해야 하고 여기에는 다양한 용어들이 사용된다. 가령, 기획자, 디자이너, 개발자가 모인 자리에서 각자 서로의 언어로 대화를 한다면 이는 원활한 커뮤니케이션을 심각하게 저해하게 된다. 이 경우에 필요한 것이 Ubiquitous Language이며 이는 domain model 을 둘러싼 언어구조를 말한다. 이 언어는 팀 전체가 각각의 업무 파트에서 공통적으로 사용될 수 있어야 하며, 실제 개발의 측면에서 모든 기획자, 디자이너, 개발자가 공통된 어휘를 사용해야 서로간에 이견이 없을 것이며 이러한 공통된 어휘를 ubiquitous language라고 합니다. Bounded Context위에서 설명한 Context에 대한 구체적인 설명으로, 특정 모델이 정의되고 적용될 수 있는 영역을 이야기 합니다.주택을 짓는 경우에 빗대어 생각해 볼 때, Bounded Context는 주택 전체를 구성하는 헛간, 농장, 수영장, 메인 주택 등의 큰 요소들 각각을 둘러싼 상황을 의미합니다.특정 모델은 어떤 bounded context에 놓이는가에 따라 다르게 이해될 수 있습니다.실제 소프트웨어를 구축함에서의 예를 들면 가령 sales를 담당한하는 subdomain이 있을 수 있고, 이를 지원하는 support와 accounting 라는 subdomain 이 존재할 수 있습니다. 이러한 각각의 subdomain이 놓인 환경인 bounded context 내에서 특정 모델 customer 가 보여지는 시각은 매우 상이할 수 있습니다. sales 팀에서 고객을 보는 시각은 주로 사회적 관심사, 좋아하는 것, 욕구 등의 것일 겁니다. 하지만 accounting의 측면에서는 사용자는 그저 하나의 계정으로써 그 사람의 결제정보 만이 중요한 정보일 수 있습니다. 즉 각기 다른 bounded context에서 ubiquitous language는 비록 표현은 같지만 다른 의미를 가지게 됩니다. Context Map각 bounded context들 사이의 관계를 말하며 즉, 주택 건축시에 헛간, 뒷간, 수영장 등 큰 요소들이 어떤식으로 서로 연관이 되어 있는지를 나타낸다. Domain ModelDomain Model 이란 실제 세계를 반영하는 구체적인 설계로, 주택 건축시에 주택을 구성하는 메인 주택의 구체적인 설계도를 말한다. Tactical Design Tactical Design Tool 들은 세부적인 사항을 구현하는 것을 위해 필요하며, 주로 Bounded Context 내의 구성 요소들을 관리합니다.이것은 개발상의 실제적인 표준을 제공하는데 services, entities, repositories, factories 와 같은 소프트웨어 디렉토리 구조들에 익숙한 개발자들이 많을 것인데, 이 모든 것은 전부 DDD에서 나온 개념입니다. 이러한 Tactical Design은 Strategic Design과 달리 개발을 진행하는 과정에서 계속해서 바뀌고 개선됩니다. Model Driven Design And Service Tactical Design을 이해하기 위한 Model Driven Design은 위와 같다.실제 구현은 모델 수준에서 이루어 지고 쉽게 비유하자면 당신의 소프트웨어 전체 즉, domain을 하나의 세계로 표현한다면 각 나라는 subdomain에 해당되고 각 subdomain은 각 나라의 언어인 ubiquitous language를 사용하게 됩니다. 이렇게 각 subdomain은 하나의 Service로 구현되게 됩니다. Layered Architecturelayered Architecture란 쉽게 말하면 모든 프로세스를 업무순서로 쪼게어 층을 나누어 수행하는 것이다.가령 맥도날드의 예를 들어보자. 맥도날드에서는 각 종업원들이 맡은 업무를 충실하게 수행하여 아주 효과적으로 업무를 처리한다. 만약 맥도날드의 종업원들이 요리, 계산, 서빙 등 많은 업무를 업무 분담 없이 하게 된다면 분명히 큰 혼란이 초래되고 손님들은 오랜시간 동안 기다려야 하고 형편없는 음식을 먹게 될 것이다. 하지만 맥도날드는 손님을 응대하는 계산원, 주문을 전달하고 컨트롤 하는 중간 매개인, 전체 프로세스에 필요한 인프라를 제공하는 요리사, 사장, 매니저, 필요한 재료들을 보관하는 창고 등으로 구성되어 빠르고 효과적으로 일을 처리한다. 소프트웨어에서도 마찬가지로 고객을 응대하는 request handler, 이를 중재하는 controller, 각종 중요한 비즈니스 로직을 처리하는 business, 다양한 자료구조 등으로 구성되어 클라이언트에 보다 빨리, 조직적으로, 잘 응대할수 있게 되었고, 이에 따라 보다 유연하고 지속가능한 소프트웨어를 구축할 수 있게 되었으며, 각 파트는 자신의 역할을 충실히 수행하고 필요한 경우 여러번 재사용 될 수 있게 된다. Value Object소프트웨어의 모델을 구성하는 수치에 대한 객체이며 훌륭한 디자인을 위한 가장 중요한 요소 중의 하나이다.가령 소프트웨어 내에 화폐를 취급하는 객체가 있다면, 이는 화폐에 관한 모든 처리를 누군가의 도움 없이 스스로 잘 처리할 수 있어야 한다.단위 환산, 표현법 변경 등 다양한 도메인 로직을 가져야 하며, 스스로 옳바른 값인지 validate 할 수 있어야 할 뿐 아니라 값이 제 3자에 의해 변하지 않고 일관성을 유지해야 한다. 가령 string 객체를 생각해 보자. 이 객체는 문자 어레이를 다루는 value object로써 substring 등의 다양한 기능을 수행하기 때문에 이를 일일히 정의할 필요가 없어져 ubiquitous language 로 소프트웨어의 표현을 간단하게 하고 보강해 준다. Entity기존의 attributes 를 기준으로 정의되었던 전통적인 객체와 달리, 연속성의 일관된 스레드에 의해 식별되는 객체이다.일반적인 개발자들이 이 개념에 대해 알고 있다. Entity는 Value Object로 구성되며 대표적인 예로 db에 있는 row들의 예를 들 수 있다.Entity는 identified id 를 가지고 business logic을 구현한다. Aggregate 와 Domain Eventsaggregates는 entities의 집합이다. 가령 cutomer, customerInfo, address 라는 세가지 종류의 entities를 생각해 보자. 사실 이 모든 정보는 customer라는 주제로 뭉칠 수 있으며, 여기서 핵심이 되는 entitiy인 customer는 이 세 entities가 이루는 aggregates의 root entity가 된다. 이렇게 되면, 다른 외부 객체는 aggregate 내의 객체로 직접 접근할 수 없고, 하나의 aggregate root item 즉 customer 에만 접근이 가능하며, 이를 통해 해당 aggregate 내에 명령을 전달해야 한다. 이는 실제 프로그래밍에 자주 쓰이는 디자인 패턴 중의 하나이다. 더욱 간편한 예로는 포스트와 댓글의 관계, 질문과 답변의 관계 등이 있다. 여기서 Domain Event 라는 개념에 대해 살표보자.domain event는 모델의 특정 행동과 관련된 이벤트인데, Aggregate 사이의 일관성을 유지하는데에 사용될 수 있다.가령 사용자의 주소가 바뀌면 주문 내용도 바뀌어야 하는데, 순서를 살펴보면 사용자의 주소가 바뀌면 같은 aggregate내에 있는 사용자 정보가 바뀌게 되고 이러한 aggregate의 변화는 주문과 관련된 aggregate의 변화를 촉구하기 위해 domain event를 발생시켜 상호간의 정보의 일치를 이룬다. FactoriesFactories는 복잡한 entity 혹은 aggregate를 생성하는 것을 담당한다.가령 엔진과 부속품을 넣으면 자동차가 나오는 공장과 같이 특정 정보를 factory에 보내면 결과로 aggregate 혹은 entity를 만들어주게 되고, 그 안에서 벌어지는 일에 대해서는 개발자들이 더 이상 신경을 쓰지 않아도 되고, 하나의 모듈로써 사용할 수 있다. Repositories일반적인 저장소와 달리 특정 aggregate에 보다 신속하게 접근하고 aggregate 단위로 데이터를 처리할 수 있게 해 준다.가령 위의 예처럼 customer 가 root entity로 있는 aggregate의 경우 1개의 repo를 만들게 되고, 사용자는 더 이상 기존의 db에서 고객 이름, 나이, 생년 등을 조합해서 사용하지 않고 repo에 aggregate를 통으로 저장해서 보다 쉽게 정보에 접근하고 정보를 변경할 수 있다. DDD를 통해 얻을 수 있는것Domain-driven design also heavily emphasizes the ever-more-popular practice of continuous integration, which asks the entire development team to use one shared code repository and push commits to it daily (if not multiple times a day). An automatic process executes at the end of the work day, which checks the integrity of the entire code base, running automated unit tests, regression tests, and the like, to quickly detect any potential problems that may have been introduced in the latest commits. DDD 구현어떻게 domain expert와 협의할 것인가과거에 Use Case Diagram, Sequence Diagram 등 많을 것을 썻다.때로는 ER Diagram도 사용했다. 하지만 요즘에는 이런 옛 방법을 사용하지 않고, Event Storming을 한다. 이것은 strategic design 을 위해 도메인 모델을 만들기 위한 연습이다.개발 전문가와 domain 전문가가 만나서 브레인 스토밍을 통해 각 도메인에서 어떤 내용들이 필요할지에 대한 직관을 기른다. 진행 단계 domain expert 와 개발 전문가와 함께 서로간의 질문을 하는 미팅 시간을 가진다. 포스트잇에 색깔에 따라 events, commands, policies, processes, errors, roles, aggregates, etc 등을 적어 놓는다.본 미팅은 event storming 이므로 이벤트를 시간의 순서에 따라 어플리케이션에서 발생 가능한 주요한 이벤트들을 나열한다.가령 쇼핑몰의 경우 상품 열람 =&gt; 상품 구매 =&gt; 상품 배송 =&gt; 배송 완료 처럼 디테일한 이벤트들을 순서대로 나열한다. 다음은 이러한 이벤트들의 포스트잇 주변에 연관된 system action, user action 등을 쭉 붙인다. 이러한 과정이 마무리 되면 이제 bounded context 를 찾을 시간이다.나열된 리스트를 보면 어느정도 분리된 subdomain 들이 보이게 되는데 가령 catalog, payments, delivery 등의 subdomain이 될 수 있다. 참고자료 - Alpha Code 동영상 강의 all images are from Alpha Code Lecture Above","link":"/2018/05/17/z_domain-driven-design/"},{"title":"블록체인이란 무엇인가?","text":"블록체인의 탄생현대 사회에서 기술의 발전의 가장 큰 흐름은 바로 atom world 를 bit world 로 옮기려 한다는 것이다.모든 실제 세계의 정보와 행동 양식 더 넘어서는 시장 그 자체에 이르기 까지 모든 atom world 즉, 실제 세계의 모든 것을 컴퓨터 사이의 네트워크로 구성되는 bit world 에 밀어 넣으려는 다양한 시도들이 계속되었다. 흔히, Database 즉, 데이터를 넣기위한 저장공간은 실제로 현대사회에서 모든 권리를 대변하고 있다.은행의 돈, 국가에서 개인의 신분 등 모든 중요한 정보들은 database 내에 존재하고 실제가 어떻게 되었든 database 안의 내용이 곧 진리인 사회속에서 우리는 살아가고 있다. 심지어는 database에 명확하게 들어가지 못하는 많은 정보들은 그 가치를 잃어가는 사회이기도 하다. 하지만, 이렇게 모든 현실 세계의 데이터를 database라는 꽉막힌 틀이 쑤셔넣는 것은 상당한 노력을 필요로 하는 일이고, 심지어 이러한 데이터베이스는 단지 하나의 컴퓨터에 존재하는 bit 덩어리에 불과하기 때문에 사람들이 서로가 소통해서 문제를 해결하듯이 database와 database 사이에서 원활하게 정보를 교류하여 문제를 빠르게 처리하는 것은 매우 어렵다. 각 database는 서로 다른 형태로 존재하고 때문에 우리는 유사한 정보를 수도없이 많이 컴퓨터에게 가르쳐 주어야 한다.흔한 예로 우리는 수많은 사이트에 수도없이 많이 같은 주소를 입력하고, 정부에서 민원을 처리하는 경우 각 부서를 옮겨다니면서 수십번씩 이름과 개인 정보를 입력하는 수고를 들여서 일을 처리해야 한다. 이는 너무나도 비효율적인 시스템이 아닐 수 없다. 시간이 지나고 우리는 이렇게 유연하지 못한 database의 홍수 속에서 어떻게 각각의 database를 통합하여 보다 유연하고 효율적인 데이터의 흐름을 만들어 낼 수 있을지 고민하게 되고 3가지의 해안을 제시하게 되었다. 1.Diverse peers model첫번째 방법은 단순히 컴퓨터와 컴퓨터를 연결하는 것이다.흔히 오늘날에는 결제를 하기 위해 쇼핑몰과 통신하고, 쇼핑몰은 은행과 은행은 다시 국세청과 정보를 교환해야 한다.이렇게 하나의 단순 작업을 처리하기 위해서 각 peer들이 계속해서 통신을 해야하고 매일매일 소프트웨어를 업그레이드해야 할 뿐만 아니라 버그에도 매우 취약하다. 또 하나의 심각한 문제는 무엇이 진짜인지를 알 수 없다는 것이다.진리는 존재하지 않고 각 peer 들 내부의 database의 수치값만이 존재하기 때문에 정보가 일관되지 않은 경우가 빈번하게 일어난다.가령 내가 쇼핑몰에서 물건을 주문과 결제를했는데 쇼핑몰 내의 database에서 내가 결제한 정보가 없다고 선언해 버린다면 우리는 대처할 수 있는 방법이 사실상 거의 없다고 보아도 무관하다.또 A 업체와 B 업체가 거래를 하려고 하는데 서로가 가진 재고량과 주문, 발송량이 일치하지 않는 경우 심각한 문제를 초래하게 된다. 2.Hub and Spoke두번째 방법은 이렇게 어려움 프로세스를 맡아줄 중앙 허브를 두는 것이다.많은 peer들이 직접 서로가 1:1 로 수십번 정보의 일관성을 흐리지 않고 정보를 교환하는 것은 매우 어렵기 때문에 이 모든 일을 다 처리해줄 마법같은 서비스들이 등장하게 되었다. 가령 결제사라던가 전자인증정보 시스템, VISA 처럼 수많은 peer들과 올바로 통신하고 데이터의 일관성을 보장해주는 중앙기관이 생기고 나머지 모든 peer는 이러한 중앙기관에 의존해 업무를 처리하는 것이다. 사실상 이러한 시스템은 자연적 독점기업이라고 보아도 무방하다. 이렇게 수많은 peer 들이 정보를 교환하는데 이 중앙 기업은 technical cost 라는 명목으로 막대한 부를 축적하고 당신의 신용과 정보에 대한 완벽한 통제권을 가지고 있다. 이는 전혀 민주적이지 못하며 VISA 사의 경우 전 세계 거래의 1% 라는 천문학적인 수입을 올릴 수 있는 시스템이 완성되는 것이다. 3.Protocol - if you can find them프로토콜은 궁극의 유니콘 같은 존재이다. 최적의 프로토콜을 찾으면 이러한 database의 완벽한 통합을 할 수 있겠지만, 현실 세계에서는 아무도 그런 프로토콜을 가지고 있지 못하다.HTTP, HTML, SMTP 등 많은 standard 들이 생겨나게 되었지만 아직 많은 한계들이 보인다.가령 slack 이나 Gchat의 경우 각 플랫폼 내의 사용자들이 서로간에 소통할 수 있도록 기존의 프로토콜사용하여 훌륭하게 동작시키고 있지만, 각 기업들 사이에 데이터를 교환하는 것은 불가능하다. 왜냐하면 각 기업이 어떤 프로토콜을 사용하는지를 공개하지 않기 때문이다. 때문에, 모든 서비스에 접근하여 중재역할을 하기 위해서는 각 게이트웨이를 해킹하는 수밖에는 없다. 블록체인은 위의 세가지 해안이 극복하지 못하는 많은 부분을 해결해 줄 해안으로 떠올랐고 그것이 블록체인의 시작이다. 참고자료 - Programmable Blockchains in Context: Ethereum’s Future by vinay gupta 블록체인이란 무엇인가요?블록체인이란 수많은 컴퓨터들을 연결하여 모든 컴퓨터가 동일한 체인 형태의 정보 리스트를 가지도록 하는 분산 컴퓨팅 기반의 데이터 위변조 기술이다.이 때 저장하고자 하는 데이터는 작은 정보들의 집합인 블록으로 구성되고 각 블록들이 서로 연결고리를 가지게 하여 누구도 중간 블록을 수정할 수 없고, 변경의 결과를 열람할 수 있게된다. 이러한 블록체인의 가장 큰 특징은 바로 분산 노드의 운영자가 임의로 데이터를 조작하지 못한다는 것이다.가령 기존의 데이터베이스의 경우 데이터베이스의 관리자가 손쉽게 데이터베이스를 조작할 수 있었고, 악한 마음을 가진다면 이를 기정사실화 하여 각종 보안 문제들에 휘말리게 된다. 하지만 블록체인의 경우 각 블록들이 수정되면 전체 연결고리가 깨어지게 되어 근본적으로 기존의 데이터를 수정하지 못하도록 고안되었기에 데이터베이스 관리자가 모든 권한을 가졌던 기존의 중앙집권적 권력체계가 무너지게 된다고 볼 수 있기에 보다 민주적인 형태의 데이터 저장 기술로 칭송받고 있다. 이러한 분산 시스템을 운영함에 있어 가장 큰 문제 중 하나는 비잔틴 장군 문제(Byzantine General Problems) 이다.여기서는 적군의 도시를 공격하려는 비잔티움 제국군의 여러 부대가 지리적으로 떨어진 상태에서 각 부대의 지휘관들이 (중간에 잡힐지도 모르는) 전령을 통해 교신하면서 공격 계획을 함께 세우는 상황을 가정하고 있습니다. 이 부대의 지휘관 중 일부에는 배신자가 섞여있을 수 있고, 배신자는 규칙을 충실히 따르는 충직한 지휘관들과 달리 규칙에 얽매이지 않고 마음대로 행동할 수 있다. 이 때 배신자의 존재에도 불구하고 충직한 지휘관들이 동일한 공격 계획을 세우기 위해서는 충직한 지휘관들의 수가 얼마나 있어야 하며, 이 지휘관들이 어떤 규칙을 따라 교신해야 하는지에 대한 문제가 비잔티움 장군 문제이다. 블록체인 기술은 이러한 비잔틴 장군 문제를 최초로 해결하였으며 비잔틴 장군 문제에 대한 내성이 있다는 의미로 비잔틴 장애 허용(BFT) 시스템 중의 하나이다. 블록체인 플랫폼 이더리움 백서에 대한 설명현대 가상화폐의 근간이 되는 블록체인 기술의 핵심은 시간의 흐름에 따른 각 노드의 상태를 저장하는 UTXO(Unspent Transaction Output) 를 모두 저장하는 것이다.각 트랜잭션은 k개의 input을 가지고 각 입력은 UTXO에 대한 레퍼런스를 가지며 특정 노드의 상태는 이러한 UTXO의 리스트로 구성된다. 블록은 10분 간격으로 생성되며, 각 블록은 timestamp, nonce, hash of previous block, transaction list 로 구성되며 블록을 생성하기 위한 과정을 채굴(mining) 이라고 하며 다음의 단계에 따라 진행된다. 이전 블록의 해시값 검사 블록의 timestamp가 이전 블록의 것보다 크고 2시간이 경과하지 않은지 검사 POW 상태집합 S 의 S[0] 에 이전 블록의 마지막 상태값을 저장 0 ~ n-1 의 모든 i에 대해 S[i+1] = APPLY(S[i], TX[i]) 를 수행 마지막 블록에 상태값 S[n] 를 등록 위 과정을 완료한 뒤에 해당 블록의 헤더를 해싱하고 그 해시를 풀기 위한 nonce를 무작위값을 계속 대입하면서 구함. = &gt; mining 블록의 구조블록은 위에서 언급했듯이 timestamp, nonce, hash of previous block, transaction list 로 구성되는데, 이 중에서 transaction list는 블록 데이터 부분에 저장되고 나머지는 블록 헤더에 저장이된다. 또, 블록 헤더에는 블록데이터에 대한 해시값이 저장되는데, 이 해시값은 머클트리 형태로 저장된 트랜잭션 리스트의 root hash의 값으로 하나의 트랜잭션이라도 조작되면 이 값이 바뀌게 되어 블록이 변질되었음을 알 수 있게 된다. 여기서 머클트리 란, 가령 n 개의 트랜잭션이 있다면 높이가 log(n)인 이진트리 형태로 구성되며, 각 부모는 자식의 해시를 가지게 되어 하나의 트랜잭션만 바뀌어도 수많은 노드의 해시값이 바뀌게 되는 트리이다. 이러한 블록들은 level DB 에 bloack hash 를 키로 블록 데이터를 value로 저장됩니다.이러한 db의 종류는 block_hash db, block_number db, transaction db 등이 있습니다. 보안의 원리블록체인은 어떠한 원리로 보안을 유지하는가? 먼저 다음과 같은 경우를 통해 블록체인을 훼손하는 경우를 생각해 보자.먼저 가장 마지막 블록번호가 270번 블록이라고 하자. 사용자가 특정 상인에게 100BTC 를 입금한다. 상인이 사용자에게 디지털 재화를 전송한다(순식간에 전송 가능하다고 전재한다.) 사용자가 스스로에게 100BTC를 입금한다. 이 경우 블록체인은 3의 트랜잭션을 보 정상적인 state에 있지 않은 utxo라 판단하게 되고 사용자의 블록체인은 따로 분기되게 된다.만약 그 동안 1시간이 경과하였다면 하지만 그와 동시에 다른 사용자들은 계속해서 블록을 생성하여 271~275까지 많은양의 블록을 생성한 상태이고 그들이 가리키는 해시값은 사용자의 270번 블록이 아닌 블록체인의 270번 블록을 가리키게 되고 사용자의 노드는 기존 블록체인에서 분리되게 된다. 이더리움이더리움의 기본 단위는 account 이며, EOA(External Owned Account) 와 Contract 두 종류의 account 가 있습니다. EOA 는 메세지를 보내는 주체이며 message에 의해 contract가 조작됩니다.여기서 message는 가상의 객체이며 송/수신자 정보와 데이터, eth 양 등의 정보를 담고 있습니다.ㄴ Contract가 Call 을 수행할때 생성됩니다. 블록체인의 비잔틴 장군 문제 해결블록체인에서는 모든 정보를 블록이라는 정보 뭉치의 연결로 보고 각 블록에는 암호화된 해시값이 있어 다음 블록을 가리키고 있는 형태로 구성되어 있습니다.또한 다음 블록이 생성되기 위해서는 참여하는 노드의 절반이상이 해당 노드가 올바른 노드라고 판단해야 다음 블록이 연결될 수 있기 때문에, 악의적인 목적을 가진 노드가 몇 개 존재한다고 하더라도 안정적으로 동작을 함을 말합니다. 합의 알고리즘POW새로운 화폐가 생성되는 과정(조폐)에서, 생성자들(채굴자들)에게 “일을 했다는 것을 증명(proof of work)”하는 것을 강제하여 화폐의 가치와 보안을 보장하는 방식이다. 분산 네트워크에서는 조폐 과정에서 누가 얼마의 새 화폐를 받을지를 결정할 중앙 권력이 없기 때문에 모든 참여자들이 자동적으로 동의할 수 있는 방법이 필요하다. 이때 일방향함수인 해시 함수가 계산(검산)하기는 쉽지만 역을 구하는 것(채굴)은 어렵다는 것에 착안하여, 모든 참여자가 해시 함수를 계산해서 가장 먼저 계산한 사람이 새 화폐를 받아가게 하는 것. 최초로 상업적 성공을 거둔 암호화폐 비트코인의 경우, 블록체인의 다음 블록을 캐기 위한 해시 함수의 입력값에 거래내역을 담은 블록체인의 최신값을 연동시켜서, 송금과 조폐 양 기능과 보안을 동시에 해결하였다. 나무 위키 참조 POS암호화폐에서 proof-of-stake의 이니셜. 가치 증명, 또는 지분 증명으로 번역된다. POW와는 근본적으로 다른 조폐 개념으로, 신규 코인을 발행할 때 이미 기존에 코인을 가지고 있던 사람들에게 전체 대비 각각의 소지량의 비율만큼을 지급하는 방식이다. 즉 암호화폐하면 으레 생각하는 채굴이 없다! 단, 현실적으로 액수에 관계없이 코인을 보유한 모든 지갑에 일괄적으로 %를 더하는 것은 불가능하므로, 조폐 과정에 참여하고 싶은 사람들이 일정 액수를 걸고(stake), 렌덤하게 추첨하여 참여자들 중 한명에게 다음 블록 보상(신규 코인)이 돌아가는 방식을 쓴다. 당연히 더 많이 걸수록 당첨 확률이 늘어난다. 참여에 필요한 최소 액수가 적어도 한화 수억원 어치이므로, 일반인들은 마이닝 풀과 유사한 개념인 스테이크 풀에 코인을 위탁해서 추첨에 참여한다. 얼핏 들으면 돈놓고 돈먹는 헤괴한 시스템으로 보일 수 있으나, 코인캡의 등락 없이는 신규 코인이 잔뜩 발행돼도 개당 가격이 내려가므로 각 코인 소유자들의 자산 가치는 동일하게 유지됨을 알 수 있다. 특정 집단이 과반수를 차지할 경우 그들의 지분이 계속 늘어나는 폐해가 벌어질 수 있으나, 채굴의 51%공격과 마찬가지로 당사자들의 이해관계 때문에 자정능력을 가진다. 채굴(POW) 대비 가장 큰 장점은 채굴에 들어가는 막대한 양의 에너지 낭비 없이 조폐와 거래를 운용할 수 있다는 점이다. 단점은 탈중앙화된 신규 코인은 이런 식으로 발행하기가 쉽지 않다는 점. 퀀텀(Qtum) 등에서 POS를 채택하고 있다. POW와 POS 외에 POI라는 기술도 있다. 나무위키 참조","link":"/2018/05/12/z_블록체인이란-무엇인가/"},{"title":"경제학 강의 01. 경제학이란 무엇인가?","text":"경제학은 무엇이며 왜 필요한가?필자는 현대 사회의 큰 축을 이루는 정치, 경제, 사회 모두의 측면에서 가장 근본이 되는 것은 바로 경제라고 생각한다. 현대 사회의 대부분의 문제들 가령, 전세난, 노조의 파업, 가계 부채, 글로벌 금융 위기와 취업난, FTA 문제들은 각 개인들 혹은 국가간 경제력을 거머쥐기 위한 치열한 전쟁의 현장이며, 이를 해결하는 것이 각국 정부의 주요 관심사가 되어가고 있다. 이토록 많은 사회적 문제를 해결하기 위한 학문이 바로 경제학 이며, 이는 그 이름이 주는 낯선 느낌과는 달리 삶의 모든 순간순간 우리가 고민하는 문제들의 집합체이기도 하다. 이러한 경제학을 간단히 정의하자면, 희소성 안에서 선택을 탐구하는 학문 이라고 할 수 있겠다. 인간의 욕망은 무한하고 인간이 가진 자원은 유한하기에 모든 개인과 국가는 더 많은 자원을 소유하기 위해 경쟁하고, 또 주어진 자원을 효율적으로 사용하기 위해 노력하며, 그 모든 행위를 위한 학문적 토대를 경제학이 제공한다. 먼저, 자원 에 대한 정의부터 생각해보자. 우리는 앞서 자원을 가지기 위해 경쟁한다고 했기 때문에, 자원이란 반드시 가치가 있어야 하고 또 그 양이 무한해야 할 것이다. 마치 공기처럼 수없이 많이 있기 때문에 다른 사람들과 경쟁할 필요가 없다면 그것은 더 이상 경쟁의 대상이 되지 못한다. 이러한 자원은 재화 와 서비스 로 분류될 수 있는데, 여기서 재화 란 쌀, 가전제품 처럼 형태가 존재하는 유형의 상품을 말하며, 서비스 란 트레이너의 PT 처럼 무형의 상품을 말한다. 또 재화 는 자유재 와 경제재 로 구분될 수 있는데, 자유재 란 앞에서 말한 것처럼 무한히 존재하여 다른 사람과 경쟁이 필요없는 재화를 말하며, 경제재 란 그 양이 한정적이기 때문에 모든 사람이 원하는 만큼 소유할 수 없기에 경쟁의 대상 이 될 수 있는 재화를 말한다. 이처럼 경제학이란 전체 사회원 혹은 국가의 입장에서는 무한하지 못한 재화를 효과적으로 사용하기 위한 학문이며, 효율성 과 형평성 을 추구하는데 즉, 최소의 비용으로 최대의 효과를 얻고, 사회 구성원간에 보다 공평하게 재화를 나눌 수 있도록 하는 것을 목적으로 한다. 이처럼 효율성과 형평성을 극대화 하기 위해서는 비용과 수익의 분석을 통해 어느 선택이 다른 대안에 비해서 효율적인가를 판단하고 각 대안에 소요되는 비용과 수익을 정확하게 계산할 수 있어야 한다. 비용이란 무엇이며 어떻게 산출되는가?경제학의 목적인 효율성과 형평성을 추구하기 위해서는 비용과 수익의 분석을 통해 어느 선택이 다른 대안에 비해서 효율적인가를 판단하고 각 대안에 소요되는 비용과 수익을 정확하게 계산할 수 있어야 한다고 하였다. 그렇다면 여기서 비용이란 무엇인가? 비용은 기회 비용(경제적 비용) 과 명시적 비용 으로 나누어 생각할 수 있는데, 먼저 기회 비용 이란 내가 얻고자 하는 것을 얻기위해 내가 지불해야하는 경제적 가치로 내가 가진 모든 선택지를 고려하여 하나의 선택지를 선택하였을때 지불해야 할 비용 뿐 아니라 다른 선택지를 선택함으로써 얻을 수 있는 이익까지 포기하는 것이 되므로 그 두 가치를 합산한 것으로, 흔히 생각하는 시장의 가격과는 차이가 있다. 반면, 명시적 비용 이란, 단순히 장부상에 기록되는 비용으로 흔히 우리가 인식하는 비용이라 생각할 수 있다. 한 예를 들면 만약 필자가 10년 할부로 페라리를 구입한다고 하면, 매달 내가 지불하는 할부금액의 합이 명시적 비용 이라고 볼 수 있다. 하지만 필자가 경제적으로 지불하는 만약 필자가 저축이라는 다른 선택을 선택하였다면 얻을 수 있는 복리에 대한 이자율 또한 포기한 셈이 되므로 10년 동안 은행에 할부금을 저축한 금액에 대한 10년간의 복리 이자액을 묵시적 비용 이라 부르고 이 둘을 합한 것이 필자가 지불한 경제적 비용 즉, 기회 비용 이 되는 것이다. 경제적 비용 = 명시적 비용 + 묵시적 비용 이처럼 매 결정에서 내가 지불하는 기회 비용 을 정확히 따져보고 선택을 내리는 것은 매우 힘든 일이다. 내가 처한 경제적 상황과 선택지를 면밀히 따져보고 경제 현상을 이해해야만 옳은 경제적 선택을 내릴 수 있으며, 이때 필요한 것이 경제적 사고 이다. 무엇을 선택할 것인가?우리는 경제학의 주요 요소인 재화 와 비용 에 대해 알아보았다. 경제학은 이러한 한정된 재화를 효율적으로 사용하기 위한 여러가지 선택을 내리는 것이라 배웠고, 각 선택을 함에 있어 정확한 경제적 비용을 측량하는 방법 또한 배웠다. 그렇다면 우리는 무엇에 관한 선택을 할 것인가? 경제학에서 우리는 크게 3가지에 관한 경제적 선택에 대해 알아볼 것인데, 그것은 바로 무엇을, 어떻게, 누구를 위하여 생산할 것인가에 대한 문제 이다. 먼저, 무엇을 생산할 것인가의 선택 은 제한된 자원을 사용하여 사회 안에서 어떠한 상품들이 생산되느냐를 선택하는 문제인데, 가령 한 국가에서 전쟁을 위한 무기를 생산하여 국력을 증강시킬 지 혹은 식량을 생산하여 국민들의 삶의 질을 높일 것인지를 선택하는 문제는 매우 중요하다. 두번째 선택은 어떻게 생산할 것인가 에 대한 문제이다. 무엇을 생산할지가 결정되었다면 그 재화를 가장 효율적으로 생산하기위한 다양한 프로세스를 고민해야 한다. 어떠한 생산 방식을 채택 하여 효율을 높일지, 노동을 주로 사용하여 생산할 것인지 혹은 자본투자를 통하여 생산을 극대화 할 것인지 등을 고민한다. 두번째 선택지에 관한 문제는 현대 과학과 공학의 주요한 발전의 목적이 되는데, 독보적인 기술의 진보를 통해 생산성 증진을 혁신적으로 끌어올릴 수 있기에 많은 국가는 막대한 자본을 투자하여 생산 기술의 진보에 열을 올리곤 한다. 선번째 경제적 선택은 바로 누구를 위해 생산할 것인가 에 대한 것이다. 이것은 분배에 관한 문제이며, 효율적으로 축적한 경제적 이윤을 어떤방식으로 형평성을 맞추어 분배할지에 대한 문제이다. 이러한 문제에 대한 다양한 선택지가 존재하는데, 극단적으로는 자본주의와 공산주의의 대립처럼 부의 효율적이고 공정한 분배에 관한 문제를 고려한다. 경제학의 종류주류 경제학과 정치 경제학경제이론에 대한 의견은 경제학사에서도 첨예하게 대립하고 있으며 흔히 아담 스미스 이후의 고전학파와 이를 이어받은 신고전학파 경제학과 1930년대 세계 대공황 이후 정부의 역할을 강조하는 케인즈 학파 로 이루어 지는 주류 경제학 과 정치 경제학 이라 부르는 마르크스 주의 경제학 이 있다. 여기서 주류 경제학 은 자유방임의 시장경제가 자원배분을 가장 효율적으로 이룰 수 있다고 믿는 경제학파 이며, 흔히 우리가 아는 보이지 않는 손 을 신봉하는 경제학파라고 볼 수 있다. 반면 정치 경제학 이란 생산 수단의 공동 소유를 기초로 하는 사회주의적 경제체제를 추구하여 국가의 이상적인 통치와 질서를 통해 경제의 효율성과 형평성을 이룩할 수 있다고 주장하는 학파이다. 규범적 경제학과 실증적 경제학규범적 이란 주관적 가치관이 개입된 경우를 말하며, 실증적 이란 가치관이 들어가지 않고 현상을 있는 그대로 묘사하는 것을 말한다. 즉, 실증적 경제학 이란 주관적 가치관의 개입 없이 경제현상을 있는 그대로 설명하는 것을 의미하며, 규범적 경제학 이란 가치관이 개입되는 경제학을 말한다. 가령 수요의 법칙 을 생각해 보자. 수요의 법칙 이란 가격이 오르면 소비가 줄고 가격이 내리면 소비가 늘어난다는 경제 법칙으로 이는 실험과 경험을 통해 측정된 사실을 바탕으로 얻어낸 실증적 경제학의 예를 보여준다. 반면, 농산물을 수입하는 정책을 세운다고 해 보자. 값싼 농산물을 수입하면, 국내의 가난한 농민들에게는 큰 타격이 되겠지만, 많은 사람들이 보다 저렴하게 식품을 구매할 수 있고, 수입하지 않으면, 국민들이 비교적 비싼 가격으로 식품을 구매해야 하지만 가난한 농민들에게는 큰 보탬이 된다. 즉, 이와 같은 경정을 할 때에는 어떤 집단의 이익을 우선시 하는가에 따라 서로 다른 선택을 해야하며 여기에는 반드시 주관적인 가치판단이 들어가야 한다. 이를 기반으로 하는 경제학을 규범적 경제학 이라 일컷는다. 미시 경제학과 거시 경제학미시 경제학 이란 개별 시장의 관점에서 경제를 보는 것이고, 거시 경제학 이란 경제 전체의 관점에서 경제를 바라보는 경제학으로, 가령 특정 개인이나 집단 혹은 기업의 입장에서 시장을 바라보는 것을 미시 경제학 에서 다루며 국가 경제 전체를 대상으로 하는 환율, 물가, 이자율 등에 대한 고민을 하는 것이 거시 경제학 이다. 즉, 미시 경제학 이란 가계와 기업의 의사결정과정을 분석하고 이들이 시장에서 어떻게 상호작용하는가를 연구하는 분야이고, 거시 경제학 은 경제 전체에 미치는 변수와 추세에 관하여 연구하는 분야이다.","link":"/2018/11/11/경제학-강의-01/"},{"title":"가치투자 시작하기","text":"가치투자란 기업을 분석하여 과거의 실적과 향후의 성장가능성을 예상하고, 그 예상치에 비해 현재 가격이 주식 시장에서 낮게 평가되어 있는 주식에 투자하여 수익을 거두는 투자 기법을 말한다. 가치투자를 위해서는 가장 먼저 어떤 기업을 평가하는 법을 알아야 한다. 기업을 평가하는 방법에는 여러 방법이 있겠지만, 다음과 같은 기준을 가지고 기본적인 평가를 할 수 있다. 기업의 영업 이익에 비해 시장에서 저평가 되었는가 기업이 하는 비즈니스가 내가 이해 할 수 있고 일반적인 기준에서 합리적인가? 기업이 하는 비즈니스에 다른 경쟁자가 들어올 진입장벽이 존재하는가?(기술기업이라면 기술력, 플랫폼 기업이라면 선점효과 혹은 네트워크 효과를 가지는가?) 향후 매출과 영업이익이 오를것으로 판단되는가? 매출의 증가에 비해 영업 이익의 증가율이 더 큰가?(고정 비용, 판관비(판매비 관리비) 의 증가율은 얼마나 상승할 것이고 그에 비해 매출은 얼마나 올라갈 것인가?) 위의 모든 조건에도 불구하고 시장에서 저평가되고 그 기조가 일정하게 유지되어 아래에 유리벽(더 이상 주가가 내려가지 않을 벽)이 존재하는가? 위의 각 평가 기준을 실제 판단함에 있어 보아야 하는 데이터는 다음과 같다. 1번의 경우 PER 를 통해 확인 할 수 있는데, PER 란 주가 수익 비율로 한 주당 가격을 주당 영업이익으로 나눈 값이다. 즉, 어떤 주식이 10만원이라 하고 전체 주식이 100,000주, 순이익이 10억이라 하면, 한 주당 순이익은 1만원이고 이 경우 PER 는 10만/1만 즉 10이 된다. 흔히 PER 는 기업의 순이익에 비해 시장이 기업을 평가하는 정도를 나타내며 PER 가 높으면, 고평가 되었고, 낮으면 시장에서 저평가 된 것으로 이해할 수 있다. 일반적인 주식의 PER 는 10 내외이고 6~7 이라 하면 순이익에 비해 기업이 상당히 저평가 되었다고 볼 수 있다. 2번의 경우는 전자공시 시스템에서 해당 기업의 사업보고서를 읽어보고 그 기업의 비즈니스를 내가 이해하고 합리적이어야 한다. 3번의 경우는 내가 투자하고자 하는 기업이 하는 비즈니스에 다른 경쟁사들이 쉽게 진입할 수 없는지를 알아보아야 하는데, 이것은 다양한 정보 검색을 통해 알아낼 수 있다. 가령 해당 기업의 브랜드 인지도와 시장 점유율 등을 보면 알 수 있다. 4번의 경우 또한 각종 기사와 사업보고서를 통해 알아낼 수 있다. 가령, 해당 기업의 현재 매출대비 영업이익이 얼마인데, 해외에서 장기 계약을 수주하고 그 규모를 안다면, 앞으로 해당 기업의 영업 이익이 10년간 얼마나 성장할지는 불보듯 뻔한 일이다. 이를 통해 몇년간 몇 % 의 영업 이익이 성장할지 구체적으로 점칠 수 있다. 5번의 경우는 기업의 매출이 증가함에 따라 영업이익이 가파르게 성장할 수 있는가이다. 가령 단순 제조업의 경우 제품을 많이 만들어도 기본적인 제조원가가 계속 들어가기 때문에 영업이익은 거의 일정하게 성장한다. 하지만, 지식 융합 산업의 경우 판관비는 그대로 인데, 매출이 늘어나면 영업 이익은 매우 가파르게 성장할 수 있다. 6번의 경우는 유리벽돌이 존재하는 가이다. 위의 모든 조건을 충족했음에도 불구하고, 주가 그래프가 우 하향을 하고있고, 그 하향이 매우 완만한 상황이라면, 기업이 저평가된 것을 시장이 모르고 안정적인 주가를 유지하고 있다는 것이기 때문이다. 해당 기업은 앞으로 기업 실적이 개선될 것이기 때문에 현재 주가 이하로 떨어지는 것은 확률이 매우 낮음을 의미한다. 이러한 정보는 기업의 배당률과 같은 지표로도 알 수 있는데, 가령 완만한 우 하향 곡선을 그리고 있음에도 배당률이 평균 1~2% 를 넘어 5% 가량이나 된다면, 매우 견실한 기업이라고 볼 수 있고, 배당률이 저렇게 높은데 우 하향이라면 곧 이 회사의 가치를 알아보고 투자하는 세력이 생길 것이기에 주가는 오를 것이라 예상할 수 있다. 추천 도서123456789101112131415161718191. 가치투자가 쉬워지는 V차트2. 한국형 가치투자 전략3. 내일의 금맥4. 단도투자&lt;강추&gt;5. 왜 채권쟁이들이 주식으로 돈을 잘 벌까?&lt;밸류에이션법&gt;6. 워렌버핏 바이블- 주식시장을 이기는 작은책- 가치투자의 비밀 (크리스토퍼 브라운)- 돈, 뜨겁게 사랑하고 차갑게 다루어라- 불황에도 승리하는 사와카미 투자법- 위대한 기업에 투자하라- 보수적인 투자자는 마음이 편하다- 가치투자의 귀재 존 네프 수익률 5600% 신화를 쓰다.- 전설로 떠나는 월가의 영웅 (피터린치)- 가치투자를 말한다 (미국대표 펀드매니저 20인의 투자법)- 작지만 강한 기업에 투자하라- 현명한 투자자, 증권분석- 금융투기의 역사- 치과의사 피트씨의 똑똑한 배당주 투자 주변에 널린 투자 아이디어를 활용하라우리는 일상 생활에서 많은 기업의 제품과 서비스를 사용하고 관찰할 수 있다. 가령 ‘허니버터 칩’ 처럼 히트 상품이 나오면 반드시 이는 그 기업의 영업이익을 막대하게 증가시킬 것이고 이는 주가에 반영될 것이다. 하지만, 주의할 점이 있다면, 그 히트상품이 그 기업의 전체 영업이익중 차지하는 비율을 알아야 전체 회사가 얼마나 성장할 지 알 수 있을 것이다. 가령, ‘허니버터 칩’ 의 매출이 차지하는 비율이 해당 회사의 전체 매출의 1% 에 불과하다면 해당 히트상품은 주가에 큰 영향을 줄 수 없다. 즉, 갑자기 많은 사람들의 입에 오르내리고 특히, 아이들과 여성 사이에서 인기가 있으며, 매스컴에서 발표하는 히트상품을 주의깊에 보라, 또 그 제품을 만드는 기업을 분석하고 그 기업에서 제품이 차지하는 비중이 얼마나 되는지 또 그 제품의 판매량 증대가 기업의 이익 증대로 연결되는지를 파악하라. 브랜드형 기업을 발굴하라.강력한 브랜드 구축에는 많은 시간과 비용이 들어가지만, 일단 본 궤도에 오르면 다른 기업들이 접근할 수 없는 강력한 경쟁력이 된다. 만약 주변인들이 제품을 찾을 때 당연시 하는 브랜드가 있고, 그 브랜드가 대안을 찾을 수 없는 브랜드라면 그 기업은 브랜드 가치가 있는 기업이라고 볼 수 있다. 또 특정 제품이 기업과 동일 시 될 정도로 강력한 브랜드를 구축한다면(마치 박카스) 더할 나위 없다. 이 중에서 경쟁제품이 없고 시장점유율이 독보적이며 기업의 이름만 들어도 누구나 알법한 브랜드라면 그 기업은 앞으로도 쭉 흥할 것이다. 용어 정리PER(Price Earning Ratio)전체 주식 가격을 순수익으로 나눈 값으로, 순수익을 벌어들인 돈으로 몇년이면 그 회사를 살 수 있는가를 나타낸다. 가령 어떤 회사의 시총이 100억인데, 순수익이 20억이라면, PER 는 5배 즉, 5년이면 그 회사의 본전을 찾는다는 뜻이다. ROE(Return On Equity)Net income / Equity 순자산 대비 순 수익으로 자산이 얼마나 효율적으로 운용되고 있는가를 나타낸다. ROA순이익/평균 총 자산 * 100 부채가지 포함한 총 자산으로 얼마나 벌었는지를 보여주는 비율 EPS주식 한 주가 벌어들이는 이익 경상이익영업이익 + 영업외 수익 - 영업 외 비용 영업외수익회사의 활동에서 생기는 수익 중 정규영업에 기인하지 않는 것. 수취이자, 유가증권이자, 유가증권매각수익, 유가증권평가수익, 매입할인, 잡수입 특별이익영업활동 이외에 우발적 원인으로 발생하는 이익 투자자산이익, 채무면제이익, 보험차익 등 유보율(자기자본 - 자본금 + 자기주식)/자본금 * 100 사업을 통해 창업 시기부터 지금까지 자본금으로 얼마를 벌었는가에 대한 비율","link":"/2019/05/23/가치투자-시작하기/"},{"title":"두나무의 블록체인 개발 플랫폼, 루니버스","text":"두나무의 블록체인 개발 플랫폼, 루니버스이번 포스트에서는 두나무의 블록체인 개발 플랫폼 루니버스에 대해 알아보고자 합니다. 루니버스란?블록체인 기술에 대한 관심은 계속해서 증가하고 있지만, 블록체인의 특성상 메인넷을 구성하고 자체 코인을 발행하는 것은 상당한 기술력을 필요로 하고, 네트워크를 구축했다 하더라도 다른 블록체인 네트워크와 접점을 만들고 블록체인 플랫폼의 참여자를 만들어 나가는 것 또한 매우 어려운 일이기에, 국내에서 성공적으로 운영되고 있는 블록체인 서비스는 사실상 전무하다고 볼 수 있습니다. 두나무의 루니버스란 이처럼 개발의 진입장벽이 높은 블록체인 기술의 장벽을 낮추고 개발자라면 누구나 쉽게 Decentralized Application을 만들 수 있도록 하겠다는 목표로 블록체인 서비스 개발 플랫폼인 ‘루니버스’ 의 출시를 준비하고 있습니다. 루니버스는 마치 아마존의 클라우드 서버처럼 클릭 몇번으로 네트워크 상에 자체적인 블록체인 네트워크를 구축하도록 도와주며, 해당 블록체인 네트워크에 토큰을 발행하고 Dapp 을 올리는 등의 일련의 작업을 매우 쉽게 만들어주어 개발자들에게 인종의 블록체인 네트워크에 대한 쉽고 간편한 인터페이스를 제공해 줍니다. 루니버스 플랫폼을 통해서 개발자는 간편한 REST API를 통해 블록체인 상의 대부분의 기능을 수행할 수 있게 되기에 오직 비즈니스 로직에만 집중하여 블록체인 서비스를 만들 수 있는 환경을 제공받습니다. 즉, 루니버스를 이용하면 블록체인 개발에 대한 전문 지식이 없어도 쉽게 컨소시엄 블록체인 네트워크를 구축하고 토큰을 발행, 운영할 수 있습니다. 루니버스 체인루니버스 체인은 파트너들 모여 분산화된 네트워크 구성합니다. 각 개발사들은 루니버스를 통해 간편하게 자신의 체인을 만들고 루니버스 체인 내의 다른 체인들에 쉽게 deploy 및 transaction 발행할 수 있습니다. 루니버스 체인을 이해하기 전에 3가지 종류의 체인에 대해 이해할 필요가 있으며, 루니버스 체인, 컨소시엄 블록체인, 프로턱트 체인이 바로 그것입니다. 먼저, 루니버스 체인은 전체 블록체인 네트워크를 포함하는 개념이며, 루니버스의 블록체인 위에서 여러 개발사들의 블록체인 네트워크가 운영되며, 여러 블록체인 사이의 인터페이스를 만들어 주어 여러 블록체인 네트워크 사이에서 통신이 가능하게 해줍니다. 다음은 컨소시엄 블록체인인데, 루니버스를 통해 블록체인을 개발하는 개발사들은 루니버스 체인 위에 자신만의 별도의 컨소시엄 블록체인을 구축할 수 있습니다. 루니버스 체인은 이러한 여러개의 컨소시엄 블록체인들을 이어주는 역할을 수행합니다. 마지막으로 프로덕트 체인 이 있는데, 이러한 프로덕트 체인 위에서 실제적인 Dapp 과 Token이 운영되게 됩니다. 각 개발사들은 자신들의 컨소시엄 블록체인 위에 다수의 프로덕트 체인을 구축하여 운영하거나 혹은 루니버스 체인 위에 바로 자신만의 프로덕트 체인을 구축하는 방식으로 서비스를 운영할 수 있습니다. 루니버스에서 프로덕트 체인은 아이콘과 협력하여 만들어지고 있으며, 12월에 정식으로 루니버스 체인의 메인넷이 가동될 예정입니다. 뿐만 아니라 루니버스 네트워크는 이더리움, 이오스 등 다른 대형 블록체인 네트워크 와의 인터페이스를 구축할 예정으로 루니버스 내의 블록체인을 다른 거대 메인넷과 손쉽게 연동할 수 있는 다리 역할을 해줄 것으로 기대됩니다. 종합하자면, 루니버스는 일종의 sass 로 볼 수 있으며, 블록체인 기술을 추상화 시켜 개발자들이 비즈니스 로직에만 집중하여 블록체인 서비스를 만들수 있게 해줍니다. 블록체인과 루니버스의 활용현시점에서 블록체인 기술은 블록체인 인프라에 그 관심이 집중되었습니다. 이더리움, 이오스 등 계속해서 새로운 블록체인 메인넷들이 출시되었으며, 해당 메인넷 위에서 다양한 서비스가 운영되기 보다는 우수한 메인넷 자체를 개발하는 것에 전 세계의 관심이 집중되었습니다. 즉, 이제까지의 블록체인산업은 블록체인 인프라에 집중되었다고 볼 수 있습니다. 하지만, 과거 산업의 발전 행태를 볼 때 현 시점에서 가장 중요한 것은 바로 블록체인을 활용한 킬러앱의 출시가 블록체인 인프라의 발전방향을 결정짓는 다고 볼 수 있습니다. 가령 인터넷이 처음 나왔을때 인터넷 상의 전자 상거래 서비스 혹은 각종 게임의 발전이 인터넷 산업과 인프라의 발전을 가속화한 것처럼 블록체인 기술을 활용한 상용적인 서비스가 계속 생겨나야 블록체인 인프라도 그에 발맞추어 발전할 전망입니다. 블록체인에서의 게임 산업루니버스는 블록체인의 여러 산업방면에서도 게임 산업 에 상당한 관심을 가지고 있습니다. 현재 블록체인 기반의 게임산업의 규모는 빠르게 성장하고 있으며, 크게 다음과 같은 3가지 활용처가 존재합니다. 게임의 블록체인화 인게임 재화 ⇒ fungible token 아이템 경재 ⇒ non fungible token 게임의 규칙 ⇒ smart contract 이미 블록체인 기반의 다양한 게임들을 성공리에 운영되고 있는데, 게임회사 뿐 아니라 게임 스트리밍, 게임 마켓 등 다양한 게임 관련 산업분야가 성장하고 있습니다. 블록체인 게임 사례 eos 기반의 한 방치형 rpg 게임인게임 상에서 재화를 획들할 수 있고 이를 게임 내에서 다시 소비하는 방식으로 토큰 이코노미가 만들어짐 이더몬각 사이트를 10명의 유저가 호스트가 되어 공동 소유할 수 있고 일반 유저는 입장료를 내고 탐험하는 방식의 새로운 비즈니스 모델을 선보였으며, 입장료 중 90%는 호스트에게 돌아가고 나머지는 개발자에게 돌아가는 방식으로 운영 게임 스킨사용자와 디자이너가 각종 게임 스킨을 만들고 이를 여러 게임에서 사용 가능 =&gt; 게임 스킨은 조단위 시장을 형성 토너먼트 형 게임좋은 아이템을 구매해서 경기에서 승리하여 상금을 얻는다 =&gt; 게임을 통한 수익창출을 위한 기회 비용으로 아이템을 구매한다. 루니버스는 무엇을 해결하는가? 크립토 키티의 경우 메타마스크를 통해 로그인하면서 이탈되는 유저가 전체의 99%에 달할만큼 편리한 유저 인터페이스의 필요성이 대두되고 있습니다. 루니버스는 간편한 사용자 경험을 제공하여 손쉽게 블록체인 서비스를 이용할 수 있도록 할 것입니다. 또한, 기존의 메인넷에서 게임을 하기 위해 필요한 막대한 거래 비용을 게임산업 발전을 저해하고 있으며, 루니버스는 0에 가까운 트랜잭션 fee를 지향하여 서비스를 만들고 있으며, 거래 비용을 줄여 게임에 진입장벽을 낮추어 줍니다. 또 무엇을 제공하나요?기업 운영 투자자 네트워크 연계 올비트 상장 패스트 트랙 글로벌 마케팅 공동 PR 진행 및 지원 편리한 개발 프로세스 루니버스 이전의 개발 프로세스에서는 프라이빗 체인 구축 및 디앱개발 및 웹3 작성 및 배포등 일련의 과정에 몇달의 기간이 소요되지만 루니버스를 통한 개발 프로세스에서는 30분 내에 체인을 만들고 토큰을 발행할 수 있습니다. 체인 생성 및 토큰을 버튼 몇번으로 생성하고, 이를 rest api 를 호출함으로써 편리하게 개발이 가능합니다. 개발 프로세스 메인 체인 만들고 메인 토큰 발행 프로덕 체인 구축 메인 토큰과 매칭 되는 프로덕 토큰 발행 트랜잭션 정의 REST api 를 call 함으로써 서비스 구현 가상화폐 지갑 비트베리와 협업하여 안전하고 편리한 가상화폐 지갑을 제공합니다. 편리한 암호화폐 상장 Allbit Alliance Program ⇒ 루니버스를 이용하기 전의 플로우 토큰 경제 설계, 백서 검토 파운데이션 컨설팅 리갈 펀드 매칭 현재 암호화폐 거래소의 문제였던 과도한 리스팅 비용, 복잡한 절차, 리스팅 네트워킹, 리스팅 사후 관리(가격 방어, 거래량 확보) 를 해결해주고, 루니버스 이용하여 서비스를 개발하여 탈중앙화 거래소인 올비트와 협력하여 간편하게 리스팅이 가능합니다. 또한 올비트가 제공하는 머미넷, 비트 고수, cmt group, Dr. Node&amp;mainblock 등을 통해 리스팅 후의 마케팅 까지 지원합니다.","link":"/2018/11/10/두나무의-블록체인-개발-플랫폼-루니버스/"},{"title":"마케팅 강의 01. 마케팅의 기본 개념","text":"마케팅의 기본온라인 마케팅은 무엇이며 무엇을 목표로 하는가마케팅의 핵심적인 목적은 고객의 요구사항을 찾아내고 예측하여 이를 충족시켜 줌으로써 강한 고객관계를 구축하는 것이다.이는 마케팅이 단지 단기적인 매출을 올리는데에 초점을 맞추지 말고 장기적인 관점에서 고객이 정말 원하는 것이 무엇인지 끊임없이 고민하고 그것을 체워주는 것이 훌륭한 마케팅임을 말해준다.이러한 마케팅에서 고려해야 할 주요 변수는 가격, 프로모션, 장소, 제품 이며, 고객이 원하는 것을 명확하게 이해하기 위해 타겟이 되는 고객의 특성을 이해하는 것이 마케팅의 주요 성공요인 이라 할 수 있다. 마케팅 계획의 수립마케팅의 계획 수립은 크게 수요 분석, 경쟁사 분석, 마케팅 믹스 개발, 브랜딩 으로 이루어 진다.여기서 수요 및 경쟁사 분석 은 표적 시장에 대한 전략을 개발하고 구현하는 기초가 되며, 마케팅 믹스 는 표적 시장을 선정하는 데 이용되는 전술이다. 마지막으로 브랜딩 은 표적시장을 대상으로 제품이나 서비스의 인지도를 강화하는 중요한 요소이다. 수요 분석수요분석에 있어 핵심적인 사항은 먼저 제품의 표적 고객군을 규명 하는 것이다. 우리의 고객을 팔고자 하는 구체적인 타겟이 명확하게 정해지는 것은 사실 사업 이전에 시장에 대한 충분한 조사가 있었다면 이미 정해져 있을 것이다. 만약, 마케팅 전략을 수립하는 과정에서 타겟으로 하는 고객을 다시금 재고해야 할 필요가 있다면 여기서 명확한 타겟 고객을 설정해야 한다. 가령 AirBnb의 경우 타겟 고객군은 미국 내에서 몇 일 이내로 여행을 간 경우 호텔이 다 차서 묵을 곳을 구하는 고객이라는 매우 niche한 target을 가지고 시작하여 점차 넓은 범위로 확장해 나가는 전략을 사용했다. 이 타겟고객은 기업의 가치명제를 통해 니즈를 명확하게 해결 해 줄 수 있는 고객군이어야 한다. 타겟고객이 정해졌다면, 해당 고객군이 어떻게 인터넷을 사용하는 지 에 대한 조사가 이루어 져야 한다. 가령 18~33세의 개인들은 스마트폰과 태블릿 PC 등을 많이 사용는 특성을 보인다던가 혹은 구체적으로 사무직 직장인이 타겟이라면 직장인의 경우 많은 시간 데스크톱에서 업무를 보므로 PC를 많이 사용한다는 조사를 수행할 수 있다. 마지막 단계는 마케팅 캠페인을 위해 어떤 온라인 플랫폼을 사용할 것인지를 결정 한다. 가령 18~33세의 연령대를 고객으로 확보하려는 경우 모바일 앱을 통한 마케팅을 진행할 수 있다는 선택을 할 수 있다. 보다 구체적인 수요 분석을 위해서 고객들이 인터넷과 얼마나 친숙하고 인터넷 내에서 제품이나 서비스를 구매할 것인가에 대한 고민과 만약 장애요인이 있다면 무엇인가에 대한 고민 또한 필요하다. 경쟁사 분석경쟁사에 대해 잘 아는 것은 기업 전략 개발에 매우 중요하다. 경쟁사가 누구인지 또 그들이 공급하는 제품이나 서비스가 무엇이며 시장 점유율과 마케팅 전략이 무엇인지를 면밀히 분석하여 우리가 하려는 사업에 어떤 영향을 끼칠 것인가를 고민하여야 한다.경쟁사에 대한 대부분의 정보는 공급사 및 경쟁사의 실제 고객에게서 수집될 수 있으며, 경쟁사의 웹사이트를 분석하면 값진 정보들을 얻어낼 수 있다. 경쟁사에 대한 넓은 범위에서의 조사를 마쳤다면 경쟁사의 주요 성공요인들을 분석하고 우리가 가진 강점과 약점을 면밀하게 분석 하여 경쟁사 프로파일링 을 진행한다. 고객가치는 경쟁사의 제품이나 서비스와 비교적으로 정의되어야 하는데, 경쟁사 프로파일링을 통해 경쟁사의 강점과 약점을 명확히 파악한다면 이를 통해 우리는 시장에서 고객에게 전달하는 탁월한 기업가치가 무엇인지 명확하게 정의하고 고객에게 어필할 수 있다. 이 프로필은 경장사의 활동 배경, 재정 상태, 제품/서비스, 시장, 시설, 인력, 전략 등을 깊이있게 서술하여야 한다. 마케팅 믹스 개발마케팅 믹스란 기업이 목표시장에서 마케팅 목표를 달성하기 위해 사용하는 마케팅 도구들의 모음이며, 4P(Product, Pricing, Place, Promotion)라 부르는 마케팅의 의사결정을 하여야 한다. 먼저 _제품_ 은 최소한도의 성능을 제공하여야 한다. 최소한도의 성능이 제공되지 않는경우 다른 요소들이 우수하더라도 의미가 없다. 또한 브랜딩 을 통해 제품 자체가 가지는 고유한 마케팅 파워를 살리는 것이 좋다._가격_ 은 회사의 전반적인 비즈니스 계획과 연계되며 제품을 차별화 하고 이미지를 향상시키기 위한 수단이 된다. 적합한 가격 책정은 사업에 아주 중요한 요소일 뿐 아니라 마케팅에서의 경쟁력 혹은 약점이 될 수 있는 중요한 요소인 만큼 많은 마케팅 요소를 고려하여 합리적인 가격책정을 하여야 한다._장소_ 는 소비자의 시선을 끌며 구매하기가 쉽도록 좋은 유통 경로 혹은 장소를 차지하는 것이다. 많은 온라인 비즈니스의 경우 이러한 장소는 별도록 구축한 웹페이지가 되거나 혹은 온라인 경매 혹은 오픈 마켓 등이 이용된다. 하지만 대부분의 IT 서비스의 경우 제품이 홈페이지 내의 웹서비스인 경우가 많으므로 사실상 장소는 정해져 있다고 봐도 무방하다.프로모션 프로모션은 제품이나 서비스를 소비자에게 알리고 권유하여 구매를 자극할 목적으로 수행하는 모든 활동을 의미한다. 어떤 방식의 프로모션을 진행할지를 정하는 것은 마케팅 전략의 매우 큰 부분을 차지한다. 광고, 구전, 보도자료, 인센티브, 커미션 등의 프로모션 요소들이 있다. 브랜딩브랜드란 경쟁사의 제품과 구별하기 위해 부여하는 이름 혹은 용어 기호이다.즉, 브랜딩이란 소비자에게 부가가치를 제공하거나 부가가치가 있다고 인지하는 브랜드들을 창조하고 개발하는 프로세스를 뜻한다. 제품에 이름을 부여함으로써 고객에게 제품이 무엇인지를 명확하게 알릴 수 있으며, 회사와 제품의 독특한 측면을 나타내고, 회사의 목표가 드러나며 지적 자산을 보호하는 데에 도움이 되어야 한다.소비자가 수많은 제품들 사이에서 유의한 차이가 존재한다는 확신이 설 수 있어야 한다.AirBnb의 경우 숙소의 개념을 아주 친숙한 ‘집’으로 변모시켜, 세계 어디에서나 자신의 집처럼 편안하고 현지인처럼 생활을 할 수 있다는 새로운 브랜딩을 하고 있다. STP 마케팅STP 마케팅은 표적 시장을 겨냥한 마케팅 계획을 수립하기 위한 3단계 접근방법으로 Segmentaion, Targeting, Positioning의 단계로 나누어 진다.STP 전략은 고객의 욕구가 다양하다는 사실을 기반으로 많은 고객들을 세분하게 나누고 기업이 적합한 타겟 시장에 어떤 어프로치를 수행할 것인가를 결정한다. 먼저 시장 세분화 과정에서는 소비자를 최대한 디테일한 요소를 기반으로 세분화한다. 이 세분화의 항목은 인구 통계적 특성, 행동적 특성, 심리적 특성 과 같은 항목이 있다.소비자들이 어떤 행동을 하고 어떤 라이프스타일을 가지며 주요 관심사와 행동적 특성을 분석함으로써 소비자들을 최대한 세분화 한다. 다음 단계인 표적시장 선정 단계에서는 세분화한 시장 중에서 기업이 제공할 수 있는 제품과 서비스에 제일 큰 공감을 일으킬 집단을 선정한다. 선정의 요소에는 많은 복합적인 요소들이 포함되는데 내가 목표로 하는 시장의 규모와 성장률 그리고 다른 경쟁사가 동일한 표적 시장을 대상으로 마케팅을 하고 있지는 않은지, 또 만약 완벽히 동일한 타겟 집단에 다른 경쟁자가 있다면 기업이 경쟁사를 상대로 내세울 수 있는 핵심적인 경쟁력은 무엇인지를 살펴 신중하게 표적시장을 선정한다. 마지막 단계인 포지셔닝 단계에서는 기업이 타겟 고객군의 마음에 어떻게 자리잡을 것인가에 대한 전략을 세운다. 만약 다른 경쟁사가 있다면 그 경쟁사와 차별화된 기업만의 고유한 가치를 어필할 수 있다. 이러한 포지셔닝 전략은 브랜드 이미지에도 큰 영향을 주는데 사용자의 요구사항을 완벽하게 이해하고 충족시켜 줄 수 있다는 이미지를 고객에게 심어주어야 하며 이는 마케팅에서 매우 중요하다. 가령 애플 컴퓨터의 경우 사용자 PC 이므로 IBM 등 다른 경쟁사에 비해 훨씬 사용자 친화적인 컴퓨터라는 점을 내세우며 고객에게 접근했고, 모든 마케팅 전략을 이런 포지셔닝에 집중한 결과 많은 사람들에게 친근한 컴퓨터라는 확고한 포지셔닝을 할 수 있었고, 막강한 브랜드 파워를 가지게 되었다. 온라인 마케팅의 방법들바이럴 마케팅가장 전통적이고 바람직한 마케팅 방법은 바이럴 마케팅 이다. 소비자들 스스로 제품이나 서비스의 가치에 공감하여 자발적으로 다른 사람들에게 홍보를 하도록 하는 것은 단순히 마케팅 역량을 넘어 사업 아이템의 성공을 가로짓는 요소이다. 계속해서 많은 광고비를 지출하는 방법은 어디까지나 돈으로 수요를 사는 마케팅 방안이기에 지속가능한 마케팅 방법이 아니며, 이처럼 많은 사람들이 자발적으로 기업의 제품과 서비스를 알리도록 하는 것은 기업의 초기 성공의 필수불가결한 요소이다. 가령 현대 사회에서의 바이럴 마케팅은 어떤 의미에서 SNS를 통한 활발한 공유 혹은 해쉬태그(#)를 사용한 주제별 커뮤니티 형성도 같은 맥락이다.제품의 가치에 공감한 많은 사람들이 인종의 캠페인 활동 혹은 과시 및 정보전달의 목적으로 자발적으로 온라인 상으로 컨텐츠를 올리고 이러한 컨텐츠들은 제품의 인지도를 높이는 데에 아주 큰 기여를 한다. 일례로 AirBnb의 경우 #BelongAnyWhere, #LiveThere 등의 다양한 캠페인 활동을 통해 사람들이 대중 매체에서 흔히 볼 수 없는 이색적인 장소에 대한 호기심을 불러 일으키는 영상을 제잠함으로써 사람들이 그러한 장소에 머물고 싶은 욕구를 불러 일으키고 인지도를 높여 많은 사람들이 SNS를 통해서 스스로 컨텐츠를 퍼트리도록 유도한다.때문에, AirBnb는 SNS상에서 사람들의 주의를 끌기 위한 수준 높은 사진 이미지 혹은 영상 컨텐츠에 각별한 주의를 기울이며 이는 큰 매출 증대 효과를 불러 일으켰다. 현대에는 이러한 바이럴 마케팅에 큰 역할을 하는 계층으로 인플루언서 의 예를 들 수 있다.이러한 인플루언서들은 유투브, 페이스북 등의 다양한 대중 매체에서 대중을 위한 다양한 컨텐츠를 생산하는 계층으로 이들에 대한 높은 신뢰도가 이미 형성되어 있기 때문에, 해당 인플루언서가 제품을 이용하는 것을 알리는 것 만으로도 큰 마케팅 효과를 거둘 수 있다.가령 AirBnb의 경우 탬즈 강에서의 수상 가옥을 호스트함으로써 세계 각국의 수많은 매체들이 이 가옥에 대한 컨텐츠를 생산해내었다. 수십억 것의 소셜 공감이 이루어 졌으며 수만건의 페이지로 번역되어 아주 큰 광고효과를 거두었을 뿐 아니라, 가수 머라이어 캐리가 인스타 그램에 올린 사진은 대중에게 큰 인상을 남겼다. 제휴 마케팅 / 파트너쉽많은 B2B 기업들의 사례를 살펴보면 제휴 마케팅 을 통해 초기에 성공적인 마케팅을 이룩해 내는 경우를 볼 수 있다. 소비자를 대상으로 하는 마케팅에 비해 이러한 제휴 마케팅은 제휴를 한 업체의 기존의 브랜드 파워에 힘입어 한번에 신뢰도를 확보할 수 있으며, 이익관계가 공유되어 제휴 업체의 자발적인 마케팅 유도 또한 이끌어 낼 수 있다. 또한 초기에 불특정 다수로 한 마케팅에 비해 제휴 마케팅의 경우 제휴를 맺고자 하는 명확한 기업이 존재하기 때문에 보다 체계적이고 추진력 있게 초기 마케팅을 시작할 수 있으며 이는 대표자의 역량이 절대적으로 필요하다. 에어비앤비의 경우 항공사인 KLM Royal Dutch Airline, 프랑스 정부 등 많은 단체와 제휴를 맺어 마케팅을 하고 있다.양 사의 가치를 융합하여 새로운 융합상품을 만들어 냄으로써 고객에게 새로운 가치를 전달한다. 소셜 마케팅대부분의 it 기업에게 SNS는 매우 중요한 채널이다.고객과 직접적으로 소통하고 바이럴이 가장 잘 퍼지는 공간인 만큼 최대한 많은 SNS 채널을 운용하는 것이 좋다.또한, 사회적 이슈가 있을 때 마다 시기에 적합한 social content를 제작하여 이슈화 시키는 것은 마케팅에서 매우 중요하다.가령 다가오는 크리스마스를 타겟으로 하여 그에 적합한 상품을 업로드 한다던가 혹은 색다른 캠페인을 진행하여 사람들의 폭발적인 호응을 얻을 수 있다. 또 다른 방법은 ‘광고처럼 안 보이는 광고’이다.일례로 앱 다운로드 url을 적어두었을 때 보다 적어두지 않았을 때 다운로드 수치가 더 높았다.광고에 대한 피로도가 높아진 요즘은 광고라는 사실을 숨긴 자연스러운 광고가 유행이다.또 그 자체로 ‘재미’가 있는 광고라면 더 할 나위가 없다. 검색광고최근에는 다양한 종류의 온라인 광고 기법들이 도입되고 있다.이메일, 디스플레이 광고 처럼 기존에도 있던 마케팅 방법 외로도, AI 기술을 활용한 문맥광고를 하거나, 검색엔진을 통한 검색광고 등이 있다. 문맥광고대표적인 it 기업인 구글에서는 이러한 문맥광고료로 아주 큰 효과를 보고 있다.관심이 있어할 만할 고객이 보고 있는 페이지의 특정 부분에 광고를 삽입함으로써 계속해서 사용자의 주의를 활기시킨다.AirBnb는 이러한 문맥광고에 아름다운 숙소의 이미지들을 지속적으로 노출시켜 구매를 유도하고 있다.","link":"/2017/12/13/마케팅의-기본-개념/"},{"title":"운영체제 | CPU 스케줄링","text":"CPU 스케줄링이란 무엇인가? 프로세스는 어떤 식으로 동작하나요? CPU 스케줄링은 누가 수행하나요? 스케줄링의 방법들 누가 프로세스에게 제어권을 주나요? 스케줄링의 기준 스케줄링 알고리즘 선입 선처리 스케줄링 최단 작업 우선 스케줄링 우선 순위 스케줄링 라운드 로빈 스케줄링 다단계 큐 스케줄링 다단계 피드백 큐 스케줄링 다중 처리기 스케줄링 다중 처리기 시스템에 대한 접근방법 처리기 친화성 부하 균등화 대칭적 다중 스레딩(SMT: Symmetric Multi-Threading) 스레드 스케줄링 CPU 스케줄링이란 무엇인가?단일 처리기 시스템에서는 한 순간에 오직 하나의 프로세스만 실행이 될 수 있었지만 다중 처리기 시스템에서는 어느 한 순간에 다수의 프로세스들이 메모리 내에 위치하게 되고 여러개의 CPU가 수많은 프로세스들을 처리하며 복잡하게 움직입니다. 운영체제는 CPU에게 여러 프로세스들을 계속해서 배분하고 교환해 줍니다. 가령 하나의 프로세스가 대기해야 할 때 다른 프로세스가 CPU 사용을 양도받아 CPU가 쉬지않고 작업을 처리할 수 있게 해 줍니다. 모든 컴퓨터 자원들은 사용되기 전에 스케줄링 되며, 따라서 CPU 스케줄리은 운영체제 설계의 핵심이라고 볼 수 있습니다. 프로세스는 어떤 식으로 동작하나요?우리는 운영체제가 CPU에게 다수의 프로세스들을 효과적으로 배분해 줌을 배웠습니다.CPU가 프로세스를 어떻게 스케줄링 해 주는지 배우기 전에 먼저 프로세스가 CPU에서 어떻게 동작하는지를 살펴봅시다. 먼저, 프로세스의 실행은 CPU 실행과 입출력 대기의 사이클로 구성되며, CPU의 실행은 CPU 버스트 로 부터 시작되고, 입출력은 입출력 버스트 로 부터 시작이 됩니다. 이렇게 CPU 버스트와 입출력 버스트가 교대로 발생하면서 프로세스가 진행이 됩니다. 프로그램 마다 이러한 CPU 버스트와 입출력 버스트의 시간 분포가 매우 상이합니다. 가령 입출력이 중심이 되는 상대적으로 짧은 CPU 버스트 시간을 가질 것이며, CPU 중심 프로그램은 상대적으로 긴 CPU 버스트 시간을 가지게 되며, 이러한 버스트의 분포는 CPU 스케줄링 알고리즘을 선택하는 데에 있어 매우 중요한 역할 을 합니다. CPU 스케줄링은 누가 수행하나요?CPU 스케줄링은 CPU 스케줄러(단기 스케줄러)에 의해 수행되며, CPU가 유휴 상태가 될 때마다 CPU 스케줄러는 준비완료 큐에 있는 프로세스 중 하나를 선택하여 실행합니다. 여기서 준비완료 큐 는 반드시 선입선출(FIFO) 방식으로 동작하지 않아도 되며 이제까지 배운 다양한 자료구조들을 통해 구현될 수 있습니다. 예를 들어 선입선출 큐, 우선순위 큐, 트리 등 다양한 자료 구조를 통해 구현되어집니다. 개념적으로 볼 때 준비완료 큐에 있는 모든 프로세스들은 CPU에서 실행될 기회를 기다리면 대기하고 있으며, 큐에 있는 레코드들은 일반적으로 프로세스들의 프로세스 제어 블록(PCB) 입니다. 스케줄링의 방법들CPU 스케줄링 결정은 다음의 네 가지 상황에서 발생할 수 있다. 한 프로세스가 실행 상태에서 대기 상태로 전활될 때 프로세스가 실행 상태에서 준비완료 상태로 전활될 때 프로세스가 대기 상태에서 준비완료 상태로 전환될 때 프로세스가 종료할 때 위의 1, 4의 경우 스케줄링 면에서는 선택의 여지가 없고 반드시 선택되어야 하며, 이러한 상황에서 스케줄링이 발생할 경우 우리는 이러한 스케줄링 방법은 비선점 또는 협조적 스케줄링이라고 말합니다. 그렇지 않으면 선점 스케줄링 이라고 합니다. 현대의 운영체제들은 이러한 선점 스케줄링 을 기반으로 하지만, 선점 스케줄링은 공유 자료에 대한 접근을 조정하는 데 필요한 비용을 발생시킵니다. 가령 프로세스 A가 쓰기 작업을 하는 중에 프로세스 B가 A 가 쓰고 있는 파일을 읽어들이는 경우를 생각해 보면, A 라는 프로세스가 컴퓨팅 자원을 선점 하고 있었으므로 프로세스 B가 이 자료에 접근을 하지 못하도록 막아야 할 필요가 생기게 되는 됩니다. 누가 프로세스에게 제어권을 주나요?디스패처 는 CPU의 제어를 단기 스케줄러가 선택한 프로세스에게 넘겨주는 모듈이며 다음과 같은 작업을 수행합니다. 문맥을 교환하는 일 사용자 모드로 전환하는 일 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동하는 일 스케줄링의 기준위에서는 CPU 스케줄링이 무엇이고 어떤 방식으로 수행이 되는지를 알아보았습니다.이제는 실제로 스케줄링 알고리즘을 설계하려고 할 때, 과연 어떤 기준에 따라 프로세스들을 선택하고 스케줄링을 해야 할까요?다음에는 스케줄링 알고리즘을 비교하기 위한 여러 기준이 제시되며, 이러한 특성에 따라 최선의 알고리즘을 결정하는 데 큰 차이가 있습니다. CPU 이용률 처리량 총처리 시간 대기 시간 응답 시간 스케줄링의 기준을 간단히 말하자면 CPU 이용률과 처리량을 최대화 하고, 총처리 시간, 대기시간, 응답시간을 최소화 하는 것에 있습니다. 스케줄링 알고리즘실제로 프로세스들을 스케줄링 하려고 할때 쓰이는 스케줄링 알고리즘 에는 무엇이 있을까요?다양한 스케줄링 알고리즘들을 소개합니다. 선입 선처리 스케줄링가장 간단한 CPU 스케줄링 기법으로, 먼저 들어온 프로세스가 CPU를 할당받는 방식입니다. 최단 작업 우선 스케줄링SJF(Shortest Job First) 알고리즘의 대표적인 예로, 이 알고리즘은 각 프로세스에 CPU 버스트 길이를 연관시켜, 짧은 CPU 버스트를 가지는 프로세스에게 우선적으로 CPU를 할당해 주는 방식입니다. 우선 순위 스케줄링각 프로세스 마다 우선순위를 부여하고 우선순위가 높은 프로세스에게 CPU를 먼저 할당하는 알고리즘 입니다.프로세스가 준비완료 큐에 도착하면, 새로 도착한 프로세스와 현재 실행중인 프로세스의 우선순위를 비교하여 높은 우선순위를 가진 프로세스 에게 CPU를 할당해 줍니다. 하지만, 이 알고리즘은 무한 봉쇄 또는 기아상태(starvation) 에 빠질 수 있는 문제점을 가지고 있습니다.예를 들어 낮은 우선순위를 가진 프로세스들으 무한정 대기완료 큐에서 대기하는 경우가 발생하게 되는데 이러한 경우에 대한 해결방안으로 노화 알고리즘을 포함시켜 오랫동안 시스템에서 대기한 프로세스들의 우선순위를 점진적으로 올려주는 방식입니다. 따라서 오랫동안 대기완료 큐에서 머문 프로세스들은 자연스레 우선순위가 올라가게 되고 최종에는 CPU를 할당받을 수 있게 됩니다. 라운드 로빈 스케줄링라운드 로빈 알고리즘은 특별히 시분할 시스템을 위해 설계된 알고리즘 입니다. 시분할 알고리즘에서는 각 프로세스가 일정 구간으로 나눈 시간을 계속해서 배정받으면서 CPU 가 같은 시간동안 프로세스들을 돌면서 작업을 처리하게 됩니다. 즉, CPU 스케줄러는 준비완류 큐를 돌면서 한번에 한 프로세스에게 한 번의 시간 할당량 동안 CPU를 할당합니다. 이러한 라운드 로빈 큐를 위해서 우리는 준비완료 규를 선입선출 큐로 유지합니다. 다단계 큐 스케줄링다단계 피드백 큐 스케줄링다중 처리기 스케줄링위의 모든 방법론들은 단일 처리기 시스템을 스케줄 하는 문제에 초점을 두고 배워보았다. 이번 장에서는 여러 개의 CPU가 있는 다중 처리기 시스템에서의 CPU 스케줄리에 대해 배워보도록 합시다. 다중 처리기 시스템에 대한 접근방법다중처리기 시스템의 CPU 스케줄링의 한가지 방법은 비대칭 다중처리(Asymmetric Multi-processing) 입니다. 비대칭 다중처리란 주 서버라는 하나의 처리기가 나머지 모든 처리기에 대한 통제권을 가지고 모든 스케줄링을 결정하고 입출력 처리 그리고 다른 시스템의 활동을 처리하게 하는 것 입니다. 이 방법은 오직 하나의 처리기 에서만 자료구조에 접근하므로 정보의 공유가 필요 없다는 장점이 있습니다. 다른 해결방안은 대칭 다중처리(SMP: Symmetric Multi-processing) 입니다. 대칭 다중처리 에서는 모든 처리기의 스케줄러가 준비완료 큐를 검사해서 실행할 프로세스를 선택함으로써 진행됩니다. 여러 개의 처리기가 공통의 자료구조를 처리하려고 한다면 문제가 발생합니다. 때문에 각 처리기가 공동 자료구조를 접근하고 갱신하려고 한다면 스케줄러가 신중하게 프로그램 되어야 합니다. 처리기 친화성위에 설명한 대칭 다중 처리기를 살펴보면 각 처리기가 독자적으로 프로세스를 처리하므로 특정 처리기에서 다른 처리기로 프로세스가 이동 하면 각 처리기의 캐시에 해당 프로세스의 정보가 적재되게 될 것입니다. 그렇게 된다면 전에 있던 처리기의 캐시에 있던 정보가 삭제되고 이동한 처리기의 캐시가 체워져야 하는데 이는 큰 비용을 초래합니다. 때문에 대부분의 SMP 시스템은 한 처리기에서 다른 처리기로의 이주를 피하고 대신 같은 처리기에서 프로세스를 실행시키려고 하는데 이러한 성질을 처리기 친화성 이라고 합니다. 즉, 프로세스가 현재 실행 중인 처리기에 친화성을 가지는 것을 말합니다. 부하 균등화다중 처리기 스케줄링 에서는 처리기가 여러개 이기 때문에 각각의 처리기가 균등하게 사용되는 것이 매우 중요합니다. 이렇게 각 처리기에 부하가 잘 분산되는 것은 부하 균등화 라고 부릅니다. 공용 실행 큐만 있는 시스템 에서는 한 처리기가 쉬게 되면 바로 공용 큐에서 프로세스를 불러와 실행하므로 문제가 없습니다. 하지만 현대의 대부분의 컴퓨터들은 자신만의 전용 큐 를 가지고 있기 때문에 각 처리기가 별도의 큐에서 프로세스를 가져와서 실행하게 됩니다. 이렇게 자신만의 전용 큐를 가지고 있는 처리기의 경우 push 이주(migration) 과 pulll 이주(migration) 을 통해 부하를 분산합니다. 푸시 이주의 경우는 부하가 높은 처리기가 프로세스를 다른 처리기로 넘기는 것을 말하며, pull 이주의 경우는 한가한 처리기가 바쁜 처리기의 프로세스를 가져오는 것을 의미합니다. 대칭적 다중 스레딩(SMT: Symmetric Multi-Threading)SMP 시스템은 다수의 물리 처리기를 제공함으로써 다수의 스레드가 동시에 실행되게 합니다. 여기서 SMT의 착상은 동일한 처리기 상에서 여러 개의 논리 처리기 를 생성하는 것입니다. 각 논리 처리기는 구조 상태 를 가지게 되며 이때 인터럽트가 물리처리기가 아닌 논리적 처리기에 전달되고 처리되는 것을 의미합니다. 스레드 스케줄링스레드는 경량의 프로세스라고 일컬어 지며, CPU 가 처리하는 task의 최소한의 단위가 된다. 이런한 thread 와 process 의 차이는 바로 공유하는 메모리 공간의 차이인데, process 는 stack 과 heap 을 모두 공유하지 않기 때문에 서로 다른 프로세스를 메모리 공간을 공유하지 않으며, 때문에 여러 프로세스 사이의 통신은 매우 어렵다. 반면, thread 는 stack 은 공유하지 않고 따로 존재하며 heap 는 공유하기 때문에 같은 메모리 공간을 공유한다. 즉, 각 thread 는 공통된 변수 및 메모리 공간에 접근이 가능하기 때문에 쉽게 통신할 수 있으나 다른 작업 que 를 가지기 때문에 병렬적으로 처리되어 병렬성을 가질 수 있다. 여러개의 thread 는 CPU 에 할당되는 시점에 CPU affinity 를 가지고 할당되기 때문에, 가급적 하나의 CPU 에서 처리된다.","link":"/2018/04/03/운영체제-cpu-스케줄링/"},{"title":"운영체제 | 운영체제란 무엇인가?","text":"운영체제가 하는 일은 무엇인가? 컴퓨터 시스템은 어떻게 구성되어 있는가? 컴퓨터 시스템의 동작 저장 장치의 구조 입출력 구조 단일 처리기 시스템에서 다중 처리기 시스템으로 단일 처리기 시스템 운영체제의 구조 운영체제는 어떤 방식으로 작업을 처리하는가? 프로세스 관리 메모리 관리 저장 장치 관리 보호와 보안 분산 시스템 운영체제가 하는 일은 무엇인가?운영체제란 컴퓨터 하드웨어를 관리하는 프로그램입니다.운영체제는 사용자의 관점에서 혹은 시스템 적인 관점에서 보는가에 따라 그 존재 목적이 달리 설명될 수 있습니다. 사용자의 관점에서의 운영체제는 바로 한낱 고철덩어리에 불과한 컴퓨터를 사람이 사용하기 쉽게 여러가지 일들을 수행해 주는 역할을 한다고 볼 수 있다.이 경우 운영체제는 주로 사용의 편리와 자원의 이용 간에 적절히 조화를 이루도록 설계된다. 시스템의 관점에서 운영체제는 하드웨어와 가장 밀접한 프로그램이라고 볼 수 있다. 컴퓨터 시스템은 특정 문제를 해결하기 위해 필요한 여러가지 자원들을 사용하는데(가령 CPU 시간, 메모리 공간, 파일 저장 공간, 입출력 장치 등) 운영체제는 이러한 자원의 관리자로써 동작 하여 자원 할당자 역할을 수행한다. 결과적으로, 운영체제를 명확히 정의하는 것은 매우 어렵지만 컴퓨터라는 순수 하드웨어를 보다 쉽게 사용하기 위한 다양한 응용 프로그램들을 원활하게 동작시키기 위해 입출력 장치의 통제와 같은 공통적인 연산과 CPU, 메모리 공간 등의 컴퓨터 자원을 제어하고 할당하는 기능을 하는 하나의 소프트웨어라고 정의할 수 있을 것 같다. 또한, 운영체제는 컴퓨터에서 항상 실행되는 프로그램(일반적으로 커널)으로 운영체제를 제외한 다른 모든 프로그램은 응용 프로그램으로 부른다. 컴퓨터 시스템은 어떻게 구성되어 있는가?컴퓨터 시스템의 동작을 배우기 전에 컴퓨터 시스템의 구조에 대해 간략하게 알아봅시다. 컴퓨터 시스템의 동작현대의 컴퓨터 시스템은 공유 메모리에 대한 접근을 제공하는 공통 버스를 통해 연결된 여러 개의 장치 제어기 와 하나 이상의 CPU 로 구성되어 있다. 각 장치 제어기는 특정 장치(가령 디스크 드라이브, 오디오 장치, 비디오 디스플레이 등)를 관리 하며, CPU와 장치 제어기는 메모리 사이클을 얻기 위해 경쟁하면서 병행 실행될 수 있다. 컴퓨터를 구동시킬 때는 가장 먼저 흔히 펌웨어 로 알려져 있는 컴퓨터 내의 읽기 전용 메모리(ROM)에 저장된 부트스트랩 프로그램 을 실행한다.부트스트랩 프로그램은 CPU 레지스터로 부터 장치 제어기, 메모리 내용 등을 포함한 시스템의 모든 면을 초기화 하고 운영체제의 커널을 찾아 메모리에 적재한다.적재가 완료되면 운영체제는 init과 같은 초기 프로세스를 동작하고 사건이 발생하기를 기다린다. 기본적으로 운영체제는 이렇게 사건을 기반으로 동작하게 되는데, 이러한 사건의 발생 사실을 인터럽트 에 의해 통보받을 수 있다.하드웨어는 언제든지 시스템 버스 를 통해 인터럽트를 발생시킬 수 있고, 소프트웨어는 시스템 호출 을 통해 인터럽트를 발생시킬 수 있다. 인터럽트가 발생되면 적절한 서비스 루틴으로 전달하고 이 루틴은 이어 인터럽트 고유의 핸들러를 호출한다. 저장 장치의 구조컴퓨터가 프로그램을 실행하기 위해서는 프로그램이 반드시 주 메모리(RAM) 에 있어야 한다.컴퓨터가 명령어를 실행한다는 것은 이 메모리로 부터 레지스터로 워드를 옮기는 적재(load) 과정을 통해 이루어 지며, 적재된 명령어는 명령 레지스터에 저장되고 명령이 해독되어 메모리에서 피연산자를 인출하여 내부 레지스터에 저장되도록 유발할 수 있다. 여기서 메모리 장치는 단지 연속적인 메모리 주소만을 인식하며 메모리는 주소값의 구체적인 생김새 등에는 관계없이 단지 주소값을 저장만 하고 있다. 이상적으로는 프로그램과 데이터가 주 메모리 안에 영구히 존재한다면 좋지만, 메모리는 용량이 너무 작고 전원이 공급되지 않으면 내용을 잃어버리는 휘발성 저장장치이기 때문에 반드시 보조 저장장치에 프로그램과 데이터를 보관해야 한다. 이러한 보조 저장장치로는 주로 자기 디스크 등이 쓰인다. 이러한 저장 장치의 구조는 하나의 계층으로 구성되며 저장 장치 구조의 최상단인 레지스터 부터 캐시, 주 메모리 순으로 내려 가면서 가격은 저렴해 지고 속도는 느려지는 피라미드형 구조를 보인다. 입출력 구조컴퓨터에 입력을 하고 또 출력 값을 받아오기 위해 다양한 입출력 장치들이 연결될 수 있으며, 범용 컴퓨터 시스템은 공통 버스에 의해 연결된 여러 개의 장치 제어기와 CPU 들로 구성된다.장치 제어기는 자신이 제어하는 주변장치와 자신의 로컬 버퍼 저장장치 사이의 데이터 전송을 담당하며, 통상적으로 운영체제는 장치 제어기 마다 장치 드라이버 를 가지고 있는데, 이 장치 드라이버는 장치 제어기의 동작을 이해하고 운영체제의 다른 부분에게 장치에 대한 일관된 인터페이스를 제공한다. 장치-&gt;장치 제어기-&gt;장치 드라이버-&gt;운영 체제로 이어지는 입출력의 흐름은 인터럽트 를 기반으로 이루어진다. 먼저, 장치 제어기는 취할 동작을 결정하고 장치에 연산이 완료되었으면 인터럽트를 이용하여 장치 드라이버에 통보한다. 그러면 장치 드라이버는 제어를 운영체제에게 반환하는 방식이다. 하지만 이러한 인터럽트 구동방식은 대량의 데이터를 전송하는 데에는 높은 오버헤드를 초래하였으며, 이를 해결하기 위해 직접 메모리 접근(DMA) 장치가 사용된다. 이를 통해 장치 제어기는 CPU의 개입 없이 메모리로 부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송한다. 즉, 장치 제어기가 전송 작업을 실행하고 있는 동안 CPU는 다른 작업을 실행할 수 있다. 단일 처리기 시스템에서 다중 처리기 시스템으로컴퓨터 시스템은 사용된 범용 처리기(CPU)의 개수에 따라 단일 처리기 시스템 과 다중 처리기 시스템 으로 나누어 집니다.하나의 CPU를 가지는 경우를 단일 처리기 시스템, 1개 이상의 CPU를 가지는 컴퓨터 시스템의 경우를 다중 처리기 시스템이라고 합니다. 하나의 CPU를 가질 때 보다 여러개의 CPU를 가지면 무엇이 좋을까요? 먼저, 시스템의 처리량이 증가 합니다.여러 개의 CPU를 가지게 되면 컴퓨터가 여러개의 일들을 동시에 처리할 수 있기 때문에 같은 시간동안 많은 양을 처리하게 되어 시스템의 처리량이 증가합니다. 비용이 절감됩니다.컴퓨터 하나에는 많은 주변 장치, 저장 장치, 전원 장치 등이 필요합니다.5대의 하나의 CPU를 사용하는 컴퓨터를 제작하는 것 보다 5개의 CPU를 가진 컴퓨터 한대를 제작하는 것이 많은 디바이스와 리소스를 공유해서 이용하기 때문에 규모의 경제 가 나타나고 저렴한 비용으로 시스템을 만들 수 있습니다. 믿을 수 있습니다. 즉, 신뢰도가 올라갑니다.CPU 하나가 고장나더라고 시스템이 정지하지 않고 살아남은 하드웨어 수준에 비례하여 지속적으로 서비스가 동작하는 것은 우아한 퇴보 라고 합니다.어떤 시스템은 하나의 구성요소의 고장에도 불구하고 시스템을 동작할 수 있기에 결함 허용 적이라고 불리며, 다중 처리기 시스템은 하나의 CPU가 고장나도 안정적으로 시스템이 동작하므로 단일 처리기 시스템에 비해 신뢰도가 높은 시스템을 구축할 수 있습니다. 이러한 다중 처리 시스템의 경우 각 처리기에 일이 할당되는 방식에 따라 비대칭적 다중 처리 와 대칭적 다중 처리 로 구분되는데, 비대칭적 다중 처리의 경우 하나의 주 처리기가 시스템을 제어하고 다른 처리기들이 복종하는 시스템이며, 대칭적 다중 처리의 경우 모든 처리기가 동등한 업무를 수행하는 방식이며 현대에는 대부분 대칭적 다중 처리가 이용된다. 단일 처리기 시스템하나의 주 CPU를 사용하는 시스템으로 운영체제의 구조컴퓨터 시스템의 구성과 구조를 알아 보았으므로 이제는 본격적으로 운영체제에 대해 알아 보겠습니다.운영체제의 가장 중요한 측면은 다중 프로그램(multi program)을 할 수 있는 능력입니다. 만약, 한명의 사용자가 컴퓨터를 사용한다면 아무리 노력해도 컴퓨터를 효과적으로 사용하여 모든 처리기를 바쁘게 유지시킬 수 없을 겁니다. CPU가 잠시라도 쉬면 서둘러 다른 업무를 시켜서 쉬지않고 일을 하도록 하는 다중 프로그래밍 은 CPU가 항상 하나의 작업을 수행하도록 조정함으로써 CPU의 이용률을 높여줍니다. 이러한 다중 프로그래밍의 기본적인 동작 원리는 다음과 같습니다.먼저 한 번에 여러 작업을 메모리에 적재하고, 운영체제는 메모리에 있는 작업 중 하나를 선택해서 실행합니다. 만약 이 작업이 어떤 일을 기다려야 한다면 CPU는 다른 작업으로 전환하여 다른 작업을 진행합니다. 이러한 다중 프로그래밍 시스템은 시스템 자원을 효율적으로 이용할 환경을 제공하지만 사용자와 컴퓨터 시스템이 상호작용을 할 수는 없는데, 이를 확장한 시분할(multi tasking) 을 통해 이를 해결할 수 있습니다. 시분할 시스템에서는 CPU가 다수의 작업을 서로 교대로 실행하지만 매우 빈번하게 교대를 일으킴으로써 프로그램이 동작하는 동안 사용자와 상호작용이 가능해 지기에, 시분할 프로그램은 대화식 혹은 hands on(실제 조작 가능한) 컴퓨터 시스템을 필요로 하며, 각 사용자에게 시분할 되는 컴퓨터의 작은 부분을 제공하기 위해 CPU 스케줄링과 다중 프로그래밍을 사용합니다. 시분할과 다중 프로그래밍 운영체제에서는 메모리에 여러 작업이 동시에 유지되어야 하는데, 일반적으로 주 기억장치(RAM)은 사이즈가 너무 작기 때문에 메모리에 들어가지 못한 작업들을 디스크의 작업 풀 에 보관된다. 이런 작업 풀에서 어떤 프로그램을 메모리에 적재할 지 선택하는 것을 CPU 스케줄링 이라고 한다. 또 다른 방법 중 하나는 가상 메모리 를 이용하는 것이다. 이것은 프로그램의 일부만이 메모리에 존재해도 작업을 실행을 허용하는 개념이기에, 프로그램 전체가 주 메모리에 적재되지 않아도 프로그램이 시작되고, 또 주 메모리의 전체 사이즈보다 큰 규모의 프로그램도 실행 할 수 있게 해 주는 중요한 개념이다. 이런 가상 메모리 는 주 메모리를 크고 균등한 저장장치의 배열로 추상화하여 사용자에게 보이는 논리 메모리 를 실제 물리 메모리로부터 분리시켜 주며, 이를 통해 프로그래머를 메모리 저장장치의 한계로부터 자유롭게 해 준다. 운영체제는 어떤 방식으로 작업을 처리하는가?현대의 운영체제는 인터럽트 구동식 으로 무언가 일이 일어나야만 동작을 한다. 사건은 트랩 혹은 인터럽트에 의해 발생하며 여기서 트랩 이란 오류 혹으 사용자 프로그램의 운영체제 서비스 실행 요청에 의해 유발되는 소프트웨어의 실행에 의해 생성된 인터럽트이다. 때문에 운영체제는 수많은 인터럽트들을 계속해서 처리해야 하며, 이중 하나만 잘못되어도 시스템이 정지한다면 그 시스템은 매우 불완전하다고 볼 수 있다.올바르게 설계된 운영체제는 잘못된 또는 악의적인 프로그램이 부정확하게 실행되지 않도록 보장해야 한다. 이렇게 안정성 있는 운영체제를 위해 운영체제 내에는 다양한 안정 장치들이 있는데 그중 하나가 이중 동작 모드 이다.이중 동작 모드란 운영체제의 적절한 동작을 보장하기 위해서 운영체제 코드와 사용자가 작성한 코드의 실행을 구분하는 것이다. 이렇게 구분된 각각의 명령은 독립된 동작모드인 사용자 모드 와 커널 모드 혹은 특권 모드 로 나뉘어 실행되게 된다. 만약 트랩 이나 인터럽트 가 발생할 때마다 하드웨어는 사용자 모드에서 커널 모드로 전환한다. 또다른 안전장치는 타이머 인데, 이는 사용자의 프로그램이 무한루프에 빠져 동작하지 않게 되어 운영체제로 통제권이 돌아오지 않는 경우를 막기 위해 특정 시간이 지나면 제어가 자동으로 운영체제로 넘어가게 하는 기능이다.타이머가 인터럽트를 발생시키면 제어는 자동적으로 운영체제로 넘어가게 된다. 프로세스 관리실행중인 프로그램을 프로세스 라 하며, 프로세스가 끝나면 운영체제는 재사용 할 수 있는 자원을 회수하게 된다.여기서 프로그램 자체는 프로세스 가 아니다. 하나의 프로그램은 디스크에 저장된 파일의 내용과 같이 수동적인 개체인 반면, 프로세스는 다음 실행할 명령을 지정하는 프로그램 카운터 를 가진 능동적인 개체이다.운영체제는 프로세스 관리와 관련하여 다음과 같은 활동을 수행한다. 사용자 프로세스와 시스템 프로세스의 생성과 제거 프로세스의 일시 중지와 재싱행 프로세스 동기화를 위한 기법 제공 프로세스 통신을 위한 기법 제공 메모리 관리메모리는 컴퓨터 시스템에서 매우 중요한 부분이며, 운영체제는 이러한 메모리를 관리하며 다음과 같은 일을 담당한다. 현재 메모리의 어느 부분이 사용되고 있으며, 누구에 의해 사용되고 있는지를 추적 어떤 프로세스들을 메모리에 적재할 것이며 제거할 것인가? 메모리 공간을 할당하고 회수 저장 장치 관리보호와 보안분산 시스템","link":"/2018/04/02/운영체제-운영체제란-무엇인가/"},{"title":"운영체제 | 가상 메모리","text":"가상 메모리는 무엇이며, 왜 사용하는가? 요구 페이징이란? 요구 페이징이란? 요구 페이징의 성능 페이지 교체 페이지 교체의 필요성 페이지 교체의 동작 원리 선입선출 페이지 교체(FIFO Page Replacement) 최적 페이지 교체(Optimal Page Replacement) LRU 페이지 교체(LRU Page Replacement) 가상 메모리는 무엇이며, 왜 사용하는가?가상 메모리란 어떤 프로레스를 실행할 때 프로세스 전체가 메모리에 적재되지 않고도 실행이 가능 하도록 하는 기법입니다. 좀 더 나아가면 어떤 프로세스가 차지하는 메모리가 전체 메모리 용량보다 크더라도 지금 현재 필요한 부분만 메모리에 적재 되면 실행이 가능하기 때문에 물리 메모리 용량을 초과하는 프로그램도 동작 시킬 수 있는 큰 장점이 있습니다. 가상 메모리는 실제의 물리 메모리의 개념과 사용자의 논리 메모리의 개념을 분리 합니다. 좀 더 쉽게 말하자면 원래의 컴퓨터의 메모리란 일반적으로 실제 존재하는 물리적인 메모리 만을 의미합니다. 하지만 이러한 물리적인 메모리를 보다 효율적으로 사용 하기 위해서 프로그래머는 가상 메모리 의 개념을 만들게 되었고, 이런 가상 메모리는 다소 복잡하게 구성되고 접근이 어려운 물리 메모리를 가상으로 재구성 하여 엄청나게 큰 배열로 추상화 시켜줍니다. 따라서 프로그래머는 물리 메모리를 신경쓰지 않고 가상의 메모리만을 신경 쓰면서 프로그래밍 을 하게 되어 보다 편리해 진 측면도 존재합니다. 여기서 말하는 가상 메모리 를 프로세스가 차지하는 공간의 측면에서 가상 주소 공간 이라고 부르며, 보다 정확히는 그 프로세스가 메모리에 저장되는 논리적인 모습을 말합니다. 앞의 내용에서 다루었듯이 실제 물리 메모리는 페이지 프레임 들로 구성되며, 논리적인 페이지를 물리적인 페이지 프레임으로 사상하는 것은 메모리 관리 장치(Memory Management Unit) 에서 담당합니다. 가상 메모리를 사용함에 따른 또 다른 장점은 파일이나 메모리가 둘 또는 그 이상의 프로세스들에 의해 공유되는 것을 가능 하게 하는 것입니다. 어떤 프로세스나 파일이 메모리 주소를 참조할 때 특정 물리주소가 아닌 가상 주소를 참조하고 이 가상 주소는 메모리 관리 장치에 의해 물리 주소로 사상되기 때문에 특정 프로세스에서 논리 메모리 값을 참조하면 자연스럽게 두 프로세스가 같은 물리 주소를 참조하게 됩니다. 요구 페이징이란?요구 페이징이란?디스크에서 메모리로 실행 프로그램을 적재할 때를 생각해 봅시다. 이 경우 실행하고자 하는 프로그램 전체를 메모리로 옮기는 것이 일반적인 방법입니다. 하지만 가상 메모리에서는 초기에 필요한 것만 적재하는 전략을 사용할 수 있는데 이것을 요구 페이징 이라고 합니다. 이러한 요구 페이징을 사용하게 되면 한번도 접근되지 않는 페이지는 물리 메모리에 전혀 적재되지 않게 됩니다. 이러한 요구 페이징은 어떤 점에서 스와핑 기법과 비슷하게 동작합니다. 프로세스를 실행하고 싶으면 메모리로 읽어 들이는 swap in 을 할 때 전체 프로세스를 읽어오지 않고 필요한 페이지만 메모리에 적재합니다. 하지만 이 경우 프로세스를 하나의 연속된 주소 공간으로 보기 보다 페이지들의 연속으로 생각하고 있으므로 스와퍼 라는 표현이 아닌 페이저 라는 표현을 사용합니다. 이러한 페이저 는 프로세스 내의 개별 페이지들을 관리합니다. 디스크에서 메모리로 페이지를 적재하는 스왑인(swap in) 을 수행하는 경우 프로세스가 다시 스왑 아웃 되기 전에 실제로 어떤 페이지들이 사용될 것인지 추측하고, 프로세스 전체를 메모리에 적재하는 대신 실제 필요한 페이지들만 메모리로 읽어옵니다. 이렇게 프로세스 전체가 아니라 프로세스의 부분 조각인 페이지 들만 가져오게 되면 무슨 일이 생길까요?특정 프로세스 내에서 어떤 페이지가 실제 메모리에 적재되었는지, 또 적재되지 않았는지를 구별할 수 없게 됩니다. 이런 문제를 해결하기 위해서 약간의 하드웨어 지원을 받아 페이지 테이블 이라는 것이 존재합니다. 이런 페이지 테이블 에는 유효-무효 비트 가 존재하여 어떤 페이지가 실제 물리 메모리에 적재되어 있는지를 표시해 주고 만약 실제 물리 메모리에 적재되지 않은 페이지는 그 페이지가 저장되어 있는 디스크 주소를 기록 해 두어 나중에 필요할 때 가져올 수 있게 해 줍니다. 이제 CPU가 필요한 페이지를 메모리에서 가져올 때 만약 가상 메모리에 해당 내용이 있다면 해당하는 물리 메모리에서 페이지를 로드하여 모든 페이지가 메모리에 존재할 때와 동일하게 실행이 됩니다. 만약 메모리에 없는 페이지에 접근 을 하려고 하면 어떨까요? 이때는 페이지 테이블 항목이 무효로 설정되어 있으므로 페이지 부재 트랩 을 발생시킵니다. 페이지 부재가 발생하면 사용하는 모든 페이지가 메모리에 올라올 때까지 필요할 때마다 페이지 부재가 발생하게 되는데, 일단 필요한 모든 페이지가 메모리에 적재되고 나면 부재 오류가 발생하지 않게 되고 이것이 순수 요구 페이징 입니다. 즉, 어떤 페이지가 필요해 지기 전에는 그 페이지를 적재하지 않습니다. 여기서, 이렇게 가상 메모리가 최초의 페이지를 적재하고 계속해서 필요한 페이지들을 불러오는 방식으로 계속해서 페이지 부재 오류를 처리하면서 페이지를 적재한다면 시스템 성능이 현저하게 떨어지지 않을까하는 의문 이 생길 수 있습니다. 한 명령어에서도 여러 개의 페이지 부재를 일으킬 수 있는 만큼 충분히 이런 의문이 제기될 수 있습니다. 하지만, 모든 프로그램은 참조 지역성 즉, 프로그램의 어느 한 특정 작은 부분만 집중적으로 참조하기 때문에 특정 페이지를 불러오면 그 안에 대부분의 유효한 정보가 밀집되어 있기 때문에, 현실에서는 문제가 될 만큼 많은 페이지 부재가 일어나지는 않습니다. 이러한 요구 페이징에서 필수적인 요구사항은 페이지 부재 오류 처리 후 명령어를 다시 시작 할 수 있어야 한다는 것 입니다. 언뜻 생각하면 이는 매우 단순한 문제인 것 처럼 보입니다. 페이지 부재 오류가 발생하면 중단된 프로세스 상태(일종의 레지스터 값 등)을 저장해 놓은 뒤에 페이지를 적재하고 다시 명령을 처리하면 문제는 해결될 것으로 보입니다. 하지만, 한 명령어가 많은 기억 장소를 변경하는 경우를 생각해 봅시다. 가령 디스크의 특정 블록을 적재하는 데 해당 블록이 페이지 사이에 걸쳐 있다면 정보가 다 적재되기도 전에 페이지 부재가 발생하여 문제가 발생하게 됩니다. 만약 적재하던 블록은 저장하는 장소가 걸쳐진 다른 블록인 경우는 문제가 더욱 심각해 집니다. 이러한 문제를 해결하기 위한 방법 중 하나는 마이크로 코드로 양 블록의 끝을 계산하여 접근을 시도하는 것 입니다. 가령 블록이 몇 페이지에 걸쳐 존재한다면 양 끝 블록을 계산하여 몇 개의 페이지를 적재해야 하는지 알 수 있고, 만약 페이지 부재가 발생하면 어떤 블록도 수정되기 전의 단계에서 부재가 발생하여 데이터의 손상이 없습니다. 요구 페이징의 성능요구 페이징은 페이지 부재가 발생하지 않는 한 실질 접근시간은 메모리 접근 시간과 같다. 즉, 유효 접근시간은 페이지 부재율 에 비례하기 때문에 페이지 부재율을 낮게 유지하는 것이 상당히 중요하다. 페이지 교체페이지 교체의 필요성페이지 부재율을 논할 때 각 페이지는 처음 그 페이지가 접근될 때 한 번만 페이지 부재가 발생한다고 가정하였으나, 이 설명은 정확한 것이 아닙니다. 가령 40프레임의 메모리 용량을 가진 컴퓨터에서 10페이지 중 실제 5페이지만 사용하는 프로세스를 6개를 실행시킨다고 합시다. 그러면 요구 페이징에 의해 총 30페이지가 메모리에 적재될 것입니다. 하지만 기존의 가정과 달리 특정 데이터 조합에 대해 이 프로세스들이 10 페이지를 모두 사용해야 하는 상황이 있을 수 있고 그런 상황의 경우 총 60페이지가 메모리에 적재되어야 합니다. 이렇게 된다면 총 40프레임만 있는 상황에서 60프레임을 필요로 하게 되고 사용자 프로세스가 실행 중 이 때 과할당(over-allocating) 이 발생하게 됩니다. 즉, 과할당이란 프로세스가 메모리보다 더 큰 용량의 페이지를 적재하려고 할 때 발생 하게 됩니다. 이런 과할당이 발생하는 경우 가장 일반적인 해결책은 바로 페이지 교체 입니다. 페이지 교체의 동작 원리그렇다면 페이지 교체는 어떻게 이루어 질까요?페이지의 교체는 다음과 같은 순서로 이루어 집니다. 디스크에서 적재가 필요한 페이지의 위치를 알아냅니다. 메모리공간에서 빈 페이지 프레임을 찾습니다.이때 빈 프레임이 있다면 그것을 사용하고 없다면 페이지 교체 알고리즘 을 통해 희생될(victim) 프레임 을 선정하고, 희생될 페이지를 디스크에 기록한 뒤 관련 테이블을 수정합니다. 새롭게 비워진 프레임에 새 페이지를 읽어오고 프레임 테이블을 수정합니다. 사용자 프로세스를 재시작 합니다. 위 순서를 잘 살펴보면 만약 메모리 공간에 빈 페이지 프레임이 있는 경우에는 프레임을 비울 때 한번, 프레임을 읽어들일 때 한번 총 2번에 걸쳐 디스크에 접근 하는 점을 알 수 있습니다. 이 때문에 페이지 부재 처리시간은 총 2베가 소요되게 되는데 이는 이러한 오버헤드는 변경 비트(modify bit or dirty bit) 를 활용해서 해결 할 수 있습니다. 변경 비트란 CPU가 페이지 내 어떤 워드나 바이트라도 쓰게 되면 페이작 변경되었음을 나타내기 위해 설정됩니다. 만약 변경 비트가 설정되어 있지 않다면 페이지가 메모리로 읽혀들어온 후에 바뀌지 않았으므로 메모리에서 그냥 삭제해도 디스크에는 원본이 잘 보존되어 있기 때문에 별도로 저장을 하지 않아도 됩니다. 이 기법은 읽기전용 페이지들에도(디스크 내용을 변경하지 않았으므로) 같은 원리로 적용이 됩니다. 위에서 다룬 페이지 교체 알고리즘 을 비롯하여 현대의 페이징 시스템은 두 가지 중요한 문제를 해결해야 하는데, 그것은 프레임 할당 알고리즘 과 페이지 교체 알고리즘 입니다.프레임 할당 알고리즘 이란 여러 개의 프로세스가 존재하는 경우 각 프로세스에 얼마나 많은 프레임을 할당해야 할지 결정하는 알고리즘이며, 페이지 교체 알고리즘 이란 페이지 교체가 필요할 때 어떤 페이지를 교체할지 선정하는 알고리즘 입니다. 현재에는 많은 페이지 교체 알고리즘이 존재하며 일반적으로는 페이지 부재율이 가장 낮은 것을 선정 하는 알고리즘을 사용합니다. 선입선출 페이지 교체(FIFO Page Replacement)페이지 교체 알고리즘 중에서 가장 간단한 알고리즘인 선입선출 알고리즘 을 살펴봅시다. 선입선출 교체 알고리즘은 각 페이지에 메모리 적재시간을 연관시켜 가장 오래된 페이지를 교체하는 알고리즘 입니다. 하지만 선입선출 알고리즘은 간단한 만큼 많은 문제점을 가지고 있습니다. 쉽게 생각해 봐도 오래된 페이지가 얼마나 자주 사용될지도 모르는데 모래되었다는 것 하나로 교체해 버리는 것은 참 무모해 보입니다. 가령 매우 중요한 변수를 들고있을 수도 있고 수없이 많이 수행되는 중요한 페이지 일수도 있기 때문입니다. 하지만 이렇게 페이지가 교체되어도 치명적인 문제는 일어나지 않습니다. 페이지가 교체되어도 필요한 시점에서 바로 부재처리 가 되어서 다시 메모리에 적재시키면서 프로세스가 동작하기 때문입니다. 하지만, 이 경우에는 페이지 부재율이 많이 높아지게 되고 효율적이지 못한 동작 이 일어난다고 볼 수 있습니다. 최적 페이지 교체(Optimal Page Replacement)최적 페이지 교체 알고리즘을 알아보기 전에 Belady 의 모순 에 대해 알아봅시다. 보통 프로세스에게 얼마만큼의 프레임을 할당하는가 하는 문제에 있어서 많은 프레임을 할당하면 페이지 부재율이 낮아질 것으로 생각을 합니다. 하지만 위의 선입선출 알고리즘과 마찬가지로 Belady 의 모순이란 많은 프레임을 할당해 주었는데도 불구하고 반대로 페이지 부재율이 더 증가하는 현상을 일컷습니다. 이러한 Belady 의 모순이 없는 알고리즘을 찾던 와중에 최적 교체 알고리즘 이 탄생하게 되었습니다. 최적 교체 알고리즘은 간단히 말하면 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체 하는 알고리즘이며, 프레임 수가 고정된 경우 가장 낮은 페이지 부재율을 보장 합니다. 하지만 불행하게도 이 알고리즘의 구현은 매우 어렵고 따라서 주로 비교 연구 목적을 위해 가장 최선의 경우를 계산할 목적으로 사용됩니다. 가령 특정 알고리즘을 개발하였는데 최적 알고리즘에 비해 12.3% 이상으로 나빠지지 않았다라는 연구결과를 얻는 등 일종의 레퍼런스로 사용됩니다. LRU 페이지 교체(LRU Page Replacement)최적 페이지 교체 알고리즘이 미래에 사용되지 않을 페이지를 찾아 교체하는 것이라 할때 최근의 과거를 미래의 근사치로 본다면 가장 오랜 시간 사용되지 않은 페이즈를 교체할 수 있고 이것이 LRU 알고리즘이다.","link":"/2018/04/04/운영체제-가상-메모리란-무엇인가/"},{"title":"운영체제 | 입출력 시스템이란 무엇인가?","text":"입출력 시스템이란 무엇인가? 입출력 하드웨어 입출력 하드웨어의 구성 입출력 하드웨어의 동작 폴링 인터럽트 직접 메모리 접근(Direct Memory Access) 입출력 시스템이란 무엇인가?컴퓨터의 주요한 두가지 작업은 연산작업 과 입출력 작업 입니다. 많은 경우 연산 작업 보다는 입출력 작업이 중요 한데, 가령 우리가 인터넷 서핑을 하거나 혹은 문서작업을 하는 경우 대부분은 컴퓨터 내의 저장된 파일을 열거나 작성하는 경우가 다반사 이기 때문입니다. 그만큼 컴퓨터는 설치된 입출력 장치들과 원활하게 소통해야 하고 운영체제는 이러한 입출력이 잘 이루어 지도록 할 필요 가 있습니다. 본 강의 에서는 어떻게 컴퓨터에 연결된 다양한 입출력 하드웨어 장치들과 소통이 이루어 지는지 를 공부하고 그 과정에서 하드웨어 인터페이스 및 소프트웨어 인터페이스의 간극을 운영체제가 어떻게 해결하는 지에 대해 알아봅니다. 컴퓨터에 연결될 장치들을 제어하는 일은 운영체제의 주요한 관심사 입니다. 다양한 장치들 은 기능이나 속도면에서 다양한 특성을 보이기 때문에 각각에 맞는 제어가 필요 하고, 이와 같은 다양한 제어 방법들이 커널의 입출력 서브 시스템을 형성 하여 커널의 다른 부분이 입출력장치를 관리하는 복잡한 일에 신경쓰지 않게 해줍니다. 이렇게 입출력을 관리하기 위한 기술들이 지향하는 바는 새로 나오는 장치들이 기존 시스템에 쉽게 결합될 수 있게 하는 것입니다. 가령 무수히 쏟아져 나오는 마우스, 키보드, 모니터 등 다양한 장치들이 내 컴퓨터와 잘 동작하게 하려면 둘 사이에 무언가 공통된 인터페이스 가 존재해야 하며 그 역할을 수행하는 것이 입출력 관리의 핵심이라고 할 수 있습니다. 때문에 이런 인터페이스의 표준화 는 입출력 관리에서 매우 중요합니다. 운영체제 커널 이 이렇게 다양한 입출력 장치들의 차이를 가려주기 위해서 장치 구동기 모듈 을 사용합니다. 장치 구동기는 모든 하드웨어를 일관된 인터페이스로 표현해 주며, 이러한 인터페이스를 그보다 상위층인 커널의 입출력 서브시스템에 제공해 줍니다. 입출력 하드웨어입출력 하드웨어의 구성다양한 입출력 장치들이 컴퓨터와 동작을 하는 원리를 알기 위해서 우리는 이런 입출력 장치 들이 어떻게 구성되어 있는지 살펴 볼 필요가 있습니다. 이런 입출력 장치들은 크게 저장 장치, 전송 장치, 사용자 인터페이스 장치 등으로 나뉘어집니다. 하지만, 이러한 다양한 입출력 장치가 어떻게 운영체제와 동작하는지 알기 위해서 우리는 몇가지 표준적인 개념만 이해하면 됩니다. 하드웨어 장치는 케이블을 통하거나 무선으로 신호를 보냄으로써 컴퓨터 시스템과 통신 하며, 포트 라고 불리는 연결점을 통해 컴퓨터에 접속합니다. 만약 하나 이상의 장치들이 공동으로 여러 선들을 사용한다면 이것을 버스 라고 부릅니다. 여기서 버스는 단순히 선만을 의미하는 것이 아니라 각 선에 어떤 전기적 신호를 보내어 통신이 이루어지는 지를 약속하는 프로토콜 까지를 포함하는 개념 입니다. 하드웨어 장치의 또 다른 구성요소는 바로 제어기 입니다. 제어기란 포트나 버스나 입출력 장치를 제어하는 전자회로의 집합체이며 많은 입출력 장치는 제어기를 내장 하고 있습니다. 그렇다면 컴퓨터는 어떻게 장치의 제어기에서 입출력을 하도록 명령할 수 있을까요?모든 제어기는 레지스터를 가지고 있고 컴퓨터의 프로세서는 제어기의 레지스터에 비트 패턴을 쓰거나 읽음으로써 입출력을 실행 합니다. 다른 방법으로는 장치 제어 레지스터를 프로세서의 주소 공간으로 사상 하는 방법이 있고 이것을 메모리 맵 입출력(Memory Map I/O) 이라고 부릅니다. 이 경우에는 각 주변장치 레지스터들은 메모리 주소와 일대일 대응이 되고, 컴퓨터는 이러한 메모리 주소에 데이터를 읽고 쓰는 것으로 장치 제어기의 레지스터에 직접 데이터를 읽고 쓰는 역할을 수행 하게 할 수 있습니다. 이러한 메모리 맵 입출력의 활용은 다양합니다. 가령 스크린에 내용을 출력하는 작업을 함에 있어서 모든 비트맵을 일일히 제어기에 작성하는 것은 너무도 큰 작업이 될 것입니다. 하지만 메모리맵 입출력을 통해 메모리에 수백만 바이트를 기록하는 방식으로 입출력 명령어를 이용하는 경우보다 훨씬 빠른 성능 을 낼 수 있습니다. 하지만 이러한 메모리 맵 이출력에서는 잘못된 포인터 등의 오류로 현재 선점 중인 메모리 주소에 임의값을 작성하는 경우 입출력 시스템에 문제가 생기게 되는 문제점 이 있습니다. 다음은 장치의 입출력 포트 가 어떻게 구성되어 있는지 알아봅시다. 장치의 입출력 포트 는 보통 4개의 레지스터로 구성 되어 있는데, 상태, 제어, 입력, 출력 레지스터가 그것입니다. 입출력 하드웨어의 동작입출력 하드웨어가 어떻게 생겼는지 알아보았으니, 이제는 그 동작을 알아보도록 합시다. 폴링컴퓨터와 입출력 하드웨어 사이의 프로토콜을 복잡하지만 기본적인 핸드셰이킹 개념은 간단합니다. 장치의 제어기의 레지스터 에는 비지 비트 라는 것이 존재 하는데, 이것은 현재 장치가 사용가능한 상태인지 아니면 다른 작업을 처리중이라 사용이 불가능 한지를 나타냅니다. 제어기는 작업이 하느라 바쁠 때에는 비지 비트를 1로 설정하고 준비 중인 경우에는 0으로 설정하여 컴퓨터가 현재 장치가 사용중인지를 알 수 있게 해줍니다. 여기서 컴퓨터는 시시때때로 장치가 사용중인지를 검사하기 위해 비지 비트 를 검사해야 하는데, 이것을 계속 돌면서 반복한다고 하여 폴링 이라고 부릅니다. 이러한 폴링에는 컴퓨터 자원이 많이 소요되지 않지만(3 사이클 정도) 장치가 준비하는 시간이 길어지면 매우 비효율적이며, 이 대신 하드웨어가 제어기가 자신의 상태가 바뀔 때 컴퓨터에 통보를 해 주면 이렇한 비효율을 막을 수 있으며 이를 인터럽트 라고 합니다. 인터럽트인터럽트의 기반 메커니즘은 다음과 같습니다. CPU는 인터럽트 요청 라인 이라고 불리는 선을 가지는데, CPU는 매 명령어를 끝내고 다음 명령어를 수행하기 전에 이 선을 검사 합니다. 만약 입출력 장치가 준비가 완료되어 인터럽트 요청 라인 에 신호를 보내면 CPU는 하나의 명령을 끝낸 시점에 인터럽트를 확인하고 인터럽트 핸들러 를 실행합니다. 여기서 인터럽트 핸들러 란 입출력 장치를 서비스함으로써 이 인터럽트를 처리해 주는 것입니다. 하지만 현대의 시스템에서는 이러한 인터럽트를 처리함에 있어 보다 세분화된 인터럽트 핸들링이 필요 했고, 다음은 인터럽트 핸들러가 수행해야 하는 기능을 보여줍니다. 임계영역을 실행 중에는 인터럽트 처리를 연기시키는 능력이 필요하다. 어떤 장치가 인터럽트를 일으켰는지 조사하기 위해 모든 장치를 폴링하지 않고 적절한 인터럽트 핸들러로 이동 하는 효율적인 방법이 필요하다. 즉, 인터럽트 요청 라인에 요청이 들어왔을 때 어디서 들어온 요청인지 바로 알아야 한다. 운영체제가 높은 우선순위와 낮은 우선순위를 구분하고 긴급한 정도에 따라 응답하기 위한 다수준 인터럽트 가 필요하다. 위의 세가지 기능을 제공하기 위해 CPU와 인터럽트 제어기 하드웨어를 통하여 구현하고 있습니다.대부분의 CPU는 두 종류의 인터럽트 요청 라인인 마스크 불가 인터럽트, 마스크 가능 인터럽트 를 가지고 있습니다. 여기서 마스크 불가 인터럽트는 회복 불가능한 메모리 에러와 같은 이벤트를 처리 하며, 마스크 가능 인터럽트는 필요 시 잠시 중단시켜 놓을 수 있는 인터럽트를 처리 합니다.보통의 인터럽트 기법에서는 인터럽트 요청을 할 때 주소라고 하는 하나의 정수를 받아 들이는 데 이것은 인터럽트 핸들러들의 메모리 주소들을 가지고 있는 인터럽트 벡터 라 불리는 테이블의 인덱스값 으로 사용됩니다. 이러한 벡터형 인터럽트 기법 은 인터럽트 벡터 를 활용하여 모든 가능한 인터럽트의 진원지를 찾아야 할 필요를 줄여 주지만 컴퓨터는 인터럽트 벡터 내에 있는 주소들보다 더 많은 수의 장치를 가지고 있고 이 문제를 해결하기 위해 인터럽트 사슬화 를 사용합니다. 인터럽트 사슬화에서 인터럽트 벡터의 각 원소들은 인터럽트 핸들러 리스트 의 헤더를 가르키고 있고, 만약 인터럽트가 일어나면 해당 핸들러를 찾을 때까지 리스트 상의 핸들러들을 하나씩 검사하게 됩니다. 직접 메모리 접근(Direct Memory Access) 이제까지 컴퓨터와 입출력 장치가 어떻게 구성되어 있고, 어떻게 동작하는 지를 알아보았습니다. 그렇다면 입출력 장치와 컴퓨터 사이의 데이터는 어떤 방식으로 주고 받을까요? 만약 CPU를 사용하여 디스크와 같은 대용량 입출력 장치의 데이터를 읽어들인다면 CPU의 사용량이 매우 높아지고 이는 컴퓨터 성능을 심각하게 저하시킬 것입니다. 즉, CPU가 매번 바이트 전송을 제어하는 것은 심한 낭비인 것이죠. 이렇게 CPU가 1바이트씩 옮기는 입출력 방식을 PIO 라고 부릅니다. 많은 컴퓨터들은 이렇게 CPU의 낭비를 막기 위해 PIO를 DMA 제어기 라고 불리는 특수 프로세서 에게 위임함으로써 CPU의 일을 줄여줍니다. 그 과정은 다음과 같이 진행됩니다 먼저, 컴퓨터(호스트)는 메모리에 DMA 명령 블록을 씁니다. 이 블록에는 전송할 데이터가 있는 곳의 포인터와 전송할 장소에 대한 포인터 그리고 전송될 바이트 수를 기록해 놓습니다. 그러면 CPU는 DMA 명령 블록의 주소를 DMA에게 알려주고 자신은 다른 일을 처리합니다. 그러면 DMA는 CPU의 도움 없이 자신이 직접 버스를 통해 DMA 명령 블록을 액세스하여 입출력을 실행합니다. 그러면 DMA 제어기와 장치 제어기는 어떻게 연결될까요?이 둘의 핸드셰이킹은 DMA request, 와 DMA acknowledge 라고 불리는 두 개의 선을 통해서 실행됩니다. 장치 제어기는 전송할 자료가 생기면 DMA request를 통해 장치 제어기에서 데이터 전송을 요청 합니다. 그러면 DMA 제어기가 메모리 버스를 얻어 거기에 원하는 주소를 올려 놓고 DMA acknowledge 신호 를 보냅니다. 장치 제어기가 DMA acknowledge 신호를 받으면 제어기는 한 워드를 메모리로 전송하고 DMA request를 제거 합니다. 그리고 전송이 끝나면 DMA 제어기는 CPU에게 인터럽트를 걸어 전송이 완료되었음을 알립니다. 이 과정에서 DMA 제어기가 메모리 버스를 점유 중이면 주 메모리는 주캐시와 보조캐시에 있는 데이터에는 접근할 수 있지만 주 메모리에 있는 데이터는 접근을 할 수 없게 되어 CPU의 속도를 저하시키지만 전체적으로 보았을 때에는 입출력 작업을 DMA로 넘기는 것은 시스템 성능을 향상 시킵니다.","link":"/2018/04/03/운영체제-입출력-시스템/"},{"title":"운영체제 | 프로세스","text":"초기의 컴퓨터 시스템은 한 번에 하나의 프로그램만을 실행할 수 있었습니다. 즉, 하나의 프로그램이 시스템에 대한 완전한 제어를 가지고, 시스템의 모든 자원에 접근하였습니다. 하지만, 오늘날의 컴퓨터 시스템들은 메모리에 다수의 프로그램을 적재하여 동시에 프로그램들을 병행으로 실행이 가능하게 되었고, 이에 따라 다양한 프로그램들의 동작을 관리할 필요성이 되었습니다. 프로세스 란 실행중인 프로그램을 말하며, 현대 시분할 시스템에서 작업의 단위를 지칭합니다. 하나의 시스템은 프로세스들의 집합체 이며, 운영체제 프로세스들을 시스템 코드를 실행하고, 사용자 프로세스들은 사용자 코드를 실행합니다. 이들 모든 프로세스들은 잠재적으로 병행 실행이 가능하고, CPU가 각 프로세스들을 번갈아 가며 실행하게 함으로써 운영체제는 컴퓨터를 보다 생산적으로 만들어 줍니다. 프로세스란 무엇인가? 프로세스란 간단히 말하면 실행중인 프로그램을 의미합니다. 하지만, 프로세스는 디스크에 저장된 실행 파일 처럼 수동적인 존재가 아니라는 점에서 프로그램 과는 큰 차이가 있습니다. 프로그램이 단지 컴퓨터 안에 있는 수동적인 것인 반면, 프로세스 는 다음에 실행할 명령어를 지정하는 프로그램 카운터 및 관련 자원의 집합을 가진 능동적인 존재입니다. 실행파일이 메모리에 적재될 때 프로그램은 프로세스가 됩니다. 이러한 프로세스들은 능동적으로 동작하고 있는 존재이기에 현재의 프로세스 상태(process status) 라는 개념이 존재합니다. 각 프로세스들은 다음 상태들 중 하나에 있을 수 있습니다. new: 프로세스가 생성 중인 상태 running: 명령어들을 실행중인 상태 waiting: 프로세스가 어떤 사건이 일어나기를 기다리고 있는 경우 ready: 프로세스가 처리기에 할당되기를 기다리는 중 terminated: 프로세스가 실행을 종료함 모든 프로세스는 위의 상태 중 하나에 있으며, 어느 한 순간에 처리기에서는 오직 하나의 프로세스만이 실행될 수 있습니다. 그렇다면 프로세스는 운영체제에서 어떻게 표현되나요?프로세스는 운영체제에서 프로세스 제어 블록(Process Control Block) 이라는 이름으로 표현되며, 특정 프로세스와 연관된 여러 정보를 수록하며 다음과 같은 것들을 포함합니다. 프로세스 상태 프로그램 카운터 CPU 레지스터들 CPU 스케줄링 정보 메모리 관리 정보 회계 정보 입출력 상태 정보 즉, 프로세스 제어 블록은 단순히 프로세스별로 달라지는 모든 정보에 대한 저장소 역할을 합니다. 프로세스들은 어떤 방식으로 처리되나요?컴퓨터 시스템 안에는 수많은 프로세스들이 동작하고 있으며, 이러한 프로세스들을 효과적으로 처리하기 위한 컴퓨터의 작업을 프로세스 스케줄링 이라고 합니다. 만약 시스템이 시분할 로 동작하는 경우, 각 프로그램이 실행되는 동안 사용자가 상호작용할 수 있도록 프로세스들 사이에서 CPU를 빈번하게 교체하는 것입니다. 이를 위해 프로세스 스케줄러 는 CPU에서 실행 가능한 여러 프로레스들 중에서 하나의 프로세스를 선택하여 교체하는 역할을 수행합니다. 프로세스가 시스템에 들어오면 이들은 작업 큐 에 들어가게 됩니다. 이 큐에는 시스템 안의 모든 프로세스들이 포함됩니다. 또한 메모리에 적재된 프로세스 중 준비완료 상태로 실행되기만을 기다리는 프로세스들은 별도로 준비완료 큐 에 들어가게 됩니다. 또 시스템에는 다른 큐들도 있습니다. 만약 입출력 장치를 대기하는 프로세스들은 장치 큐 안에서 장치를 대기하게 되며, 각 장치는 자기만의 장치 큐 를 가집니다. 일단 프로세스에게 CPU가 할당되어 CPU가 실행되면, 다음 사건들 중 하나가 발생할 수 있습니다. 프로세스가 입출력 요청을 하여 입출력 큐에 넣어질 수 있다. 프로세스가 새로운 서브프로세스를 생성하고 그 프로세스의 종료를 기다릴 수 있다. 프로세스가 인터럽트 처리 결과에 의해 강제로 CPU로부터 제거되어 준비완료 큐에 다시 놓일 수 있다. 프로세스 스케줄링이렇게 프로세스는 일생 동안에 다양한 스케줄링 큐 사이를 이주 하며 운영체제는 어떤 방식으로든지 프로세스들을 이 큐에서 반드시 선택해야 하며, 이러한 선택절차 는 적절한 스케줄러 에 의해 실행됩니다.프로세스 스케줄러에는 장기 스케줄러와 단기 스케줄러가 있습니다. 먼저, 장기 스케줄러(작업 스케줄러) 를 살펴봅시다.앞에서 말했듯이 컴퓨터에는 수많은 프로세스들이 존재하고 모든 프로세스들은 자원을 할당받기 위해 서로 경쟁구도에 놓여 있습니다. 또 어떤 경우에는 동시에 실행 가능한 수보다 많은 수의 프로세스들이 제출되는 경우가 존재하며, 이 경우에는 특정 프로세스를 보류하고 나중에 실행을 해야 할 필요성이 생기게 됩니다. 이것을 처리하는 것이 바로 장기 스케줄러 입니다. 장기 스케줄러는 실행 할 수 없는 프로세스들을 대량 메모리(디스크 등)에 저장시켜 놓고 나중에 프로세스를 실행 시킬 수 있는 시점에 다시 메모리에 적재 시킵니다. 이렇게 디스크에서 메모리로 프로세스를 교체 시키면서 전체 시스템의 다중 프로그램의 개수를 조절 하는 중요한 역할을 수행합니다.이러한 장기 스케줄러를 잘 살펴보면, 새로운 프로세스를 생성하는 시점에만 그 기능을 하는 것을 쉽게 알 수 있습니다. 또, 새로운 프로세스의 생성이 필요해 졌다는 말은 기존에 있던 하나의 프로세스가 종료되었음을 뜻하기 때문에 장기 프로세서는 프로세스가 시스템을 떠날 때에만 호출 됩니다. 장기 스케줄러는 다음 프로세스를 매우 신중하게 선택해야합니다. 일반적으로 대부분의 프로세스들은 입출력 중심 프로세스 와 CPU 중심 프로세스 로 나뉘게 되는데, 장기 스케줄러는 이러한 입출력 중심과 CPU 중심 프로세스들이 적절하게 혼합되도록 선택하는 것이 중요합니다. 단기 스케줄러(CPU 스케줄러) 는 이러한 장기 스케줄러 와는 달리 매우 빠른 속도로 준비 완료 큐 에 있는 프로세스들의 상태를 바꾸며 CPU에게 교체로 할당하는 역할을 수행합니다. 장기 스케줄러와, 단기 스케줄러 외로 중기 스케줄러 도 있습니다.중기 스케줄러 는 메모리에서 프로세스들을 제거 하여 다중 프로그래밍의 정도를 완화하는 역할을 수행합니다. 이 중기 스케줄러는 추후 스와핑 을 통해 메모리로 프로세스를 불러와 중단되었던 지점에서부터 실행을 재개합니다. 중단된 프로세스는 어떻게 다시 실행되나요?여러 프로세스들은 인터럽트 를통해 작업이 중단되고 특정 프로세스가 끝나면 다시 CPU에 의해 실행되게 됩니다.이렇게 중단된 프로세스가 추후에 어떻게 다시 실행이 되는 것일까요? 이것은 바로 문맥교환 에 의해 이루어 집니다. 시스템은 인터럽트 처리가 끝난 후에 문맥 을 복구할 수 있도록 실행중이던 프로세스의 문맥을 PCB에 저장 하고, 문맥교환 을 통해 새로운 프로세스의 저장된 문맥을 불러들여 복구 합니다. 프로세스의 생성과 종료운영체제는 이러한 프로세스를 생성하고 종료하기 위한 기법을 제공해야 하며, 이에 대해 배워봅시다. 프로세스 생성프로세스들은 프로세스를 실행하면서 여러개의 다른 프로세스들을 새롭게 생성할 수 있습니다. 여기서 새롭게 생성된 프로세스를 자식 프로세스 라고 하며, 생성을 하는 프로세스를 부모 프로세스 라고 합니다. 이렇게 프로세스는 프로세스를 생성할 수 있고 궁극적으로 트리 구조 를 형성하게 됩니다. 프로세스가 버스 프로세스를 생성할 때 운영체제로부터 직접 자원을 얻거나 혹은 부모 프로세스의 자원의 일부분을 사용하도록 제한할 수 있습니다. 프로세스가 프로세스를 생성할 때 실행과 관련하여 두가지 기능이 있습니다. 부모가 계속해서 자식과 병렬로 실행된다. 부모가 모든 자식 또는 일부 자식이 끝날 때까지 기다린다. 프로세스간 통신운영체제 내에서 실행되는 프로세스들은 서로에게 영향을 주는 경우도 있고, 또는 전혀 영향을 주지 않고 별도로 존재하는 경우도 있습니다. 두 프로세스가 서로간에 영향을 주고 받는다면 이를 협력적 프로세스 라고 하며, 그렇지 않고 서로에게 전혀 영향을 주지 않는 프로세스를 독립적인 프로세스 라고 합니다. 이렇게 프로세스 끼리 서로 통신이 가능한 협력적 프로세스 가 생성될 수 있는 환경을 제공하는 데에는 다음과 같은 이유가 있습니다. 정보 공유가 쉽습니다.동리한 정보를 공유해야 할 필요가 있습니다. 계산 가속화특정 태스크를 빨리 실행하고자 하려면 그것을 서브태스크로 나누어 각각 다른 서브태스크들과 병렬로 실행되게 하여 더욱 빨리 특정 프로세스를 실행시킬 수 있습니다. 모듈성각 시스템의 기능을 별도의 프로세스로 나누어 모듈로 구성하기 쉽습니다. 모듈로 구성하기 위해서는 반드시 상호간의 통신이 필요합니다. 편의성한 사용자가 동시에 여러 태스크를 가지는 경우 필요합니다. 협력적 프로세스들은 데이터와 정보를 교환할 수 있는 프로세스간 통신 기법을 필요로 하며, 기본적으로 공유 메모리 모델 과 메시지 전달 모델 을 통해 구현할 수 있습니다. 공유 메모리 모델공유 메모리를 사용하는 프로세스간 통신에서는 통신하는 프로세스들이 공유 메모리 영역을 구축해야 한다. 일반적으로 운영체제는 한 프로세스가 다른 프로세스 메모리의 접근을 금지하기 때문에, 공유 메모리를 사용하기 위해서는 이 제약 조건을 제거하는 것에 동의가 필요합니다. 그런 뒤에는 프로세스들은 공유 영역에 읽고 씀으로써 정보를 교환할 수 있습니다. 메시지 전달 모델클라이언트 서버 환경에서 통신클라이언트와 서버의 관계에서 사용할 수 있는 통신 전략인 소켓, 원격 프로시저 호출 에 대해 알아봅시다. 소켓","link":"/2018/04/10/운영체제-프로세스/"},{"title":"운영체제 | 프로세스 동기화","text":"컴퓨터의 프로세스 중에서 협력적 프로세스 는 실행 중인 다른 프로세스의 실행에 영향을 주거나 받는 프로세스입니다. 이러한 협력적 프로세스는 논리주소 공간을 직접 공유하거나, 파일 또는 메세지를 통해서만 데이터를 공유할 수 있습니다. 이 경우 두개 이상의 프로세스가 동시에 특정 데이터에 접근하면 데이터가 비일관성을 가지게 될 수 있습니다. 본 강의에서는 이렇한 논리주소 공간을 공유하는 협력적 프로세스의 질서있는 실행을 보장하여 데이터의 일관성을 유지 하는 다양한 메커니즘을 다루어 보겠습니다. 두개의 프로세스가 동일한 공유된 변수에 접근하는 프로그램을 동작시킨다면 어떤 프로세스가 어떤 순서로 동작함에 따라 결과가 달라지게 됩니다. 하지만 두 프로세스가 비동기적으로 실행되는 경우 실제로 변수가 어떻게 변화하게 되는지 부정확해지는 일이 생기게 됩니다. 이런 문제는 두개의 프로세스가 동시에 같은 변수에 접근 하기 때문입니다. 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 경쟁 조건 이라고 합니다. 이를 해결하기 위해서는 한 순간에 하나의 프로세스만이 공유 변수를 조작하도록 보장해야 합니다. 임계영역 문제(The Critical Section Problem)여러 개의 프로세스가 동작하는 처리기를 생각해 봅시다. 각 프로세스는 임계영역(Critical Section) 이라고 부르는 코드 부분을 가지고 있으며, 그 안에서는 다른 프로세스와 공유하는 변수를 변경하거나, 테이블을 갱신하거나 파일을 쓰거나 하는 등의 작업을 실행합니다. 각 프로세스는 자신의 임계영역으로 진입하려면 진입허가를 요청해야 한다. 이러한 요청을 구현하는 코드 부분을 진입 영역(entry section) 이라고 부르며 임계영역 뒤를 퇴출영역(exit section) 이 따라올 수 있고, 코드의 나머지 부분을 통틀어 나머지 영역 이라고 부릅니다. 이러한 임계영역 문제를 해결하기 위해 서는 다음의 세 가지 요구 조건 을 충족해야 합니다. 상호 배제(mutual exclusion)프로세스 P가 자신의 임계영역에서 실행되고 있다면, 다른 프로세스들은 그들 자신의 임계영역에서 실행될 수 없습니다.즉, A라는 프로세스가 자신의 임계영역에서 실행되고 있다면, 프로세스 B는 자신의 임계영역에서 실행될 수 없습니다. 진행(Progress)자신의 임계영역에서 실행 중인 프로세스가 없는 상태에서 자신의 임계영역으로 진입하려고 하는 프로세스가 있다면, 나머지 영역에서 실행 중이지 않은 프로세스들만 임계영역으로 진입할 프로레스를 결정하는데 참여할 수 없으며, 이 선택은 무한정 연기될 수 없습니다.가령, A, B, C 라는 프로세스가 모두 자신의 임계영역에서 실행되고 있지 않은데 프로세스 A가 자신의 임계영역으로 진입하려고 한다면, 반드시 A는 나머지 영역 에서 실행중이지 않아야 하며, 유한한 시간 내에 임계영역으로 진입하고자 하는 프로세스를 선택해야 합니다. 한정된 대기프로세스가 자기의 임계영역에 진입하려는 요청을 한 뒤 그 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계영역에 진입할 수 있는 횟수에 제한이 있어야 합니다.예를 들어, 프로세스 A, B, C 가 있을 때 프로세스 A가 자신의 임계영역으로 진입하려고 진입 영역 에서 요청을 한 뒤 실제로 임계영역에 진입하기 전까지는 프로세스 B, 프로세스 C 가 임계영역에서 무한히 많이 진입하도록 되어서는 안되고 몇번 진입 후에는 반드시 프로세스 A에게 진입 할 순차가 와서, 프로세스 A가 한정된 대기를 해야 합니다. 운영체제에서 임계영역을 다룰 때는 두가지 상황을 고려해야 합니다.바로, 선점형 커널 인가 혹은 비선점형 커널 인가에 대한 문제입니다. 선점형 커널 은 프로세스가 커널 모드에서 실행되는 동안 선점되는 것을 허용하며, 비선점 커널 은 커널 모드에서 실행되는 프로세스의 선점을 허용하지 않고, 커널을 빠져나갈 때까지 또는 봉쇄될 때까지 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 실행됩니다.비선점형 커널 의 경우에는 커널 안에서 실행중인 프로세스가 명백하게 하나 밖에 없기 때문에 경쟁조건을 걱정하지 않아도 되지만, 선점형 커널 의 경우는 그렇지 않기 때문에 경쟁 조건이 발생하지 않는 것을 보장할 수 없습니다. 특히, SMP(Symmetric Multi-Processing) 구조에서는 서로 다른 처리기의 두 프로세스가 동시에 커널 모드에 있을 수 있기 때문에, 선점형 커널을 설계하는 것은 특히 어렵습니다. 피터슨의 해결방안이러한 임계영역 문제 에 대한 고전적인 소프트웨어 기반 해결책인 피터슨의 해결안 에 대해 알아봅시다. 피터슨의 해결안은 임계영역과 나머지 영역을 번갈아 가며 실행하는 두 개의 프로세스로 한정됩니다.쉽게 말하면 두 개의 프로세스를 구현할 때 특정 변수를 인덱스 값으로 놓아 해당 변수가 임계영역 에 대한 접근의 승낙여부를 공유하는 것입니다.이를 위해서 다음과 같이 두개의 데이터 항목을 공유합니다. 12int turn;boolean flag[2]; //프로세스가 임계영역으로 진입할 준비가 됨을 나타냅니다. 위에서 turn 변수 는 임계영역으로 진입할 순번을 나타냅니다. 가령 turn이 i 이면 프로세스 i가 임계영역에서 실행되는 것을 나타냅니다.flag 변수 는 프로세스가 임계영역으로 집입할 준비가 되었다는 것을 나타냅니다. 가령 flag[i]가 true 라면 프로세스 i가 임계영역으로 들어갈 준비가 되었다는 것을 나타냅니다. 이렇게 동일한 변수를 공유하면 turn에 동시에 접근이 되더라도 하나의 값만을 나타내기 때문에 바로 다음에 접근한 값에 의해 덮어 씌워지게 되어 둘 중 하나의 값만이 될 것입니다. 위의 공유변수를 이용한 피터슨의 해결방안을 코드로 보이면 다음과 같습니다.12345678910while(true)&#123; flag[i] = TRUE; turn = j; while(flag[j] &amp;&amp; turn ==j)&#123; 임계영역 코드 &#125; flag[i] = FALSE; 나머지 영역&#125; 위 코드는 프로세스 i가 임계영역에 접근하고자 하는 코드입니다. 위에서 flag[i]를 true로 지정함으로써 프로세스 i가 임계영역에 진입하고자 하는 것을 나타냅니다. 하지만 프로세스 i는 임계영역에 진입하기에 앞서 프로세스 j에게 먼저 입계영역에 접근하고 싶으면 접근하도록 turn을 돌려 줍니다. 만약 flag[j] 가 true 즉, 프로세스 j가 임계영역에 진입하고자 했다면 먼저 진입할 수 있습니다. 동기화 하드웨어앞에서는 임계영역 문제에 대한 소프트웨어 기반의 해결책을 살펴보았다. 하지만 일반적으로 임계영역의 문제는 록(lock) 이라는 간단한 도구가 필요하다고 말할 수 있다. 경쟁 조건은 임계영역에서 록에 의해 보호함으로써 예방할 수 있습니다. 즉, 프로세스가 임계영역에 진입하기 전에 반드시 록 을 획득하도록 함으로써 임계영역 문제를 해결할 수 있습니다. 이를 간단히 코드로 표현하면 다음과 같습니다.123456while(true)&#123; 록 획득 //임계영역 록 방출 //나머지 영역&#125; 위처럼 임계영역에 진입하기 전에 록을 획득 하고 임계영역을 나오면서 록을 방출 하는 방식을 잘 보여주고 있습니다. 이러한 임계영역의 문제에 대한 해결은 단일처리기 환경 혹은 다중 처리기 환경이냐에 따라 간단하거나 복잡할 수 있습니다.만약 단일 처리기 환경 이라면 임계영역 문제는 쉽게 해결될 것입니다. 공유 변수가 변경되는 동안에는 하나의 프로세스가 진행되는 것을 막는 인터럽트 의 발생을 허용하지 않는 것이지요. 이렇게 하면 공유 변수가 변경되는 동안에는 인터럽트가 발생하지 않고 해당 프로세스는 방행 없이 자신의 코드를 실행시킬 것 입니다.반면, 다중 처리기 환경 에서는 이것이 불가능 합니다. 다중 처리기에서 인터럽트를 막기 위해서는 모든 처리기에 인터럽트를 금지시키도록 해야 하는데 이것은 상당한 시간을 소비하기 때문이지요. 이러한 많은 이유들 때문에 현대의 많은 기계들은 한 워드의 내용을 검사하고 변경하거나 두 워드의 내용을 원자적으로 교환(swap) 할 수 있는, 즉 인터럽트 되지 않는 하나의 단위로서 특별한 하드웨어 명령어들을 제공합니다. 즉, swap을 통해 여러 처리기의 공유 변수를 원자적으로 변경시켜 록 을 획득하는 것 입니다. 세마포위에서 제시한 하드웨어 기반의 해결방법은 응용 프로그래머가 사용하기에는 매우 복잡하기에 이를 극복하기 위해 세마포 라고 하는 동기화 도구를 이용할 수 있습니다. 세마포 S는 정수 변수를 포함하며 초기화를 제외하고는 오직 두개의 표준 연산 acquire(), release() 로만 접근이 가능합니다. 이러한 세마포의 간단한 구현은 다음과 같습니다.12345678910acquire()&#123; while(value&lt;=0)&#123; 아무런 작업 하지 않음 &#125; value--;&#125;release()&#123; value++&#125; 위 코드를 분석해 봅시다.먼저 세마포는 임계 영역에 진입하기 위해 acquire() 를 호출합니다. 하지만 이 경우 누군가가 먼저 acquire를 호출하여 value의 값이 0보다 작다면 아무런 작업도 하지 않고 대기합니다. 그러다가 다른 세마포가 release()를 호출하여 value값을 증가시켜 주면 while 문에서 벗어나고 또 다른 acquire() 요청을 막기 위해 value를 줄여 줍니다. 하지만, 여기서는 치명적인 문제가 있습니다.바로 while 문에서 value를 검사하면서 바쁜 대기(busy waiting) 을 하고 있는 것이죠. 한 프로세스가 임계영역에 있으면, 자신의 임계영역에 진입하려는 다른 프로세스는 진입 코드를 계속 반복 실행해야 합니다. 이러한 현상을 프로세스가 록 을 기다리면서 회전한다고 하여 spinlock이라고 부르기도 합니다. 어떻게 하면 이런 바쁜대기(busy waiting) 을 없앨 수 있을까요?바로 바쁜 대기를 하는 대신에 자기 자신을 봉쇄시키는 방법이 있습니다. 봉쇄 연산은 프로세스를 세마포에 연관된 대기 큐 에 넣고, 프로세스를 대기상태로 전환 합니다. 그 후에 제어가 CPU로 넘어가게 되고 추후 다른 프로세스가 release()연산을 실행하면 wakeup() 연산을 통해 재시작 됩니다. 이런 wakeup() 명령은 프로세스의 상태를 대기상태에서 준비완료 상태로 변경합니다. 그 뒤 wakeup 된 프로세스는 준비완료 큐에 넣어지게 됩니다. 이러한 block, wakeup 을 구현하기 위해 우리는 세마포를 한 개의 정수 value와 프로세스 리스트로 정의합니다. 프로세스를 기다려야 한다면 이 프로세스는 그 세마포의 프로세스 리스트에 추가됩니다. release() 연산은 프로세스 리스트에서 한 프로세스를 제거하여 그 프로세스를 깨워줍니다. 이를 구현한 코드는 다음과 같습니다.12345678910111213acquire()&#123; value--; if(value&lt;0)&#123; block(); &#125;&#125;release()&#123; value++; if(value&lt;=0)&#123; wakeup(P); &#125;&#125; 위 코드에서 block() 연산은 자기를 호출한 프로세스를 보류시키고, wakeup(P) 연산은 봉쇄된 프로세스 P의 실행을 재개시키며, 이들 두 연산은 운영체제의 기본적인 시스템 호출 로 제공됩니다.","link":"/2018/04/13/운영체제-프로세스-동기화/"},{"title":"이더리움 토큰 만들기","text":"기본 contract 작성123456789101112131415161718192021222324252627pragma solidity ^0.4.20;contract MyToken &#123; event Transfer(address indexed from, address indexed to, uint256 value); /* This creates an array with all balances */ mapping (address =&gt; uint256) public balanceOf; string public name; string public symbol; uint8 public decimals; /* Initializes contract with initial supply tokens to the creator of the contract */ function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public &#123; balanceOf[msg.sender] = initialSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes decimals = decimalUnits; // Amount of decimals for display purposes &#125; /* Send coins */ function transfer(address _to, uint256 _value) public &#123; require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // Check for overflows balanceOf[msg.sender] -= _value; // Subtract from the sender balanceOf[_to] += _value; // Add the same to the recipient /* Notify anyone listening that this transfer took place */ emit Transfer(msg.sender, _to, _value); &#125;&#125; 상속을 이용한 보다 심플란 contract 작성하기is owned를 통해 상속을 하여 owner 변수와 onlyOwner modifier에 접근할 수 있게 되었다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.4.20;contract owned &#123; address public owner; function owned() &#123; owner = msg.sender; &#125; modifier onlyOwner &#123; require(msg.sender == owner); _; &#125; function transferOwnership(address newOwner) onlyOwner &#123; owner = newOwner; &#125;&#125;contract MyToken is owned&#123; event Transfer(address indexed from, address indexed to, uint256 value); /* This creates an array with all balances */ mapping (address =&gt; uint256) public balanceOf; string public name; string public symbol; uint8 public decimals; /* Initializes contract with initial supply tokens to the creator of the contract */ function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter ) &#123; if(centralMinter != 0 ) owner = centralMinter; &#125; /* Send coins */ function transfer(address _to, uint256 _value) public &#123; require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // Check for overflows balanceOf[msg.sender] -= _value; // Subtract from the sender balanceOf[_to] += _value; // Add the same to the recipient /* Notify anyone listening that this transfer took place */ emit Transfer(msg.sender, _to, _value); &#125;&#125; # 향상된 최종 코인123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244pragma solidity ^0.4.16;contract owned &#123; address public owner; function owned() public &#123; owner = msg.sender; &#125; modifier onlyOwner &#123; require(msg.sender == owner); _; &#125; function transferOwnership(address newOwner) onlyOwner public &#123; owner = newOwner; &#125;&#125;interface tokenRecipient &#123; function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; &#125;contract TokenERC20 &#123; // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public &#123; totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes &#125; /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal &#123; // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] &gt;= _value); // Check for overflows require(balanceOf[_to] + _value &gt; balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); &#125; /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public &#123; _transfer(msg.sender, _to, _value); &#125; /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123; require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; &#125; /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) &#123; allowance[msg.sender][_spender] = _value; return true; &#125; /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) &#123; tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) &#123; spender.receiveApproval(msg.sender, _value, this, _extraData); return true; &#125; &#125; /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) &#123; require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough balanceOf[msg.sender] -= _value; // Subtract from the sender totalSupply -= _value; // Updates totalSupply emit Burn(msg.sender, _value); return true; &#125; /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) &#123; require(balanceOf[_from] &gt;= _value); // Check if the targeted balance is enough require(_value &lt;= allowance[_from][msg.sender]); // Check allowance balanceOf[_from] -= _value; // Subtract from the targeted balance allowance[_from][msg.sender] -= _value; // Subtract from the sender&apos;s allowance totalSupply -= _value; // Update totalSupply emit Burn(_from, _value); return true; &#125;&#125;/******************************************//* ADVANCED TOKEN STARTS HERE *//******************************************/contract MyAdvancedToken is owned, TokenERC20 &#123; uint256 public sellPrice; uint256 public buyPrice; mapping (address =&gt; bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); /* Initializes contract with initial supply tokens to the creator of the contract */ function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public &#123;&#125; /* Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal &#123; require (_to != 0x0); // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] &gt;= _value); // Check if the sender has enough require (balanceOf[_to] + _value &gt;= balanceOf[_to]); // Check for overflows require(!frozenAccount[_from]); // Check if sender is frozen require(!frozenAccount[_to]); // Check if recipient is frozen balanceOf[_from] -= _value; // Subtract from the sender balanceOf[_to] += _value; // Add the same to the recipient emit Transfer(_from, _to, _value); &#125; /// @notice Create `mintedAmount` tokens and send it to `target` /// @param target Address to receive the tokens /// @param mintedAmount the amount of tokens it will receive function mintToken(address target, uint256 mintedAmount) onlyOwner public &#123; balanceOf[target] += mintedAmount; totalSupply += mintedAmount; emit Transfer(0, this, mintedAmount); emit Transfer(this, target, mintedAmount); &#125; /// @notice `freeze? Prevent | Allow` `target` from sending &amp; receiving tokens /// @param target Address to be frozen /// @param freeze either to freeze it or not function freezeAccount(address target, bool freeze) onlyOwner public &#123; frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); &#125; /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth /// @param newSellPrice Price the users can sell to the contract /// @param newBuyPrice Price users can buy from the contract function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public &#123; sellPrice = newSellPrice; buyPrice = newBuyPrice; &#125; /// @notice Buy tokens from contract by sending ether function buy() payable public &#123; uint amount = msg.value / buyPrice; // calculates the amount _transfer(this, msg.sender, amount); // makes the transfers &#125; /// @notice Sell `amount` tokens to contract /// @param amount amount of tokens to be sold function sell(uint256 amount) public &#123; require(address(this).balance &gt;= amount * sellPrice); // checks if the contract has enough ether to buy _transfer(msg.sender, this, amount); // makes the transfers msg.sender.transfer(amount * sellPrice); // sends ether to the seller. It&apos;s important to do this last to avoid recursion attacks &#125;&#125;","link":"/2018/05/09/이더리움-토큰-만들기/"},{"title":"자료구조 | 트리(Tree)","text":"트리(tree)란? 이진 트리 이진 트리 순회 예제 스레드 이진 트리 이원 탐색 트리(BST, Binary Search Tree) 이원 탐색트리의 탐색 INSERTION IN BST DELETION IN BST 선택 트리 승자 트리 패자 트리 분리 집합의 표현 이진 트리의 개수 계산 AVL 트리 AVL 트리에서의 삽입 트리(tree)란?트리 구조란 정보의 항목들이 가지로 연결될 수 있게 데이터가 조작되는 것이며, 가계표, 족보, 왕조의 나열 등에서 쉽게 찾아볼 수 있다.가계표를 예를 들어 설명을 하면 최 상단에 조부모님이 계시고 그 아래로 아버지와 어머니, 동생 친척들이 쭉 나열이 되는데, 이러한 조직 체계를 트리를 통해 나타낼 수 있다. 트리 구조에서 노드 란 각 항목들을 의미하며 한 정보 아이템에서 다른 노드로 뻗어진 가지를 포함한 개념이다.각 노드는 아래로 계속해서 가지를 뻗어나갈 수 있는데, 한 노드에서 뻗어져 나간 가지들(서브트리) 의 수를 그 노드의 차수 라고 부른다.또한, 차수가 0인 노드를 리프 혹은 단말 노드 라고 부르며, 뻗어나간 구조의 상위의 노드를 아래 노드의 부모(parent) 라 하고 아래 노드를 상위 노드의 자식(child) 이라고 부른다. 또한 한 노드에서 뻗어져 나온 병렬관계의 노드를 서로의 형제(sibling) 이라고 부른다. 특정 노드의 차수와 구분하여 트리의 차수 트리에 있는 노드의 최대 차수를 말한다. 이진 트리다시 가계표의 예를 들면 한 부모 밑에는 수많은 자식들이 생길 수 있으나, 컴퓨터가 이를 처리하는 시점에서 특정 부모노드 아래에 숫자를 알 수 없는 자식들이 존재하게 된다면 포인터 필드가 가변적이기에 효율적으로 메모리를 사용할 수 없다. 이 때문에 일정한 크기의 노드를 사용하기 위한 트리의 표현법이 나타나게 되었고, 한 노드가 가지만을 가지도록 만들어진 트리를 이진 트리 라고 한다. 제일 위의 노드(root)로 부터 2배씩 증가하며 가지들이 뻗어나와 크리스마스 트리 형태를 띄는 형태를 이진트리라고 부르며 모든 노드들이 규칙적으로 2개씩 가지를 쳐 나가 각 층의 노드가 꽉꽉 들어차면 이를 포화 이진 트리 라고 한다.깊이가 k인 포화 이진트리의 노드 수는 (2^k-1)개 이다. 컴퓨터에서는 이러한 이진트리를 메모리에 저장할 방법을 찾게 되었고 최 상단 노드부터 차례로 메모리에 저장을 하게 되면 포화 이진트리가 아닌 대부분의 이진트리에서는 메모리 중간 중간이 비게 되어 효율적인 메모리 사용에 어려움을 겪게 되었는데, 이를 해결하기 위해 열결표현 방식을 사용하여 각 노드가 다른 노드의 링크를 연결하여 포인터를 들고 있는 방식으로 저장하게 되었다. 어떠한 트리도 이진 트리로 표현할 수 있다. 다음은 C 언어를 이용한 이진 트리의 구현이다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;/*node 구조체로 *treePointer 라는 별칭 선언*/typedef struct node *treePointer;/*node 구조체를 선언한다.*/typedef struct node&#123; char data; treePointer leftChild, rightChild;&#125; node;treePointer createNode(char newData)&#123; treePointer newNode = (treePointer)malloc(sizeof(node)); newNode-&gt;leftChild = NULL; newNode-&gt;rightChild = NULL; newNode-&gt;data = newData; return newNode;&#125;void inorder(treePointer ptr)&#123; if(ptr)&#123; inorder(ptr-&gt;leftChild); printf(&quot;%c&quot;, (*ptr).data); inorder(ptr-&gt;rightChild); &#125;&#125;/*추가된 노드를 출력하는 부분*/int main()&#123; treePointer nodeA = createNode(&apos;A&apos;); treePointer nodeB = createNode(&apos;B&apos;); treePointer nodeC = createNode(&apos;C&apos;); treePointer nodeD = createNode(&apos;D&apos;); treePointer nodeE = createNode(&apos;E&apos;); treePointer nodeF = createNode(&apos;F&apos;); treePointer nodeG = createNode(&apos;G&apos;); treePointer nodeH = createNode(&apos;H&apos;); (*nodeA).leftChild=nodeB; (*nodeA).rightChild=nodeC; (*nodeB).leftChild=nodeD; (*nodeB).rightChild=nodeE; (*nodeD).rightChild=nodeG; (*nodeC).leftChild=nodeF; (*nodeF).rightChild=nodeH; inorder(nodeA);&#125; 이진 트리 순회앞서 설명한 이진 트리를 조회하기 위해서 다양한 방법을 사용하는데, 한 노드에서 왼쪽으로 이동(L), 오른쪽으로 이동(R), 노드 방문(V) 의 순서에 따라 중위 순회, 후위 순회, 전위 순회로 구분한다. 먼저 전위 순회(preorder traversal) 는 이름 그대로 노드를 먼저 방문하는 경우 즉, VLR의 순서로 노드를 방문하는 경우이다.후위 순회(postorder traversal) 은 노드를 제일 마직막에 방문하는 경우 즉, LRV의 순서로 노드를 방문하는 경우이다.중위 순회 란 노드를 중간에 방문하는 경우 즉, LVR의 순서로 노드를 방문하는 경우이다. 중위 순회를 하는 경우를 C 코드로 나타내면 다음과 같다.12345678void inorder(treePointer ptr)&#123; if(ptr)&#123; inorder(ptr-&gt;leftChild); printf(&quot;%c&quot;, (*ptr).data); inorder(ptr-&gt;rightChild); &#125;&#125; 위의 코드를 살펴보면 반복법이 아닌 순환법을 이용하여 즉, 스택의 도움 없이 순회를 진행하는데 이는 스택을 이용하여 스택에 노드를 저장하고 제거하는 방식으로도 순회가 가능하다. 이러한 순회를 반복적 중위 순회 라고 하며 이를 C 코드로 구현하면 다음과 같다.1234567891011121314void iterInorder(treePointer ptr)&#123; int top = -1; /*스택 초기화*/ treePointer stack[MAX_STACK_SIZE]; for(;;)&#123; for(;node;node=node-&gt;leftChild) push(node);/*스택에 삽입*/ node=pop();/*스택에서 제거*/ if(!node)/*스택이 비어있는 경우 중지*/ break; printf(&quot;%d&quot;, node-&gt;data); node=node-&gt;rightChild; &#125;&#125; 예제이진 트리에서 리프 노드의 수를 세는 C 함수를 작성하여라.123456789101112int totalCount=0;void countLeaf(treePointer ptr)&#123; if(ptr&amp;&amp;(!(*ptr).leftChild)&amp;&amp;(!(*ptr).rightChild))&#123; totalCount++; printf(&quot;\\n리프 노드: %c, count:%d\\n&quot;, (*ptr).data, totalCount); &#125; if(ptr)&#123; countLeaf((*ptr).leftChild); printf(&quot;%c&quot;,(*ptr).data); countLeaf((*ptr).rightChild); &#125;&#125; 스레드 이진 트리2n개의 링크 중 n+1개가 null link 이므로 효율성이 떨어지는 문제가 생기게 되고 이를 해결하기 위해 null link에 포인터를 넣어 다른 노드의 링크를 거는 것을 스레드 라고 한다. 이원 탐색 트리(BST, Binary Search Tree)이원 탐색 트리는 탐색, 삽입, 삭제 연산에 있어서 지금까지 공부했던 어떤 자료 구조보다도 성능이 좋다.이원 탐색트리의 모든 원소는 키를 가지고 어떤 두 원소도 동일한 키를 갖지 않으며, 왼쪽 서브트리가 존재한다면 그 키들은 루트의 키보다 작고 오른쪽 서브트리가 존재한다면 루트의 키보다 크다. 또한, 왼쪽과 오른쪽 서브트리도 모두 이원탐색 트리이다. 이원 탐색트리의 탐색탐색은 루트부터 시작하여 루트와 키 값이 같다면 탐색은 종료된다. 탐색하고자 하는 키 값이 루트의 키보다 작다면 왼쪽 서브트리를 탐색하고 크다면 오른쪽 서브트리를 탐색한다. 왼쪽과 오른쪽 서브트리는 모두 이원탐색 트리이므로 각각을 다시 탐색하는 순환 탐색 방식을 사용한다. 다음은 이원 탐색 트리의 순환적 탐색을 구현한 프로그램이다.1234567element * search(treePointer tree, int key)&#123; if(!root) return NULL; if(k == root-&gt;data.key) return &amp;(root-&gt;data); if(k&lt;root-&gt;data.key) return search(root-&gt;leftChild, k); return search(root-&gt;rightChild, k);&#125; 아래는 동일한 기능의 반복 함수로 구현한 프로그램이다.1234567891011element* iterSearch(treePointer tree, int k)&#123; white(tree)&#123; if(k==tree-&gt;data.key) return &amp;(tree-&gt;data); if(k&lt;tree-&gt;data.key) tree = tree-&gt;leftChild; else tree = tree-&gt;rightChild; &#125; return NULL;&#125; Time Complexity: O(h) BST 에서의 찾는 시간은 찾고자 하는 노드의 높이만큼 분기를 수행하므로 O(h) 이다. INSERTION IN BST Time Complexity: O(h) BST 에서의 삭제는 search 후에 단순 삽입으로 search 시의 time complexity와 같은 complexity 를 가진다. DELETION IN BST Time Complexity: O(h) BST 에서의 삭제는 다음과 같이 진행된다. BST에서 해당 노드를 찾음 해당 노드를 삭제하고, maximum value in left subchild 로 대체 하거나 혹은 minimum in right subchild 로 대체한다. 대체된 노드에 대한 삭제를 진행한다. 이 경우 해당 노드는 차수가 0이거나 혹은 1 이므로 삭제는 매우 간편하다. 위의 각 과정별로 시간 소모를 생각해 보면, 노드를 찾는데에 O(h), 삭제하고 서브 트리에서 값을 찾는데에 O(h) 삭제에 1 이므로 BST 에서 deletion 시에 time Complexity 는 O(h) 이다. 선택 트리승자 트리다음은 8개의 런(k=8) 을 가진 승자 트리의 개념도 입니다. 패자 트리다음은 위의 승자 트리에 대응하는 패자 트리의 개념도 입니다. 분리 집합의 표현이진 트리의 개수 계산AVL 트리AVL 트리란 균형 이진 트리의 한 종류이며, 이원 탐색트리가 항상 완전 이진트리로 유지되도록 한 트리입니다. 탐색, 삽입, 삭제 시간: O(logn) AVL 트리에서 각 노드는 균형 인자(balance factor) 를 가지는데, 이는 왼쪽 트리의 높이에서 오른쪽 트리의 높이를 뺀 값으로 높이의 균형도를 나타냅니다. balance factor = h_L - h_R AVL 트리에서는 어떤 서브트리 T 에서도 BF(T) 의 절대값은 1 이하입니다. AVL 트리에서의 삽입LL rotation RR rotationLR rotation","link":"/2018/03/27/자료구조-트리/"},{"title":"전자상거래 수업","text":"E비즈니스의 개요 디지털 혁명 구경제에서 신경제로 신경제는 곧 ‘지식경제’ - 지식경제라는 단어가 매우 중요하다. 신경제의 주요 특징 디지털 제품 및 서비스의 거래 증대 E비즈니스와 E커머스의 관계 이비즈니스 기술 인터넷 기술 인터넷의 개념적 이해 인터넷의 기술적 이해 인터넷의 애플리케이션 인트라넷과 엑스트라넷 월드 와이드웹의 기술 월드와이드웹의 개념 웹의 구성요소 / 시험 출제 웹 2.0 E비즈니스의 개요디지털 혁명 기본 경제 패러다임의 변화농경사회 -&gt; 산업화 사회 -&gt; 정보화 사회 디지털 경제(신경제)의 개념질량, 물질, 교통과 같은 물리적 세계의 한계가 무중력, 가상, 순산적 글로벌 이동과 같은디지털 세계의 장점으로 해소 가능 디지털 경제란?개인과 기업들이 디지털 네트워크 및 통신 기술 인프라를 기반으로 시공장벽에 구애받지 않고 상호대화, 협업 및 정보검색 할 수 있는 새로운 경제 IT 산업 비중의 증가 구경제에서 신경제로신경제는 곧 ‘지식경제’ - 지식경제라는 단어가 매우 중요하다.경제의 부가가치 창출이 인간두뇌에 의해 가능하다. 지식경영을 통해 기업이 지식을 수집, 창출, 축적하고, 구성원들 간의 지식 공유 및 활용으로 부가가치 창출 활동을 수행한다. 신경제의 주요 특징 지식: 창출 능력이 기업의 경쟁력의 원천이다. 디지털화: 모든 컨텐츠가 디지털 형태로 변환된다. 가상화: 실제적 사물을 가상세계에서 만나게 함 실제 생활의 위험상황을 배제하여 가상에서 구현하여 체험과 학습이 가능하게 해 준다. 분자화: 조직의 구성원들이 팀으로 재구성됨 통합화/네트웍화: 네트워크에 의해 상호 연결, 통합 비중개화: 네트워크로 중개자의 역할이 사라짐 융합화: 디지털 기기들 간의 융합화 방, 통 융합 혁신: 지속적인 변화와 개선을 추구함 고객중심 생산: 소비자들이 생산과정에 참여제품의 설계 및 개발에 소비자들이 참여함사용자의 니즈를 명확하게 반영한 소비자 시장에 집중해야 즉시성: 시간기반 경쟁으로 신속한 대응능력이 중요 글로벌화: 글로벌 고객들이 니즈 충족 이슈충돌: 사회적 이슈들에 대해 논쟁이 확대됨 디지털 제품 및 서비스의 거래 증대 디지털 컨텐츠뉴스, 사진이미지, 동영상, 음악, 게임, 애니메이션, 논문, 발표자료 등DRM 기술의 부상 디지털 서비스금융, 여행, 중개 등인터넷을 통해 서비스 제공과정을 자동화할 수 있어 효율성 증대 디지털 매체디지털 TV, 디지털 라디어, 동영상, 디지털 음악 등콘텐츠나 서비스를 온라인으로 전달할 수 있는 수단 E비즈니스와 E커머스의 관계유입물류, 조업, 유축물류, 서비스, 마케팅 및 판매를 아우리는 개념이 E비즈니스 이며E 커머스는 위 내용 중 마케팅 및 판매만을 포함한다. 이비즈니스 기술인터넷 기술인터넷의 개념적 이해인터넷이란? 인터넷이란 전세계의 수만 개의 네트워크들을 상호연결한다는 의미를 지닌 Internetwork의 줄임말이다. 개인 관점에서의 인터넷의 의미 생활에 필요한 정보를 접할 수 있는 새로운 매체로 부상 방송, 인쇄물과 같은 기존의 오프라인 매체를 보완할 수 있는 온라인 매체로서의 역할을 담당 인터넷이 개인에 주는 큰 의미는 바로 개인이 거대 기업과 싸울 힘을 가지게 되었다는 데에 있다. 인터넷을 통해 한 개인은 전 세계와 연결되어 자신의 영향력을 발휘할 수 있는 수단이 된다. 기업 관점에서의 인터넷의 의미 기업 내부 프로세스를 효율화하고 조직의 솓고 및 유연성을 증대시키는 수단 상거래를 할 수 있는 추가적인 판매 채널 인터넷의 유래 미국방부가 1969년 연구목적으로 구축한 ARPANET이 인터넷의 전신이다. 초기에는 주로 국방연구 프로젝트를 위해 이용되었고 차츰 외부 연구소 및 대학들도 연결되면서 연구용도 망으로 발전하였다. 이후 교육 및 연구 목적의 학술망으로 발전하였다. 1985년 미과학재단(NSF)의 지원에 의해 NSFNET가 구축되면서 대학에서의 교육 및 연굴를 지원하는 학술망으로 진화발전하였다. 인터넷의 상용화와 함께 세계규모의 망으로 확대되었다. 인터넷의 기술적 이해패킷교환 방식 전송하고자 하는 메시지를 작은 패킷 단위로 나누어 전송하고 또 패킷이 도착하면 다시 패킷들을 본래 메시지로 조합하는 이른바 패킷교환 방식을 이용한다. 인터넷의 전송방식 패킷교환 방식이란? 인터넷에서 전송하고자 하는 메시지를 작은 패킷 단위로 나누어 전송하고, 패킷이 도착하면 다시 패킷들을 본래 메시지로 조합하는 방식 메시지 전체가 한꺼번에 전송될 필요 없이 통신경로를 따라 패킷들이 각각 독립적으로 이동하므로 전송이 더 효율적이며 빠름 회선교환 vs 메시지 교환 vs 패킷 교환 회선교환의 대표적인 예는 유선 전화망이다. 회선 교환:송신자와 수신자 간의 토신회선 전체가 동시에 열려있어야 메시지 전송이 가능하므로, 주로 전화망에서 이용된다. 메시지 교환:회선이 동시에 열릴 필요는 없지만, 한번에 메시지 전체가 구간, 구간을 이동하므로 전송이 크게 지연될 수 있음 패킷교환:패킷들이 트래픽 상황에 따라 유연하게 이동하므로 지연시간을 최소화하며 전송속도를 극대화할 수 있음 패킷의 구성 헤더 안에 어떤 정보가 들어가는지 알아야함 개별 패킷은 헤더 및 데이터로 구성되어 있으며, 패킷들이 모두 도착했을 때 고정길이의 이들 패킷ㅇ르 조합함으로써 본래 메시지를 재생할 수 있다. 프로토콜의 필요성 및 개념 컴퓨터기술의 발전과 함께 소프트웨어 및 하드웨어의 이질성이 점차 심화됨 네트워크상의 이질적 컴퓨터들 간에 통신이 이루어지기 위해서는 서로 약속된 통신규약이 필요한데, 이를 프로토콜이라고 함 예전의 기업고유 표준은 정보공유가 쉽지 않았던 반면, 최근에는 보편적 성격을 띤 산업표준, 즉 개방형 프로토콜이 요구되고 있음 다양한 기종의 컴퓨터들이 함께 존재하는 네트워크에서는, 하드웨어 및 소프트웨어가 모두 동일 프로토콜을 적용하여 제작되어야만, 상호통신이 가능함 TCP/IP 프로토콜 하드웨어 및 통신기기 제조업체들이 공통적으로 적용할 수 있도록 만든 통신 규약, 이기종 컴퓨터기기들 간의 상호 호환성 및 접속성을 제공하기 위해 개발, 인터넷을 누구나 접속가능한 네트워크가 되게 하는데 핵심적 역할을 담당 HTTP HyperText Transfer Protocol 웹환경에서 웹페이지 문서를 이용자에게 전달하기 위해 이용되는 인터넷 프로토콜 SMTP Simple Mail Transfer Protocol 이메일 관련 프로토콜이다. 이메일 송신에 관련되 프로토콜이다. 1980년대에 개발된 문자열 위주의 이메일 프로토콜로서, 서버로 이메일을 전송하는데이용됨 POP 및 IMAP 이메일 수신에 관련된 프로토콜 이다. Post Office Protocol 및 Internet Message Access Protocol SMTP를 통해 서버로 전달된 메일을 수신하기 위해 이용됨 FTP File Transfer Protocol 인터넷 환경에서 서버와 클라이언트 컴퓨터 사이에 파일을 서로 주고 받을 수 있는 프로토콜 인터넷의 애플리케이션 이메일 인스턴트 메시징실시간 검색 엔진 스트리밍 미디어 재생인터넷에서 동영상을 재생할 때 사용됨. 인터넷 전화(VoIP)Voice Over IP 인터넷 TV 인트라넷과 엑스트라넷월드 와이드웹의 기술월드와이드웹의 개념월드와이드웹이란? 웹의 구성요소 / 시험 출제하이퍼텍스트 웹서버와 웹클라이언트 웹 브라우저 HTML XML eXtensible Markup Lnaguage HTML이 화면 표시 모양을 만들어 내기 위한 언어라면, XML은 데이터 및 정보를 정의하기 위한 언어이다. 웹 2.0제 2세대의 웹기반 커뮤니티 및 서비스를 의미한다. 웹 2.0 이란? 사용자들이 웹 브라우저만을 통해 소프트웨어 프로그램들을 실행할 수가 있게 되었다. 과거의 웹사이트환경에서는 방문자가 콘텐츠를 받아보는 기능으로만 제한된 반면, 2.0은 참여적 웹이며, 정보원으로서의 웹은 웹 1.0 이다.","link":"/2017/11/15/전자상거래-수업/"},{"title":"컴퓨터 구조 | 캐시(cache)","text":"캐시란 무엇인가요? 캐시에 데이터 쓰기 캐시 성능의 측정 캐시 성능의 향상 유연한 블록 배치를 통한 캐시 실패 줄이기 완전 연관 방식 집합 연관 방식 다단계 캐시를 이용한 실패 손실 줄이기 캐시란 무엇인가요?캐시란 메모리와 프로세서 사이에 있는 메모리 계층을 나타내기 위해 선택된 이름이며, 오늘날 대부분의 컴퓨터가 캐시 메모리를 사용하고 있습니다.위의 도서관에서의 예처럼 캐시는 ‘책상’ 의 역할을 수행합니다. 우리는 도서관에서 책상위의 책들을 뒤적거려 책을 찾는다면 캐시는 어떻게 정보를 찾을 까요? 캐시는 다양한 형태로 구성되지만 이번 강의에서는 가장 대표적인 캐시 내의 정보를 찾는 방법으로 직접 사상 캐시 를 기반으로 하여 설명을 진행합니다. 직접 사상 이란 바로 메모리 주소에 기반하며 메모리 주소 하나당 캐시 내의 정확한 하나의 물리적 위치가 사상되는 방식입니다. 이러한 직접 사상 방식에서 실제 물리 메모리는 주소값 을 가지는데 이 주소값의 마지막 몇자리를 인덱스로 하여 캐시에 저장이 됩니다. 가령 물리 메모리의 주소값이 0101100101 이고, 블록의 수가 8개 라면 끝의 3자리(log2_8)는 인덱스 필드로 캐시 내에서의 주소를 담당합니다.모든 직접 사상 캐시는 블록을 찾기 위하여 다음의 사상 방식을 사용합니다. (블록주소) modulo (캐시 내에 존재하는 전체 캐시 블록 수) 위의 사상 방식을 따르면 10101011, 11101011, 00101011 처럼 끝의 인덱스 필드가 같은 메모리의 정보들을 캐시 메모리에서 같은 블록에 사상될 것입니다. 이렇게 되면 가져온 블록이 정말 원하는 정보인지 알 수 있어야 하며 이를 위해 태그 필드가 존재합니다. 이 태그 필드는 주소 중에서 인덱스 필드를 제외하고 남은 숫자들이며 이를 통해 해당 블록이 찾고자 하는 블록인지 알 수 있습니다. 캐시 블록은 항상 유효한 숫자를 가지고 있을까요?만약 캐시가 비어있고나 혹은 올바르지 못한 값을 가지고 있는 경우가 있을 수 있습니다. 심지어 이 데이터는 물리 주소에 없는 값일 수도 있고요, 그렇다면 이러한 블록을 어떻게 표기해야 할까요?이를 위해 캐시에는 유효 비트 라는 것이 존재합니다. 이 비트가 1로 설정되어 있지 않으면 유효한 블록이 없는 것으로 간주합니다. 이처럼 캐시는 예측 기법 을 통해 자료의 찾는 속도를 빠르게 해 주는 역할을 하며, 현대 컴퓨터에서 캐시 예측 적중률은 95% 이상입니다. 필요한 캐시의 사이즈는 어떻게 알 수 있나요?필요한 캐시의 사이즈는 전체 블록의 수와 블록의 크기를 가지고 알 수 있습니다.여기서 가장 중요한 점은 캐시는 몇개의 블록으로 구성되지만 블록이 정확한 값을 들고 있는지 알기 위해서 태그 필드 와 유효 비트(1비트) 를 별도로 필요하게 되며, 이것은 블록의 사이즈와 별도로 필요한 공간 이라는 점입니다. 또한, 인덱스 필드 의 경우는 캐시 메모리에 영향을 주지 않는데, 그것은 바로 인덱스 필드는 별도로 비트 필드를 가지지 않아도 하드웨어에서 물리적인 주소로 바로 연결이 되는 것이기 때문에, 인덱스를 가르쳐 주기 위한 별도의 비트는 필요하지 않습니다. 예를 들어,32비트의 직접 사상 캐시가 있고, 2^n개 블록 을 가지고 있다고 하면 당연히 n개의 비트는 인덱스 필드 에 사용됩니다.또 실제 캐시에서는 블록의 크기가 1워드보다 보통 크기 때문에, 만약 블록의 크기가 2^m개 워드 라고 하면 m개 비트는 블록 내부에서 워드를 구분 하는 데에 사용되며 하나의 워드는 4바이트로 구성되므로 2 개의 비트는 주소 중 바이트 구별용 으로 사용됩니다. 이 경우 태그 필드의 길이는 32-(m+n+2) 가 되며, 직접 사상 캐시의 전체 비트 수는2^n * (블록 크기+태그 크기+유효 비트 크기) 이므로 2^n _ (2^m _ 32 + 32-n-m-2 + 1) = 2^n(32*2^m+31-n-m) 비트 이다. 캐시 실패의 경우는 어떻게 처리되나요?만약 캐시에서 원하는 정보를 찾지 못하는 경우에는 임시 레지스터와 프로그래머에게 보이는 레지스터의 내용을 그대로 유지한 채 메모리로부터 데이터가 오기를 기다리면서 전체 시스템이 지연되게 됩니다. 캐시 실패의 처리 단계는 다음과 같습니다. 원래의 PC값(현재 PC 값 -4)을 메모리로 보낸다. 메인 메모리에 읽기 동작을 지시하고 메모리가 접근을 끝낼 때까지 기다린다. 메모리에서 인출된 데이터를 데이터 부분에 쓰고, 태그 필드에 주소의 상위 비트를 쓰고 유효 비트를 1로 만들어서 캐시 엔트리에 쓰기를 수행한다. 명령어 수행을 첫 단계부터 다시 시작하여 캐시에 명령어를 가져온다. 이제는 필요한 명령어를 캐시에서 찾을 수 있다. 캐시에 데이터 쓰기캐시에 데이터를 수정하고 저장하는 경우 데이터 캐시에만 작성 되고 메인 메모리에는 쓰지 않아지는 불일치 가 나타날 수 있습니다. 이를 해결하는 방법 중 하나는 즉시쓰기(write through) 이며, 통해 데이터를 항상 메모리와 캐시에 동시에 작성하게 됩니다. 하지만 이는 프로세서의 성능을 심하게 저하시키고 보통은 쓰기 버퍼 를 활용하여 일단 캐시에만 작성하고 천천히 메모리에 작성되는 방식으로 처리합니다. 두번째 방법은 나중 쓰기(write-back) 입니다.이 방식에서는 쓰기가 발생했을 때 새로운 값을 캐시 내의 블록에만 쓰고, 나중에 해당 블록이 캐시에서 쫓겨나는 경우 쓰기에 의해 내용이 바뀐 블록이라면, 메모리 계층 구조의 더 낮은 계층에 씌어집니다. 두 방식 모두 장단점이 있는데 이는 다음과 같습니다. 나중쓰기(write-back) 의 장점 각각의 워드는 프로세서에 의해 메인 메모리가 아닌 캐시가 받아들일 수 있는 속도로 쓰인다. 다수의 쓰기가 행해진 블록을 계층의 하위 계층에 한 번만 쓰면 된다. 블록들이 하위 수준에 쓰일 때, 전체 블록을 한꺼번에 쓰기 때문에 높은 대역폭을 효과적으로 사용할 수 있다. 즉시쓰기(write-through) 의 장점 실패가 발생해도 하위 수준 블록을 쓸 필요가 없으므로 간단하고 비용이 적게 든다. 즉시 쓰기는 나중 쓰기보다 구현이 간단하다, 하지만 실제적으로 즉시 쓰기 캐시는 쓰기 버퍼를 요구한다. 가상 메모리 시스템에서는 계층의 하위 수준에 쓰기를 수행할 때 매우 큰 지연시간이 발생하기 때문에 나중 쓰기 방식이 유일한 실용적인 대안이다. 캐시 성능의 측정캐시가 무엇인지 알았다면 실제 캐시의 성능을 측정하고 분석하는 방법을 배워 봅시다. 캐시의 성능을 측정할 때의 기준은 필요한 메모리를 인출한 시간이라고 볼 수 있으며, 그에 따른 CPU 시간은 다음과 같습니다. CPU 시간 = (CPU 클럭 사이클 + 메모리 지연 클럭 사이클) X 클럭 사이클 시간 위의 식에서 메모리 지연 클럭 사이클은 주로 캐시 실패 때문에 생기며 다음과 같이 읽기 지연 사이클과, 쓰기 지연 사이클로 나누어 지며 그 값 또한 다음과 같이 계산 할 수 있습니다. 메모리 지연 클럭 사이클 = 읽기 지연 사이클 + 쓰기 지연 사이클 읽기 지연 사이클 = 읽기 접근 횟수 / 프로그램 X 읽기 실패율 X 읽기 실패 손실 쓰기 지연 사이클 = (쓰기 접근 수 / 프로그램 X 쓰기 실패율 X 쓰기 실패 손실) + 쓰기 버퍼 지연 캐시 성능의 향상앞에서는 직접 사상 으로 구성된 캐시와 캐시의 성능 측정에 대해 알아보았습니다. 이번에는 캐시의 성능을 향상시키기 위한 방법을 알아봅시다. 유연한 블록 배치를 통한 캐시 실패 줄이기기존에는 메모리 블록을 캐시에 넣을 때 각 블록이 캐시의 정확한 한 곳에만 들어갈 수 있는 단순한 배치 방법을 사용하였고, 이를 직접 사상 이라고 불렀습니다. 하지만, 실제로는 블록을 배치하는 다양한 방법이 존재하는데, 블록의 배치 방법에 따라 완전 연관 방식 과 집합 연관 방식 이 있습니다. 완전 연관 방식완전 연관 방식에서는 블록이 캐시 내의 어느 곳에나 위치할 수 있으며, 때문에 블록 하나를 찾기 위해서 캐시 내의 모든 엔트리를 검색해야 합니다. 물론 이러한 방법은 하드웨어 비용을 크게 증가시키기 때문에 블록을 적게 갖는 캐시에서만 유용합니다. 집합 연관 방식 집합 연관 방식 은 직접 사상과 완전 연관 사상의 중간 방식입니다. 집합 연관 사상 캐시에서는 한 블록이 들어갈 수 있는 자리가 고정되어 있습니다. 가령 각 블록당 n개의 배치 가능한 위치를 갖는 집합 연관 캐시가 있다면 이를 n-way 집합 연관 캐시라고 부릅니다. 집합 연관 방식에서 메모리의 각 블록은 인덱스 필드에 의해 캐시 내의 한 집합으로 사상 되며, 때문에 일치하는 블록을 찾기 위해서는 집합 내의 모든 블록들을 검색 하여야 합니다. 직접 사상 캐시는 단순히 1-way 집합 연관 캐시라고도 볼 수 있습니다. 이렇게 연관 정도를 늘리는 것의 장점은 대개 실패율이 줄어든다는 것이며, 단점은 적중 시간의 증가입니다.그 이유는 간단히 생각해 보면 이해할 수 있습니다. 가령 특정 블록을 찾을 때에 기존의 직접 사상 방식에서는 하나의 인덱스에 오직 하나의 블록만이 들어갈 수 있기 때문에, 다른 블록이 들어왔다면 기존의 블록을 삭제하고 새로운 블록을 저장하기 때문에 실패율이 높을 수 밖에 없습니다. 하지만 연관 방식 사상 을 통해서는 하나의 인덱스가 집합을 이루고 과거에 찾아진 블록이 해당 집합에 들어 있다면 캐시에 저장되어 있어 찾을 수 있으므로 실패율이 줄어들게 됩니다. 단점인 적중 시간의 증가도 같은 원리로 만약 하나의 블록을 특정 집합에서 찾았다면 기존의 직접 사상 방식에서는 각 집합마다 블록이 유일하게 존재하므로 집합 내에서 검색이 필요하지 않았습니다. 하지만 n-way 집합 연관 방식에서는 특정 집합을 찾을 이후에도 집합 내에서 n 개의 엔트리 중에서 일치하는 태그인 블록을 찾는 시간이 추가되기 때문에 적중 시간이 증가 하게 됩니다. 집합 연관 방식에서 집합 내의 블록은 어떻게 교체될까요?집합 연관 방식 사상을 할 때 집합 내에는 정해진 수의 블록 만이 들어갈 수 있으므로, 집합이 가득 찾다면 기존의 블록이 새로운 블록으로 교체되어야 합니다. 이 경우 가장 많이 쓰이는 방법은 LRU 교체 방식 을 사용합니다. 즉, 가장 오래전에 사용된 블록이 교체 됩니다. 집합 연관 방식에서는 캐시 내에서 블록을 어떻게 찾을까요?직접 사상 캐시에서와 같이 집합 연관 캐시 내의 블록도 블록 주소를 나타내는 주소 태그 를 가지고 있습니다. 선택된 집합 내 모든 블록의 태그는 프로세서로 부터 나온 태그와 일치하는 지를 검사하게 됩니다. 여기서 빠른 속도가 매우 중요하기 때문에 선정된 집합 내 모든 태그는 병렬로 검색이 수행됩니다.완전연관 캐시 의 경우에는 실제로 한 개의 집합 만이 존재하며 모든 블록들은 병렬로 검사가 되게 됩니다. 다단계 캐시를 이용한 실패 손실 줄이기현대의 모든 컴퓨터는 캐시를 사용하고 있으며, 프로세서의 빠른 클럭 속도와 상대적으로 점점 느려지는 메모리 접근 시간 사이의 차이를 줄이기 위해, 고성능 마이크로프로세서들은 캐시를 한 계층 더 사용합니다. 여기서 각 단계의 캐시들을 L1, L2, L3, L4 로 부르고 각각은 1차, 2차, 3차, 4차 캐시를 의미합니다.다단계 캐시를 이용한 CPU 에서 1차 캐시에서 미스가 발생하면 2차 캐시에서 다시 검색을 하고 2차 캐시에서도 미스가 발생하면 메인 메모리 접근이 필요하게 되고 더 큰 실패 손실이 발생하게 됩니다. 1차 캐시와 2차 캐시의 설계 시에는 각자 다른 것을 우선시 합니다. 가령 1차 캐시의 경우에는 어차피 실패를 해도 2차 캐시에서 데이터를 찾는 작업이 일어나므로 메모리 접근이 필요 없기 때문에 실패율이 그다지 높지 않아도 됩니다. 대신, 제일 많이 접근이 되는 만큼 적중 시간의 최소화 에 초점을 맞추어 설계를 진행합니다. 반대로 2차 캐시 의 경우에는 실패가 일어나면 메인 메모리 접근이 필요하게 되기 때문에 긴 메모리 접근 시간으로 인한 손실을 줄일 수 있도록, 실패율이 중점을 맞춘 설계 를 합니다. 같은 원리로 1차 캐시는 실패 손실을 줄이기 위해 블록 크기가 더 작으며, 2차 캐시는 실패율을 줄이기 위해 크기가 더 크고, 높은 연관정도가 많이 사용된다.","link":"/2018/04/08/컴퓨터-구조-캐시/"},{"title":"컴퓨터 구조 | 파이프라이닝 이란?","text":"파이프라이닝이란 파이프라인 해저드 구조적 해저드 데이터 해저드 제어 해저드(control hazard) / 분기 해저드(branch hazard) 본 강의에서는 컴퓨터 구조에서 파이프라이닝 이 무엇이며 어떤 역할을 수행하는 지를 알아봅니다. 파이프라이닝이란파이프라이닝 이란 마치 조립 라인처럼 어떤 명령어가 중첩되어 실행되는 구현기술입니다.보통 파이프라이닝을 설명할 때에는 세탁소에서 세탁을 하는 절차를 비유하여 많이 이용하며 세탁소가 세탁을 하는 절차를 컴퓨터에 빗대어 설명을 해보도록 하겠습니다.세탁소에서 세탁을 하기 위해서는 먼저 다음과 같은 순서로 세탁물을 처리합니다. 세탁기에 한 아름의 더러운 옷을 넣는다. 세탁기 작동이 끝나면 젖은 옷을 건조기에 넣는다. 건조기 작동이 끝나면 건조된 옷을 탁자 위에 놓고 접는다. 접는 일이 끝나면 같은 방 친구에게 옷을 장롱에 넣어달라고 부탁한다. 하지만, 위 순서대로 차례차례 일을 진행하는 것 만큼 바보같은 짓은 없을 것이다.세탁기가 다 돌아가기를 기다렸다가 세탁이 다 되면 젖은 옷을 건조기에 넣고 건조기가 다 돌아가면 접어서 장롱에 넣는 일련의 전차들은 사실 각 단계 를 담당하는 별도의 자원(세탁기, 건조기, 나, 친구) 들이 있는 한은 모두 동시에 처리될 수 있다. 이 작업을 파이프라이닝을 한다면 다음과 같을 것이다. 첫번째 빨래가 다 돌아가면 건조기에 빨래를 넣고 나는 다시 세탁기에 옷을 집어 넣는다. 건조기와 세탁기가 다 돌아가면 나는 건조된 옷을 접고, 세탁이 된 빨래를 건조기에 넣고, 새로운 빨래를 세탁기에 넣는다. 옷을 다 접었으면 친구에게 옷을 장롱에 넣어달라고 하고, 다시 빨래를 개고, 건조기에 세탁이 된 옷을 넣고, 새로운 빨래를 세탁기에 넣는다. 위처럼 동시에 처리 가능한 일들을 동시에 처리함으로써 처리량 을 올리는 것이 파이프라이닝의 핵심이다. 이 경우 중요한 점은 각 단계를 수행하는 속도가 빨라지지는 않느다는 점이다. 모든 단계는 원래의 동작속도대로 일을 해 나가지만 병렬적으로 처리를 함으로써 쉬는 시간을 없애어 전체 처리량 을 올려 많은 작업을 빠른 시간 내에 처리 할 수 있도록 하는 것이다. 위 과정에서 알 수 있듯이 할 일이 충분히 많다면 파이프라이닝에 의한 속도 향상은 파이프라인의 단계 수와 같다. 위의 예에서는 세탁, 건조, 빨래 개기, 장롱에 넣기 의 4 단계로 파이프라이닝이 진행되므로 4배 빠른 시간에 작업량을 처리 한 것이 되고 처리량은 4배 증가 한 것이 된다. 여기서 또 유의깊에 보아야 할 부분은 각 단계별 걸린 시간이다.세탁, 건조, 개기, 넣기 4가지의 작업을 하는 각 단계별로 걸리는 시간은 물론 전부 다를 것이다. 하지만, 파이프라이닝을 한 경우에 우리는 제일 빠른 단계의 작업이 끝나도 전체 작업이 다 끝나는 것을 기다렸다가 다음 단계로 넘어갈 수 밖에 없다. 가령 건조가 빨리 다 끝나더라도 세탁기가 덜 돌아갔다면 세탁기가 다 돌아가기를 기다려야 하는 것이다. 컴퓨터 시스템에서 이러한 한 단계를 처리하는 시간을 컴퓨터의 클럭 사이클 이라고 하며, 파이프라이닝에서 클럭 사이클은 전체 단계 중 가장 시간이 오래걸리는 것을 기준으로 한다. 이처럼 이상적으로 파이프라인 프로세서에서 속도향상은 파이프 단계 수와 거의 같아야 하지만 위와 같은 문제 때문에 향상 률은 단계수보다는 조금 적으며, 파이이프라이닝 되지 않은 컴퓨터와 파이프라인 컴퓨터에서의 실제 프로그램의 전체 실행시간의 비율은 명렁어 사이의 시간 비율에 가깝다. 파이프라인 해저드각 명령어가 다음 클럭 사이클에 실행되지 못하는 상황을 파이프라인 해저드라고 하며 3가지 종류의 해저드가 있다. 구조적 해저드첫번째 해저드는 구조적 해저드 라 불리는데, 이는 가은 클럭 사이클에 실행하기를 원하는 명령어의 조합을 하드웨어가 지원할 수 없기 때문에 발생하는 해저드이다.가령, 세탁소의 예를 들면 세탁기와 건조기가 붙어있다던지, 혹은 장롱에 개어진 세탁물을 넣어줄 친구가 없다던지 하는 경우이다. 이러한 해저드를 없애기 위해서는 설계자가 파이프라인을 설계하는 시점에서 구조적 해저드를 피하는 것이 비교적 용이하다. 데이터 해저드두번째 해저드인 데이터 해저드 는 어떤 단계가 다른 단계가 끝나기를 기다려야 하기 때문에 파이프라인이 지연되는 경우 생기는 것으로, 컴퓨터 파이프라인에서는 앞선 명령어에 종속성을 가질 때데이터 해저드가 일어난다. 가령, add 명령어를 사용하여 %s0 레지스터에 값을 저장하고, 바로 다음 명령어에서 sub 명령어 혹은 기타 명령어를 통해 &amp;s0에 저장된 값을 사용하는 경우 첫번째 명령어에서 미처 데이터가 레지스터에 저장되기도 전에 해당 레지스터를 참조하게 되어 연산이 이루어 질 수가 없게 된다. 이를 해결하기 위한 방법 중 하나는 바로 전방전달(forwarding) 혹은 우회전달(bypassing) 이다.이것은 별도의 하드웨어를 추가 하여 정상적으로는 얻을 수 없는 값을 내부 자원으로부터 일찍 받아오는 것을 의미하는데, 레지스터나 메모리에 아직 나타나지 않은 데이터를 기다리지 않고 데이터패스를 추가로 하드웨어에 연결하여 내부 버퍼로 부터 가져오는 것이다. 앞의 add 연산 뒤에 바로 sub 연산을 처리하는 경우를 예로 들면, 하드웨어 자체에 앞에서 계산한 결과가 나오는 부분에서 다음 연산의 뺄셈의 입력 부분으로 새롭게 데이터 패스를 연결하여 데이터가 레지스터에 씌어지기 전에 비트값으로 값을 받아와 연산에 활용하여 데이터 해저드 를 해결 할 수 있다. 하지만, 위의 예인 add와 sub 연산의 연속적 사용이 아닌 데이터 적재 명령어를 사용하는 경우 문제는 더 커진다. 이 경우에는 메모리의 적재까지 4단계 정도의 오랜 시간이 소요되고 이것을 기다리는 것은 너무도 큰 성능 저하를 불러 일으키는데 이러한 적재 명령어 사용에 따른 데이터 해저드를 별도로 적재 사용 데이터 해저드 라고 부른다. 이것은 파이프라인 지연(pipeline stall) 의 대표적인 예이며 거품(bubble) 이라는 별명으로도 지칭된다. 제어 해저드(control hazard) / 분기 해저드(branch hazard)세번째 해저드인 제어 해저드 는 분기 명령어 처럼 다른 명령어들이 실행 중에 한 명령어의 결과 값에 기반을 둔 결정 을 할 필요가 있을 때 일어납니다.보다 쉽게 이해하기 위해 다시 세탁소의 예를 들어봅시다. 어떤 세탁소의 점원이 옷들을 세탁할 때 세탁 세제와 물의 온도를 선택함에 있어 옷들이 상하지는 않는 한도 내에서 강한 세제와 높은 온도를 통해 옷을 깨끗하게 세척을 해야 합니다. 하지만, 이 때 세탁소의 점원은 그 옷의 성질을 알지 못하므로 일단 한번 세탁을 한 뒤 말려보아야 올바른 세탁 세제와 물의 온도를 사용했는지를 알 수 있습니다. 이를 해결하기 위해서는 다음과 같은 세가지 해결법 이 있습니다. 지연 첫번째는 지연 으로, 첫번째 묶음의 옷들이 건조될 때까지 그냥 순차적으로 작업하되 올바른 비율이 결정될 때까지 계쏙 순차적 작업을 반복하는 것입니다. 위의 세탁소의 예를 들면 일단 옷을 세탁하고 말리는 작업까지를 했다면 그 결과값이 나올때까지 다음 세탁을 대기한 뒤 결과가 나오면 다시 파이프라이닝을 시켜 세탁을 시작합니다. 하지만, 이렇게 계속 반복적으로 분기 명령어 마다 지연을 시킨다면 훨씬 더 큰 속도 저하를 초래할 것입니다 때문에 다른 방법을 필요로 하게 되었고 만들어 진 것이 예측 기법입니다. 예측 예측을 수행하는 가장 간단한 방법은 분기가 항상 실패한다고 예측하는 것 입니다. 예측이 옳으면 파이프라인은 최고 속도로 진행되고, 실제로 분기가 일어날 때만 파이프라인이 지연이 됩니다. 좀 더 정교한 버전은 동적 하드웨어 예측기 를 이용하는 것으로 각 분기가 일어났지는 지록함으로써 최근의 과거 이력을 사용하여 미래를 예측하는 것입니다. delayed branch 세번째 방법은 분기 지연 입니다. 이 방법은 분기가 필요한 명령어의 결과값이 나오는 동안 해당 분기와 관련이 없는 다양 명령어를 먼저 실행하여 시간이 지연되지 않도록 하는 방법이며, 이를 위해서는 명령어를 적합한 순서에 따라 배치해야하며 주로 컴파일 최적화 를 통해 이루어 질 수 있습니다.","link":"/2018/04/07/컴퓨터-구조-파이프라이닝-이란/"},{"title":"비즈니스 기획","text":"경쟁사 분석과 비즈니스 환경 분석경쟁 환경에서 기업을 운영하려면 경쟁사에 대해 충분히 꿰뚫고 있어야 한다.이는 경쟁사를 모방하기 위해서가 아니라 그들과 차별화된 전략을 모새하기 위해서이다.경쟁사와 비즈니스 환경에 대한 이해가 깊을 수록 성공적인 전략 수립에 한발 다가선 것이다. 진짜 경쟁사를 찾아라진정한 경쟁사를 파악하는 것은 매우 중요하다.이는 단순히 같은 시장을 두고 제품이나 서비스를 공급하는 다른 기업을 말하는 게 아니라 우리의 목표 고객을 빼앗아 가는 기업을 의미한다.모든 고객을 목표로 삼아야 한다고 생각하는 리더에게는 이것이 별것 아닌 문제로 보일 수 있지만 모든 고객을 잡을 수 있는 회사는 없다. 예를들어 사우스 웨스트항공은 대형 고속버스 회사인 그레이하운드와 철도회사인 암트랙을 다른 항공사들보다 더 중요한 경쟁사로 보고 있다.사우스웨스트가 목표로 잡은 고객은 육상 교통편보다 비싼 요금을 내고서는 절대로 비행기를 타지 않으려는 알뜰한 여행자들이기 때문이다. 경쟁사 분석서 작성 예시1234567891011121314151. 위치 : 시카고2. 대표이사 : 로버트 스미스3. 제품/서비스 : 종이, 판지, 열성형 플라스틱으로 만든 속포장재 및 겉포장재4. 목표 시장 : 제빵, 제과업계, 포장용 건조식품업계5. 경쟁사를 능가하는 본사의 제품/서비스와 세분시장 : 없음6. 매출액 : 1200만 달러7. 당기순이익 : 50만 달러8. 직원 수 : 120명9. 성장률 : 연 21%10. 뚜렷한 특정/고객 혜택 : 청결한 공장, 높은 신뢰성, 적시 공급11. 경쟁적 강점 : 높은 인지도, 우수한 기술력 및 서비스, 빠른 배송, 낮은 부채 비율12. 경쟁적 약점 : 원가 대비 낮은 단가, 공개시장에서 원자재 구입, 기술력이 우수하기는 하나 브라운 사보다 뒤떨어짐13. 최근의 주요 사건 : 디자인 및 실험 연구소 설치14. 경쟁 전략 : 특제품/틈새시장15. 취약점 : 가격 경쟁력이 떨어짐 비즈니스 환경에 영향을 주는 요인들기술, 공급자, 전반적인 경제 상황, 시장 규제 사항은 매우 중요한 요소이다. 시장의 기술을 평가하라현재 시장에서 각광받고 있는 주요 최첨단 기술은 무엇인가?다음과 같은 기술의 종류가 있다. 제품 기술 : 고객에게 제공할 제품 및 서비스와 관련된 기술 제조 공정 기술 : 제품을 만들거나 서비스를 제공하기 위해 거치는 과정과 관련된 기술 서비스 기술 : 제품과 서비스의 판매, 유통 또는 공급과 관련된 기술 예를들어 모터용 연결장치를 생사하는 있다고 한다.이 모터용 연결장치는 100년도 훨씬 이전부터 생산되어 오던 제품이지만 이 회사는 여전히 그 분야에서는 기술력이 생명이라고 생각한다.기술은 그 제품 자체에는 영향을 미치지 않지만 회사가 그 제품을 생산하는 방식에는 영향을 미치고 있다.선반 위에 금속얼 얹어 압형하던 전통적 방식에서 벗어나 이제는 금속 가루로 형태를 뜨고 있다.재래식 기술 대신 비교적 새로운 제주 기술을 갖추어 비용을 절감하고 품질을 향상시키고 있다. 기술 분석서 예시123456789101112131415161718192021222324252627282930313233343536373839404142434445464748491. 제조 공정 기술 1-1. 기술 상태 - 수동 설비 : 시간당 1500단위 생산 가능, 결함 발생률 100ppm - 자동 및 반자동 설비 : 시간당 3천~4천 단위 생산 가능, 결함 발생률 20ppm 1-2. 생산 기술의 효율성 - 수동 설비 : 소량 작업 시에만 효율적이다. - 자동 설비 : 장시간에 걸친 대량 작업 시 효율적이다. 작업 전환 시간이 길다. - 반자동 설비 : 다양한 작업에 가장 효율적이다. 1-3. 비용 효율성 - 수동 설비 : 작업 속도가 느리고 비용이 많이 든다. 소량 작업 시에만 효율적이다. - 자동 설비 : 속도가 빠르고 신뢰성이 높다. 대량 작업 시에도 모두 처리할 수 있다. - 이 설비에 합당한 투자수익률을 달성하려면 시장점유율이 5년간 20%를 넘어야 한다. - 반자동 설비 : 가장 효율적이다. 제품 구성이 다양하고 작업량이 중간 정도일 때 적합하다. - 작업량이 중간 정도인 대규모 작업을 할 때는 어떤 기술로든 비용이 많이 든다. 1-4. 가용성/취득 비용 - 작업량이 중간 정도인 대규모 작업을 할 때 적한한 설비가 없다. - 유일하게 시판되는 설비는 다른 산업용으로 만들어진 다목적 설비다. - 자체 설비 제작을 위해서는 숙련된 엔지니어를 직원으로 채용해야 하는데, 해당 기술을 보유한 뛰어난 기술자를 찾기가 쉽지 않다. 경쟁 우위를 확보하기 위해서는 필수적인 자산이다. 1-5. 노후화율/내용연수 - 제조공정 기술은 약 5~8년마다 전환을 맞는다. - 수동 설비는 대부분 업그레이드만 약간 하면 내용연수가 15~20년에 이른다. - 자동 설비는 업그레이드하기가 어렵고 비용이 많이 든다. 예상 내용연수는 5년이다. 1-6. 경쟁사와의 비교 - 완전 자동설비를 갖춘 브라운 사가 기술적으로 가장 앞서 있다. - ABC 사, 내셔널 사, 본사는 비슷한 수준이지만 브라운 사에는 뒤진다. - 다른 경쟁사들은 기술력이 전무한 수준이다.2. 서비스 기술 2-1. 기술 상태 - 완전히 통합된 IS 시스템 - 고객 서비스팀에 실시간으로 생산/재고 데이터 전송 - 판매 직원이 컴퓨터로 자동 주문 입력 - 고객 데이터베이스부터 엔지니어링/생산 데이터베이스까지 직접 전송 2-2. 경쟁사와의 비교 - 본사는 최신 기술에서 상당히 뒤떨어져 있으나 경쟁사들도 마찬가지다.3. 제품 기술 3-1. 기술 상태 - 상품 보호력이 뛰어나고 항부착성이 가미된 100% 생물 분해성 제품을 생산하고 있다. 3-2. 경쟁사와의 비교 - 최근에 특허를 받은 본사의 &apos;그린 팩&apos;은 다른 모든 경쟁사를 훨씬 앞서는 첨단 기술 제품이다. 공급자 시장을 분석하라기업 활동을 위해 투입되어야 할 원자재, 기타 물품 뿐 아니라 노동과 서비스도 상당수 외부에서 공급받는 기업이 많다.갑자기 물품 공급이 끊기거나 비용이 크게 오르거나 품질이 형편없거나, 적기에 납품되지 않는 등의 문제가 발생한다면 기업의 진로와 방향에 타격이 갈 수밖에 없다. 공급 시장 평가서 예시123456789&lt;판지 시장&gt;1. 경제적 측면2. 사용처3. 업종 성장률 및 가격 결정 요소4. 경쟁적 위치&lt;노동력 시장&gt;1. 경제적 측면2. 공급 상태 경제 상황을 분석하라비즈니스에 형향을 미친느 경제적 요인은 과업ㅁ위하다.제품 및 서비스를 판매하는 시장과 관련된 주요 경제지표를 분석하다 보면 훌륭한 전략을 수립할 수 있을 것이다.비즈니스에 영향을 주는 종합적인 지표로 가장 먼저 검토해야 할 것으로는 GDP가 있다.결국 개개의 기업도 한 나라의 경제를 이루는 일부인 것이다. 여기서 중요한 것은 기업의 비즈니스와 고나련이 있는 특정 선행지표 에 주목해서 전략을 세워한 한다는 것이다.이들 지표는 전략적인 사고에 큰 도움이 된다.예를 들면 존슨 식품 기계는 닭고기를 소매로 판매하기에 적당한 조각으로 가공하는 기계를 제작하는 회사다.이 회사는 닭 사료 가격에 큰 영향ㅇ르 받는다.사료 가격이 올라가면 닭고기 가격도 올라가기 때문에 닭고기 수요가 줄어들기 때문이다.따라서 이 회사는 닭 사료로 쓰이는 곡물의 가격도 주시할 수밖에 없다.사료 가격을 해당 산업의 수요를 측정하는 전략적인 지표의 하나로 이용하는 것이다. 경제상황 분석서회사의 강점과 약점을 파악하라수많은 사람들이 자신이 할 수 없는 일을 할 수 있다고 착각하고 있다.결국 회사의 지금 그대로의 못브이 중요하다 리더가 생각하는 못브도 아니고 바라는 모습도 아니다.어느 회사든 고유의 강점과 약점을 지니고 있다.실행 가능한 전략을 만들어 내기 위해서는 이런 것에 대해 정직해져야 한다. 약점이 아닌 강점에 주력하라모든 회사들은 심지어 성공적인 회사도 약점을 갖고 있다.무한한 자원을 보유한 완벽한 회사가 아니라면 어느 정도 약점은 있게 마련이다.그리고 그 약점은 강점으로 인해 생기는 경우가 많다.가령 거북이는 자기 몸을 보호하는 무거운 등딱지 때문에 속도를 내지 못해서 느린 동물의 대명사가 되었다.속도를 내려면 몸을 보호해 주는 등딱지를 포기해야 한다.더 훌륭한 방법은 이미 앞서 있는 영역을 파악해서 더 앞서 나가기 위해 노력하는 것이다. 강점에 주력해서 성공한 좋은 예는 고대 그리스 시대에서 찾아볼 수 있다.당시 2만 명가량의 대군이었던 페르시아군은 그리스 침공에서 처음에는 승승장구 했다.하지만 2000 명 남짓이었던 스파르타군은 병력에 있어서는 자국 군대가 강점을 지니지 않았다는 것은 분명히 알고 있었고,대신 그리스 영토에 대해 더 잘알고 그리고 일대일 접전에서 매우 뛰어나다는 장점도 잘 알고 있었다.스파르타군은 이러한 강점을 활용하여 한 번에 500명 정도가 들어설 수 있는 좁은 테르모필레 협곡에서 전투를 벌여 2만 명의 페스리아 군에게 승리할 수 있었다. 기업 역량 평가서 예시기업의 강점과 약점을 찾는 가장 효과적인 방법은 전략기획팀 구성원들에게 물어보는 것이다. 강점 중요도 성과 서비스 수준 1 2 고위 경영진의 경영 밀착도 6 1 일상적인 경영 성과 4 3 대응 속도 3 1 유연성 3 2 시장에서의 인지도 2 2 설계 기술 2 2 약점 중요도 성과 고위 경영진이 받는 일상적인 압박감 2 7 미래 계획을 위한 시간의 부족 2 8 제조 원가의 문제 3 6 회사 밖의 관점이나 경험의 폭 협소 5 6 원자재 구매 4 6 차별화된 전략적 역량을 키워라어느 한 면만 판단하고 그것을 전략적 역량이라고 말할 수는 없다.한 가지 기술, 한 사람의 인재, 하나의 특허나 브랜드를 갖추었다고 해서 전략적 역량을 갖추었다고 할 수는 없다. 전략적 역량이란 무엇인가?전략적 역량이란 다음 세 가지 구성 요소로 이루어져 있다.사실 전략적 역량은 거의 대부분 이 세 가지 요소의 조합이다. 기술:재능과 훈련 그리고 실행의 결과로 얻을 수 있는 육체적 정신적 활동을 일컫는다. 프로세스:어떤 업무를 완결하기 위한 일련의 육체적 정신적 활동의 체계를 말한다. 기업이 보유하고 있는 중요한 노하우는 모두 여기에 포함된다. 지식:기업이 보유하고 있는 정보, 데이터 또는 사실이나 원칙에 대해 이해하고 있는 바를 말한다. 역량과 자산을 혼동하지 마라기업이 가진 것의 가치가 일시적이고 유동적이라면, 그것은 전략적 역량이 아니라 전략적 자산에 지나지 않는다.예를 들어 워싱턴 기념탑 건너편에 있는 티셔츠 판매점은 그곳에서 기념 티셔치를 사려는 고객들에게 특별한 가치를 제공하고 있다. 또 시설관리소가 허가한 유일한 판매점이기 때문에 이를 모방한 경쟁 점포가 들어서기도 어렵다.그러나 시설관리소에서 갑자기 판매점 운영권을 입찰에 붙이거나 특정한 사유로 인해 운영권을 주지 않는다면, 앞으로 그곳에서 계속 티셔츠를 판매할 수 있을지의 여부가 불투명해 진다.따라서 현재 티셔츠 판매점의 독점권은 유동적이며 일시적이다. 그러나 만약 그곳 말고도 다른 주요 관광지 여러 곳에 티셔치 판매점 장소를 물색해서 이를 확보할 방법을 마련해 놓았다면 얘기가 달라진다. 전략적 역량의 가치적략적 역량이라 하면 다음의 지표를 갖추어야 한다. 기술, 프로세스, 지식의 조합인가? 경쟁사와 차별화시켜 주는가? 고객을 위한 가치를 창출하는가? 모방하기 어려운가? 전략적 역량 분석서 예시 기술, 프로세스, 지식 A B C D 설계 엔지니어링 기술 X 클레임에 대한 신속한 대응 X 프로세스 엔지니어링 기술 X 장애 발생에 대한 경험적 데이터베이스 X X 내부 완충재 관련 지식 X X 특수 속포장재의 신속한 디자인을 위한 CSD 프로세스 도구 X X 광폭 소재의 가공 X 카탈로그 레이아웃 기술 저비용, 고효율의 코팅 프로세스 X 장식적 기능을 위한 소개 관련 지식 X 대규모 고객 데이터베이스를 기반으로 한 DM 업무 지식 겉포장을 위한 디자인 감각 X 신속한 제품 개발 프로세스 X X 3M 신소재 패키지 솔루션으로의 변형 노하우 및 관계 X 원자재 적기 공급 생산 방식 X 2색 양각 박을 입힌 디자인 독특한 외관 X 전략적 역량 후보군 고객 가치 창출 경쟁사와의 차별화 모방의 어려움 A. 속포장 설계 기술 상 상 중 B. 고객 서비스 상 하 중 C. 광폭 소재의 비용 효과적인 생산 상 중 상 D. 겉포장의 외관 상 중 상 전략 시나리오: 미래를 위해 무엇을 준비할 것인가?5년 후에는 어떤 신기술이 주목받을 것인가? 10년 후에도 지금의 시장은 그대로 유지될 수 있을까?앞으로 어떤 회사가 시장을 주도할 것인가?오늘 1위라고 해서 내일도 1위 자리를 지키리라는 보장은 없다.따라서 현재에 안주하지 말고 미래를 바라보아야 한다.향후 3~5년 및 10년 후의 비즈니스 환경과 시장 판도를 예측해 보고, 미래의 기회를 잡고 혹시라도 다가올지 모르는 위협에 대처하는 방법을 알아보자. 미래에 대한 가정가정은 지금 당장은 통제하기 힘든 미래에 일어날 법한 사건이나 발전에 대한 일시적인 판단을 의미한다.기업의 전략 수립을 위해서는 반드시 미래에 대한 가정이 필요하다.단, 가정은 사실과는 달리 취급되어야 한다. 가정과 사실을 혼동해서는 안 된다. 미래의 기업과 비즈니스에 영향을 미치는 중요한 변수인 그러한 핵심 원동력이 무엇인지 밝혀내는 것이 전략적 의사결정에 도움이 되는 가정을 도출하는 첫 번째 단계다. 지나치게 낙관적으로 가정하고 이를 기정사실로 생각하는 것은 매우 위험하다.순진한 예측을 삼가하고 트렌드의 전환점에 집중하라.가장 첫 단계인 결정적인 불연속성을 찾아내는 것 부터 시작하라.즉, 업계 시장 전체는 물론이고 고객 또는 공급자 시장에 변화를 불러일으킬 많나 큰일이 무엇인지 찾아내는 것이다.이를 통해 먼 미래에까지 사고를 넓힐 수 있다.가정은 모든 전략기획의 결정적 요소다.가정이 사실과 어떻게 다른지 그리고 일반적인 위험을 최소화하도록 적절한 가정을 수립하기 위해서는 어떻게 하는 것이 좋을지를 생각해야 한다. 비즈니스 환경에 대한 가정고객의 구매패턴에 따라 시장을 세분화한 후, 장차 세분시장에 어떤 일이 생길 것이며, 무엇이 상황을 변화시킬 것인지에 대해 전략적으로 살펴보아야 한다.세분 시장의 다음과 같은 요소들의 변화 가능성을 살펴본다. 고객의 니즈와 기호 성장률 이익수준 시장의 소멸 가능성 세분 시장에 대한 가정 예시1234567891011121314151617181920211. 세분시장의 정의캔디의 속포장 산업2. 시장의 니즈 변화현재로서는 캔디를 부서지지 않게 보호하려는 니즈를 사라지게 할 만한 캔디 생산 기술이 개발될 가능성이 보이지 않는다.아직 그런 연구는 진행되고 있지 않다.3. 시장의 미래 기호 변화3일 내 배송4. 시장 위협 요소(시장 규모를 줄일 만한 원동력)4-1. 생산원가 문제로 캔디의 매력이 떨어진 가능성이 있다.(가능성 중, 영향 중)4-2. 미각의 변화 때문에 캔디의 매력이 떨어진다.(가능성 하, 영향 중)4-3. 생산설비 과잉으로 대폭적인 가격 인하가 단행된다. (가능성 중~하, 영향 중)5. 시장 기회 요소(시장 규모를 늘릴 만한 원동력)5-1. 전체 판매량을 증대시킬 수 있는 새로운 캔디 제품 개발(가능성 하, 영향 하)6. 실질 시장 성장률향후 수년간 연 3%의 성장률이 예상된다.7. 업계의 평균이익 수준38%의 공헌이익과 11%의 투하자본 수익률8. 제품 및 서비스의 대체 가능성희박9. 기타 중대한 사건이 일어날 가능성희박 비즈니스 환경에 대한 가정을 수립하라비즈니스 환경은 통제하기 힘든 방식으로 변화하며 기업은 그러한 변화에 대응해야 한다.이때 최선책은 공급자 시장, 기술, 경제, 정부 규제의 네 영역에서 일어날 것으로 생각되는 바에 관해 가정을 수립하는 것이다. 비즈니스 환경에 대한 가정 예시123456789101112131415161718192021221. 기술 변화- 본사에서 개발중인 반자동 기계는 중간 규모 작업에 효과적이고 효율적이다. 이 기계는 2년 내에 완성될 것이며, 이 덕에 상당한 원가 우위를 누릴 수 있을 거싱다.(90% 확률)- 우리 회사를 비롯해서 ABC 사와 내셔널 사는 대량생산 체계 도입에 큰 어려움을 겪을 것이다. 성공 가능성은 10%에 불과하며, 5년 내에 이룰 가능성은 전혀 없다.- 예상되는 또 다른 변화는 없다. 그러나 예상치 못한 일이 일어날 가능성은 언제나 존재한다.2. 공급자 시장의 변화내년에 원자재 시장은 다음과 같을 것으로 예상한다.- 생산량은 1340만~1460만 톤이 될 것이다. 1400만 톤일 가능성이 가장 크다.- 생산 능력은 1540만 톤이 될 것이다.(99.9% 확률)- 설비 가동률이 83%에서 75%로 떨어져 소폭의 가격 하락이 예상된다.3. 경제 상황의 변화- 고정 달러 GDP는 약간 상승할 것으로 보인다.(3~4%) 경기침체는 없을 것으로 전망된다.(95% 확률)- 생산설비가 확장되면서 산업생산도 계속 증가할 것이다.(80% 확률)- 투자는 4% 증가할 것이다. (75% 확률)- 소비자 지출은 4% 증가할 것이다.(60% 확률)- 취업률은 증가하고 실업률은 5.3% 선을 유지할 것이다. (80% 확률)- 소비자 물가지수는 6%상승할 것이다.(90% 확률)- 생산자물가지수는 5% 상승할 것이다.(90% 확률)/이러한 가정들은 다소 제한적인 내년도 연방준비제도이사회의 정책과 경제적인 쇼크가 없을것이라는 예상하에 수립된 것이다.4. 정부 규제의 변화보수적인 정치 성향이 우세해지면서 양대 정당 모두 대체로 보수적인 움직임을 보일 것이다.대체적으로 정부 규제가 상당히 완화될 것으로 보이고, 복지와 정자를 감축하려는 노력이 계속될 것으로 예상된다.","link":"/2018/01/14/비즈니스-기획/"},{"title":"사업계획서의 작성","text":"사업 계획서의 필요성인터넷을 기반으로 새로운 비즈니스를 시작할 예정이거나 기존 비즈니스를 인터넷 영역으로 확장하고자 한다면, 사업계획서를 작성하는 것이 중요하다.사업계획서(business plan)란 회사의 목표를 명시함은 물론 회사가 그 목표를 어떻게 달성할 것인지에 대해 정리한 문서이다. 사업계획서를 작성하는 과정을 통해 사업제안자는 사전에 생각을 하고, 달성 가능한 목표를 설정하며, 문제를 예상하고, 또 경쟁에 대응할 준비를 하게 된다. 사업계획서 자체보다는 사업계획서를 작성하는 과정이 비즈니스의 성공확률을 좌우한다.일반적인 사업계획서와 마찬가지로, 인터넷 사업계획서도 필요성 및 예상되는 사업결과뿐 아니라 창업을 하고자 하는 벤처기업의 상세한 내용에 관해 기술하여야 한다. 또 전자상거래 특유의 속성을 함께 고려하여야 한다. 사업계획서를 필요로 하는 경우는 다음의 두 가지 유형이다. 신규 벤처기업 (전자상거래 기업 창업) – 사업계획서는 대출 혹은 투자 기관에 제출됨 기존 오프라인 기업의 전자상거래 사업부문 – 사업계획서는 전자상거래 사업에 투자하는 후원기업에 제출됨 사업계획서의 목적사업계획서는 제안된 사업을 실행에 옮기는데 필요한 자금을 확보하는데 그 목적이 있다. 사업계획서는 투자자나 기업후원자의 재정적 지원을 이끌어내는 것 이외에도 또 다른 목적이 있는데, 사업제안자가 철저하고 효과적인 사업분석을 실시함으로써 빈틈이 없는 치밀한 사업계획을 수립할 기회를 제공하는 것이 바로 그 것이다. 사업계획서의 작성1. 요약문전자상거래 사업계획서의 전체적인 내용이 작성이 되면, 1-2 페이지 분량의 요약문(executive summary)을 작성 해야 한다. 사업계획서 서두부분에 삽입되는 이 요약문은 전체 사업계획서의 핵심요지를 포함한다. 이 부분을 읽은 투자자나 관리자는 이 업체가 대략 어떠한 회사인지 알게 되며 더 상세한 내용을 보기 위해 본문을 읽게 된다. 일반적으로 요약문은 사업계획서의 개별 섹션과 관련하여 한 두 가지의 주요 포인트를 정리해 작성된다.요약문의 내용은 그 것을 읽는 독자를 염두에 두고 작성되어야 한다. 만일 투자자를 위해 작성된다면, 재정적인 요구사항에 관한 중요한 정보를 담아야 할 것이다. 마찬가지로, 정보중개자, 디지털 디바이스, 매스 커스토마이즈 등과 같이 독자에게 난해한 전자상거래 전문용어나 개념은 별도의 정의를 제공하지 않는 한 사용을 피하는 것이 좋다. 가장 훌륭한 요약문은 독자에게 중요한 이슈 및 의문사항들이 무엇인지를 이해하며 이들에 대해 명료하고 직설적인 문체로 알기 쉽게 설명한 글이다. 2. 사업 개요독자에게 회사의 사업내용 및 목적에 대해 소개하는 섹션으로, 회사의 미션, 목표, 가치명제, 제품 및 서비스에 관한 정보를 기술하여야 한다. 회사가 어떤 활동을 하게 되며 어떻게 성공을 할 것인지에 대해 큰 그림을 제공하는 것이 목적이다. 제품과 인터넷이 서로 어떤 관련이 있으며 또 서로 보완이 되는지 설명이 돼야 한다. 회사 미션 미션이란 회사가 존재하는 이유를 뜻한다. 예를 들어, 삼성전자의 미션은 혁신적인 디지털 제품과 E-프로세스롤 통해 디지털 컨버전스 혁명을 주도하는 기업이 되는 것이며, LG 전자의 비전은 혁신적인 디지털 제품과 서비스로 세계 모든 고객에게 행복을 선사하는 글로벌 디지털 리더가 되는 것으로 정의되고 있다. 이 부분에서는 회사의 미션을 정의하고 이 미션의 중요성을 보여줄 수 있는 설명을 앞에서 정의한 업종과 연관시켜 한두 단락으로 제시한다. 바람직한 미션은 명확한 가치를 밝히고, 기업이 활동할 사업영역을 명시하며, 종업원들의 동기를 유발하고, 기업장래에 대한 비전을 제공하는 특징을 지닌다. 가치명제 고객에 대한 가치명제와 그에 대한 타당성을 기술하는 부분이다. 가치명제(value proposition)는 회사의 제품이나 서비스가 고객에게 제공하는 가치 혹은 혜택을 표현한다. 다시 말해, 왜 고객이 이 회사의 제품이나 서비스를 구매해야 하는가에 대한 답이 가치명제에 포함되는 것이다. 가치명제의 초점은 고객에 있기 때문에, 고객 관점에서 가치명제를 결정하여야 한다. 예를 들면, 가치명제는 낮은 가격(예: buy.com), 탁월한 고객서비스(amazon.com), 제품검색 비용절감(autobytel.com), 제품 커스토마이징(dell.com) 등의 가치에 기초할 수 있다. 가치명제에 관한 보다 상세한 설명은 교과서 제2장에 수록되어 있다. 회사 미션 미션이란 회사가 존재하는 이유를 뜻한다. 예를 들어, 삼성전자의 미션은 혁신적인 디지털 제품과 E-프로세스롤 통해 디지털 컨버전스 혁명을 주도하는 기업이 되는 것이며, LG 전자의 비전은 혁신적인 디지털 제품과 서비스로 세계 모든 고객에게 행복을 선사하는 글로벌 디지털 리더가 되는 것으로 정의되고 있다. 이 부분에서는 회사의 미션을 정의하고 이 미션의 중요성을 보여줄 수 있는 설명을 앞에서 정의한 업종과 연관시켜 한두 단락으로 제시한다. 바람직한 미션은 명확한 가치를 밝히고, 기업이 활동할 사업영역을 명시하며, 종업원들의 동기를 유발하고, 기업장래에 대한 비전을 제공하는 특징을 지닌다. 제품 및 서비스 가치명제가 실현가능함을 보여주기 위해 제공할 제품이나 서비스에 대해 소개하는 부문이다. 예를 들어, 기능, 디자인, 스타일, 색상 등과 같은 제품특성에 대해 서술한다. 이 회사의 제품이나 서비스가 타사의 것과 비교해 어떤 점이 다르고 독특한지 설명하여야 한다. 또 궁극적으로는 이 제품이나 서비스가 어떻게 가치명제를 뒷받침하는지 보여줄 수 있어야만 투자자에게 어필할 수가 있다. 비즈니스 모델 제안된 전자상거래업체가 따르게 될 비즈니스 모델에 관해 서술이 되어야 한다. 비즈니스 모델이란 회사가 존속하기 위해 비즈니스를 수행하고 수익을 창출시키는 방법을 뜻하며, 온라인 소매, 거래중개, 경매, 포털, 키워드검색 광고, 오픈콘텐츠 등이 그 예에 속한다. 투자자들은 비즈니스 모델을 통해 미래의 수익창출 및 성공의 가능성을 가늠할 수 있기 때문에, 독특한 비즈니스 모델을 신중하게 선택하는 것이 중요하다. 비즈니스 모델과 관련한 상세한 내용은 교과서의 제2장에서 수록되어 있다. 3. 사업 타당성 검토타당성 검토 및 분석을 필히 수행하여야 한다. 팀 프로젝트에서 제안된 비즈니스 모델을 사업화하기 위해 도입하여야 하는 정보기술에 대한 타당성이 있는지 확인하여야 하기 때문이다. 타당성(feasibility)이란 특정 정보기술(GPS, 웹, 휴대폰/스마트폰, 증강현실 등)을 도입하는 것이 기술적으로 또 경제적으로 타당한지를 뜻합니다. 따라서 기술적 타당성과 경제적 타당성의 두가지로 나누어 분석할 필요가 있습니다.기술적 타당성은 해당 기술을 구현하는 것이 현실적으로 큰 어려움이 없이 원만하게 진행될 것인가를 뜻합니다. 반면, 경제적 타당성은 해당 기술을 도입하는 데 따른 비용이 지나치게 많이 들지 않으며, 우리 회사의 가용 자금으로 충당이 가능한지를 의미합니다.이 두 가지 타당성이 존재하는 것으로 확인이 되어야만, 사업화를 추진하는 것이 의미가 있다고 할 수 있습니다. 한 예로, AR(증강현실) 기술을 휴대폰과 접목시켜 새로운 정보서비스를 제공할 사업을 구상하고 있는 기업의 경우, 현재까지 개발된 기술수준으로는 해당 기술을 구현하기 어렵거나, 혹은 해당 기술을 외부에서 구매하거나 내부적으로 개발하는데 비용이 지나치게 많이 소요될 것으로 예상될 때에는 타당성 결여로 인해 사업 아이템을 포기하고 다른 사업 아이템을 찾아봐야 합니다. 타당성 조사를 위해서는 가능하다면 해당 기술을 보유한 기업에 전화를 걸어 도입비용이나 기술수준 등에 대해 문의한다면 보다 현실적인 아이디어를 얻을 수 있을 것입니다. 4. 시장 분석산업분석 회사가 속한 산업 및 그 산업 내에서의 업종을 결정하고 그 업종에 대한 분석을 실시한다. 이를테면, 결정된 업종이 오픈마켓, 종합 쇼핑몰, 웹호스팅서비스, 온라인보험, 온라인여행중개, 혹은 온라인교육이라고 할 때, 그 업종에서 활동하고 있는 기존 회사들과 현 업계동향을 조사해 내용을 정리한다. 시장분석 섹션은 고객들이 누구인지 알고 있음을 보여주기 위한 부분이다. 타겟 고객들이 누구인지, 이 고객들이 어떠한 특성을 지니는지, 그리고 이 고객들이 왜 이 회사에서 구매할 것으로 예상되는지에 대해 기술하는 부분이다. 예를 들어, 타겟 고객이 30대 직장여성들 이라면, 이들 중 대략 몇 퍼센트가 온라인 구매 경험이 있으며, 월평균 소득이 얼마인지에 대해 관련정보를 수집할 수가 있다. 고객 베이스의 분석은 단순한 짐작보다는 인터넷 검색을 통해 통계 데이터에 의해 뒷받침될 때, 그 신뢰성이 더 높아진다. 시장분석 섹션에서는 타겟 시장을 정의하고, 매출극대화를 위해 제품이나 서비스를 어떻게 포지셔닝 할 것인지를 분석한다.전자상거래 회사의 타겟시장을 선정하는데 있어, 그 범위가 적절하도록 함은 물론 시장세분화 특성을 고려하여야 한다. 시장세분화 특성으로는 인구통계적(연령, 성별, 인종, 교육, 직업, 소득), 지역적(국가, 행정구역, 도시/농촌, 모바일 근로자), 심리적(태도, 믿음, 니즈, 욕구) 및 소비자(충성도, 쇼핑빈도, 사이트 방문횟수, 온라인 구매의도) 등이 고려될 수 있다. 이들 특성들을 상세하게 묘사함으로써 타겟 시장을 기술하도록 한다. 5. 경쟁사 분석주요 경쟁사들에 대해 철저한 분석을 함으로써 경쟁에 대응하기 위한 준비가 되어있다는 것을 보여주는 부분이다. 이를 위해, 인터넷 검색엔진을 이용해 알려진 경쟁사나 유사한 제품들이 있는지 찾아본다. 검색엔진들마다 검색기법이 다르므로, 두세 가지의 검색엔진을 사용하는 것이 좋다. 사업계획서의 독자들은 어떻게 경쟁에서 이기려고 하는지에 대해 큰 관심이 있음을 명심해야 한다. 경쟁사분석 섹션은 경쟁사들 및 그들의 제품이나 서비스를 검토함으로써 시장에서 경쟁사들에 비해 회사가 지니는 우위 및 열위가 무엇인지 알 수 있으며, 경쟁력을 강화하기 위한 전략을 개발하는데 도움이 되며, 또 경쟁이 회사 성공전망에 미칠 영향을 과소평가할 경우 투자자들은 경영자가 비현실적인 사업계획을 가지고 있다고 단정할 수 있다는 점에서, 매우 중요하다고 할 수 있다.경쟁사 분석에서 첫 단계는 잠재적 경쟁사들을 찾아내는 것이다. 시장에서의 경쟁의 범위 및 진행패턴을 고려하면서 경쟁대상이 될 수 있는 업체들을 규명하도록 한다. 이 부분에서는 구글, 네이버, 다음과 같은 웹기반 검색엔진을 이용하면 도움이 된다.다음은 경쟁사 분석이다. 선정된 경쟁사들을 대상으로, 각 기업의 상대적인 강점 및 약점 분석을 실시할 수가 있다(즉 경쟁사분석표 작성). 경쟁사 분석이 왜 중요한지 알아보자. 기업은 시장에서 자산과 핵심능력과 경쟁우위를 통해 성공을 이룬다. 성공적인 경쟁사들을 잘 살펴보면 회사성장의 원천요인들을 알 수 있으며, 이들 요인은 비즈니스 아이디어를 탐색하는데 큰 도움이 될 수 있다. 또 경쟁사들의 약점을 보면 어떤 실패를 어떻게 피해 좋은 결과를 얻을 수 있는지 학습할 수가 있다.끝으로, 회사의 경쟁우위 원천요인들을 제시한다. 즉, 경쟁사들에게서 발견한 경쟁우위 원천 요인들을 바탕으로, 본 전자상거래 업체가 어떻게 경쟁력 있는 기업으로 시장에서 발돋움할 것인지 구체적인 경쟁전략을 제시할 수 있어야 한다. SWOT 분석을 통해 전략적 방향을 제시하는 방안도 고려할 수 있다. 6. 운영위의 섹션들(즉, 사업개요, 시장분석 및 경쟁사분석)은 모두 전략적인 측면을 다루고 있는데 반해, 여기부터 살펴볼 섹션들은 일상적 운영 측면을 다루는 것이 특징이다. 운영계획은 향후 회사를 운영해 나가는데 관련된 다양한 이슈들을 커버한다. 비즈니스 인프라 비즈니스의 일상적인 운영 측면을 기술하는 섹션이다. 회사의 물리적 공간 확보, 인력 채용, 업무프로세스 개발 등 기본적인 회사 인프라의 구축 이외에도, 어떠한 시설 및 장비가 필요한가, 인터넷 전문직원을 고용할 것인가 아니면 직원을 내부적으로 훈련시킬 것인가와 같은 이슈에 대해서도 계획을 세워야 한다. 경영진 누가 회사를 경영할 것이며 그들의 전문지식은 어느 정도인지를 기술해 주는 섹션이다. 회사가 인터넷을 중심으로 운영이 될 것이므로, 경영진이 지닌 인터넷 전문지식의 수준과 더불어 어느 곳에서 지식을 쌓았는지를 토의하여야 한다. 또 경영진의 각기 구성원의 역할도 명시할 필요가 있다. 제품 개발 전자상거래 창업프로젝트의 기술적인 부분에 해당한다. 이를테면, 쇼핑몰 웹사이트를 개발하고, 결제시스템을 구현하며, 외부 협력업체와의 시스템 통합을 위한 엑스트라넷을 구축하는 것이 그 예에 속한다. 회사 자체의 웹서버를 사용할 것인지 아니면 웹호스팅업체와 계약을 체결할 것인지에 대해서도 결정해야 한다. 또 필요한 시스템을 어떤 방법으로 개발하며, 비용이 얼마나 들지 명시하도록 한다. 마케팅 판매하고자 하는 제품 및 서비스에 대해 잠재고객들에게 어떻게 소개할 것인지에 대해 기술한다. 근사한 웹페이지를 디자인하는 것은 그 첫 단계에 불과하다. 구축된 웹사이트에 대해 소문을 내는 것이 중요하다. 이를 위해서는, 웹 주소를 검색엔진 데이터베이스에 추가하고 발송하는 이메일 메시지마다 메시지 끝 부분에도 웹주소를 표시하는 등 다양한 효과적 방법들을 동원하여야 한다. 가격체계 제품 및 서비스에 대해 어떻게 가격을 결정하고 있는가? 제품이 인터넷상에서 배달 가능한 무형의 정보라면, 가격을 정당화하기 위한 가격책정 모델을 개발하여야 한다. 유사 제품을 판매하는 다른 업체들이 어떻게 요금을 부과하는지 조사하는 것도 좋은 출발점이 될 것이다. 배송 및 결제 제품을 어떻게 배송하며 고객의 결제는 어떻게 해결할 것인가? 이메일만으로는 결제의 안전성은 보장할 수 있으며, 암호화 기법 및 온라인 지불서비스를 고려할 필요가 있다. 7. 재무이 섹션은 수익성의 예측을 보여줄 수 있으므로, 잠재적 투자자들의 큰 관심을 끌게 될 부분이다. 일반적인 사업계획서에서와 같이, 관련된 모든 재무제표들을 포함한다. 인터넷상에서 회사를 운영하는데 따른 비용절감 측면을 강조해 보여줄 필요가 있다.재무제표 섹션에 포함되어야 하는 첫 번째 재무제표는 매출발생 이전 시점까지 회사 운영을 준비하기 위해 투입되어야 하는 자금지출 항목들을 명시한 초기 자금지출계획(start-up budget)이다. 그 다음으로는 회사 창업 후 3-5년간 회사의 재무상태를 예측하는 재무제표들(즉, 추정 손익계산서, 추정 대차대조표 및 현금출납표)이 제시되어야 한다. 초기 자금운용계획: 새 회사를 창업하는 경우, 매출을 발생시키기 전까지 회사를 창업하는데 필요한 지출항목들을 명기하는 자금지출 계획을 준비할 필요가 있다. 대부분 회사들은 사무실 임대료, 법무비용, 제품개발비, 제조장비 구입비, 차량구입비 등의 항목들이 초기 자금운용계획에 포함된다. 전자상거래 회사의 경우에는 컴퓨터, 소프트웨어, 웹사이트 개발비, 인터넷서비스 이용대금 등이 추가적으로 포함된다.추정 손익계산서: 창업자가 사업아이템에 대하여 미래의 수익과 손익을 미리 분석하는 계산서를 추정 손익계산서라고 한다. 추정 손익계산서는 매출 및 이자와 같은 수입 항목들뿐만 아니라, 매출원가, 관리비, 이자지출, 세금 등과 같은 지출항목들도 포함한다. 이 재무제표에서는 이들 수입 및 지출 항목들을 근거로 하여 영업이익, 세전 이익, 순 이익과 같은 수익관련 수치들을 산출하게 된다.추정 대차대조표: 추정 대차대조표는 회사의 자산, 부채, 그리고 자본금을 명기한 재무제표이다. 손익계산서가 일정 기간 동안의 재무 결과를 보여주는 반면, 대차대조표는 일정 시점에서의 회사 재정상태의 청사진을 보여준다.현금흐름표: 어느 회사의 손익계산서가 이익이 난 것으로 나타나고, 또 대차대조표의 자본금이 양호한 상태라 하더라도, 회사가 실제로는 건실하지 못한 경우가 있다. 그 이유는 회사가 청구된 대금들을 결제하기 위해 즉시 사용 가능한 현금이 항상 필요하기 때문이다. 현금흐름표의 주요 목적은 일정 기간 동안 회사의 현금상태의 변동을 모니터하는 것이다. 유입되는 현금항목들과 유출되는 현금항목들을 이 현금흐름표에 모두 기록하여야 한다. 현금흐름표의 내용은 어떤 면에서는 손익계산서와 유사하다고 할 수 있지만, 수입항목들과 지출항목들이 실제로 현금변동이 있는 경우에만 기록된다는 점이 다르다고 할 수 있다. 8. 추진 일정제안한 내용을 현실화하기 위해 거쳐야 하는 단계들에 대해 추진일정 계획을 제시하는 부분이다. 이 일정을 개발하는데 있어, 다른 인터넷 회사들과의 대화를 통해 회사를 인터넷상에 띄우는데 얼마의 기간이 소요됐는지 알아보면 도움이 될 수 있다.","link":"/2018/01/04/사업계획서의-작성/"},{"title":"안드로이드 시작하기","text":"개발 세팅 및 환경 설정 가상화 기기 설정 기본 환경 설정 Android 프로젝트 세팅 IDE란? XML이란? Advanced Layout Drawable의 활용 ListView Network URL이란? Uniform Resource Locator API Parsing Permission in Android readFromStream() InputStream MainThread 레이아웃 Fragment WorkFlow TabLayout WorkFlow 라이브러리 ButterKnife 개요 WorkFlow RecyclerView WorkFlow Retrofit 개발 세팅 및 환경 설정가상화 기기 설정안드로이드 가상화 기기 설정을 위해 VT-X 켜기컴퓨터의 BIOS세팅에 진입(레노버의 경우F1 혹은 Enter)에 진입하여Intel 가상화 세팅을 Enable로 바꾼다. 기본 환경 설정 자바 JDK(Java Development Kit)를 설치한다.JDK는 앱을 만드는 일종의 작업장과 같은 역할을 한다.JDK는 컴퓨터가 JAVA 프로그래밍 언어를 읽고 쓸수 있게 해 주는 소프트 웨어 이다.결론적으로 JDK Standard Edition을 설치한다. 안드로이드 스튜디오를 설치한다.안드로이드 스튜디오는 우리가 앱을 만드는 일종의 작업장과 같은 개념이다. Android Setting의 plugin에서 lombok plugin 다운로드 도메인 이름 설정 흔히 알고 있는 패키지 명은 .com 형식을 취하며 이것은 특정 도메인을 일컷는다.패키지 명은 이를 단순히 뒤집은 꼴이며 제일 뒤에 Application name이 붙게 된다.이는 어플리케이션을 배포 할때 각각 고유한 패키지를 가지게 한다. 만약 company domain 이 tangentx.com이고 어플리케이션 이름이 expirit이라면 패키지 명은com.tangentx.expirit이 된다. 모바일 설정 핸드폰에게 내가 개발자라는 사실을 알리기 위해 개발자 모드를 적용한다.핸드폰 제작사 별로 알맞은 드라이버를 설치한다.핸드폰을 연결하여 에뮬레이팅 할 수 있다.가상 장치를 이용하여 에뮬레이팅 할 수 있다.컴퓨터의 프로그램 및 기능에 들어가서 vt-x를 활성화 한다. 한글 설정 1234//plugins/android/lib/layoutlib/data/fonts/fonts.xml 에서&lt;family lang=&quot;&quot;ko&quot;&quot;&gt;&lt;font weight=&quot;&quot;400&quot;&quot; style=&quot;&quot;normal&quot;&quot; index=&quot;&quot;1&quot;&quot;&gt;NanumGothic.ttf&lt;/font&gt;&lt;/family&gt; 를 추가해준다. 바로 수정이 되지 않는 경우가 있으므로 파일을 바탕화면에 저장하여 바꾼뒤 복사해주는 식으로 한다. Android 프로젝트 세팅AndroidManifest 세팅AndroidManifest에서 처음 어플리케이션을 시작한다. IDE란?IDE란 Integrated Developing Envionment의 약자로써 코드를 작성하는 공간을 의미한다.안드로이드 에서는 흔히 Android Studio를 일컷는다. XML이란?XML이란 Extensible Markup Language의 약자로써 기본적인 표현 언어이다.이 언어의 문법을 XML Syntax라고 한다. Advanced LayoutDrawable의 활용123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:shape=&quot;oval&quot;&gt;&lt;solid android:color=&quot;@color/magnitude1&quot; /&gt;&lt;sizeandroid:width=&quot;36dp&quot;android:height=&quot;36dp&quot; /&gt;&lt;corners android:radius=&quot;18dp&quot; /&gt;&lt;/shape&gt; Drawable에 새로운 Shape을 정의하고 이를 background로 사용 ListViewNetworkURL이란? Uniform Resource Locatorhttp: 는 protocol, scheme을 의미한다.example.com은 host/domain/authority를 의미한다./animal/mammal/primate/tarsier는resource path를 의미한다.?diet=carnivore&amp;active=night은 query부분이다.12 APIApplication Programming Interface다른 소프트웨어에서 해당 어플리케이션이 편하게 사용되도록 하는 장치모든 사람람들은 API를 사용하게 된다.API의 url 에 특정한 request를 보내면 일정한 데이터 형식을 같추어 response를 보내준다. 12 Parsing긴 스트링을 컴퓨터가 이해하기 쉬운 다른 형태로 변형하는 과정 즉 JSON과 같은 형태로 변형JSON = JavaScript Object Notation Permission in Android인턴넷에 접속하거나 혹은 메시지를 보내고 카메라를 작동 시키는 등 다양한 동작을 하기 위해서는permission을 얻어야 한다. readFromStream()클라이언트가 서버에 요청을 보내면 서버는 이진수 형태의 raw data를 보내주는데 이를 사람이 이해 할 수 있는 형태의 데이터로 읽어들이기 위해서 readFromStream을 사용한다. InputStreaminput Stream은 이미지나 텍스트 등 다양한 resource들이 입력되는 입력 형태이다.이 input Stream을 읽어들여 이미지, 텍스트 등 다양한 요소들을 적합한 형태로 받아온다. MainThreadAndroid가 작업들을 처리할때는 처음부터 순차적으로 처리하게 되는데 이러한 주 작업목록을MainThread 라고 한다. 이는 사용자가 쓰는 측면에서 UIThread 라고도 하는데 이 작업목록에 긴 시간동안의작업이 포함되면 사용자가 다음 입력을 지시하여도 화면이 얼어있게 된다.그래서 절대 UIThread를 막으면 안된다.즉, UIThread에서는 사용자가 실제 사용하는 것들만 처리하고 그 동안 다른 근 작업들은 backgroundthread에서 처리하도록 한다. - AsyncTask&lt;Params, Progress, Result&gt; 레이아웃FragmentWorkFlow Activity에 Fragment 추가activity_main에 fragment를 추가해 준다. Fragment를 위한 Layout Resource XML 작성 각 Fragment Class 구현 Activity의 onCreate()에서 Fragment초기화. FragementTransaction을 사용한 Fragment 제어FracmentTansaction의 replace()함수를 통해 제어. TabLayoutWorkFlow gradle에 dependencies를 추가해 준다. style.xml에서 액션바를 제거한 다음, 탭으로 사용할 Fragment를 생성한다. 프래그먼트를 구현할 xml를 생성한다. MainActivity에서 Toolbar, TabLayout, ViewPager를 생성하고 설정한다.출처 바로가기 라이브러리ButterKnife개요일반적으로 레이아웃을 생성하고 난뒤, 제일 먼저 View를 선언하고 할당하는 작업이다. WorkFlow Gradle에 추가그레이들 -&gt; compile ‘com.jakewharton:butterknife:7.0.1’ Activity에서 버터나이프로 바인드 해주기 1234567//액티비티의 경우super.setContentView(layoutResID);ButterKnife.bind(this);//Fragment의 경우View view = LayoutInflater.from(getActivity()).inflate(resId, null);ButterKnife.inject(this, view); 레이아웃에서 View 객체 선언 123456@Bind(R.id.view_action_sms)View view_action_sms;@Bind(R.id.view_action_comment)View view_action_comment;@Bind(R.id.view_input_comment)View view_input_comment; 기타 기능onClickListener달기ClickListener가 필요한경우 setOnClickListener를 선언해줄필요 없이 바로 실행될 함수를 만들고 @OnClick 을 사용하면 됩니다.만약 View가 button처럼 클릭 이벤트만을 받고싶은 경우라면 2번에서 처럼 View객체를 선언할 필요조차 없이 그냥 바로 @OnClick함수만 사용해도 됩니다. 12345678910@OnClick(R.id.view_action_call)void onCallClick() &#123;.... &#125;&lt;!-- 여러 뷰에 대해서 하나의 함수만을 실행시키고 싶다면 아래와 같이 선언해주면 됩니다. --&gt;@OnClick(&#123;R.id.pager, R.id.indicator, R.id.cell_picture, R.id.cell_product, R.id.cell_price, R.id.cell_description,R.id.cell_location&#125;)public void onSomeThingClick(View view) &#123;&#125; RecyclerViewWorkFlow 레이아웃에 RecyclerView를 추가한다. 액티비티에 레이아웃을 연결한다. RecyclerView.Adapter 클래스를 생성한다. // 굳이 만들지 않고 다음단계로 진행해도 된다.RecyclerView.Adapter를 extends하여 클래스를 생성하고, 내부에서 ViewHoler를 생성한다. onCreateViewHolder(ViewGroup parent, int viewType)뷰와 뷰홀더를 만들고 레이아웃의 사이즈 마진 패딩 등을 조절한다.뷰홀더에 뷰를 넣어 뷰홀더 인스턴스를 만들어 리턴한다. onBindViewHolder(ViewHolder holder, int position)데이터베이스에서 데이터들을 받아와 뷰홀더 내의 요소들에 입혀준다. 액티비티에 LayoutManager와 Adapter를 생성한다.어댑터는 데이터 집합의 항목에 액세스할 수 있게 해주며, 항목 뷰를 생성하고, 원래의 항목이 더 이상 보이지 않을 경우 일부 뷰의 콘텐츠를 새 데이터 항목으로 교체합니다 Google Developer 참조 Retrofit개요Rest API통신을 위한 Android/Java 라이프러리WorkFlow build.gradle에 의존성 설정 1234dependencies &#123;compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos; // Retrofitcompile &apos;com.squareup.retrofit2:converter-gson:2.0.0-beta3&apos; // Gson 변환을 위한 converter&#125; 퍼미션 추가12345678910111213141516171819202122232425인터넷 통신을 하기 위한 퍼미션을 추가해 준다.&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;!-- Resource URIhttp://apis.skplanetx.com/weather/current/hourly?version=&#123;version&#125;&amp;lat=&#123;lat&#125;&amp;lon=&#123;lon&#125;&amp;city=&#123;city&#125;&amp;county=&#123;county&#125;&amp;village=&#123;village&#125;Protocol - RESTHTTP Method - GET --&gt;public interface WeatherApiInterface &#123;@Headers(&#123;&quot;Accept: application/json&quot;&#125;)@GET(&quot;weather/current/hourly&quot;)Call&lt;WeatherRepo&gt; get_Weather_retrofit(@Query(&quot;version&quot;) int version, @Query(&quot;lat&quot;) String lat, @Query(&quot;lon&quot;) String lon);&#125;&lt;!-- @Headers 에는 필요한 헤더 부분을 (&#123; ~~ . ~~ &#125;) 형식으로 넣어줄 수 있습니다.@GET 부분에는 현재날씨(시간별)에 해당하는 URL 을 넣어줍니다.다음으로 Call입니다.Call &lt;&apos;주고받을 객체&apos;&gt; &apos;함수명&apos; (@Query (&apos;변수 이름&apos;) &apos;자료형&apos; &apos;변수 이름&apos;) 형태로 나타나 있는데요@Query 를 통해 위치가 바뀌어도 동적으로 값을 받아올 수 있습니다! --&gt; GSONJSON의 파싱을 쉽게 하기 위해 구글에서 만든 라이브러리이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class WeatherRepo &#123;@SerializedName(&quot;result&quot;)Result result;@SerializedName(&quot;weather&quot;)weather weather;public class Result &#123;@SerializedName(&quot;message&quot;) String message;@SerializedName(&quot;code&quot;) String code;public String getMessage() &#123;return message;&#125;public String getCode() &#123;return code;&#125;&#125;public class weather &#123;public List&lt;hourly&gt; hourly = new ArrayList&lt;&gt;();public List&lt;hourly&gt; getHourly() &#123;return hourly;&#125;public class hourly &#123;@SerializedName(&quot;sky&quot;) Sky sky;@SerializedName(&quot;precipitation&quot;) precipitation precipitation;@SerializedName(&quot;temperature&quot;) temperature temperature;@SerializedName(&quot;wind&quot;) wind wind;public class Sky&#123;@SerializedName(&quot;name&quot;) String name;@SerializedName(&quot;code&quot;) String code;public String getName() &#123;return name;&#125;public String getCode() &#123;return code;&#125;&#125;public class precipitation&#123; // 강수 정보@SerializedName(&quot;sinceOntime&quot;) String sinceOntime; // 강우@SerializedName(&quot;type&quot;) String type; //0 :없음 1:비 2: 비/눈 3: 눈public String getSinceOntime() &#123;return sinceOntime;&#125;public String getType() &#123;return type;&#125;&#125;public class temperature&#123;@SerializedName(&quot;tc&quot;) String tc; // 현재 기온public String getTc() &#123;return tc;&#125;&#125;public class wind&#123; // 바람@SerializedName(&quot;wdir&quot;) String wdir;@SerializedName(&quot;wspd&quot;) String wspd;public String getWdir() &#123;return wdir;&#125;public String getWspd() &#123;return wspd;&#125;&#125;public Sky getSky() &#123;return sky;&#125;public hourly.precipitation getPrecipitation() &#123;return precipitation;&#125;public hourly.temperature getTemperature() &#123;return temperature;&#125;public hourly.wind getWind() &#123;return wind;&#125;&#125;&#125;public Result getResult() &#123;return result;&#125;public weather getWeather() &#123;return weather;&#125;public interface WeatherApiInterface &#123;@Headers(&#123;&quot;Accept: application/json&quot;&#125;)@GET(&quot;weather/current/hourly&quot;)Call&lt;WeatherRepo&gt; get_Weather_retrofit(@Query(&quot;version&quot;) int version, @Query(&quot;lat&quot;) String lat, @Query(&quot;lon&quot;) String lon);&#125;&#125;&lt;!-- GSON이 쉽고 편하고 아름답게 파싱해 주는 것을 볼 수 있습니다!여기서 @SerializedName 어노테이션이 포인트인데요이 어노테이션을 이용하면 wspd(풍속) 을 @SerializedName(&quot;wspd&quot;) String windSpeed; 처럼 변수 이름을 바꿔 넣을 수도 있습니다.--&gt; 장점 / 용도다음과 같은 귀찮은 작업들을 매우 편리하게 바꾸어 준다. 네트워크 통신 연결/해제 가져온 데이터 파싱 Json통신의 경우, Json데이터를 Class로 변환 각종 에러 처리 출처 - 박상권의 삽질 블로그출처 - Retrofit 공식 홈페이지 EventBusWorkflow Otto를 관리해주는 Singleton 개념의 BusProvider 클래스를 생성 Event를 감지하고자 하는 ACtivity 혹은 Fragment에서 register를 수행한다. Event가 발생하는 위치에서 Event가 발생했음을 알린다. 이벤트가 발생했을때 수행할 함수를 FinishLoad 메소드에 만들어 준다. 해당 이벤트에서 원하는 변수, 리스트 등을 받아서 작업을 처리한다.출처 바로가기 Dagger개요Android/Java에서 Dependency Injection을 위한 편리한 도구이다.주요 Annotation @Module, @Provides, @Component, @Inject@Inject: 이 어노테이션은 의존성을 요청합니다. 의존성 주입을 통해서 해당 어노테이션이 달린 클래스나 필드에게 값을 주입해 달라고 Dagger 에게 요청합니다. Dagger 는 어노테이션이 달린 클래스의 인스턴스를 생성하고 그것들의 의존성을 만족시킵니다. @Module: 모듈들은 의존성을 제공하는 메서드들을 가진 클래스입니다. 의존성을 제공하는 클래스를 정의하고 @Module 어노테이션을 답니다. 그러면 Dagger 는 클래스 인스턴스를 만들 때 의존성을 만족시키기 위한 정보를 찾을 수 있습니다. @Provide: 모듈 안에서 해당 어노테이션이 달린 메서드를 정의합니다. 해당 어노테이션이 달린 메서드가 Dagger 가 어떻게 의존성에 맞게 객체를 만들고 제공하는지 알려줍니다. @Component: 컴포넌트는 @Inject 와 @Module 사이 다리이며 의존성을 주입하는 역할을 합니다. 컴포넌트는 미리 정의한 모든 타입의 인스턴스를 줍니다. @Component 어노테이션은 인터페이스에다만 달아야합니다 그리고 컴포넌트를 구성하는 모든 @Module 이 달린 클래스 목록을 적어야합니다. 컴포넌트에서 사용하는 모듈들중 하나라도 없다면 컴파일 타임에 에러를 만듭니다. 모든 컴포넌트들은 컴포넌트에 포함된 모듈들을 통해 의존성의 범위를 알 수 있습니다. @Scope: 스코프는 매우 유용하고 Dagger 2 에서 사용자 정의 어노테이션을 통해 범위를 나누는 명확한 방법입니다. 나중에 예제에서 보겠지만 이것은 매우 강력한 기능입니다. 앞에서 언급한바와 같이 하기 때문에, 모든 객체는 자기 자신의 인스턴스를 관리하는 방법에 대해 알필요가 없습니다. 예를들어 사용자가 지정한 @PerActivity 어노테이션이 달려있는 클래스는 액티비티가 살아있는 동안 존재합니다. 다시말하자면 객체 범위의 단위를 정의할 수 있습니다. @Qualifier: 클래스의 유형이 종속성을 식별하기 불충분할 때 사용하는 어노테이션입니다. 예를 들어 안드로이드의 경우, 많은 경우 컨텍스트의 다양한 타입이 필요합니다, 그래서 “@ForApplication”, “@ForActivity” 같은 식별자 어노테이션을 정의합니다. 컨텍스트를 주입할 때 이 식별자 어노테이션을 이용해서 Dagger 가 어떤 타입을 제공할지 정해줍니다. WorkFlow buil.gradle에 dependencies를 추가하여 준다.출처 바로가기 PluginsLombok주요 요소 @Getter / @Setter기본적으로 멤버필드들에 대한 getter/setter메소드들을 만들어 줍니다. @AllArgsConstructor / @NoArgsConstructor멤버필드들이 모두 파라미터로 지정된 생성자와 빈 생성자를 만들어 줍니다. @Builder모델을 빌더 패턴으로 만들어 줍니다. @ToStringtoString의 override된 메소드를 만들어 줍니다. WorkFlow 1. Lombok Plugin 설치 gradle에 Lombokk 적용하기. gradle에 annotaion을 provide 해주기","link":"/2018/01/14/안드로이드-시작하기/"},{"title":"운영체제 | 메인 메모리","text":"메모리의 기본 개념 기본적인 하드웨어 구조 논리 주소와 물리 주소 동적 적재 스와핑 연속 메모리 할당 단편화 페이징 페이지 테이블의 다양한 구조 계층적 페이징 해시된 페이지 테이블 역 페이지 테이블 세그먼테이션 주 메모리에는 여러개의 프로세스가 적재되어 있고, 운영체제는 이러한 프로세스를 효율적으로 처리하기 위해 메모리를 효율적으로 관리해야할 필요가 생겼습니다. 이를 위해 두가지 알고리즘인 페이징과 세그먼트 를 다루겠습니다. 최근 디자인이 하드웨어와 운영체제를 밀접하게 통합하고 있지만 본 장에서 설명하는 알고리즘은 대부분 하드웨어 지원을 필요로 합니다. 메모리의 기본 개념기본적인 하드웨어 구조메모리는 각각 주소가 할당된 일련의 워드 또는 바이트들로 구성되며 CPU는 PC(Program Counter)가 지시하는 대로 메모리로부터 다음 실행할 명령어를 가져오고, 필요한 경우 추가적인 데이터를 더 가져오거나 데이터를 메모리로 내보냅니다. 전형적인 명령 실행은 먼저 메모리로부터 한 명령어를 가져오는 데서부터 시작되어, 그 다음 명령어를 해독하고 메모리에서 피연산자를 가져와 피연산자에 대해 명령어를 실행합니다. CPU가 주 메모리에 접근하기 위해서는 많은 CPU 클록 틱 사이클이 소요되며, 이 때문에 CPU가 명령어를 실행하지 못하고 대기하는 시간이 길어집니다. 이러한 상호아은 주 메모리 접근이 빈번하게 일어나는 경우에는 큰 문제가 되며 이를 해결하기 위해 캐기 라고 부르는 메모리 버퍼를 사용합니다. 메모리에 많은 프로세스들이 적재되어 있는데 각각의 프로세스가 다른 프로세스가 사용하는 메모리 영역을 침범하면 큰 문제가 생길 것 입니다. 즉, 각각의 프로세스는 독립된 메모리 공간을 가지고 특정 프로세스만 접근할 수 있는 메모리 영역을 하드웨어 단에서 정해주어야 할 필요가 있습니다. 이 문제는 기준(base)과 상한(limit)이라고 불리는 두개의 레지스터들을 사용 하여 해결합니다. 기준 레지스터 는 가장 작은 합법적인 물리 메모리 주소의 값을 저장하고, 상한 레지스터 는 주어진 영역을 크기를 저장합니다. 이러한 기준과 상한 레지스터는 여러가지 특권 명령을 사용하는 운영체제에 의해서만 적재됩니다.하지만, 커널 모드 에서 실행되는 운영체제는 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 어떠한 제한도 받지 않는다. 프로세스는 실행되기 위해 디스크에서 메모리로 이동되고, 디스크에서 메모리로 들어오기를 기다리고 있는 프로세스 들은 입력 큐(input que) 를 형성합니다. 이 큐에서 하나의 프로세스를 선택하여 메모리로 적재한 후 실행합니다. 논리 주소와 물리 주소CPU는 오로지 논리 주소 만을 사용하여 작동하는 반면 메모리가 취급하는 주소는 물리주소 입니다. 따라서 프로그램이 실행되기 위해서는 CPU가 다루는 논리주소가 물리주소로 변환이 되어야 하며 이것은 메모리 관리기(Memory Management Unit) 에 의해 처리됩니다. 이렇게 모든 논리주소와 물리주소 사이의 변환은 MMU에서 처리하며 CPU는 물리주소에 전혀 관심을 두지 않습니다. 즉, 사용자 프로그램은 실제적인 물리주소를 결코 알 수 없습니다. 동적 적재일반적으로 CPU가 프로세스를 실행하기 위해서는 프로세스 전체가 메모리에 적재되어야 했다. 하지만 동적 적재 는 프로세스의 부분만이 메모리에 적재해도 프로세스를 실행 할 수 있도록 해 준다. 동적 적재에서 각 루틴은 실제로 호출되기 전까지는 메모리에 적재되지 않고 재배치 가능한 상태로 디스크에서 대기하고 있다. 이러한 동적 적재의 장점은 사용되지 않는 루틴들의 경우 절대로 미리 적재되지 않는다는 것이다. 이러한 동적 적재는 공유 라이브러리 를 사용하는 데에 사용될 수 있으며, 주로 시스템 라이브러리에 사용된다. 만일 이 방식이 없다면 모든 프로그램들은 그들의 이진 프로그램 이미지 내에 시스템 라이브러리의 복사본 또는 적어도 참조되는 루틴의 복사본을 가지고 있어야 할 것이다. 하지만 이러한 동적 연결에서는 라이브러리를 호출하는 곳 마다 스텁(stub) 이 생기게 되고, 이 스텁은 메모리에 적재하는 라이브러리를 찾는 방법 또는 메모리에 없을 경우 라이브러리에 적재하는 방법을 알려주는 작은 코드 조각이다. 스텁 은 필요한 라이브러리 루틴이 이미 메모리에 존재하는 지를 검사하고 없으면 루틴을 메모리로 적재한다. 동적 연결 이 없었다면 새로운 라이브러리를 사용하기 위해 모든 프로그램이 새로 연결되어야 한다. 이러한 시스템을 공유 라이브러리 라 한다. 스와핑프로세스가 메모리에서 실행되기 위해서는 메모리에 적재되어 있어야 하며 이렇게 디스크에서 메모리에 프로세스를 적재하는 것은 스와핑 이라고 한다. 스와핑 은 반드시 보조 메모리가 필요하며 보통 디스크를 사용한다. CPU는 준비완료 큐 에서 프로세스를 가져와 CPU를 할당해 주며, CPU 스케줄러는 다음 프로세스를 고를 때 디스패처 를 호출한다. 디스패처 는 이 큐에 있는 다음 프로세스가 메모리에 적재되어 있는지를 확인하여 없다면 디스크에서 불러들이도록 하여야 한다. 연속 메모리 할당주 메모리는 여러 사용자 프로세스를 수용해야 하며, 일반적인 메모리 할당방법 중의 하나인 연속 메모리 할당 에 대해 배워보도록 하겠습니다.메모리는 일반적으로 두 개로 나누어집니다. 하나는 운영체제를 위한 것 이고 다른 하나는 사용자 프로세스를 위한 것 입니다. 운영체제는 메모리의 어느 쪽 끝에도 위치할 수 있으며, 이 결정에 영향을 미치는 중요한 요인은 인터럽트 벡터입니다. 보통 여러개의 프로세스가 메모리에 적재되어야 하며, 입력 큐 에서 대기 중인 프로세스들에게 메모리를 어떻게 할당하는 것이 좋은가를 생각할 필요가 있습니다.이번에 배울 연속 메모리 할당 에서는 프로세스는 연속된 메모리 공간을 차지하게 됩니다. 연속 메모리 할당에서는 여기 메모리 저기 산재해 있는 여러 크기의 자유 공간 중에서 적절한 것을 찾아 할당하게 됩니다. 만약 자유공간의 크기가 크면 두 개로 나누어 하나는 프로세스에게 할당하고 나머지 하나는 다시 자유공간으로 되돌려 줍니다. 만약 되돌려 준 자유공간이 주변의 공간과 인접해 있다면, 이 두개의 블록을 합쳐서 한개의 큰 자유 공간 블록으로 만들어 줍니다. 이러한 기법은 동적 메모리 할당 문제 은 특별한 예이며, 자유 공간 리스트로부터 크기 n-바이트 블록 요청을 어떻게 만족시켜 줄 수 있는지를 결정하는 문제입니다. 해결방안에는 크게 3가지 정도가 있는데, 최초 적합 기법은 요청을 만족시키는 충분히 큰 첫 번째 가용공간을 할당해 주는 것이며, 최적 적합 은 요청을 만족시키는 충분히 큰 공간들 중에서 제일 작은 자유 공간을 활도해 줍니다. 최악 적합 은 가장 큰 가용 공간을 선택합니다. 단편화위의 예처럼 자유 공간을 임의의 조각으로 나누어 할당하는 방법은 두가지 형태의 단편화 를 만들어 냅니다. 단변화의 종류에는 내부 단편화 와 외부 단편화 가 있습니다. 먼저, 외부 단편화 는 다음과 같이 설명할 수 있습니다. 가령 계속해서 자유 공간을 할당해 주다 보면 남은 자유공간들이 너무 작은 조각들로 여러 군대에 산재되어 있는 현상이 있을 수 있습니다. 이 모든 조각을 다 모으면 큰 자유공간이 되지만 너무 잘게 쪼게어져 있기 때문에 사용하지 못하는 공간이 되어 버립니다. 이를 해결하는 방법은 압출 을 하는 것입니다. 압축 이란 이런 작은 자유 공간 조각들을 하나의 큰 조각으로 합치는 것으로 사이 사이의 프로세스가 차지하는 공간을 한쪽으로 몰아 재배치 하는 것입니다. 때문에 이 경우에는 프로세스내의 모든 주소들이 동적으로 재배치 되어야 하기 때문에 실행시간이 길어집니다. 다음으로는 내부 단편화 가 있습니다. 보통 자유 공간을 할당해 줄 때는 메모리가 분할된 크기의 정수 배로만 해주는 것이 보통이며 때문에 할당된 메모리 중 프로세스가 사용하지 않는 공간이 생길 수 있으며 이를 내부 단편화 라고 할 수 있습니다. 이러한 내부 단편화 를 줄이기 위해서는 할당해주는 메모리 조각을 최대한 작게 해 주는 것이 좋습니다. 이러한 다양한 단편화를 줄이기 위한 방법으로는 한 프로세스의 주소 공간을 여러 개의 동떨어진 공간으로 배정하는 것입니다. 그 대표적인 예로는 페이징과 세그먼테이션 이 있습니다. 페이징페이징의 기본적인 개념은 바로 논리주소 공간이 연속된 하나의 공간에 모두 모여 있어야 한다는 제약을 없애는 것입니다. 물리 메모리는 프레임 이라고 불리는 고정 크기의 블록으로 나누어져 있으며, 논리 메모리는 페이지 라고 불리는 고정 크기의 블록으로 나뉘어져 있습니다.CPU 는 논리 메모리를 기준으로 프로그램을 처리하며 이러한 논리 주소는 페이징 하드웨어의 페이지 테이블 에 의해 물리 주소로 변환된다. 또, 모든 물리 주소는 핻아 논리 주소로 사상될 수 있다. CPU에서 나오는 모든 주소는 논리 주소로써 페이지 번호와 페이지 변위 두 개의 부분으로 나누어 진다. 페이지 번호 는 페이지 테이블 에 접근할 때 사용되며, 해당 페이지 번호에 해당하는 주 메모리 내의 페이지의 기준 주소를 찾기 위해 사용되며, 페이지 변위 는 해당 프레임 내에서의 변위 를 나타낸다. 페이지 주소 에 페이지 변위 를 더하면 메모리 장치로 전송될 물리 주소가 된다. 프레임의 크기와 마찬가지로 페이지의 크기 도 하드웨어에 의해 결정된다. 만약 논리주소 공간의 크기가 2^n 이고 페이지의 크기가 2^m이면 논리 주소의 상위 m-n 비트는 페이지 번호를 나타내며, 하위 m 비트는 페이지 변위를 나타낸다. 페이징은 기본적으로 메모리를 정해진 페이지 사이즈로 잘라서 사용하기 때문에 외부 단편화가 발생하지 않는 대신 통산 페이지 사이즈의 반 정도의 내부 단편화 가 생기게 된다. 페이징의 가장 중요한 특징은 메모리에 대한 사용자가 생각하는 메모리와 실제 물리 메모리를 명확하게 분리한다는 사실이다. 그러나 실제로 프로그램은 물리 메모리 여러 곳에 프레임 단위로 산재되어 있고, 이 물리 메모리는 다양한 프로그램을 적재하고 있다. 사용자가 생각하는 메모리와 실제 메모리의 차이는 주소 변환 하드웨어에 의해 가려진다. 대부분의 운영체제는 프로세스마다 하나의 페이지 테이블을 할당합니다. 페이지 테이블을 가르키는 포인터는 다른 레지스터 값과 함께 프로세스 제어 블록(Process Control Block) 에 저장된다. 디스패처가 어떤 프로세스를 시작할 때 이 레지스터들을 다시 적재하면 페이지 테이블도 함께 사용할 수 있게 됩니다. 이러한 페이지 테이블 은 대부분의 경우 매우 크기 때문에 레지스터에 저장되지 못하고 주 메모리에 저장된 후 페이지 테이블 기준 레지스터(PTBR: Page Table Base Register) 로 하여금 페이지 테이블을 가르키도록 합니다. 하지만 이 경우에는 특정 정보에 접근하기 위해 두번의 메모리 접근이 필요합니다. 페이지 테이블에 접근하기 위해 한번 주 메모리에 접근하고, 얻은 주소를 통해 주 메모리에서 정보에 접근하기 위해 또 한번 접근하게 됩니다. 그래서 메모리 접근은 두 배로 느려 지며 이를 해결하기 위한 표준 방법으로 TLB(Translation Look-aside Buffers) 라고 불리는 특수한 소형 하드웨어 캐시가 사용됩니다. TLB의 각 항목은 키와 값 의 두 부분으로 구성됩니다. TLB에 페이지를 찾아달라는 요청이 들어오면 찾고자 하는 페이지를 동시에 모든 내부 키(페이지 번호)와 비교하여 해당하는 페이지 번호에 해당하는 프레임 번호를 알려줍니다. 하지만 이러한 TLB 하드웨어는 가격이 매우 비싸므로 페이지 테이블 의 일부분 밖에 들고있을 수가 없습니다. TLB에서 찾아진 페이지 번호와 프레임 번호는 TLB에 추가되어 다음 참조 시 매우 빠르게 처리할 수 있습니다. 이러한 페이지 번호는 수시로 교체되며 LRU 부터 무작위 교체까지 다양한 정책이 사용됩니다. 어떤 TLB는 각 항목에 ASID(Address Space IDentifiers) 를 저장하기도 하며, 이 ASID는 그 TLB 항목이 어느 프로세스에 속한 것인지를 알려주며, 이러한 ASID를 통해 TLB 안에 여러 프로세스들의 정보를 동시에 보관할 수 있게 됩니다. 여기서 페이지 번호가 TLB 에서 발견되는 확률을 적중률(hit ratio) 라고 합니다. 페이지 테이블의 다양한 구조각 프로세스가 필요한 페이지들은 매우 크므로 해당 프로세스의 페이지 테이블 또한 매우 커지게 됩니다. 이를 막기 위해 다양한 페이지 테이블 구조가 있는데 대표적인 테이블 구조인 계층적 페이징, 해시된 페이지 테이블, 역 페이지 테이블 에 대해 알아보겠습니다. 계층적 페이징계층적 페이징이란 페이지 테이블이 계층적으로 나타나는 것 입니다.즉, 페이지 테이블이 두개로 나뉘어 하나의 페이지 테이블은 다음 페이지 테이블에 대한 포인터를 가지고 있게 됩니다. 이러한 계층적 페이지의 구조를 전방 사상 페이지 테이블(forward mapped page table) 이라고 합니다. 해시된 페이지 테이블페이지 테이블을 사이즈를 줄이기 위해서 해시된 페이지 테이블 이 도입될 수도 있습니다. 주소 공간이 32bit 보다 커지는 경우 가상 주소를 해시 값으로 사용하는 해시 페이지 테이블 을 많이 사용합니다. 역 페이지 테이블역 페이지 테이블은 일반 테이블 페이지 처럼 메모리 페이지 값에 대한 물리 페이지를 가지는 것이 아니라 특정, 물리 페이지에 대한 논리 페이지 값을 가지는 테이블 입니다. 이렇게 되면 시스템에는 단 하나의 페이지 테이블 만 존재하게 되며, 모든 물리 페이지는 특정 논리 페이지를 가르키게 됩니다. 이 경우에는 물리 프레임에 해당한느 항목만 테이블에 저장하면 되기 때문에 메모리에서 훨씬 작은 공간을 차지하게 되지만, 주소변환 시간은 더 오래 걸릴 수 있습니다. 세그먼테이션페이지 테이블의 가장 큰 문제는 사용자가 사용하는 메모리 공간과 실제 물리 메모리 공간이 분리되어 헷갈린 다는 점입니다. 세그먼테이션 이란 이와 같이 메모리를 바라보는 사용자 관점을 그대로 반영합니다. 세그먼테이션에서 논리 구조 공간 은 세그먼트 들의 집합이며, 물리 메모리도 같은 원리로 세그먼테이션이 이루어집니다.","link":"/2018/04/13/운영체제-메인-메모리/"},{"title":"운영체제 | 교착상태(deadlock)란 무엇인가?","text":"시스템 모델 교착 상태의 특징 교착 상태 처리 방법 교착 상태의 예방 상호배제 점유하며 대기 비선점 순환 대기 교착 상태 회피 안전 상태 자원 할당 그래프 알고리즘 은행원 알고리즘(Banker’s Algorithm) 교착 상태 탐지(deadlock detection) 교착 상태로 부터의 회복 프로세스 종료 자원 선점 컴퓨터 시스템의 다중 프로그래밍 환경에서는 여러 프로세스들이 한정된 자원을 사용하기 위해 경쟁하고 있으며, 한 프로세스가 자원을 요청했을 때 해당 자원이 사용이 불가능한 상태라면 교착상태가 발생 하게 됩니다. 즉, 요청한 자원을 다른 프로세스가 점유하고 있고, 점유하고 있는 프로세스도 다른 자원에 대해 대기 상태에 있기 때문에 두 프로세스가 대기 상태에서 벗어날 수 없는 상황을 교착상태(deadlock) 라고 합니다.본 강의에서는 운영체제 수준에서 교착상태를 예방하거나 다룰 수 있는 방법들을 논의 합니다. 시스템 모델교착 상태에 대해 이야기 하기 전에 시스템에 대한 이야기를 잠깐 하고 넘어갑시다. 시스템은 경쟁하는 프로세스들 사이에 분배되어야 할 유한한 자원들로 구성 이되며, 여러 프로세스들을 해당 자원을 점유하기 위해 서로 경쟁 구도에 놓여있습니다. 메모리 공간, CPU 주기, 파일, 입출력 장치 등이 이러한 자원 유형이 예입니다. 프로세스가 자원을 사용하기 위해서는 반드시 사용하기 전에 요청 을 해야 하고 사용 후에는 반드시 방출해야 합니다. 즉, 정상적은 작동 모드에서 프로세스는 다음 순서로만 자원을 사용할 수 있습니다. 1. 요청프로세스는 자원을 요청하고, 즉시 허용되지 않는 경우 자원을 얻을 때까지 대기상태에 놓이게 됩니다.2. 사용프로세스는 자원에 대해 작업을 수행합니다.3. 방출프로세스가 자원을 다 사용하였다면 방출합니다. 이렇게 경쟁 구도에 놓인 프로세스들은 자원을 요청하는 시점에 해당 자원이 다른 프로세스에 의해 점유되어 있으면 대기상태에 놓이게 되고 각 프로세스와 자원들이 서로 꼬리를 물며 자원을 대기하게 되는 경우 이를 교착상태 에 놓여있다고 합니다. 즉, 한 프로세스 집합 내 모든 프로세스가 그 집합 내 다른 프로세스에 의해서만 발생될 수 있는 사건을 기다린다면, 그 프로세스 집합은 교착상태 에 있는 것입니다. 다중 스레드 프로그램은 공유 자원을 위해 경쟁하는 다수의 스레드가 있을 수 있기 때문에 교착상태의 좋은 예 가 됩니다. 교착 상태의 특징시스템 내에서 프로세스와 자원이 어떤 관계를 가지는 지 또, 교착 상태가 어떤 상황에서 발생하는 지를 알아보았으므로 이제 교착 상태 가 가지는 특징에 대해 알아봅시다.교착 상태에서 프로세스들은 결코 실행을 끝낼 수 없으며, 시스템 자원이 묶여 있어서 다른 작업을 시작하는 것도 불가능 하며, 이런 교착 상태는 다음의 필요 조건 을 만족합니다. 상호배제(mutual exclusion)최소한 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 대기하고 있어야만 한다. 점유하며 대기(hold-and-height)프로세스는 최소한 하나의 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 디기하고 있어야 한다. 비선점(no-preemption)자원들을 선점할 수 없어야 한다. 즉, 자원이 강제적으로 방출될 수 없고, 점유하고 있는 프로세스가 태스크를 종료한 후 프로세스에 의해 자발적으로만 방출될 수 있다. 순환대기(circular-wait)각 프로세스가 꼬리를 물며 자원을 점유하고 있어야 한다. 교착 상태가 발생하려면 위의 4가지 조건이 반드시 성립되어야 합니다. 하지만, 위와 같은 필수 조건들로는 어떤 시스템이 교착상태에 빠질 수 있는지를 간결하게 알 수 없는데, 이를 위해 우리는 자원과 프로세스의 관계를 그래프로 표현을 한 자원 할당 그래프 를 통해 시스템의 교착상태 유무를 파악할 수 있습니다. 자원 할당 그래프란 시스템 내 모든 활성 프로세스의 집합인 P 와 모든 자원의 집합인 R로 정점의 집합 V를 구성합니다. 이 그래프에서 P 로 부터 R 로 뻣어나가는 간선은 특정 프로세스가 해당 자원을 요청하고 기다리는 것을 표시하며 자원 R 에서 P로 뻣어나가는 간선 R-&gt;P 는 할당 간선 으로 해당 자원이 해당 프로세스에 할당되어있음을 나타냅니다. 이러한 자원 할당 그래프의 정의로 부터 그래프가 사이클을 포함하지 않은 경우 시스템 내 어느 프로세스도 교착상태가 아니라는 것을 보일 수 있습니다. 역으로, 반대의 경우에는 해당 시스템이 교착 상태 를 가질 가능성이 있다고 판단합니다. 여기서 왜 확실히 교착상태가 존재하는 것이 아닌 교착 상태가 될 가능성이 있다라는 표현을 하는 것일까요? 그것은 바로 자원이 하나의 인스턴스가 아니라 여러개의 인스턴스를 가질 수 도 있기 때문입니다. 만약 자원이 여러개의 인스턴스를 가질 수 있어서 여러 프로세스에게 자원을 제공한다면 교착상태가 일어나지 않게 됩니다. 교착 상태 처리 방법이제 특정 시스템이 교착 상태에 빠질 우려가 있는지를 판단하는 방법 까지를 알아보았으니, 교착상태를 처리 하는 방법 에 대해 알아봅시다. 먼저, 교착상태 처리에는 3가지의 방법이 존재합니다.첫째 방법 은 교착상태를 예방하거나 회피 하는 프로토콜을 사용하는 것 이며,두번째 방법 은 시스템이 교착상태가 되도록 허용한 다음에 이를 회복 시키는 방법입니다.마지막으로 세번째 방법 은 시스템의 교착상태를 무시하고 발생하지 않는 것처럼 꾸미는 방법입니다. 세번째 방법의 경우 터무니 없이 들리지만, 현대의 운영체제들이 대부분 사용하는 방식이며 이 경우 교착상태를 처리하는 것은 응용 개발자의 몫입니다. 위와 같은 여러가지 방법들을 통해 교착 상태가 발생하지 않게 할 수 있지만, 대부분의 경우는 이러한 해결 방법들은 큰 비용을 필요로 합니다. 가령 일년에 한두번 교착상태가 일어난다던가 혹은 특수한 경우 교착상태가 없으면서도 실행이 동결된 상태가 있을 수 있는데, 이를 피하는 것 보다는 수작업으로 한번 복구하는 것이 훨씬 효과적인 방법인 것과 같은 원리입니다. 때문에, 시스템은 교착상태가 아닌상황을 위해 수작업 복구 방법 을 반드시 가지고 있어야 하며 간단하게 이 방법을 교착상태 회복을 위해 사용 할 수도 있습니다. 교착 상태의 예방교착 상태 처리방법 가운데 교착상태를 예방하는 법부터 배워봅시다.시스템이 교착상태에 빠지지 않도록 하기 위해서는 앞에서 얘기한 교착 상태의 필요조건 들 중 적어도 하나가 성립하지 않도록 보장하는 방법입니다. 그렇다면 각 필요조건마다의 조건을 하나씩 따져 보며 해당 필요조건이 발생하지 않는 방안에 대해 고민해 봅시다. 상호배제교착상태의 첫번째 필요조건인 상호배제 가 일어나는 경우는 공유가 불가능한 자원 에 의해서 입니다. 만약 여러 프로세스가 읽기 전용의 파일을 열면 프로세스들은 그 파일에 대한 동시 접근을 보장받고 이 경우 상호배제 가 깨어지게 되어 교착상태를 예방할 수 있습니다. 하지만, 어떤 자원들은 근본적으로 공유가 불가능 하기 때문에 이러한 상호배제가 반드시 일어나야 하기 때문에 교착 상태를 예방하지 못하는 경우가 발생할 수 있습니다. 점유하며 대기두번째 필요조건인 점유하며 대기 를 방지할 조건에는 무엇이 있을까요?점유하며 대기 조건이 발생하지 않도록 하려면 프로세스가 자원을 요청할 때 다른 자원들을 점유하지 않고 있다는 것을 반드시 보장 해야 합니다. 즉, 자기 자신이 아무런 자원도 점유하지 않고 있을 때에만 다른 자원을 요청 할 수 있도록 하면, 대기 상태에 빠지더라도 자신은 아무런 자원도 점유하지 않고 있기 때문에 대기 하더라도 점유하며 대기는 발생하지 않게 됩니다. 이 경우 사용할 수 있는 프로토콜은 프로세스가 실행되기 전에 자신이 필요한 모든 자원을 요청하여 할당받도록 하는 것입니다. 이렇게 되면 프로세스가 정도에 다른 자원을 요청하여 할당받을 때까지 대기하는 일이 없고 모든 자원을 가지고 프로세스를 시작하기 때문에 대기하는 일이 발생하지 않습니다. 하지만 이 경우 큰 단점이 발생하는데 바로 많은 자원들이 할당 된 후 오랫동안 사용되지 않기 때문에 자원의 이용률이 낮아 지는 것 입니다. 가령 어떤 명령이 디스크 접근과 인쇄를 같이 하는 것이라면 프로세스가 디스크 접근을 수행하는 동안에도 이 프로세스는 프린터의 자원을 점유하게 되어 그 시간동안 프린터가 이용되지 못하는 상황이 발생하게 됩니다. 또 기아 상태가 가능하다 는 단점이 있을 수 있습니다. 필요한 자원 중 최소 하나가 계속 다른 프로세스에게 할당되어 있으면 이 프로세스는 무한정 대기해야 할 가능성이 생기게 됩니다. 또 다른 프로토콜은 프로세스가 자원을 전혀 점유하지 않을 때만 자원을 요청할 수 있도록 하는 것 입니다. 이 경우 자원을 대기할 때 절대 자원을 점유하지 않게 되므로 점유하며 대기가 일어나지 않습니다. 하지만, 이 경우에도 치명적인 단점이 존재하는 가령 DVD 드라이브에서 디스크로 자료를 복사한 다음 디스크에서 파일을 정렬하고 이를 인쇄하는 경우를 생각해 봅시다 이 경우 프로세스는 드라이브와 디스크를 점유한 뒤에 인쇄를 하기 위해서 디스크와 드라이브를 모두 방출하고 다시 디스크의 자원을 할당받는 비효율적인 동작이 나타나게 되어 자원의 이용률이 낮아지게 됩니다. 비선점세 번째 필요조건인 비선점 이 발생하지 않도록 해봅시다. 비선점 이란 이미 할당된 자원이 선점되지 않아야 한다는 것 입니다. 이를 위해서는 자신이 점유하고 있는 자원을 강제로 방출시켜 다른 프로세스가 선점하게 함으로써 교착상태를 끈어버리는 다음과 같은 프로토콜 을 생각해 볼 수 있습니다. 만일 어떤 자원을 점유하고 있는 프로세스가 즉시 할당할 수 없는 다른 자원을 요청하면 현재 그 프로세스가 점유하고 있는 모든 자원이 방출되어 필요로 하는 다른 프로세스에게 선점됩니다. 또 해당 프로세스는 자신이 요청하고 있는 새로운 자원은 물론 현재 강제로 방출한 옛 자원들을 다시 획득할 수 있을 때에만 다시 시작될 것입니다. 순환 대기교착 상태가 일어나기 위한 마지막 조건인 순환대기 를 없애기 위해서는 모든 자원 유형들에게 전체적인 순서를 부여 하여 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 강제하는 것입니다. 이를 통해 모든 자원들은 먼저 할당되는 순서가 정해져 있기 때문에 교착상태가 일어날 수 없습니다. 교착 상태 회피이처럼 교착 상태 예방 알고리즘은 요청 방법을 제약하여 교착 상태를 예방합니다. 그러나 이런 방식으로 교착 상태를 예방할 때 가능한 부작용은 바로 장치의 이용률이 저하 되고 시스템 이용률이 감소 된다는 것입니다. 이처럼 교착 상태를 처리하는 다른 방법 중 하나는 교착상태 회피 입니다. 교착상태 회피는 각 프로세스의 요청과 방출에 대한 순서를 파악하고 있다면 우리는 각 요청에 대해서 가능한 미래의 교착상태를 피하기 위해 프로세스가 대기해야하는 지를 결정할 수 있다는 점에 착안하여 나온 방안입니다. 즉, 어떤 프로세스가 요청을 할 때 미래에 대한 분석을 통해 나의 요청을 늦추는 방법으로 교착상태를 피할 수 있습니다. 이렇게 교착상태를 피하기 위한 알고리즘을 위해서는 각 프로세스가 요청할 각 유형의 자원의 최대 개수를 파악하는 것입니다. 안전 상태안전 상태란 이러한 교착 상태 알고리즘을 설계함에 있어 각 유효 자원의 최대 개수까지 어떤 순서로 요청을 하더라도 교착상태를 야기하지 않고 모두 할당을 잘 해줄 수 있음 을 뜻합니다. 회피 알고리즘은 시스템이 정해진 최대 자원 내에서 시스템이 항상 안전 상태에 있도록 한합니다. 이를 위해 프로세스들이 자원을 요청하면 그 요청을 받아주던지 혹은 교착상태를 피하기 위해서 대기 시킬지를 결정하며, 오직 시스템이 안정상태로 유지될 수 있는 경우에만 즉시 요청을 들어줍니다. 자원 할당 그래프 알고리즘앞에서 우리는 교착 상태 회피를 위해 정의한 자원 할당 그래프 를 살펴 보았습니다. 우리는 교착 상태 회피를 위해서 예약 간선 을 도입하겠습니다. 예약 간선이란 현재는 아니지만 추후 자원을 요청하게 될 것을 의미 합니다. 즉, 추후 시스템에서 교착상태가 일어날 가능성이 생기는 것이지요. 이러한 예약 간선 은 요청이 발생되면 요청 간선 으로 전환되고 자원이 할당되면 할당 간선 으로 전환됩니다. 은행원 알고리즘(Banker’s Algorithm)교착 상태 탐지(deadlock detection)교착 상태로 부터의 회복탐지 알고리즘에 의해 시스템에 교착 상태 가 발생이 되면 이를 회복하는 여러가지의 방법이 있지만 크게 두가지로 나누어 집니다. 첫번째는 한 개 이상의 프로세스를 중지 시키는 것이고, 둘째는 하나 이상의 프로세스들로부터 자원을 선점하는 것입니다. 프로세스 종료먼저 교착 상태를 해결하기 위해 존재하는 프로세스 하나를 임의로 종료하여 교착 상태를 해결하는 방법에 대해 알아봅시다.프로세스를 종료함에 있어 우리는 두가지의 방법 을 사용할 수 있습니다. 첫째는, 교착 상태 프로세스를 모두 중지 하는 것 입니다. 이 방법은 상당히 큰 비용 이 들어가는데, 이유는 단순합니다. 교착상태에 가기까지 프로세스들이 이제껏 많은 작업을 진행했을 것이며, 이를 통해 결과가 폐기된다면 다시 계산을 시작해야 하기 때문입니다. 둘째는, 교착 상태가 제거될 때까지 한 프로세스씩 중지 하는 방법이 있습니다. 이 방법은 각 프로세스가 중지될 때마다 아직도 교착 상태에 있는지 매번 살펴봐야 하기 때문에 상당한 오버헤드를 유발합니다. 자원 선점자원 선점을 통해 교착상태를 제거하기 위해서는 교착 상태가 깨어질 때까지 프로세스로부터 자원을 계속적으로 선점해 다른 프로세스에게 주어야 합니다.이런 자원 선점 에 있어서 다음을 사항들을 꼭 고려하여야 합니다. 1. 희생자 선택(selection of a victim)자원 선점에 앞서 어떤 자원과 어느 프로세스가 선점될 것인가 를 고민해야 합니다. 이 때 비용을 최소화 하기 위해 교착 상태 프로세스가 점유하고 있는 자원의 수, 그리고 교착상태 프로세스가 지금까지 실행하는 데 소요한 시간 등과 같은 변인들을 고려하여 희생자를 선택해야 합니다. 2. 롤백(rollback)만약 특정 프로세스을 자원을 강제로 방출하고 선점시켰다면, 그 프로세스를 어떻게 처리 할 것인가에 대한 고민이 필요하다. 보통 가장 안전한 방법은 프로세스를 중지시키고 재시작하는 것 즉, 롤백하는 것이다. 3. 기아 상태(starvation)자원 선점을 통해 기아상태가 발생하지 않을까를 고려해 보아야 한다. 계속해서 특정 프로세스의 자원을 강제 방출시켜 선점을 시켜주게 되면 그 프로세스는 계속해서 희생자로 선택될 확률이 높고 이경우 그 프로세스는 영원히 실행이 완료되지 못하는 기아상태에 빠질 수 있기 때문에 이를 심사숙고 해야 한다. 즉, 프로세스가 한정된 시간에만 희생자로 선정된다는 것을 반드시 보장 해야 한다.","link":"/2018/04/05/운영체제-교착상태-deadlock-란-무엇인가/"},{"title":"행복의 철학","text":"사랑과 행복 사랑의 종류 Agape philia (친애, 우정) Eros 에로스를 통한 사랑의 정의 에로스의 정의 두 가지 종류의 에로스 : 천상의 에로스 VS 범속적 에로스 여성, 남성의 신화적 기원 - 인간의 성의 탄생 신화(Aristophanes) 에로스는 아름다운 존재인가? 사랑의 기능과 원인 (ergon) 사랑의 본성 사랑의 확장된 의미 - 에로스의 사다리 첫째, 에로스는 젊을 때 아름다운 몸들을 사랑하는 것으로 시작한다 둘째, 에로스의 두번째 단계는 몸에 있는 아름다움보다 영혼에 있는 아름다운이 더 귀중하다고 여기는 것이다.\\ 셋째, 그를 앎으로 이끌어 ‘앎의 아름다움’을 보게 하면 그는 ‘아름다움 일반’을 보게 될 것 넷째, 이러한 에로스의 사다리를 차근차근 밟아 올라가다 보면 사랑하는 자는 최종적으로 “놀라울 정도로 본성상 아름다운 것”을 직관하게 된다 사랑과 행복 우정과 행복 친애란? 친애의 종류 부수적인 것에 따르는 친애 즐거움을 추구하는 친애 덕(탁월성)에 따르는 친애 친애의 특징 행복과 친애 에피쿠로스의 우정론 우정에 대한 우리의 태도 친애의 조건 신과 행복 종교란? 종교의 공통적인 내용 영원의 추구 지복 사상 아우구스티누스의 행복론 신과 행복 종교의 의의 정의 정의란? 플라톤 [국가]의 정의 아리스토텔레스의 니코마코스윤리학의 정의 이론 에피쿠로스의 정의 개념 역사적으로 규정되고 있는 정의의 개념 공통된 정의 개념 정의와 행복 J. Rawls 도덕과 행복 도덕이란 도덕에 관한 학문적 탐구로서의 윤리학 윤리학의 두 가지 원리 공리주의적 입장 의무론적 입장 도덕과 행복 노동과 행복 노동이란? 일, 노동의 어원적 의미 노동의 역사 고대 그리스의 노동 개념 기독교의 ‘노동’ 개념 르네상스의 노동 개념 근대의 노동 개념 현대의 ‘노동’ 노동과 행복 소외를 지양하는 생활 노동에 관한 비판적 접근 지식과 행복 지식이란? 플라톤이 말하는 지식의 종류 참된 지식이란?=진리? 지식의 기원 F.Bacon의 우상이론 지식과 지혜 지식과 행복 자연과 행복 자연이란? 스토아학파의 자연 개념 인간과 자연(세계) 환경 환경윤리이론의 주요 방향 행복의 방법 자아 성찰 독서와 사색을 통한 정적인 자기 탐구 거울 만들기 자아 능력 개발 실천적 습관과 태도 개인적인 방법 사랑과 행복사랑의 종류Agape신의 사랑 또는 인간의 신에 대한 사랑부모의 사랑도 이 범주에 들어간다. philia (친애, 우정)우정, 아는 사람간의 정 Eros남녀간의 사랑, 열정적인 사랑사랑은 눈으로 보지 않고 마음을 봅니다.그래서 큐피트는 장님으로 그려졌나 봅니다. 에로스를 통한 사랑의 정의플라톤의 향연(Symposion / 같이 술을 마심)아가톤의 비극경연대회 우승을 기념하여 모인 소크라테스와 그의 추종자들이 에로스에 대해 나누는 대화 에로스의 정의사람들은 아름다운 것을 사랑한다.아름다운 것을 사랑하는 자는 무엇을(무엇 때문에) 사랑하는가(욕망하는가)? 자기 것이 되기를 사랑한다.(욕망한다) 아름다운 것이 자기 것이 될때 그에게 무엇이 있게 되는가?좋은 것이 자기 것이 될 때 그에게 무엇이 있게 되는가?사람은 누구나 좋은 것들이 자신에게 있기를 바란다.사람은 누구나 ‘공통적으로’ 사랑이 자신에게 있기를 바란다. 두 가지 종류의 에로스 : 천상의 에로스 VS 범속적 에로스천상의 에로스(아프로디테)천상의 에로스는 상대의 영혼을 사랑하는 에로스이며 상대가 아름답고 훌륭하고 지혜롭게 되기를 바라고 실천하는 에로스이다.천상의 아프로디테는 더 나이가 많고 어머니가 없다 - 우라노스의 딸이다. 범속적 에로스(아프로디테)범속적 아프로디테는 더 젊고 제우스와 디오네의 딸이다.범속적 에로스는 육체를 탐하는 에로스이며 상대를 아름답게(kalos) 하는 일에는 관심이 없다. 천상의 에로스만이 칭송될 만하다. 여성, 남성의 신화적 기원 - 인간의 성의 탄생 신화(Aristophanes)본래 인간의 성은 남성, 여성, 남-여성(남녀추니)으로 세가지 였는데, 여기서 남녀추니의 힘이 세지자 신들이 이를 질투하여 둘을 갈라놓았다.즉, 사람은 오만으로 인해 떨어지게 되었고, 겸손함을 통해 원래의 삶을 유지할 수 있다.이처럼 반쪽으로 나뉜 각 짝들이 자신의 다른 짝을 그리워하고 욕구하는 것이 에로스(사랑)이기에 자신의 짝을 만나면 친애와 친근함 사랑에 압도되어 서로떨어져 있으려 하지 않는다. 이것은 성적인 함께함 이상이며 서로가 하나가 되려는 영혼의 열망이다.이러한 온전한 하나됨에 대한 욕망과 추구가 곧 에로스이며, 사랑은 헤어진 짝과의 이별의 고통을 치유하는 활동이다. 에로스는 원래 함께였던 인간이 오만하여 떨어지게 되었기 때문에 항상 자신의 본래모습으로 돌아가려고 하는 성질이다.즉, 사랑의 고통은 서로가 떨어져 있음에서 오고, 에로스는 인간이 본래의 자신의 모습으로 돌아가다록 하여 행복하게 해 주는 존재이다. 에로스는 아름다운 존재인가?에로스는 ‘어떤 것’에 대한 에로스이다.에로스는 아름다운 것을 사랑(욕망)하는 것이며, 그 대상은 아름다운 것이 된다.무언가를 욕망한다는 것은 자신에게 결여된 것을 욕망한다는 뜻이며 즉, 에로스 자체는 자신이 가지지 못한 아름다움을 추구하는 행위이기 때문에 그 자체로 아름답지 못하다.에로스는 사랑하는 자 자체를 의미한다. 따라서 에로스는 아름다움을 결여하고 있다. 사랑의 기능과 원인 (ergon)사랑의 근본적인 원인은 아름다운 것 안에서 출산하는 것이고, 이는 좋은 것과 더불어 불사를 욕망하는 것이다.이렇게 출산을 욕망할 때면, 자신을 목숨을 불사하고 어떤 어려움이나 고초도 이겨내고 출산을 하고자 한다.즉, 사랑은 출산을 통한 불사적 존재에 대한 갈구 때문에 발생하며 이를 통해 동물이건 사람이건 평생에 걸쳐 항상 새롭게 생겨나고 있다.이것은 몸뿐만이 아니라 영혼에서도 그러하다. 성격, 성품, 의견, 욕망, 쾌락, 고통 , 두려움 등 모든 것이 새롭게 생겨나고 소멸한다. 사랑은 근본적으로 출산을 통해 불사를 추구하는 기능을 수행하며, 그것이 사랑 자체의 발생 원인이다.즉, 에로스는 불사를 위해 계속해서 사랑하는 것이고 때문에 사랑 자체가 ‘실현’되지는 않는 유비적 의미를 지닌다. 사랑의 본성 사랑 받는 자는 어떤 추한 일에 연루되었다가 들키게 되었을 때 자신을 사랑하는 사람에 의해 발각되는 경우 더욱 수치심을 느낀다. 자신의 목숨도 기꺼이 바칠 정도로 상대를 사랑하는 사람은 신조차도 감동시킨다. 알케스티스와 아킬레우스의 경우. 사랑의 확장된 의미 - 에로스의 사다리첫째, 에로스는 젊을 때 아름다운 몸들을 사랑하는 것으로 시작한다한 몸을 사랑하고 거기에 아름다운 이야기를 낳음어느 한 몸에 속한 아름다움이 다른 한 몸에 속한 아름다움과 형제지간임을 깨달아야 함하나의 몸을 향한 열정을 느슨하게 만듬 둘째, 에로스의 두번째 단계는 몸에 있는 아름다움보다 영혼에 있는 아름다운이 더 귀중하다고 여기는 것이다.\\사람이 행실과 법을 아름다움을 보면, 그는 몸과 관련된 아름다움이 사소한 것이라고 여기게 될 것이다. 셋째, 그를 앎으로 이끌어 ‘앎의 아름다움’을 보게 하면 그는 ‘아름다움 일반’을 보게 될 것그것을 관조하고 지혜를 사랑하면서 많은 아름답고 웅장한 이야기들과 사유들을 산출하게 될 것아름다움에 관한 앎에의 직관 넷째, 이러한 에로스의 사다리를 차근차근 밟아 올라가다 보면 사랑하는 자는 최종적으로 “놀라울 정도로 본성상 아름다운 것”을 직관하게 된다-&gt; 아름다움 자체의 순수한 형상아름다움 자체의 순수한 형상 생성하거나 소멸하지 않는 영원한 것 관계적인 것이나 상관적인 것이 아닌 그 자체로 아름다운 것 시공간을 초월하여 아름다운 것 증가하거나 감소하지 않는 불변의 것 에로스의 사다리는 하나의 몸을 사랑하는 것에서 시작하여, 여러 몸들을 사랑하게 되고, 이를 넘어서는 몸보다 안에있는 영혼을 사랑하게 된다.그 사람과의 많은 아름다운 경험과 이야기들을 통해 아름다운 것에 대해 알고 보편적인 아름다움에 관해 알게 된다.아름다움에 대한 보편적인 아름다움을 알게 되면 최종적으로는 아름다움 자체의 순수한 형상을 보게 된다.이러한 아름다움이란, 생성, 소멸하지 않고, 관계적이고 상관적이지 않으며 시공관을 초월하고 불변하는 아름다움 그 자체이다.이는 아름다움의 이데아 라고 일컬어 진다. 사랑과 행복행복이란? 아리스토텔레스 - Eudaimoniaeu(좋은) daimonia(신과 같은 사람) - (좋은 신과 같은 특성)비교 : eutychia (행운)은 내가 조절할 수 없고 지속적이지 못하기 때문에 절대 행복이 될 수 없다. 에피쿠로스 학파 - Hedone의 지속적인 소유 [향연] 좋은 것을 갖는 것 우정과 행복친애란?친애란 우정을 포함하여 다른 사람에 대해 가지는 서로 아끼고 의지하는 마음과 행동을 포괄적으로 지칭한다. 친애의 종류부수적인 것에 따르는 친애 상대를 그 자체로서 좋아하는 것이 아니라 어떤 좋음이나 즐거움 때문에 좋아하는 것ex) 이득 등 상대를 더 이상 유익이나 즐거움을 주지 못할 때 사라짐즉, 서로 친구가 될 수 있었던 이유가 사라지면 친애는 해체된다.이러한 친애를 가진 사람은 다른 사람들과 함께 사는 일이 별로 없다. 즐거움을 추구하는 친애 감정에 따라 살며 즐거움과 현재를 추구하는 친애 점은이의 친애 쉽게 친구가 되고 쉽게 헤어진다. 하루에도 몇 번씩 변하면서, 함께 시간을 보내고 같이 살기를 원한다. 에로스 지향적 친애 덕(탁월성)에 따르는 친애 덕에 있어 유사한 사람들 사이에서 성립하는 친애 친구를 위해 그 친구가 잘되기를 바라는 친애 덕은 지속적인 것이므로 이러한 친애는 지속적인 친애 가장 완전한 종류의 친애 이러한 친애는 서로에게 즐거움을 줌 이러한 친애는 드물다 이러한 친애는 시간과 사귐이 필요함 친애의 특징 함께 있고 함께 시간을 보내고 싶어한다. 서로에게 즐거움과 기쁨을 느낀다. 친애는 사랑 받는 것보다 사랑하는 것에서 더 잘 성립한다. 행복과 친애 행복은 일종의 활동인데, 활동은 생겨나는 것이지, 어떤 소유물처럼 소유되는 것은 아니다. 지극히 복된 사람은 즐거운 사람을 필요로 하겠지만, 유익한 사람을 필요로 하지 않는다. 역경에 처해 있는 사람은 자신에게 선행을 베풀어 줄 친구가 필요하고, 또 좋은 처지에 있는 사람은 자신이 잘해 줄 사람이 필요하다. 친구가 곁에 있다는 것 자체가 좋은 처지에 있을 때나 곤경에 처해 있을 때나 모두 즐거운 일이다.(1170a29) 에피쿠로스의 우정론행복하게 살도록 분별력을 제공하는 것 중에서 우정보다 크고 생산적이며 기쁜 것은 없다고 에피쿠로스는 말한다.우정의 토대는 자기이익언제나 도움을 청하는 사람도 친구가 아니며, 우정을 도움과 전혀 연결시키지 않는 사람도 친구가 아니다.친구가 있으면 이롭고, 친구를 도우면 쾌락을 얻을 수 있다.이로움을 얻는 것보다 이루옴을 주는 것이 더 즐겁기 때문에 우정은 욕구될 수 있다.-&gt; 친구 공동체 / 에피쿠로스의 정원 우정에 대한 우리의 태도어떻게 하면 내가 좋은 친구가 될 수 있을까를 고민해라. 친애의 조건 서로에 대한 선의를 가지고 있어야 한다. 상대방이 잘 되기를 바라야 한다. 그러한 사실을 서로가 알아야 한다. 신과 행복종교란?인간의 문화활동의 한 형태신(절대자)에 관한 인간의 믿음과 의례인간이 가진 내적, 심리적 경외감, 경건의 마음 종교의 공통적인 내용영원의 추구 죽음의 인식 인간의 불완전성에의 인식 불사 지복 사상복을 준다고 생각을 하여 믿음현실의 삶에 관한 성찰삶의 규범 제시(신의 말씀, 종교교리에 따른 삶)마음의 안정, 행복 추구 기독교적 신과 ‘악’의 문제아우구스티누스(Augustinus)“만약 이 세상에 신이 존재한다면 악은 존재하지 않을 것이다.이 세상에 악은 존재한다.그러므로 이 세상에 악은 존재한다.” 실제 악은 없고악은 선의 결핍이다. 아우구스티누스의 행복론아우구스티누스는 고백록은 집필한 교부철학의 아버지라 불리며 마니교, 신플라톤주의, 키케로, 그리스도의 영향“나는 의심한다. 따라서 나는 존재한다.”하느님의 사랑이라는 개념을 정초하였다. 행복의 규정 - 자신이 원하는 것을 갖고 있는 사람은 모두 행복할까?자신이 욕구한는 것을 갖고 있지 않은 사람은 행복 할 수 없지만, 자신이 원하는 것을 갖고 있는 사람이라고 모두 행복한 것은 아니다.행복해지려면 지속적이고 영원한 것을 가져야 한다.자신이 소유한 것 중 아무것도 잃지 않을 것이라고 확신하다고 해도, 사람은 그것에 만족하지 않는다.우리를 끊임없이 욕구하게 만드는 것이 우리를 불행하게 만든다. 진정한 행복의 조건진정한 행복을 위해서는 영원한 것을 소유하려는 영혼의 절제가 필요하다.영혼의 절제는 인간의 자유의지와 필연의 관계를 맺음 영원불변의 존재이며, 인간에게 자유 의지를 부여한 것은 신이기 때문에진정한 행복은 오직 신의 향유에서만 가능 하다. 행복을 추구하려면 언제나 어느 정도의 자기포기가 필요하고, 더욱이 자기 아닌 다른 존재가 되어야 하는 고통이 따른다는 패러독스를 직시해야 한다. 행복과 사랑인간의 의지에 힘을 부여하는 것은 사랑이며, 신으로부터 부여 받은 자유의지와 사랑이 결합되어 영혼의 운동력이 형성된다.즉, 행복과 불행의 문제는 자유의지에 힘을 주는 사랑이 어디를 향하느냐에 달려있다. 선한 사랑 카리타스피조물을 그 존재의 위계에 맞게 사랑하는 바른 사랑이다. 악한 사랑 쿠피디타스위계적 분수에 어긋나는 잘못된 사랑이다. 신과 행복진정한 행복은 영원 불변한 행복이어야 하는데, 이것은 신만의 속성이다.따라서, 진정한 행복은 오직 영원 불변한 신으로부터만 나오며, 신을 모시고 선하게 사는 사람이 진정 행복한 삶이다. 종교의 의의종교는 주관적인 안녕감을 주고, 내세와 구원에 대한 믿음을 주며, 인간 삶에 관한 실존적 안녕감을 제공함으로써 어느정도 행복하게 해 준다고 할 수 있다. 실존주의 - 세계대전 이후 본질보다 실존이 우선시 되는 사상을 반영한다. 종교를 가진 신앙인들이 가지는 특별한 안녕감 종교 단체에서의 봉사는 내적인 긍정감 형성시킴 죽음에 대해 덜 두려워하고, 심한 스트레스에 잘 대처함 종교적 공동체로부터 강한 사회적 지원감을 얻음 정의정의란?제우스가 인간에게 ‘부끄러움’과 ‘정의’를 주어 최고의 생명체가 되었다. 플라톤 [국가]의 정의 개인의 측면에서는 영혼의 세 요소가 조화를 이루는 상태욕구적 부분, 기개적 부분(가슴에서 나오는 것 일종의 욱하는것), 이성적 부분 국가의 측면에서는 공동체의 세 부류가 통치자의 지도 하에 조화로운 삶을 이룬 상태생산자 부류(개인의 욕구적 부분에 해당), 수호자 부류(개인의 이성적 부분에 해당), 통치자 부류(개인의 기개적 부분에 해당) 지혜+용기+절제 -&gt; 정의 아리스토텔레스의 니코마코스윤리학의 정의 이론정의란 법을 지키는 것이며, 공정한 것을 말한다.정의가 완전한 것은 그 덕을 자기자신 뿐만이 아니라 타인에 대해서도 활용할 수 있게 하기 때문이다. 에피쿠로스의 정의 개념헬레니즘의 사상적 특징세계 시민주의 에피쿠로스에게 정의란 서로 간에 해치지 않겠다는 약속의 이행이며 원래 타당한 법과의 일치를 말한다. 역사적으로 규정되고 있는 정의의 개념객관적: 법의 내용이 옳음주관적 : 한 인격의 공정성객관적 : 법의 개념은 인간과 인간사회가 요청하는 개념. 공통된 정의 개념같은 경우에는 똑같이 다루어야 한다.-&gt; 불편부당성(훌륭한 사람이건 나쁜사람이건 죄의 경중에 따라 똑같이 처벌)각자에게 적합하게 다ㄹ루어야 한다.-&gt; 실적의 원리 : 주관적 죄책의 정도(획득한 만큼 돌려 준다.) 정의가 요구되는 조건 궁핍, 갈등 정의는 상반되는 이해, 이익관계에 따른 요구와 의무들이 상충할 때 문제가 됨 행위 능력최소한 행위능력이 있는 존재인 자연적이며법률적인 인격체에 귀속되어야 한다. 정의와 행복사회 공동체적인 측면에서 볼 때, 다른 사회구성원과의 조화로운 삶을 위한 조건를 만족하기 위해 우리는 정의를 추구해야 한다. J. Rawls우리 인간은 공존하기 위해 각자의 이해관계를 조절할 수 있는 도덕률이 필요하다.궁극적 도덕원리는 사회적 정의 또는 공정성이다. 도덕과 행복도덕이란도덕이란 전통을 통해 확립되고 현재 용인되고 있는 공동체 행위규범의 총체ex) 약속을 지키는 것, 다른 사람을 돕는 것, 다른 사람의 인격을 존중하는 것 도덕의 최소 개념자기의 행위를 이상을 통해 인도하려는 노력자기의 행동에 의하여 영향을 입게 될 각 개인, 타인에게 동등한 도덕에 관한 학문적 탐구로서의 윤리학윤리학의 종류 규범 윤리학 : 인간 행위의 올고 그름에 대한 탐구 메타윤리학 : 유리학적 논의에서 사용되는 용어들을 분석하고 의미를 명료화, 도덕적 추론의 규칙과 인식방법 연구 응용 윤리학 : 현실세계의 구체적인 도덕 문제를 다루는 분야ex) 직업 윤리, 공학윤리, 기업 윤리, 생명 윤리, 의료 윤리 … 윤리학의 두 가지 원리공리주의적 입장: 결과나 행위의 효용성을 기준. 의무론적 입장: 도덕적 의무감이 행위의 기준 공리주의적 입장보편적 행위공리주의: 최대다수에게 최선의 결과를 가져다 주는 행위 선택ex) 진실을 말하지 않는 것이 최선의 결과를 가져오는 상황 보편적 규칙공리주의: 최대다수에게 최선의 결과를 가져다 주는 규칙을 고려하여 개별 행위 선택ex) 만약 모든 사람이(의사가)거짓말을 한다면… 의무론적 입장도덕적 규범은 마땅히 따라야 할 규칙이다.I.Kant - 너는 너 자신이나 다른 사람을 수단으로가 아니라 목적으로 대우하라.궁극적 도덕의 원리는 타인의 인격에 대한 존중타인의 자율적 의사 존중 덕윤리학: 덕을 갖춘 사람 -&gt; 올바른 인간상 도덕과 행복도덕은 각 개인의 행위판단에 기여할 뿐만 아니라, 타인과의 공존의 법칙을 제공한다. 개인 - 행위 판단의 원리사회 - 공존의 원리 도덕은 그 무엇보다도 개인보다는 사회에서의 행복에 직간접적으로 노동과 행복노동이란?노동이란 일종의 운동(몸의 움직임, 행위, 활동)이다. 사적 노동 개념 - 개인적 행복감에 관여: 어떤 행위나 활동이 그 자체 때문이 아니라 수단적으로 이루어질 때, 즉 다른 목적을 위해 이루어질 때: 행위 주체가 그 활동을 수고롭다고 느끼고, 힘들 때도 해야 할 때 일, 노동의 어원적 의미 arbeit - 경작된 농지, 불어 travail - 말뚝 세개, 괴롭히다, Labor - 새로운 것을 만들어내는 일 노동의 역사전 인류 문명의 역사는 노동의 역사이다.노동은 가치 창조의 본질적 요인 이다. 노동에 대한 정당한 평가가 이루어져야 한다.육체적 노동의 재평가 고대 그리스의 노동 개념신체 활동을 자유시민에게는 어울리지 않는 것으로 봄. 신체의 활동은 강제를 동반하며 인간에게 관조의 여유를 빼앗기 때문. 아리스토텔레스 일과 덕은 서로를 배척한다. 키케로 - 수공업은 낮은 부류의 직업이다.: 귀족주의적 노동관 기독교의 ‘노동’ 개념신의 피조물로서 과업을 완성하기 위해서는 일, 노동은 필수적이다.죄와 구원의 개념과도 연관 르네상스의 노동 개념귀족주의적 노동 개념 잔재Homo faber(만드는, 창조하는 인간)에 대한 관심 - 수공업자, 예술가조르다노 브루노 - 여가, 여유에 대립되는 ‘활동’에 가치 부여 근대의 노동 개념수공예에서 기계로의 전환에 따른 산업의 발전, 생산적 자본주의의 발달, 자본 계층과 노동자 계층의 갈등을 통한 ‘노동’개념의 이슈화 칼 마르크스 - ‘노동’이란 인간 삶의 창조적 근원이며 ‘삶을 생산하는 삶’이다. Homo Laborans(노동하는 인간): 마르크스의 노동 개념으로 인간은 자신의 삶과 사회적 생산이라는 면에서, 불가결하지만 자신의의지와는 무관한 관계 즉, 생산관계에 들어간다.생산관계의 총체는 사회의 경제적 구조를 형성하며, 이 경제적 구조는 사회의 진정한 토대로서 이 토대 위에 법률적 정치적 상부구조가 세워진다.물질이 정신을 규정한다.물질적 삶의 생산방식이 사회적, 정치적 및 정신적 삶의 과정을 전반적으로 조건짓는다.노동은 물질적 삶의 생산을 규정하는 계기로서 가치척도이자 가치창조의 본체이다. ‘소외’(Entfremdung): 인간과 그의 생산물 사이의 진정한 관계를 자유로운 생산의 관계이어야 한다.인간의 노동이 만든 생산물이 인간으로부터 분리되어 인간에게 낯선 존재가 되고 인간을 억압, 종속시키는 현상소외의 원인을 자본주의 분석에서 찾음인간 존재는 그 자체 자기목적적이며 소외되어서는 안된다. 현대의 ‘노동’노동중심적 패러다임: 취업 노동을 전제로 한 노동 중심적 삶의 방식을 근복적 삶의 방식으로 인정하는 태도.취업 노동을 통해 물질적 안정을 확보하고, 자아 정체성을 형성하려 함. ‘노동중심적 패러다임’의 위기: 자동화, 정보화에 따른 일자리 감소와 실업의 증가제 4차 산업혁명의 예고 노동중심적 패러다임의 위기에 대한 대처: 노동중심적 패러다임 탈피? 노동과 행복소외를 지양하는 생활 ‘나’를 위한 ‘노동’ 자발적인 노동 노동의 즐거움과 보람을 동시에 획득하는 선택과 생활 노동에 관한 비판적 접근 신체적 활동으로서의 노동 개념의 가치 인식육체적 노동의 신성한, 가치 인식수고스러움의 의미 노동 가치에 대한 새로운 시각노동 가치에 대한 비판적 평가 노동 중심적 패러다임의 재고나동화 등 제 4차 산업혁명에의 대비노동 개념의 변화 지식과 행복지식이란?플라톤이 말하는 지식의 종류Episteme(지식, 인식)Doxa(의견, 견해, 억견) 참된 지식이란?=진리?진리 대응설: 어떤 것이 사실과 일치하면 진리(참)이다. 진리 정합설: 어떤 것이 기존의 지식체계에 맞거나 모순이 아니면 진리(참)이다. 진리 약정설: 사회구성원들이 모두 동의하는 것이, 참이라고 약속한 것이 진리이다. 지식의 기원지식은 어떻게 얻어지는가?직접 대면, 기술구에 의한 인식 아는 것이 힘이다.정보력내가 아는 정보에 의해 내가 규정된다. F.Bacon의 우상이론우상을 조심해야 정부의 홍수 속에서 진리를 얻을 수 있다. 종족의 우상: 우리 인간 종족이 피할 수 없는 이성의 오류, 선입견을 가리킴, 우리는 인간의 눈으로만 세계를 보고 인간의 관점에서만 세계를 판단함 동굴의 우상: 한 개인의 잘못된 외고집에서 기인하는 선입견, 오류 시장의 우상: 언어에 대한 인간의 잘못된 선입견에서 오는 오류, 예컨대 진짜 사물과 그에 대한 명칭을 혼동하는 데서 오는 선입견, 오류 극장의 우상: 전승되어 온 사상이나 교리를(그 권위 때문에)실제로 의문을 제기하지 않은 채 그대로 답습하는 데서 오는 선입견, 오류에 속지 말아라. 지식과 지혜이론적 지식, 실천적 지식 실천적 지식: ~을 할 수 있음(techne) 정치, 사회, 문화에 대한 비판 의식이론적 지식과 실천적 지식을 모두 갖추어야 지혜를 가지게 될 수 있다. 지식과 행복에피쿠로스에게 (자연에 관한)지식단편적 지식(정보 등)에서 실천적 지혜까지 살아있는 지식을 가져라! 생산적 지식반성과 비판을 통해 얻어낸 지식지속성과 안정석ㅇ을 가진 지식-&gt; 전문적 능력(끊임없는 자기 개발)교양과 전문적 지식 사이 자연과 행복자연이란? 자람, 성장 자연세계, 자연계 본성 스토아학파의 자연 개념자연의 운용 원리는 질서와 조화로 logos이다.자연의 일부로서 인간은 이성적 존재인간의 본성은 이성적, 합리적이다. 이성적, 합리적으로 생각하고 행위하는 것이 인간의 자연(본성)에 합당한 일이다. 본능적 욕망에 휘둘리는 것은 인간다움에서 벗어난 일이다. 인간과 자연(세계)자연의 일부인 인간이지만 문명의 지배자로서 자연과 대립자연의 지배자로서 인간의 모습환경문제의 대두 + 4차 산업혁명 환경 문제환경 오염, 지구온난화, 자연 파귀(인간의 문명 개발, 과학과 기술 발전, 경제적 성장으로 인해 야기됨)환경문제는 불가피한 것인가? 환경환경윤리이론의 주요 방향인간중심적 윤리: 오직 인간만이 도덕적 가치를 가진다.인간에게는 자연계와 관련된 책임은 있을 수 있지만 자연계에 대한 직접적 책임은 없다.ex) 대기오염, 수질 오염 등오염된 식품과 식수는 인간의 복지에 직접적 위험을 주기 대문에 미래 세대의 인간에게 해를 끼칠 수 있기 대문에 자연을 보호하고 핵폐기물을 처리해야 한다.(인간중심적 윤리의 확장) 인간에게 이득이 되는 것을 최고로 하고, 인간에 대한 도덕만을 고려한다.이 경우 환경을 보호해야 되는 이유를 미래의 인류에 대한 책임감으로 고려한다. 탈인간중심적 윤리: 동물, 식물과 같은 자연물에도 도덕적 지위를 부여하는 입장우리는 인간 이외의 다른 자연적 존재에 대해서도 직접적인 책임이 있다. 전체주의 윤리: 개체가 아닌 개체의 집합, 즉 전체를 중심으로 윤리적 판단개별생명체뿐만 아니라 종, 군집, 생태계에로 관심의 초점을 맞춤무생물, 생태계 자연물들간의 관계등의 전체에도 도덕적 지위를 부여생태학의 중요성야생의 가치와 이념 인간을 종으로 보고, 단지 하나하나의 개체를 넘어서 인류라는 종을 중심으로 윤리적 판단을 한다. 근본생태주의 강령: 인간과 지구상에 존재하는 모든 생명체의 번성은 본질적 가치를 지닌다. 생명체의 가치는 협의의 인간의 목적에서 나오는 유용성과 무관하다.인간은 없어서는 안될 본질적 필요를 충족시키는 경우를 제외하고는 생명을 죽이면 안된다. 인간과 동물은 같은 생명체로써 동일하다는 주의이다.본질적 필요를 충족시키는 경우를 제외하고는 생명을 죽이면 안된다. 행복의 방법자아 성찰독서와 사색을 통한 정적인 자기 탐구운동이나 문화, 예술 활동을 통한 동적인 자아에의 심취(진정한)’나’와 만나기 거울 만들기나에 관한 정확한 진단, 나의 장점과 훌륭한 점을 부각시켜줌 자아 능력 개발자신이 원하는 자신의 모습 만들남들이 원하는 자신의 모습은? 실천적 습관과 태도행복은 지속적인 것평상시의 긍정적 습관 형성 개인적인 방법 자유로운 공간 스스로 발견하는 행복의 방법 자신에게 만족감을 주는 활동하기 자신이 주인인 생활 복합적인 면모를 지닌 자신 안에서 ‘주인’발견 자신의 삶은 자신이 주도하라! 끌려 다니는 삶에 대한 반성 공존의 법칙 이해하기 나도 역시 남에게는 타인이다. 타인을 존중하곳 소중히 여긴다. 먼저 다가가기 의사소통 방법 연구 친구 및 남과 함께 행복해지기 즐겁게 만들어라 규칙적으로 만나라 만남에 투자하라 자아성찰(자아탐구, 자아개발) =&gt; 공존의 법칙(타인 존중, 먼저 다가가기)을 통해서 행복해 질 수 있다.","link":"/2018/01/14/행복의-철학/"},{"title":"세계사 개론","text":"세계사 개론고대: 인류 문화의 시작보통 서로마 제국의 몰락한 476년까지를 그 기간으로 한다. 농업 혁명기원전 1만년 ~ 8000년 농업과 목축의 발달로 잉여생산물이 생기고 그에따라 사유재산도 생기고 고대 문명이 시작되었다. 고대 문명기원전 8000년 부터 기원전 4000년 까지 이집트 문명나일강 유역에서 발생한 문명으로 기원전 3100년경 가장 먼저 통일한 이집트는 유럽이 원시사회, 중국은 문자도 없던 선사시대에 1대 파라오 나르메르의 통치로 찬란한 문명을 이어간다. 메소포타미아 문명이그리스, 유프라테스 강 유역에서 시작되어 여러 왕조를 거쳐 기원전 400년 마케도니아 제국 건설한 알렉산드로스 대왕의 점령까지 이집트와 메소포타미어 문명은 고대 그리스, 로마 문명에 큰 영향을 끼친다. 인더스 → 인도 황하 → 중국 함무라비 법전, 모든 법률의 시조가 되다인류문명은 그 자체만으로 매우 취약하기 때문에 강력한 법률로 보호하지 않으면 유지될 수 없다. 고대 바빌로니아의 흥성 / 수메르인이 설형문자를 발명하고 메소포타미아 문명이 발상된다. 함무라비는 온 천하의 왕이라 일컬으며 정의의 왕이라 일컷는다. 함무라비 법전은 메소포타미아 지역의 속국들을 법률로 통일하고 고대 바빌로니아 왕국의 지위를 강조하는 한편 각종 사회관계를 조정하고, 군사력을 강화하였으며, 사회질서 안정에 이바지하였다. 하지만, 신격화된 왕권을 강조하고, 법 앞에서 만민 평등 개념이 빠졌으며 노예를 사유재산으로 인정한 허점이 있다. 공평(equality)의 개념을 확립한 계기가 된다. 법치관리의 막을 열고, 인류문명과 법률생활의 기틀을 닦았으며 훗날 수많은 법률의 토대가 된다. 나르메르, 이집트를 통일하다 (기원전 3100년)이집트는 유구한 문명을 가진 나라로써 전체 인류 문명사에서 가지는 의의가 매우 크다. 이집트 통일 이전의 역사는 확실하게 밝혀지지 않았으나 수로를 만들어 농지에 물을 공급하고, 전쟁을 수행하기 위해서 강력한 권위와 힘이 필요하였으며, 이 힘이 마침내 왕권으로 발전하였다. 이는 인류 최초의 왕권이 된다. 이집트의 통일로 인해 고대 이집트 문명의 발전을 촉진하고 찬란한 인류문명을 형성하였다. 고대의 로마 통치자들은 이집트의 obelisk를 보고 놀라움을 금치못해 로마 광장에 이전하였다. 바빌론 유수 유대인의 방랑이 시작되다서아시아 메소포타미아 남부의 우르 셈족의 한 부락에서 시작해서 외적의 침략으로 부족이 멸망하자 Abraham은 부락민을 데리고 하나님이 그들에게 약속한 땅 ‘가나안’에 도착한다. 이곳의 원주민을 페니키아인이라 하고 이주민인 그들 민족은 헤브라이라 불린다. 이곳에서 Abraham의 손자 야곱이 하느님의 사자와 씨름을 해서 이겨 이름을 Israel로 바꾼다. 이집트의 파라오 람세스2세가 헤브라이인을 노예로 삼아 힘든 노동을 시키자 헤브라이인의 우두머리 모세가 홍해를 건너 이집트에서 도망가 여호와에게 십계명을 받고 유대교를 창시한다. 모세가 죽은 뒤 여호수아가 무리를 이끌고 가나안에 정착하나 12개의 쇼페팀으로 분할되고 말고 (이 중 가장 유명한 쇼페팀이 삼손이다) 이를 틈타 필리스틴민족의 공격을 받는데 이때 사울이 나타나 모두를 구한다. 다윗과 솔로몬왕을 거쳐 남부의 유다왕국과 북부의 이스라엘로 분열되는데, 이 중 유다왕국은 신바빌로니아의 속국이었으나 유다의왕 여호야김이 이집트에 투항하여 신바빌로니아의 왕 네브카드네자르의 분노를 사게 된다. 시드기야의 죽음, Babylonian Captivity 이를 통해 유대인들은 20C에 이스라엘이 건국될 때까지 유랑민족으로 남게 되며, 경제적 이익과, 배움을 중시하는 민족으로 거듭나 마르크스, 아인슈타인, 프로이트 등 수많은 인재를 남긴다. 늑대가 기른 로물루스, 로마를 건국하다로마의 풍습과 법률, 정신, 라틴어 등은 모두 유럽 대부분의 지역으로 전파되어 중동, 아프리카, 지중해 연안에 지대한 영향을 끼치며 이런 광활한 지역에 무시할 수 없는 영향을 미친 제국은 로마가 유일하다. 아가멤논이 이끄는 그리스 연합군이 ‘트로이 목마’ 전술로 소아시아의 트로이를 함락하고 이때, 트로이의 영웅 아이네이아스는 탈출하여 알바롱가를 건립하고 이는 로마인의 시조가 된다. 곧 아물리우스에 의해 왕가가 찬탈되고 로물루스, 레무스가 기원전 753년 로마를 건립한다. 로물루스는 정치권력을 원로원(Senatus), 민회(Comitia)로 분리하여 개국 초부터 로마에 민주적 분위기를 불어넣는다. 사비니여인의 강탈을 통해 로마의 여성 부족 문제를 해결하고 BC 4C말까지 강대국으로 군림하며 포에니 전쟁때 카르타고를 멸망시킨다. 솔론의 개혁, 민주주의의 기초를 다지다아테네의 발달한 상품경제와 건전한 민주정치 페리클레스는 이를 두고 “아테네는 모든 면에서 그리스의 학교다” 라는 말을 남긴다. 아테네의 모든 정치권력은 귀족의 후예에 의해 장악되었고, 집정관, 원로원 구성원도 귀족 중에서만 선출되었다. 이에 수석집정관을 임명하고 헥테모로이를 폐지하여 노예로 전락했던 아테네인이 모두 자유의 몸이 될 수 있었다. 프리드리히 엥겔스 「가족, 사유재산 및 국가의 기원」 에는 이런 말이 있다. “합리적인 개혁만이 대중으로부터 인정받는다. 지금까지 발생하였던 모든 혁명은 한 가지 소유제를 보호하는 동시에 다른 소유제에 반대하고자 한 혁명이다. 솔론의 개혁은 채권자의 재산에 손실을 입혀 채무자의 재산을 보호한 혁명이다.” 솔론의 개혁은 공정의 개념을 제시하고 그리스 민주제도와 자유에 기틀을 다졌을 뿐 아니라 유럽 민주제도의 중요한 근간이 된다. 고대 그리스 올림픽, 인류를 단결하다엘리스(Elis) VS 스파르타(Sparta) 처럼 고대 그리스는 여러 도시국가로 나뉘어 싸움은 끊이지 않았지만, 서로 같은 민족임은 의식하고 있었다. 이에 오랜 분열과 살상에 불만을 느끼고 강력한 군주가 나타나 평화롭고 통일된 그리스를 건립해주길 바랐고, 제우스, 헤라클레스 등 영웅이 출몰하게 된다. 엥겔스 「가족, 사유재산 및 국가의 기원」 “노예제가 그리스 사회의 발전과 번영에 결정적 역할을 하였다. 노예제가 없었다면 그리스는 존재 할 수 없었고, 그리스의 예술과 과학도 발전할 수 없었을 것” 올림픽을 통해 도시국가들 사이의 긴장된 대치 국면도 어느 정도 완화된다. 석가모니, 세계적인 종교인 불교가 탄생하다석가모니는 왕위를 포기하고 출가하여 사문유관(四門遊觀) : 네 개의 성문에서 인생의 4고(四苦)를 직접 보고 늙음, 병듦, 죽음에서 자유/해탈을 추구하였다. 석가모니 불교의 네 가지 진리고 : 인생이 생로병사/희로애락 등 고통으로 가득 참을 인식. 집 : 고통의 원인을 가리키는 것으로써 인간이 갖가지 욕망을 행동으로 옮겨 바라는 결과를 얻으려 하는데, 그러한 행동의 대가로 원망과 고통이 생겨남 멸 : 고통에서 벗어나려면 욕망을 없애야 함. 도 : 수행을 제시 공자와 노자, 동양 문명의 핵심이 되다.공자의 유가「논어」 완전한 철학 체계와 일관된 논리가 부족 노자의 도가도가 천지를 만들고 덕이 도의 성능이며 천지가 만물을 나아 기르고, 만물은 각기 다른 형상을 가지고 있으며, 용도 또한 다 달라 만물에는 귀천이 없고, 자연창조의 기원을 자연 자체에 초자연적인 힘이 지배한다는 종교와 유심론의 기초를 부정 살라미스 해전, 아테네 문명이 우둑 서다BC 490년 기원전 490년 일어난 세계역사상 최초 유럽과 아시아의 대규모 국제전쟁 고대 그리스는 지리적 개념일 뿐 여러 도시국가로 이루어진 나라였다. 페르시아의 크세르크세스 1세는 그리스 연합군의 지휘관이자 스파르타의 왕인 레오니다스와 전투를 벌인다. → 영화 ‘330’의 기원 살라미스 해전은 테미스토클레스의 지휘아래 그리스의 완승으로 끝이 난다. 이를 통해 아테네는 에게 해 지역의 패권을 장악하고, 흑해로 통하는 요충지를 통제하며 비잔틴을 포함한 에게 해 연안 전략적 요충지를 획득한다. 고대 그리스 철학, 서양 철학의 기원이 되다르네상스→소크라테스, 플라톤, 아리스토텔레스의 시대로 돌아가자 소크라테스의 사상BC 469 ~ 399 소크라테스는 고대 그리스의 유명한 유심주의 철학자로써 제자들의 질문에 문답식으로 대답해 제자들이 스스로 정확한 답을 찾을 수 있도록 하였으며 귀납법 의 아버지라 불렸다. 소크라테스의 대화법은 산파술이라는 학문의 갈래로도 발전 사물의 진정한 원인을 개별적인 현상의 배후에 있는 일반적인 사물의 공통된 본성으로 간주하여 만물의 통일성에 대한 인간의 인식을 일반성고, 개별성, 본질과 현상의 경지로 올려놓았다. 플라톤의 유심주의BC 427~ 347 소크라테스의 제자이자 유심론(Spiritualism)철학자로써 펠레폰네소스전쟁 중 탄생하였다. “물질의 세계 밖에 비물질적인 관념의 세계, 즉 이데아의 세계가 있는데, 이데아의 세계만이 실재하는 것이고 물질의 세계는 이데아의 세계를 모방한 것에 지나지 않는다” 고대 그리스 철학을 집대성한 아리스토텔레스BC384 ~ 322 “현실생활에서 여러 가지 삼각형 형태의 물건들이 존재한 후에야 사람들의 머릿속에 비로소 삼각형에 대한 관념이 생겨나며 대수와 기하의 법칙은 자연 현상 속에서 추상화 된 것이다. 생명과 세계는 끊임없이 운동을 하고 있고, 운동을 하지 않으면 시간이나 공간, 물질도 없으며, 모든 것이 변증법적 관념을 가지고 있다.” 아리스토텔레스의 말은 과학의 탄생을 알리고 과학을 하나의 방대한 유기체로 만들었다는 점에서 매우 위대한 철학자이다. 알렉산드로스의 동방원정, 동서양 교류를 촉진하다.펠레폰네소스 전쟁 BC431 ~ 404 아테네와 스파르타가 각각 자기 편 동맹 시들을 거느리고 싸운 전쟁으로써 스파르타의 승리로 끝이 나며 이는 고대 그리스가 쇠망하고, 북부 이웃국가 마케도니아가 강성하게 되는 계기가 된다. 알렉산드로스 대왕의 원정 알렉산드로스 : 아리스토텔레스의 제자로, 그리스 문화를 좋아하여 전세계 그리스화의 꿈을 꾼다. 그리스 반란 평정 후 페르시아로 진격하여 다리우스 3세를 무너뜨리고 그의 어머니와 아내, 딸을 포로로 잡아 페르시아의 반과 바꾼다. 이로써 마케도니아는 이집트를 통치하게 되고 이를 기념하기 위해 나일강 삼각주 서쪽에 알렉산드리아를 건설한다. 동서양교류의 촉진 원정 이전의 알렉산드로스는 그리스 민족이 세계유일의 개화된 문명이라 생각했으나 원정 후 모든 민족은 평등하며 평화롭게 살아야 한다고 주장하게 된다. 하지만 갑작스러운 사망으로 13년 만에 그의 대제국은 멸망하고 만다. 진시황, 중국을 최초로 통일하다.BC259 ~ 210 전국시기에 전국칠웅이 패권 다툼을 벌인 결과 서쪽의 진나라가 강력한 권세를 가지게 된다. 진시황 황제로부터 직접적인 통제를 받고 중앙에서 군현에 이르는 관료제를 도입하고, 중농억상 정책을 펼치며, 도량형을 통일한다. 하지만 분서갱유를 통해 학술과 사상의 자유로운 발전을 심각하게 억압하였으며, 흉노족을 통합하고 만리장성을 축조하는 업적을 세운다. 카이사르(BC100에 탄생), 로마 제국의 기초를 닦다.당시 로마 공화국은 심각한 정치적위기에 직면하고 있었으며, 노예제가 가장 발달한 국가였다. 또한 군사약탈, 조공 등 피정복 지역에 대한 압박과 수탈로 로마 사회의 계급 분화가 가속화 되고 있는 실정이었다. 이에 기원전 130년대부터 많은 사람들이 여러 관점에서 다양한 민주개혁 방안을 제안하게 되는데 처음의 민주운동은 합법적 개정요구이나 점차 폭동과 내란이라는 폭력적인 방법으로 변화하게 된다. 결국 기원전 70년, 검투사 출신의 노예반란 지도자 ‘스파르타쿠스’가 주도하는 노예봉기가 나라를 풍전등화의 위기로 몰아간다. 노예봉기는 로마의 노예제도와 노예제 경제를 뿌리째 흔들어 놓았고, 노예주들은 노예를 통제하고 농사를 짓는 방식을 변화시킬 수밖에 없었다. 로마의 노예제 경제의 발전을 보장할 수 없는 공화정 체제를 변화시켜야만 했고 이때 카이사르가 등장한다. 원수가 되다 젊은 시절부터 귀족 공화파로부터 배척당하여 민주파에 합류하고 점차 반대파의 우두머리가 된다. 히스파니아(Hispania : 지금의 스페인 지역) 총독으로 부임한 카이사르는 그곳에서 군대를 조직해 현지의 독립마을을 정복하는데, 전쟁에서의 승리는 그의 군대에 큰 부를 안겨다 준다. 그 후 로마로 돌아온 카이사르는 원로원의 멸시를 받고 군대에서 막강한 권력을 가진 폼페이우스, 로마 최고의 부자 크라수스와 ‘삼두동맹’을 맺게 된다. 군사적 기반을 확립한 카이사르는 삼두동맹을 깨고 로마를 다시 통일한다. 이때의 로마는 과거의 우유부단한 로마공화국이 아닌 완전히 새로운 중앙집권적 군사독재 국가이다. 카이사르의 죽음과 그의 역사적 지위 귀족 공화 체제를 붕괴시키고 군사, 정치적 대권을 장악하여 군주독재 체제로의 이행을 완수했다. 카이사르는 한 시대를 주름잡는 영웅이자 위대한 정치가 일 뿐 아니라 율리우스력 제정에서도 알 수 있듯이 천부적인 재능과 관대함, 넓은 도량을 갖춘 군주의 전형이자 진정으로 위대한 정치가였다. 악티움 해전, 이집트를 멸망시키고 로마가 제국이 되다.옥타비아누스는 신격화 되어 아우구스투스라 불린다. “나는 벽돌로 된 로마를 물려받아 대리석으로 된 로마를 물려주노라” 카이사르가 살해된 후 그의 부관 마르쿠스 안토니우스 와 옥타비아누스 사이의 완권다툼이 일어난다. 안토니우스, 옥타비아누스, 레피두스는 제 2차 삼두동맹을 결성하나 안토니우스가 클레오파트라에 휘둘릴 때 삼두에서 제외시키고 이집트에 선전포고를 한다. 이에 악티움 해전(BC32년)이 발발하고, 안토니우스는 아테네로 진격하여 옥타비아누스를 공격하나 해전에서 참패하고 클레오파트라가 사망했다는 소문을 들은 그는 자결하고 클레오파트라도 또한 뒤따라 자결한다. 이로써 옥타비아누스는 알렉산드리아로 진격하여 이집트를 합병하고 이집트 왕조는 멸망한다. 이로써 로마 대제국이 건설된 것이다. 예수의 탄생, 기독교를 창시하고 전파하다.콘스탄티누스 대제 : 유럽에서 기독교에 확실한 지위를 부여하고, 왕권과 기독교의 관계를 강화하여 중세 유럽의 기초를 닦았다. 흉노족, 유럽에 진출하다.한나라 시대 초기에 흉노족에 대항할 힘이 없었던 한나라 황제 유방은 화친정책을 편친다. 하지만 한나라 무제는 기원전 2세기경 흉노족과의 결전을 벌인다. 흉노족은 숲속에 살던 게르만족을 역사 무대로 끌어올리고 게르만족 때문에 로마인들의 시대가 종말하게 된다. 또한, 제국의 역사가 사라지고 다원화된 봉건주의 정치가 시작된다. 2세기 무렵 그러한 흉노족의 이주는 시작된다. 게르만족의 대이동, 로마 제국이 쇠망하다. 3세기경 노예제도에 심각한 위기가 오게 되고 350년 경 유럽으로 진출하게 된다. 중세 : 유럽과 아시아유스티니아누스 법전, 로마 법률을 집대성하다.마그나 카르타, 군주 전제정치가 몰락하다. / 1215년1215년에 일어난 마그나카르타는 민주공화제 영국헌정의 기원이 된다. ‘무지왕’이라 불렸던 존 왕은 국가 권력을 이용하여 각 계급을 탄압하였고, 대외정책에 실패하였으며, 교황과의 충돌을 빗었다. 또한, 이러한 처지에서 프랑스를 공격하게 된다. 전쟁에서 패한 영국의 영주들은 존 왕에게 역대 국왕들이 제정한 법률을 준수하고 신하와 백성들의 자유를 존중할 것을 요구하였으며, 존 왕이 받아들이지 않는다면 무력도 서슴지 않겠다고 위협한다. 하지만 존 왕은 이를 받아들이지 않고 무력제압당하여 결국 마그나카르타에 서명하게 된다. 마그나카르타 주로 국왕의 권력을 제한하고 교회와 세습귀족의 경제적, 정치적, 사법적 특권을 보호하는 내용 영국에서 부르주아 혁명이 일어나 봉건 전제왕권이 역사의 발전을 가로막는 걸림돌이 되자 신흥 부르주아 계급과 귀족들은 마그나카르타를 왕권제한의 법률적 근간으로 삼아 새롭게 재해석한다. 영국 부르주아 혁명이 성공한 후에는 또다시 군주 입헌정치를 확립하는 헌법적인 특징의 법률로 변화한다. 마그나카르타는 궁극적으로 의회제도를 확립하고, 천부인권 사상을 내세우는 계기가 된다. 페스트의 창궐, 전 유럽을 삼키다.14C 100년 동안 당시 유럽 인구의 1/4에 해당하는 2천 5백만명이 흑사병으로 사망하였다. 18세기 전후하여 유럽 각국에서는 기초 위생시설 건설에 박차를 가하게 되고 이것이 ‘제 1차 위생혁명’의 계기가 된다. 르네상스 : 서유럽에서 일어난 문화운동 / 14C ~ 17C르네상스란?고대 그리스, 로마 문화를 이상으로 보는 반면, 중세를 인간의 창조성이 무시된 ‘암흑시대’로 봄으로써, 인간들의 지적, 창조적 힘을 부흥시키려는 신념 르네상스, 인문주의가 사상해방 운동의 기초가 되다.14C 이탈리아 인문주의자, 페트라르카 “사람이 만물의 근본” → 사람이 모든 사문을 평가하는 잣대 르네상스의 유산투쟁성, 실용주의 정신, 과학적 사고 등의 유산을 남김 실용주의 정신의 측면에서는 인간 중심적 사고를 보여주는 보카치오 「데카메론」이 있다. 데카메론 에서는 남녀평등 주장, 인간의 지혜와 재능, 사상과 감정을 신의 금욕주의적 통제와 봉건의 억압에서 해방시킬 것을 강조, 현실생활을 열정적으로 주창. 르네상스를 통해 유럽이 중세 봉건사회에서 근대 자본주의 사회로의 전환을 일으켰다. 사상의 대 해방, 인간 가치관의 근본적인 변화가 이루어 졌으며 생활 태도 또한 변화되었다. 콜럼버스의 신대륙 발견, 유럽 세계를 넓히다제1차 항해(1492 ~ 1493) : 신천지, 새로운 인종 발견 제2차 항해(1493 ~ 1496) 아메리카 대륙의 발견 – 새로운 부를 추구하고 자본주의를 발전시키고자 하는 유럽 부르주아들의 욕망에 부응 유럽 자본주의 발전과 봉건제도 붕괴를 가속화 신대륙의 풍만한 물자를 가지고 유럽으로 돌아가나 담배/매독도 함께 옮겨감 마젤란 – 세계최초 세계일주 바스코 다 가마(1460 ~ 1524, 포르투갈) 동서양의 상업무역을 변화시키다. 희망봉을 돌아 최초로 인도 항해 성공 약탈의 시작 - 신항로 개척으로 포르투갈의 수도 리스본은 서유럽의 해외 무역의 중심지로 부상 신항로 개척 - 상업혁명 촉진 가격혁명으로 서유럽의 봉건제도의 쇠락과 자본주의의 반전이 촉진됨 동양 국가들에 대한 유럽 국가의 약탈과 식민지화의 시작 루터의 종교개혁, 부르주아 혁명의 토대가 되다종교개혁 운동이란?종교에 의해 단단히 묶이고 비틀려 있던 마음이 속박에서 벗어나 진리로 회귀한 역사 막스베버 「프로테스탄티즘의 윤리와 자본주의 정신」 “근대 자본주의가 제일 처음 발전하게 도니 계기는 종교개혁을 통해 형성된 프로테스탄티즘의 윤리 덕분” 비로소 근대화의 길로 접어듦 마틴 루터(1483 ~ 1546, 독일) 16C독일에서 종교개혁운동을 처음 일으킨 인물이자, 개신교 루터파의 창시자 신학공부중 하느님의 공명정대함과 징벌이 전현 별개의 것임을 깨닫게 됨 교황(레오10세)가 면죄부 발행을 빌미로 백성들을 수탈하자 「19개조 논제」 “교황이 면죄부를 판매하는 것은 기독교 원리에 위배” 교황과 종교회의의 권력은 신이 부여한 것이 아니라 인위적으로 만든 것이라고 당당하게 주장 →봉건적 신권정치 전체를 공격 교회의 법규 자체를 부정 자본주의 발전에 적합한 부르주아의 청렴한 교리 주장 사람들의 내면세계 일깨움 하지만 독일 농민들이 종교개혁을 당시의 제도를 뒤업는 정치 혁명으로 변화시키기를 원하자, 루터는 움츠러들고 결국 세속의 통치자를 대변하기에 이름. 독일에 천주교와 개신교간의 전쟁인 30년 전쟁(1618 ~ 1648)을 촉발한다. →정치적 모순과 종교적 대립이 서로 충돌하는 유럽 전체의 분쟁으로 확대 개신교는 북유럽, 영국, 미국 등에서 가장 영향력 있는 종교로 부상한다. 스페인 무적함대의 종말, 영국이 강국으로 부상하다.16C 콜럼버스가 대서양을 건너 아메리카 대륙을 발견한 뒤 스페인은 유럽에서 가장 부강한 해상제국을 건설한다. → 무적함대 영국은 자본주의가 겨우 싹트고, 경공업이 발전하는 단계였다. 무적함대가 몰락하고 스페인은 쇠락의 길을 걷게된다. 영국은 해상패권을 장악하고 섬나라에서 일약 초강대국으로 부상한다. 메이플라워호의 신대륙 상륙, 미국이 탄생하다.16C 말 ~ 17C / 영국의 청교도들은 거센 종교개혁으로 새로운 교회를 성립하길 원하게 된다. 17C 중압 / 의회가 국교회를 주장한다. 1620년 09월 / 청교도의 유명한 지도자 브래드 퍼트가 102명을 이끌고 메이플라워호를 탑승한다. 폴리머스 항에 상륙한 그들은 메이플라워 서약을 하고 그해 혹독한 겨울 이민자 102명중 50명만이 살아남게 되는데 그들은 인디언의 도움으로 첫 수확을 거두고 그 날을 ThanksGivingDay라 하여 기념한다. 메이플라워 서약미국 민주정치의 수많은 이념이자 이상 정부는 반드시 통치자들의 동의를 얻어야만 통치할 수 있다는 원칙의 기반 신민지 초창기 의회권력 강화 영국 국왕을 대표하는 총독과 투쟁하며 식민지의 역사 이끔 입법권, 행정권 분리의 계기가 되고 미국 정치 체제의 형성에 중대한 영향을 미친다. 근대 : 과학혁명과 산업혁명베스트팔렌 조약15C 말 / 유럽의 강대국 들로부터 절대주의 시대가 시작 절대군주제가 계급군주제 대체되어 다원화된 초기 국가가 중앙집권적 근대 민족국가로 변화 16세기에 런던, 파리, 바르샤바, 마드리드, 빈, 암스테르담, 스톡홀름이 유럽권력의 중심 1618년 부터 1648년 동안의 30년 전쟁으로 베스트팔렌 조약이 성립된다. 공통의 이익과 통인된 규정, 단일한 가치관을 가지는 국가 관계 체제 확립 공통의 이익과 통일된 규정, 단일한 가치관을 가지는 국가 관계 체제 확립 30년 전쟁 유럽에서 처음 벌어진 대규모 국제 전쟁 베스트팔렌 조약에 따라 유럽 영토가 다시 분할 서양의 국가관계를 탄생시킨 산파 국가 주권을 보유하고 있음을 서로 인정하는 국가와 국가법 원칙에 따른 상화 관계, 그리고 세력균형의 정책에 따라 자국의 생존 환경을 지키는 국제 사회가 기독교를 매체로 결합된 것이 서양의 국가 관계체제라고 분석 영국의 권리장전, 최초로 개인의 자유를 보장하다17C 영국혁명 → 유럽정치혁명의 시작 스튜어트 왕조 1대 국왕 제임스 1세, 2대 아들 찰스 1세에 걸쳐 잉글랜드 성공회의 교리와 인식을 모든 사람에게 강요하고, 국교를 믿지 않는 백석, 청교도 탄압하였다. 왕당파 VS 의회파(크롬웰)에서 의회파가 승리하고 크롬웰은 재판을 통해해 찰스 1세를 처형한다. 그리고 제임스 2세, 찰스 2세가 재위한다. 그러나 제임스 2세의 재위 반대운동이 일어나고 의회파가 사위인 윌리엄을 국왕으로 둘째딸 메리를 여왕으로 앉히는 명예혁명이 일어난다. 권리장전 : 국왕은 반드시 국교회를 신봉하고 국왕의 권한을 제한하며 국회의 권위를 보장하고 법률에 대한 국왕의 거부권을 폐지했다. 국회의 권리에 대해 자유주의 원칙을 적용하고 국회의원은 언론의 자유와 자주회의를 보장받게 된다. 또한 권리장전은 부르주아의 통치지위를 인정하고 정식으로 입헌군주제의 새로운 국가를 수립한다. 표트르 1세, 러시아의 현대화를 촉진하다당시 러시아는 매우 낙후된 내륙국가로 서양인들의 눈에는 야만족의 국가일 뿐이었다. 러시아를 강대국으로 만들기 위하여 가장 필요한 것은 바로 서양을 본받는 것이었고, 표트르대제는 이에 가장 필요한 것은 바다로 보아, 터키의 아조프를 공략한다. 표트르대제의 개혁 문화교육을 장려하고, 전문학교를 설립 생활양식을 개혁하여 귀족들에게 서양풍습 권장 행정기관도 전면 개혁하여 지방정권을 완벽하게 중앙, 즉 자신의 손안에 집중 강력한 군대와 해군을 창설하고, 능력에 따른 관리등용 마르크스 “표트르대제는 야만적인 방법으로 러시아의 야만성을 정복했다” 표트르 요새북유럽 최강국이자 유럽의 강대국 중 하나인 스웨덴을 공격목표로 하여 ‘발트해’의 통제권을 빼앗으려 했다. 첫 침략에 패배하자 표트르는 백성들을 수탈하고 무자비한 징용으로 러시아 최초의 해군 함대인 ‘발트함대’를 창설했다. 표트르 1세는 전제정치를 강화하고, 경제력, 군사력 증강을 통한 대외확장으로 러시아를 유럽의 강대국으로 만들었다. 계몽운동, 부르주아 혁명의 원동력이 되다.18C 계몽(Enlightenment)이란?사람을 지혜롭게 하고, 교육과 홍보를 통해 사람들을 무지하고 낙후된 암흑의 봉건 사회엣 해방. 18C 유럽에서 일어난 봉건주의와 교회에 반대하는 사상, 문화 혁명운동 영주의 주권/신권/특권이 장기간 독보적인 지위를 유지할 수 있었던 중요한 원인은 바로 사람들이 무지하고 무언가를 맹목적으로 믿었기 때문. 인간의 가치/권리를 강조하는 사조 출현 르네상스 이후 유럽에서 두 번째로 일어난 정신 해방운동. 민주정치와 평등한 권리, 개인의 자유 추구 프랑스 대혁명을 위한 여론을 형성하고 형명의 충분한 정신적 토향을 제공했다. 계몽운동의 중심지는 프랑스였다. 사상가의 배출볼테르 봉건교회와 봉건통치를 신랄하게 비판 but, 그의 비판은 무신론적 관점에서 나온 것이 아닌 종교의 부패와 타락, 음탕함에서나온 것 “하느님이 없다면 일부러 만들어 내기라도 해야한다.” 종교가 사람들의 마음을 이어주리라 믿음 몽테스키외 계급혁명 입법권, 사법권, 행정권의 삼권분립 원칙 완성 → ‘견제와 균형의 원칙’ 루소 프랑스 사회 신랄하게 비판 사회계약론 “사람은 태어날 때부터 평등한 존재이고 사회에는 사람의 공통된 이익인 ‘공적이익’ 이 있어서 그 공적 이익을 수호하기 위하여 사람들은 모두 계약을 준수해야 한다.” 통치자가 사회계약을 파괴하려고 할 때 사람들은 그를 몰락시킬 권리가 있다. 국민 주권론 디드로 프랑스 계몽사상가 중 가장 영향력이 크다 「백과전서」 계목사상의 특징인 반미신, 반종교, 반전제, 반사회 불공평을 반영 대혁명의 정신볼테르와 몽테스키외는 영국의 입헌군주제를 찬성하였다. 루소 “영국인들은 스스로 자유롭다고 생각하지만 그들은 큰 착각을 하고 있는 것이다.그들은 국회의원을 선출할 때만 자유로우면, 국회의우너이 선출된 후에는 곧 노예로 변할 것이다.” 국민이 직접 국가 주권과 입법권을 가지는 ‘민주공화제’ 주장 루소의 사상은 프랑스 대혁명의 정신이 된다. 계몽운동프랑스 대혁명의 이론, 사상적 기반이 된다. 국경, 시대를 초월하여 광범위한 공간과 오랜 시간속에서 커다란 작용을 한다. 18C 미국의 독립전쟁과, 정치제도 수릭, 헌법 제정에 영향을 주고, 중국, 일본에도 큰 영향을 준다. 산업혁명, 현대 자본주의 사회의 서막이 울리다.18C 산업혁명은 작업기계에서 시작되었고, 점차 다른 분야에서도 기계를 사용하기 시작하였다. 엥겔스는 다음과 같이 말한다. “방직 산업의 혁명과 함께 산업 전체에 혁명이 시작 되었다. 기계를 사용하고 과학원리를 널리 응용하는 거싱 진보의 원동력임을 곳곳에서 확인할 수 있다.” 새로운 사회 계층인 프롤레타리아가 역사의 무대위로 등장하였고, 19C 영국과 프랑스 등지에서 수탈, 압박에 저항하는 차티스트 운동이이 일어났다. 리옹에서는 노동운동인 파리코뮌이 일어났다. 애덤 스미스의 국부론, 자유주의 경제학을 확립하다.도덕감정론 이기주의적 본성을 가진 개인이 어떻게 감정이나 행위, 특이 이기적인 감정이나 행위를 억제하고, 또 행위 준칙이 필요한 사회를 확립하는지에 대해 설명한다. 국부론 ‘국가의 부의 성질과 원인에 대한 고찰’ 핵심은 국민의 부의 성질과 원인을 명확하게 규명하여, 국가를 부강하게 하고 국민을 풍요롭게 하는 것이다. 국민의 부는 국가가 생산한 상품의 전체 수량이며, 정치경제학의 목적은 국민의 부의 성장을 촉진하고, 개인과 사회, 생산자의 이익 중 어느 하나도 희생시키지 않고 골고루 보호하는 것이다. 인성론에서 출발하여 인간을 분석하고, ‘경제인’으로서의 사람들이 이기주의에서 출발하여 이타적인 결과에 도닥한다는 자유 발전 정책을 지지한다. 시장 경제의 이론적 기초와 상품경제 운행의 원칙을 설명하였다. 미국 독립 전쟁, 아메리카 합중국이 탄생하다.18C 17세기 초 유럽인들이 북아메리카 지역으로 옮겨가기 시작하고, 1607년 영국의 첫 이민자들이 버지니아에 첫 근거지인 ‘제임스 타운’을 설립하면서 북아메리카 대륙으로의 이민 열풍이 시작되었다. 1733년 마지막 식민지인 조지아가 건립될 때까지 13개 식민지가 미국 최초의 13개 주이다. 이미 영국과는 다른 새로운 민족, 즉 미합중국 민족이 형성되었다. 영국령 북아메리카 식민진의 자본주의가 발전하면서 이론적인 위치에서 벗어나 독립적으로 자본주의를 발전시키려는 움직임이었다. 보스턴 학살사건 1770년, 북아메리카에 주둔한 영국군이 보스턴 시민을 사살하였다. 이로인해 민중의 분노가 극에 달했고, 각 식민지마다 민병대를 조직하게 되었다. 1774년 12개 식민진에서 선출된 55인이 필라델피아에서 제 1차 대륙회의를 가졌다. 영국 국왕 5만 군대 동원하여 대륙회의에서 정규 대륙국은 창설하였고, 조지 워싱턴이 대륙군 총사령관으로 임명된다. 1776년 7월 4일 제 2차 대륙회의에서 독립선언이 통과되었다.(독립 기념일) 토마스 제퍼슨이 독립선언 주요 기초위원이다. 미국 독립전쟁은 반영전쟁으로 확대되고 영국은 고립된다. 미국 독립 전쟁 세계역사상 첫 식민지의 민족 해방 전쟁이다. 미국의 자본주의와 현대 문명이 신속하게 발전할 수 있는 탄탄대로를 닦았다. 독립 선언 천분인권과 사회계약론을 계승 발전하여 식민지 독립 투쟁의 이론적 근거가 된다. 인간은 모두 태어날 때부터 평등하며, 하느님으로 부터 부여받은 생존과 자유, 행복을 추구할 권리가 있고, 이 같은 권리를 추구하기 위해 정부를 수립하며, 그 어떤 정부라도 이를 침해하면 국민들이 정부를 교체하거나 해산시키고 새로운 정부 수립이 가능하다. 프랑스 대혁명, 서구 민족주의와 자유주의가 탄생하다.18세기 프랑스는 자본주의 상공업이 이미 크게 발달해 있었으나, 그와 동시에 유럽 대륙에서 가장 전형적인 봉건 전제국가였다. 부르주아 계급은 정치적 권리를 요구하였고, 사회 전반적으로 계급간 갈등 대립이 심각해졌다. 프랑스 봉건 정부의 재정 악화로 삼부회(성직자, 귀족, 평민 대표 신분제 회의)를 소집하였다. 제 3계급 대표는 국왕 권력 제한하고 삼부회를 국가 최고 입법기관으로 정하기로 하였으나 루이 16세가 국민의회의 개최를 막자 ‘제헌국민의로’로 개명하고 공개적으로 반항하였다. 1789년 7월 14일 (혁명 기념일) 바스티유 감옥 습격이 일어났다. 제헌국민의회가 프랑스 최고 행정기관이자 입법기관이 되고 ‘인권선언’을 표한다. 이 인권선언에는 천부인권, 자유, 평등의 원칙이 제시되어 있다. 1791년 제헌국민의회에서 헌법이 발표되고 입헌군주제를 선포하였다. 지롱드파의 정권 장악에서 테르미도르 반동까지지롱드파 상공업자들의 이익을 대변한다. 입법의회를 장악하고 행정권을 손에 넣었다. 프랑스 발미전투 이후 국민공회가 입법의회를 대신하여 계승한 국민 공회가 공화정 선포하는 결의를 통과시켰고, 이는 프랑스 제 1 공화정이 된다. 자코뱅파 중산적 부르주아와 소생산자층의 이익 대변하는 계파이다. 공포정치를 시행하였고, 공화정과 혁명을 구원하는 데는 큰 효과를 발휘하였지만, 급진성과 공포정치 때문에 분열과 내분이 일어 났다. 로베스 피에르는 프랑스 대혁명의 성과를 완전하게 지켜내지 못했고, 설상가상으로 유럽 각국의 봉건군주가 반프랑스 동맹을 구축하고 봉건통치를 부활시키려 했다. 온건파가 테르미도르 반동을 일으켜 새로운 혁명정부인 총재정부를 구성하나 나폴레옹이 쿠데타를 일으키고 봉건세력을 완전히 궤멸시키고 최종적으로 혁명의 성과를 굳건히 수호한다. 프랑스 대혁명을 통해 민족주의와 자유주의가 유럽 대륙에서 빠르게 성장하였다. 민족주의 중세시대에는 백성은 나라에 충성해야 한다는 개념이 없었다. 첫째로 기독교인이며, 둘째로 부르고뉴나 콘원 주민이고, 끝으로 프랑스인이나 영국인이라 생각하였다. 프랑스 혁명, 나폴레옹 시기 민족주의가 고취되었고, 이는 유럽 역상의 중요한 일부이자 20C 세계 역사의 중요한 일부이다. 자유주의 프랑스 대혁명으로 19세기 말 유럽 대부분 국가에서 성년 남자에게 선거권을 부여하였다. 새롭고 민주적인 자유주의가 발전하여 국가가 국민 전체의 복지를 책임져야 한다는 인식이 확산되었고, 복지국가 탄생의 밑거름이 된다. 프랑스 대혁명의 사상과 원칙은 유럽에서 널리 전파되어 19세기 유럽 각국에서 등장한 부르주아 계급 혁명가를 길러낸다. 워털루 전쟁, 나폴레옹이 몰락하다19세기 유럽의 반프랑스 연합군이 파리를 함락하고 나폴레옹은 퇴위하여 엘바 섬으로 유배된다. 몰래 탈출한 나폴레옹은 다시 황제의 자리에 오르나 영국, 러시아, 프로이센, 오스트리아, 네덜란드, 벨기에 등 연합군과 전투를 벌여 결국 워털루 전쟁에서 패배한다. 프랑스 제 1제국이 완전히 몰락하고 유럽은 프랑스 대혁명 이전모습을 회복하였다. 부르주아 혁명의 좌절과 전제정치의 부활이 되었고, 영국은 세계적인 대제국이 된다. 아편전쟁, 서구 열강이 중국을 삼키다.","link":"/2018/01/14/세계사-개론/"},{"title":"컴퓨터 네트워크","text":"1. Computer Network And The Internet 인터넷이란? 인터넷의 하드웨어, 소프트웨어적인 기초 ISP protocol RFCs(Request For Comments) 서비스를 제공하는 주체로서의 인터넷의 기본 지식 Socket Interface The Network EDGE 엔드 시스템(hosts)의 종류 Access Networks Home Access THE NETWORK CORE 패킷 스위칭 store and forward transmission Queing Delays and Packet Loss Forwarding tables and Routing Protocol Circuit Switching Multiplexing in Circuit-Switched Networks Packet Switching VS Circuit Switching A Network of Networks Delay, Loss, and Throughput in Packet-Switched Networks Overview of Delay processing delay queing delay transmission delay propagation delay total delay End to End delay Throughput in Computer Networks Protocol layers and their Service Models Layered Architecture Protocol Layering Application Layer Transport Layer Network Layer Link Layer Physical Layer Encapsulation Network Under Attack 사용자를 공격하는 형태 서버 혹은 네트워크 인프라를 공격하는 형태 패킷을 가로채는 형태 신뢰하는 다른 사람으로 위장하는 형태의 공격 2. Application Layer Principles of Network Application Network Application Architecture client-server architecture P2P application Process Communicating The Interface Between the Process and the Computer Network Addressing Process Transport Services Available to Applications reliable data transfer Throughput Timing Security Transport Services Provided by the Internet TCP Services UDP Services The web and HTTP User-Server Ineraction: Cookies Web Caching web cache의 작동 순서 Electronic Mail in the Internet DNS - The Internet’s directory Service Services Provided by DNS Overview of How DNS Works A Distributed, Hierarchical Database DNS Caching Peer to Peer File Distribution Scalability of P2P Architectures Server to Client Architecture P2P Architecture bit torrent 3. Transport Layer Introduction and Transport-Layer Services Multiplexing and Demultiplexing Connectionless Transport: UDP PRINCIPLES OF RELIABLE DATA TRANSFER Building a Reliable Data Transfer protocol Reliable Data Transfer over a perfectly Reliable Channel: rdt1.0 Reliable Data Transfer over a Channel with Bit Errors: rdt2.0 rdt2.1 rdt2.2 Reliable Data Transfer over a lossy Channel with Bit Errors:rdt3.0 Go-Back-N(GBN) Selective Repeat(SR) 4. The Network Layer: Data Plane Overview of Network Layer Forwarding and Routing: The Data and Control Planes Control Plane: The Traditional Approach Control Plane: The SDN Approach 5. The Network Layer: Control Plane Routing Algorithms The Link State(LS) Routing Algorithm The Distance-Vector Routing Algorithms 7. Wireless and Mobile Networks WIFI : 802.11 WIRELESS LANS The 802.11 MAC Protocol Dealing with Hidden Terminals: RTS and CTS 8. Security in Computer Networks What is Network security? Confidentiality Message integrity End point authentication Operational security 중간 침입자는 다음과 같은 기능을 할 수 있다. Principles of Cryptography Symmatrcic Key Cryptography Public Key Encryption Message Integrity and Digital Signature Cryptographic Hash Functions 비트코인 비트코인이란? Industry 4.0 Ubiquitous Layering Architecture History Of Computer Network 80년대 90년대 2000년대 유비쿼터스 컴퓨팅 VS 모바일 컴퓨팅 Mobile Computing 유비쿼터스 컴퓨팅 Home Network Security VS privacy Energy Introduction Of Data Analytics Data Analytics R/D Environment Three Types of Communication 1. Computer Network And The Internet인터넷이란?인터넷이란 컴퓨터 네트워크의 한 형태이다.인터넷은 전 세계에 있는 수십억개의 컴퓨팅 디바이스들을 연결하는 컴퓨터 네트워크 이다.이를 구성하는 요소들에는 컴퓨터 뿐만이 아니라 다양한 기기들이 있으며, 이 모든 기기를 hosts 또는 end systems 라고 부른다. end systems들은 communication link와 packet switches들의 네트워크에 의해 연결되어 있다. packet switch는 여러 가지 형태로 있는데, 가장 많이 사용되는 형태는 router와 linke-layer switches이다.link layer switch는 네트워크에 접속하는 데 많이 쓰이고, 라우터는 네트워크 코어에 쓰인다. 인터넷의 하드웨어, 소프트웨어적인 기초ISPend systems들은 ISP(Internet Service Provider)를 통해 인터넷에 접속한다.이 종류에는 local cable, telephone companies같은 지역 ISP와, Wifi Access를 제공하는 ISP 등을 포함한다. protocolEnd System, Packet Switch 그리고 다른 인터넷의 구성요서들은 인터넷을 통해 정보를 전송하고 수신하는 것을 컨트롤 하기 위해 프로토콜을 실행한다.TCP(Transmission Control Protocol)IP(Internet Protocol)가 인터넷에서 가장 중요한 두개의 프로토콜이다.프로토콜이란 두개 혹은 여러개의 communicating entities들이 메세지를 교환할 때 사용하는 포맷이나 규칙을 정의한다. 예를 들어 사람사이의 커뮤니케이션에서의 프로토콜이라 하면 특정 사람이 어떤 메세지를 받았을 때, 답으로 전달할 구체적인 메세지와 특정한 행동 양식이 있다는 것이다.만약 두 사람 사이의 커뮤니케이션에 있어 한 사람은 매너가 좋은데 한 사람은 매너가 없다면 대화가 이루어 지지 않고, 한 명은 아예 다른 문화권(혹은 외계인)일 경우에도 대화가 이루어 지지 않는다.즉, 프로토콜이란 이러한 커뮤니케이션이 가능한 환경을 말한다. 네트워크 프로토콜의 경우도 사람사이의 프로토콜과 마찬가지로 많이 존재한다.예를 들어 두 개의 컴퓨터가 비트를 주고받기 위한 물리적인 프로토콜이 있고, 또 다른 예로는 엔드 시스템에서 전송자와 수신자 사이의 패킷 전송률을 관장하는 congestion control protocol이 있다.위에서 보듯이 프로토콜을 정의하는 핵심 요소는 특정 메세지를 보내거나 받을 때 취해지는 메세지나 행동의 교환이다. 프로토콜은 두개 혹은 여러개의 커뮤니케이팅 대상들의 메세지 교환의 형식과 순서를 정의한다.또한, 메세지의 전송 혹은 수신이나 또 다른 이벤트가 발생하였을 때의 행동을 정의한다. 컴퓨터 네트워크를 마스터한다는 것은 네트워크 프로토콜들이 왜, 어떻게 동작하는지를 아는 것과 동일하다 RFCs(Request For Comments)모두가 프로토콜들이 하는 역할을 동의하기 위해서 IETF(Internet Engineering Task Force)에서 internet Standards를 도입했다.IETF의 공식 문서를 RFCs라고 하는데, 여기서는 다양한 종류의 프로토콜을 정의한다.대표적으로 IP, TCP, HTTP(웹을 위한 프로토콜), SMTP(이메일을 위한 프로토콜) 등이 있다. 서비스를 제공하는 주체로서의 인터넷의 기본 지식Socket Interface하나의 end system에서 동작하는 프로그램이 다른 end system에서 동작하는 특정 대상 프로그램에게 데이터를 전송하기 위해 Internet Infrastucture에게 요청하는 양식 혹은 환경을 말한다.마치 편지를 보낼 때 우체국을 이용하려면 그들이 갖추어 놓은 체계에 따라 편지 봉투에 우편번호를 작성하는 것 처럼.인터넷을 통해 무언가 정보를 보내기 위해서는 이러한 internet socket interface환경에 맞추어야 한다. The Network EDGE컴퓨터, 스마트폰 등 네트워크에서 우리가 가장 흔하게 접해본 내용들을 학습한다.즉, 네트워크의 엔드시스템들을 다룬다.그리고 다음 장에서는 실제 컴퓨터 네트워크에서 스위칭과 라우팅이 어떻게 동작하는 지를 다루는 network core를 학습한다. 엔드 시스템(hosts)의 종류여기서 host는 client와 server로 나뉜다.데스크탑 컴퓨터, 서버, 모바일 기기, iot devices Access Networks엔드 시스템에서 네트워크의 edge로 접속하는 것을 다룬다.엔드 시스템과 최초의 라우터(edge router) 사이의 네트워크 이다. Home AccessDSL 방식: 전화선을 공유하여 인터넷을 연결한다.전화선에 각각 다른 주파수를 통해 통신을 하기 때문에 전화 통신이랑 같은 선을 쓸 수 있다. THE NETWORK CORE패킷 스위칭인터넷의 end system들을 연결하는 packet switch와 links의 동작 흐름을 알아본다.source가 되는 end system 하서 destination이 되는 end system으로 정보를 전송할 때 source는 긴 메세지를 작은 정보의 뭉터기로 쪼게는데 이를 패킷이라고 한다.소스에서 destination으로 가기 위해서 각 패킷은 커뮤니케이션 링크와 패킷 스위치들을 통과하게 되는데 이 패킷 스위치에는 가장 잘 알려진 라우터와 링크 레이어 스위치가 있다.각 커뮤니케이션 링크의 패킷들을 그 링크의 전송률을 최대로 활용하므로전송률 R로 L bit의 패킷을 보내는 데 걸리는 시간 $T=L/R$이다. store and forward transmission대부분의 packet switch들은 link의 input단에서 store and forward transmission을 하는데 이는 packet switch가 다른 outbound link로 최초의 packit 의 bit를 보내기 전에 전체 packet을 받아야 함을 의미한다. 라우터는 받은 패킷을 어떤 링크로 전송하는 지를 결정하는 역할을 수행하는데, packet의 bit를 buffer하여 다 받고 나서 outbound link로 패킷을 전송하기 시작한다. propagation delay: 피트가 와이어를 타고 빛의 속도로 이동하는 데 걸리는 시간으로 지금은 무시하기로 한다. queing delay: 전송하기 전에 output buffer에서 packet bit들이 쌓이게 되는데 이 때문에 queing delay가 발생한다. transmissioin delay: 패킷의 모든 비트를 링크로 밀어넣는데 걸리는 시간이다.router의 output link단에서의 buffer 때문에 발생한다. 실제 전송에 걸리는 시간: source에서 $L/R$의 시간동안 데이터를 전송하면 propagation delay를 무시하므로 데이터를 전송하는 동안 라우터의 buffer에 이 패킷의 비트들이 쌓이게 된다.전송이 끝나면 이 라우터는 목적지로 데이터를 전송하기 시작하는 데, 이때도 또한 $L/R$의 시간이 걸리게 되므로 총 걸리는 시간은 $2L/R$의 시간이 걸리게 된다. 하나의 소스에서 여러개의 라우터를 통해 패킷을 전송하는 경우: 소스부터 라우터 사이에 N-1개의 링크가 있고, 라우터에서 destination사이에 하나의 경로가 있어 전송률이 R인 총 N개의 링크를 통해 데이터를 보내는 데 걸리는 시간은$$d_{end-to-end} = NL/R$$ Queing Delays and Packet Lossqueing Delays: 라우터는 각각의 링크들과의 연결에서 보낼 패킷을 저장해두는 outer buffer가 있다.만약 각 링크들에 이미 패킷을 보내고 있다면 라우터는 이런 패킷들의 전송이 끝나기 까지 기다려야 하는데 이것이 바로 queing delay이다. 이러한 queing delay는 네트워크의 혼잡도에의해 결정된다. pakcet loss: outer buffer가 전송을 기다리는 다른 패킷들로 꽉 차있어서 패킷을 받지 못하는 경우 패킷이 유실된다. Forwarding tables and Routing Protocol우리는 라우터가 패킷을 받아 다른 링크로 전송해 준다고 배웠다. 하지만 이 라우터는 어떻게 보내야할 링크를 선택하는 것일까?이것은 마치 사람이 길을 찾아갈 때 전체 지도를 가지고 있지 않더라도 분기점 마다 방향에 대한 정보만을 받아 목적지에 도착할 수 있는 것과 같은 원리이다.모든 end system은 IP주소를 가지고 있다.source end system 이 destination end system 으로 패킷을 전송하고자 할 때에는 packet의 header에 destination end system의 IP주소를 포함해야 한다.각 router는 destination address를 해당 router의 outbout link에 매칭시키는 forwarding table을 통해 목적지로 가는 다음 라우터의 주소를 가르쳐주고, 이런 forwarding table은 routing protocol을 통해 만들어 진다. Circuit Switching서킷 스위칭 네트워크에서, 각 엔드시스템 사이에서 통신을 하기 위한 자원들(버퍼, 링크 전송률 등)이 커뮤니케이션 세션이 유지되는 동안에만 제공된다.전화 네트워크가 서킷 스위칭의 예이다. 전화 통신에서의 이런 연결은 circuit(회선)이라고 부른다. 전화가 한번 연결이 되면, 네트워크에서의 전송률을 보장을 한다.각 연결은 총 4개의 링크가 유지되어야 하기 때문에 전체 전송률이 1Mbps라면 각각의 circuit switch 연결은 250Kbps의 속도밖에 얻지 못한다. Multiplexing in Circuit-Switched NetworksFDM(Frequency Division Multiplexing): 주파수를 다르게 하여 송신한다, 이러한 주파수의 범위를 bandwidth라고 한다. TDM(Time Division Multiplexing): 시간간격을 쪼개어 데이터를 전송한다.시간은 프레임으로 쪼개지고 각 프레임의 slop이 하나의 통신 데이터를 담고 있다.만약 초당 8000프레임의 속도로 링크를 통한 전송을 할 때 각 slot이 8bit로 구성되어 있다면이 circuit의 전송률은 8000*8bps 즉 64Kbps이다. packet switching을 옹호하는 많은 사람들은 서킷 스위칭은 쉬는 시간에도 자원을 소모한다는 점을 단점으로 꼽는다. Packet Switching VS Circuit Switching현 트렌드는 패킷스위칭을 주로 한다. A Network of Networks엔드시스템들이 ISP를 통해 인터넷에 연결되는 만큼 이런 ISP들 사이의 네트워크 또한 필요하다. Network Structure 1: 각각의 access ISP들을 묶어 하나의 global transit ISP를 만든다. Network Structure 2: 여러개의 global transit ISP들이 생겨나고 이 transit ISP들이 연결된다. Network Structure 3: 기존의 global transit ISP들을 tier-1 ISP라 명명하고 이를 통합하는 regional ISP들이 생겨나게 된다.여기서 global transit ISP들에는 많은 통신사들이 포함된다. Network Structure 4: access ISP를 제외한 모든 ISP 들은 provider ISP에 접속하기 위한 PoP이 있다.그리고 가가운 ISP들이 모여 Internet Exchange Point를 형성한다. Network Structure 5: google과 같은 큰 대기업들은 content provider networks를 구성한다.구글은 수십개의 데이터센터를 보유하고 있으며 독자적인 TCP/IP를 통해 연결되어 있으며 이는 전 세계를 연결하는 동시에 public 망과는 독자성을 띄고 있다.구글의 독자적인 네트워크는 internet의 upper tiers를 건너뛰고 바로 access ISP에 접근하고 자하며, 이를 통해 가격을 절감한다. Delay, Loss, and Throughput in Packet-Switched Networks가장 중요한 delay들은 nodal processing delay, queing delay, transmission delay, propagation dalay가 있다.위의 모든 delay를 합산하면 total nodal delay가 된다. Overview of Delayprocessing delay패킷의 헤더를 통해 목적지가 어디인지 파악하는데 걸리는 시간이다. queing delayoutbound link 에서 전송되기를 기다리는 데 걸리는 delay이다.이는 전체 delay에서 매우 중요한 역할을 하며 이를 다루는 논문들이 매우 많다.이는 다른 delay와 다르게 패킷마다 그 정도가 다르다.예를 들어 10개의 패킷이 도착하면 첫 패킷은 처음왔으므로 queing delay가 zero이나 뒤의 패킷들은 앞에 남은 패킷에 따라 그 정도가 제각각이다.때문에 queing delay를 말할 때는 통계학적 수치를 가지고 말한다.가령 평균 queing delay라고너, variance of queing delay, 그리고 queing delay가 특정 수치 이상일 확률 등으로 표현한다. a를 queue에 도착하는 패킷 개수의 초당 비율이라 하고, R을 transmission rate라 하고, 각 패킷의 비트수가 모두 L이라고 하면 도착하는 비트의 속도는 La/sec가 된다.여기서 $La/R$을 traffic intensity 라고 부른다.이 수치가 1을 넘게 되면, queing delay는 무한으로 본다.이 수치가 1에 가까워 지면 가까워 질수록 Average Queing Delay는 급격하게 증가한다.또한 packet lose가 발생한다. transmission delay패킷의 모든 피트를 링크 안에 밀어넣는데 걸리는 시간이다.$L/R$이다 propagation delay비트가 전선을 타고 전달되는 속도이다.흔히 빛의 속도를 일컬어 지며 무시해도 될만큼 작다. total delay$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$여기서 propagation delay는 거의 무시 가능하나, 위성 통신 등에서는 상당한 값을 가진다.또한, processing delay의 경우도 거의 무시 가능하나, 하나의 라우터의 최대 throughput을 결정하는 데 큰 영향을 준다. throughput in computer Networks파일을 전송받는 데 걸리는 시간이다. End to End delaysource 와 host 사이에 N-1개의 router가 있는 경우$d_{end-end}=N(d_{proc}+d_{trans}+d_{prop})$여기서 $d_{trans}=L/R$ 이다. Throughput in Computer NetworksF bit의 파일을 보내는 데 T 초가 걸린다면average throughput은 $F/T$이다.하지만 만약 서버가 라우터에 보내는 속도($R_s$)보다 라우터가 클라이언트에 보내는 속도($R_s$)가 더 느리다면 이 때 전송 속도는 라우터가 클라이언트에 보내는 속도와 같을 것이다.그러므로 throughput은 $min(R_c, R_s)$ 이다. Protocol layers and their Service ModelsLayered Architecture비행기를 타고 내리는 것과 마찬가지로 인터넷도 패킷을 보내고 받는 일련의 과정으로 나눌 수 있다.티켓을 끈고 수화물을 찾는 등 여러가지 절차들로 나누어 비행서비스를 설명할 수 있듯이 네트워크도 이러한 일련의 작업들의 집합으로 설명한다. 이런 구조화를 layering Architecture라고 한다.이러한 layered architecture를 통해 우리는 각 부분들을 더욱 잘 이해할 수 있으며, 크고 복잡한 시스템의 각 부분을 더 잘 이해하게 된다. 이러한 간소화작업은 모듈화를 해주며, 각 레이어들이 제공하는 서비스들을 알 수 있게 해준다. 각 레이어들은 상위 레이어에게 같은 서비스를 제공하고, 하위 레이어와 같은 서비스를 이용하기 때문에 특정 레이어의 기능이 바뀌어도 전체 시스템은 변하지 않고 유지 될 수 있도록 해 준다.예를들어, 공항에서 승객들을 실어나르는 방식이 바뀌어도 역시 승객을 실어나른다는 같은 기능을 수행하기 때문에 전체 시스템은 변하지 않고 유지될 수 있다. layering을 통해서 크고 복잡한 시스템의 각 부분의 동작방식을 바꾸어도 다른 요소들에 영향을 주지 않을 수 있는 점은 아주 중요하다. Protocol Layering각 프로토콜은 하나의 레이어에 속하게 된다.우리는 하위 레이어가 상위 레이어에게 어떤 서비스를 제공하는가를 관심있게 살펴볼 것이며, 이것을 service model 이라고 한다. 각기 다른 레이어들의 프로토콜들을 protocol stack이라고 부른다.인터넷 프로토콜 스택은 5개의 레이어로 나뉜다. physical, link, network, transport, application 이 그것이다.이책은 application-layer를 시작으로 하위 위에서 아래로 학습해 나가는 top-down 접근을 사용했다. 프로토콜 레이어 사용하는 패킷 단위 대표적인 프로토콜 application-layer message HTTP, SMTP, FTP transport-layer segment TCP, UDP network-layer datagram IP Link-Layer frame Ethernet, Wifi physical-layer bit protocol for copper wire etc Application Layer네트워크 어플리케이션과 어플리케이션 레이어의 프로토콜들이 있다.어플리케이션 레이어 프로토콜은 여러개의 엔드 시스템에서 동작하며 각 각의 엔드 시스템에서 프로토콜을 사용하여 다른 엔드시스템의 어플리케이션과 메세지 형태로 패킷을 주고 받을 수 있다.어플리케이션 레이어 프로토콜의 종류 프로토콜 이름 기능 HTTP 웹 문서를 전송하고 받는 프로토콜 SMTP 이메일 메세지를 주고 받는 프로토콜 FTP 두 엔드시스템 사이에서 파일을 주고받는 프로토콜 Transport Layerapplication-layer의 message들을 전송한다.TCP와 UDP 두 종류가 있는데, 둘 다 어플리케이션 레이어의 메세지들을 전송할 수 있다. TCP: connection 기반의 서비스를 제공하여, 어플리케이션 레이어의 메세지 전송을 보장하고 flow control을 제공한다.또한 큰 메세지들을 작은 segment로 나누고, congestion control mechanism을 제공한다. UDP: 무선 서비스를 제공한다.이는 안정성도 보장하지 못하고 흐름제어 또한 하지못하며, 혼잡 컨트롤이 안된다. transport layer의 패킷을 segment 라고 부를 것이다. Network Layerdatagrams라 불리는 네트워크 레이어 패킷들을 호스트들 사이에서 전송하는 역할을 한다.트랜스포트 레이어의 프로토콜은 네트워크 레이어에게 segment와 목적지 정보를 전달하면, 목적지의 호스트의 트랜스포트 레이어에 세그먼트를 전달한다.일반적으로 IP 프로토콜을 포함하는 개념이며, 네트워크 레이어를 구성하는 모든 구성요소들이 IP프로토콜을 실행하여야 한다. Link Layer라우터의 한 노드에서 다른 노드로 패킷을 옮기기 위해 네트워크 레이어는 링크 레이어의 서비스에 의존한다.링크 레이어에 의해 제공되는 서비스는 링크에 적용된 링크레이어 프로토콜에 의존한다.예를 들어, 어떤 링크 레이어 프로토콜은 송신 노드에서 링크를 거쳐 수신 노드로 reliable delivery를 제공한다.여기서 말하는 reliable delivery service는 한 엔드 시스템에서 달느 엔드시스템으로 reliable delivery를 하는 TCP의 reliable delivery service와는 다르다.네트워크 레이어는 각각 다른 링크 레이어 프로토콜에게 다른 서비스를 받는다. 이 책에서 링크 레이어 패킷을 frames라고 부른다. Physical Layer한 네트워크 요소에서 전체 프레임을 다른 인접한 네트워크 요소로 옮기는 역할을 link layer가 수행한다. Encapsulation 전체 네트워크 프로세스는 한 엔드 시스템에서 어플리케이션의 메세지가 그 엔드 시스템의 transport layer와 network layer, link layer, physical layer를 거쳐 라우터의 link layer로 들어가 physical layer를 거쳐 네트워크의 physical layer로 가서 link layer, network layer 를 거쳐 다른 엔드 시스템의 physical layer로 들어가고 여기서 다시 link layer, network layer, transport layer, application layer를 거쳐 전달된다. 우체국을 예를 들자면 편지(메세지)를 봉투(segment)에 담는것이 트랜스포트 레이어에서의 작업이다. 여기에 우편번호를 쓰고 다른 봉투에 담는 행위를 네트워크 레이어에서 처리하고 이를 가까운 우편 사무국에 전달 함으로써 (링크레이어로 보냄) 우편을 보낸다.여기서 부터 decapulation이 시작되는데, 여기서 정보를 읽어들여 실제 배송을 준비하고 밥에게 메세지를 전달한다. Network Under Attack사용자를 공격하는 형태인터넷을 통해 악한 것들을 보낼 수 있는데 이런 악한 것들의 모음을 malware라고 칭한다.이런 malware들은 온갖 종류의 나쁜 짓을 할 수 있고, 현대의 많은 malware는 자가 복재를 하여 주변의 인터넷을 사용하는 많은 호스트들을 감염시킨다.Virus는 사용자가 특정 행동을 취할때 사용자의 디바이스를 감염시키는 것이다.Worm은 유저의 상호작용없이도 사용자의 디바이스에 침임할 수 있는 형태이다. 서버 혹은 네트워크 인프라를 공격하는 형태Denial Of Service(Dos) Attacks: 네트워크, 호스트, 다른 인프라환경을 변형하여 기능을 못하도록 하는 것. 대표적인 Dost 공격은 다음과 같다. Vulnerability Attacks특정하게 조작된 메세지를 취약한 어플리케이션이나 운영 시스템에 보내는 것적합한 형태의 패킷이 전달되면 서비스가 중지될 수 있다. Bandwidth flooding막대한 양의 패킷을 보내 공격 대상의 access link가 마비되게 하는 것 Connection flooding많은 양의 TCP 연결을 걸어 다른 연결을 못하도록 하는 것. 패킷을 가로채는 형태신뢰하는 다른 사람으로 위장하는 형태의 공격2. Application LayerPrinciples of Network ApplicationNetwork Application Architecture네트워크 아키텍쳐는 이미 그 체계가 잡혀있고, 어플리케이션에게 정해진 서비스를 제공한다.어플리케이션 아키텍쳐란 어플리케이션 개발자들에 의해 디자인되며, 여러가지 시스템들에서 어떻게 동작하는 지를 명시한다.어플리케이션 아키텍쳐를 디자인 할 때, 두 가지 종류의 큰 아키텍쳐 디자인 패러다임이 있는데 그것은 바로 client-server Architecture 와 peer-to-peer architecture 이다. client-server architecture클라이언트 서버 구조에서는 서버라 불리는 호스트가 항상 존재한다.서버는 클라이언트라 불리는 많은 호스트들이 계속해서 요청을 하고 그에 맞는 서비스를 제공한다. P2P applicationp2p 구조에서는 피어라고 불리는 호스트들 사이에 직접 통신이 이루어 진다.현대의 매우 유명하고 트래픽이 많은 어플리케이션들이 p2p에 기반한다. Process Communicatingend system 내에서 서로 소통을 하는 것은 program이 아니라 process이다. The Interface Between the Process and the Computer Networkprocess는 소켓이라는 소프트웨어 인터페이스를 통해 네트워크에 메세지를 전송하고 수신할 수 있다.socket은 application layer와 transport layer의 경계 이다.또한 소켓은 network application이 구성되어 있는 환경에서의 programming interface이기 때문에 API(Application Programming Interface)라고 불린다. Addressing Process프로세스의 주소를 찾아가기 위해서는 두가지를 알아야 한다. 목적 디바이스의 IP 주소 해당 프로세스가 작동하고 있는 디바이스의 포트번호 Transport Services Available to Applications트랜스포트 레이어의 프로토콜이 제공하는 서비스는 어떤 것들이 있는가? reliable data transfer프로토콜이 데이터 전송 서비스를 보장하면 안정적인 데이터 전송을 한다고 말한다.트랜스포트 레이어 프로토콜이 제공하는 것 중 하나는 프로세스에서 프로세스로의 안정적인 데이터 전송을 가능하게 한다는 것이다. Throughput트랜스포트 레이어 프로토콜은 일정한 수준의 throughput을 보장한다.특정 수준의 throughput을 필요로 하는 어플리케이션을 bandwidth-sensitive application이라고 한다. TimingSecurityTransport Services Provided by the Internet인터넷이 제공하는 구체적인 트랜스포트 레이어 프로토콜의 서비스를 알아본다. TCP Services 연결 기반의 서비스 이다. 안정적인 데이터 전송 서비스를 제공한다. UDP ServicesUDP는 Connectionless하기 때문에 handshaking 이 필요없다. The web and HTTPOverview of HTTPHttp란 Hypertext Transfer Protocol의 약자로, 웹의 application-layer protocol이다. User-Server Ineraction: Cookies쿠키는 웹 사이트가 유저를 트래킹 하기 위해서 존재한다. Web Cachingproxy server라고도 불리는 web cache는 원래 서버를 대신하여 HTTP 요청을 만족하는 네트워크 요소이다.web cache는 자체적인 디스크 저장소가 있어서 최근에 요청된 객체들의 카피를 저장하고 있는다. 브라우저가 무언가를 요청하면 가장 먼저 web cache로 요청이 간다. web cache의 작동 순서 브라우저가 Web Cache와 TCP Connection을 형성하고, HTTP 요청을 보낸다. Web Cache는 요청한 내용의 가피본을 자체적으로 저장하고 있는지를 체크하고 만약 있으면 해당 객체를 돌려준다. 만약 Web Cache가 요청받는 객체를 가지고 있지 않으면 Web Cache는 origin server와 TCP Connection을 열고 요청받은 객체를 가져온다. Web Cache가 요청한 객체를 받으면 이 것을 자체 저장소에 저장하고 카피본을 보내준다. 웹 캐시를 통해 클라이언트의 요청을 보다 빠르고 저렴하게 처리할 수 있다.또한 인터넷으로의 접근량을 줄여 획사 혹은 대학에서 대역폭을 업그레이드 하지 않아도 된다.또한, 웹 캐시는 전체 인터넷의 웹 트래픽을 현저하게 줄여준다. Electronic Mail in the InternetDNS - The Internet’s directory ServiceServices Provided by DNSDonmain Name System은 hostname을 IP주소로 번역해주는 시스템이다. Overview of How DNS WorksA Distributed, Hierarchical Database host가 인근 local dns server에 domain name을 요청한다. local dns server는 root DNS Server에 요청을 보낸다. Root DNS Server는 .com 등 domain을 분석하여 해당 도메인을 관리하는 TLD DNS Server를 가르쳐 준다. Local DNS Server는 위의 TLD DNS Server로 요청을 보낸다. TLD DNS Server는 해당 Authoritative DNS Server를 가르쳐 준다. 위의 Authoritative DNS Server로 요청을 보낸다. Authoritative DNS Server는 Local DNS Server 에게 도메인을 보낸다. 도메인을 받아 host에게 돌려준다. DNS Caching위의 DNS 구조는 DNS Caching을 무시한 것이다.이 구조는 매우 간단한데 바로 한번 요청한 url에 대해서 이를 캐싱해 놓는 것이다. Peer to Peer File DistributionScalability of P2P ArchitecturesServer to Client Architecture서버에서 클라이언트로 데이터를 주고 받는 방식에서는 Distribution time은 클라이언트가 서버로 부터 다운받는 속도가 가장 느린 경우보다 커야하며, 또한 클라이언트가 서버에 자료를 올리는 시간보다도 커야한다.최소 배포 속도(Minimum Distribution Time)를 결정할때 다음을 고려한다. 최초에는 서버만 원본 파일을 가지고 있기 때문에 최소 이 전송시간 보다는 minimum distribution time이 길어야 한다. 제일 느린 피어가 다 받아야 하므로 이 시간보다도 길어야 한다. 전체 전송 가용량(upload capacitance)는 서버와 다른 피어들의 전송률의 합과 같다.전체 피어들의 개수와 전체 파일 크기를 곱한 만큼을 전송해야 한다.즉, 최소 $NF/u_s$보다 커야한다.$D_{cs} = max(NF/u_{s}, F/d_{min})$$while,$ $d_{min} = min(d_1, d_p, …, d_N)$ P2P Architecture각 피어들이 파일을 배포할 때 서버를 도울 수 있다. 배포의 시작점에서 파일은 오직 서버만이 들고있다.이 파일을 피어들의 집합으로 전송하기위해 하나의 파일을 온전히 다 전송해야 한다.즉, minimum distribution time은 적어도 $F/u_s$ 이상이다. 가장 느린 피어가 다 받는데 걸리는 시간인 $F/d_min$보다도 커야한다. 전체 시스템의 업로드 역량은 서버 뿐 아니라 각 피어들의 업로드 전송률을 다 합한 것이다.즉, $u_{total}=u_s+u_1+u_2+…+u_N$ 이다.따라서 전체 업로드에 걸리는 시간은 $NF/u_{total}$ 이다. $D_{P2P}=max(F/u_s, F/d_{min}, NF/(u_s+u_1+u_2+…+u_N))$ bit torrent비트 토렌트는 매우 유명한 P2P Protocol이다.하나의 피어가 다운로드를 받는 동안 이 피어는 동시에 자체적인 업로딩 성능을 가지고 서버를 도와 다른 피어에게 데이터를 전송한다.(TCP Connection)특정 파일을 배포하는데 참여하는 모든 피어들의 집합을 토렌트라고 부른다.각 토렌트는 tracker라고 불리는 infrastructure node를 가지는데, 한 피어가 토렌트에 조인하면 그 자신을 트래커에 등록시키고 주기적으로 자신이 아직 토렌트에 있음을 알려준다. 이런식으로 트래커는 토렌트에 참여하는 피어들을 추적하게 된다. 예를들어 엘리스라는 사람이 토렌트에 참여했다고 보자. 엘리스가 토렌트에 참여하는 순간 무작위로 토렌트에 참여한 다른 피어들의 IP주소를 받아와 엘리스에게 전달한다.이 피어들을 가짐으로써 엘리스는 이 IP리스트의 피어들과 모두 TCP Connection을 연결한다. 이 피어들을 neighboring peers라고 부른다. 모든 시간대에서 각 피어들은 파일의 뭉텅이들 중 일부를 가지고 있을 것이다. 엘리스는 자신의 neighboring peers에게 뭉텅이들의 리스트를 요구할 것이고, 만약 엘리스가 L명의 각기 다른 이웃을 가진다면 그녀는 L개의 뭉텅이들을 가질 것이다. 모든 시간대동안 엘리스는 자신의 이웃들이 어떤 chunks를 가지고 있는지 알고 있다. 엘리스는 자신의 이웃들중 누구에게 어떤 chunks를 요청할지 결정해야 하는데 이는 rarest first원칙에 따라 가장 희소한 chunks를 먼저 받아오게 된다.이를 통해 희소한 chunk들은 더 빨리 redistribute 될 수 있게 된다. 어떤 요청에 대해 응답할지를 결정해야 하는데 여기서 BitTorrent는 아주 똑똑한 알고리즘을 사용한다.이는 바로 그녀에게 가장 빨리 전송해 주고 있는 4명의 peer에게 chunk를 보내는 것이다.10초 마다 그녀는 이 4명의 peer를 갱신하고, 이 4 개의 피어는 unchoked라고 말한다.30초 마다 그녀는 또한 한명의 추가적인 이웃을 무작위로 골라 chunk를 전송한다. 위에서 임의로 선택되 피어를 bob이라고 하자.여기서 bob은 optimistically unchoked되었다고 하는데 이를 통해 엘리스는 bob의 최고 4명의 uploader중 한명이 되었기 때문이다. 만약 엘리스가 최초로 토렌트에 입장하였다면 다른 사람들보다 optimistically unchoked 될 확률이 3배가량 더 높게 책정되어 최대한 빨리 완전한 chunk를 가지게 되어 다운로드에 참여할 수 있게 한다. 출처 바로가기 3. Transport LayerIntroduction and Transport-Layer Services 내용없음 Multiplexing and Demultiplexing 내용없음 Connectionless Transport: UDPUDP는 Transport Protocol이 할 수 있는 최소한의 기능만을 수행한다.UDP를 사용하면 segment를 전달할 때 handshaking이 필요없다.TCP가 보다 안정적이고 믿을만한 데이터 전송 서비스를 수행하지만 다음과 같은 이유로 인해 UDP가 많이 쓰이는 경우가 있다. Finer application-level control over what data is sent, and when.UDP를 사용하면 데이터를 받는 즉시 세그먼트에 담아 네트워크 레이어로 보내기대문에 속도가 매우 빠르다.실시간 방송 등 어느정도의 데이터 유실이 발생하더라도 실시간으로 빠르게 정보를 주어야 하는 어플리케이션의 경우 UDP를 사용한다. No Connection establishmentTCP의 경우 다양한 방식으로 핸드쉐이킹을 하기 때문에 속도가 느리다.UDP는 핸드쉐이킹 없이 즉시 연결한다.구글의 크롬 브라우저는 UDP를 메인 프로토콜로 이용하고 어플리케이션 레이어의 프로토콜을 통해 안정성 문제를 보완하고 있다. No Connection StateTCP는 엔드 시스템과의 연결을 계속 유지한다.UDP는 연결을 유지하지 않는다. Small Packet header overheadTCP segment는 20 bytes 가량의 헤더를 포함하는데 반해 UDP는 단지 8bytes 가량만 포함한다. 미래에는 TCP를 사용하지 않을 것이다.네트워크 환경이 완벽하게 reliable 해 질 것이기 때문이다. PRINCIPLES OF RELIABLE DATA TRANSFER내가 보낸 데이터가 상대방에게 100% 잘 전달되었는지는 네트워킹에서 가장 중요한 논점이다. 만약 신뢰적이지 못한, 비신뢰적인 채널(unreliable channel)에서 데이터를 전송한다면 어떤 문제가 발생할 수 있을까요? 메세지 에러(message error) 그리고 메세지 분실(message loss) 등의 문제점이 발생할 수 있음을 예상할 수 있습니다. 그렇기 때문에 신뢰적인 데이터 전송 프로토콜(reliable data transfer protocol)이 필요한 것입니다. 그러나 생각보다 이 topic이 어렵고 중요한데요. 이유는 위 그림을 보면 알 수 있듯이 TCP가 Reliable Channel로 데이터를 잘 전송하는 것 같지만, 사실 그 서비스 구현을 위해 Network Layer의 Unreliable Channel 위에 구현되어 있기 때문입니다. 그러니깐 다시 말해서, 우리 눈(초록색)에는 TCP는 Reliable하게 데이터를 잘 전송하는게 맞지만, 실제로(빨간색) 구현 측면에서 보자면 TCP는 Unreliable Channel이 존재하는 Network Layer 위에 존재하므로 구현하기가 복잡하다라는 의미입니다. Building a Reliable Data Transfer protocol신뢰적인 데이터 전송 프로토콜을 구축하기 위해서 가장 간단한 상황부터 시작해서 조금씩 더 복잡해지는 상황으로 이어지는 다음의 4가지 경우에 대해 알아봅시다.좀 더 복잡하고 무결하고 안정적인 데이터 전송 프로토콜을 생각해 본다.일단 송신자로부터 수신자로의 데이터 전송은 단방향의 경우만 고려합니다. 그리고 송신자와 수신자를 정의하기 위해 유한 상태 머신 FSM(Finite State Machine)을 사용합니다. Reliable Data Transfer over a perfectly Reliable Channel: rdt1.0완벽하게 신뢰적인 채널 상에서의 신뢰적인 데이터 전송에 쓰이는 프로토콜 rdt1.0을 살펴본다. 송신측: rdt_send(data) 이벤트에 의해 상위 계층으로부터 데이터를 받는다.paket=make_pkt(data) 이벤트에 의해 데이터를 포함하는 패킷을 생성한다.udt_send(packet) 이벤트에 의해 패킷을 채널로 내려보내며 송신한다. 수신측: rdt_rcv(packet) 이벤트에 의해 하위 채널로부터 패킷을 수신한다.extract(packet,data) 이벤트에 의해 패킷으로부터 데이터를 추출한다.deliver_data(data) 이벤트에 의해 데이터를 상위 계층으로 전달한다. rdt1.0의 경우에는 하위 채널이 완전히 신뢰할 수 있는 경우이므로 중간에 데이터 변형이 없고(비트에러가 없음), 패킷의 손실도 없기 때문에, 오류가 생길 수 없으므로 수신 측이 송신 측에게 송신을 늦추어 달라는 어떠한 피드백도 제공할 필요가 없다. Reliable Data Transfer over a Channel with Bit Errors: rdt2.0비트 오류가 있는 채널 상에서의 신뢰적인 데이터 전송 : rdt2.0패킷 안의 비트들이 하위 채널에서 손상되는 경우이다. 비트의 손상은 패킷이 전송되고, 버퍼되는 등 네트워크의 물리적인 부분에서 발생한다.rdt1.0보다 조금 복잡한 rdt2.0이라고 부르며, 모든 패킷들이 순서대로 수신되고 패킷손실은 없다고 가정한다.여러분은 전화통화를 할 때, 상대방의 말이 잘 들리면 계속 대화를 이어가지만 상대방의 말이 잘 안들리거나 하면 “뭐라고? 잘 안들려”라고 상대방에게 피드백을 줄 것입니다. 통신에서도 마찬가지입니다. 상대방의 말이 잘 들리면(데이터가 잘 도착하면) ACKs(acknowledgements)라는 긍정확인응답을 보내고, 상대방의 말이 잘 안들리면(데이터가 잘 도착하지 못하면) NAKs(negative acknowledgements)라는 부정 확인응답을 보내서 재전송을 요청합니다. 이렇게 재전송을 기반으로 하는 신뢰적인 프로토콜을 자동재전송요구 프로토콜인 ARQ(Automatic Repeat reQuest) 프로토콜이라고 합니다. ARQ의 기능은 크게 3가지 입니다. 오류검출 : 체크섬 필드를 사용하여 비트오류 발생 시 수신자가 검출할 수 있게 합니다. 수신자 피드백 : 패킷이 정확하게 수신되었는지 아닌지를 수신자가 송신자에게 ACK 또는 NAK로 피드백 합니다. 재전송 : NAK의 피드백일 경우 송신자는 재전송합니다. 송신 측(2가지의 상태를 가집니다) 송신 측은 상위 계층으로부터 데이터가 전달되기를 기다립니다. rdt_send(data) 이벤트에 의해 상위 계층으로부터 데이터를 받으면, sndpkt=make_pkt(data,checksum) 이벤트에 의해 데이터와 체크섬을 포함하는 패킷을 생성하고, udt_send(sandpit) 이벤트에 의해 패킷을 채널로 내려보내며 송신합니다. 송신 후에는 오른쪽 상태로 넘어와 ACK 또는 NAK로 피드백 받기를 기다립니다. 만약, 수신 측이 잘 받고(receive) ACK의 피드백이 돌아온다면 왼쪽의 상태로 넘어가 상위계층으로부터 데이터가 전달되기를 기다리며 위의 과정을 반복합니다. 그러나, 수신 측이 잘 받았지만 NAK의 피드백이 돌아온다면 ACK의 피드백이 돌아올 때까지 udt_send(sandpit)의 과정을 반복합니다. 이 때 송신 측이 ACK 또는 NAK를 기다리는 오른쪽 상태에 있는 중에는 상위 계층으로부터 더 이상의 데이터를 전달받을 수 없습니다. rdt2.0은 전송-후-대기(Stop-and-Wait) 프로토콜이라고도 합니다. 수신 측 rdt_rcv(rcvpkt) 이벤트에 의해 하위 채널로부터 패킷을 수신합니다. corrupt(rcvpkt) 이벤트에 의해 수신한 패킷에 오류가 있는 경우 udt_send(NAK)로 NAK 피드백을 합니다. 수신한 패킷에 오류가 없는 경우 extract(rcvpkt, data) 이벤트에 의해 패킷으로부터 데이터를 추출합니다. deliver_data(data) 이벤트에 의해 데이터를 상위 계층으로 전달합니다. udt_send(ACK) 이벤트에 의해 ACK 피드백을 합니다. rdt2.0은 위와 같이 잘 동작되는 것처럼 보이지만 실제로는 치명적인 결합이 있는데 바로 ACK/NAK 패킷의 손상 가능성을 무시했다는 것입니다. 송신 측으로부터 수신 측으로 data가 잘 왔고, ACK 피드백을 보냈는데 중간에 ACK 패킷이 손상되어서 송신 측이 ACK를 못 알아듣는다면 어떻게 해야할까요? 가장 간단하면서 단순한 방법으로 송신 측은 그저 data를 수신 측으로 다시 한 번 보냅니다. 그러면 ACK/NAK가 다시 올테니깐요. 그런데 수신 측은 혼란스러울 겁니다. 자신은 아까 받은 data에 대해 ACK를 보내주었는데, 동일한 data가 한 번 더 왔으니… 이게 다음 data인지 똑같은 data를 두번 중복(duplicate)으로 보낸건지…. 헷갈립니다. 이러한 중복 패킷에 대한 문제에 대한 간단한 해결책은 패킷에 순서번호(sequence number)를 붙이는 것입니다. 그래서 수신 측은 수신된 패킷이 재전송으로 인한 중복패킷인지 새로운 패킷인지를 결정할 때 sequence number만 확인하면 됩니다. 동일한 sequence number의 패킷이 수신된다면 이는 중복패킷으로 인식하는 것입니다. rdt2.1세번째로, 바로 위에서 언급한 sequence number를 추가한 모델이 rdt2.1입니다. 송신 측은 0과 1을 sequence number로 사용합니다. 그리고 수신측은 0과 1로 중복패킷인지 여부를 결정합니다. 아래의 FSM을 봅시다 왼쪽 송신 측이 sequence number 0의 패킷을 보내면 0번에 대한 ACK/NAK를 기다립니다.오른쪽 수신 측은 문제없이 잘 수신한 경우 ACK를 보내며 sequence number 1의 패킷이 수신되기를 기다립니다.왼쪽 송신 측은 ACK를 받으면 sequence number 1의 패킷을 보내고, NAK를 받거나 피드백 패킷에 오류가 있을 경우에 sequence number 0의 패킷을 재전송합니다.오른쪽 수신 측은 sequence number 1의 패킷을 기다리고 있는데, sequence number 1의 패킷이 수신되면 순조롭게 ACK를 보내면 되고, sequence number 0의 패킷이 도착한다면 sequence number 0의 패킷이 중복도착했으므로 무언가 중간에 문제가 생겼음을 알고 sequence number 0에 대한 ACK를 보냅니다. rdt2.2기능은 rdt2.1과 동일하지만 NAK를 사용하지 않고(NAK-free) ACK만 사용하는 모델이 rdt2.2입니다. NAK를 보내는 대신에, 가장 최근에 잘 받은 패킷에 대한 ACK를 보냄으로써 NAK를 보내는 것과 동일한 효과를 얻을 수 있습니다. 다음 그림을 보면 쉽게 이해할 수 있습니다. 송신 측이 pkt1을 보냈지만 수신측이 ACK1이 아닌 ACK0만 계속 보낸다면 송신 측은 pkt1의 전송에 문제가 생겼음을 인식하고 재전송할 수 있다라는 의미입니다. Reliable Data Transfer over a lossy Channel with Bit Errors:rdt3.0마지막으로, 비트 손상과 함께 패킷을 손실하는 모델을 고려봅시다. 이를 rdt3.0이라고 부르며, 어떻게 패킷 손실을 검출하며 패킷손실이 발생했을 때 어떤 행동을 해야하는지가 중요한 사항이 됩니다. 다행히 패킷손실이 발생했을 경우 rdt2.2까지 설명하면서 사용되어 왔던 체크섬,sequence number, ACK, 재전송 등은 패킷손실이 발생했을 때 해야하는 행동에 대한 답이 될 수 있습니다. 패킷 손실의 검출은 바로 Timer로 할 수 있습니다. 타이머는 패킷 손실이 일어났다는 100% 보장은 아니지만, 손실이 일어났을 만한 그런시간을 현명하게 선택하는 방식입니다. 만일 ACK가 이 시간안에 수신되지 않는다면 패킷은 재전송될 것(그림 b,c)입니다. 심지어 패킷이 유별나게 큰 delay를 가져서 타이머 시간보다 늦게 도착하는 경우 비록 ACK가 손실되지 않았다 하더라도 패킷은 재전송할 수 있습니다. 이는 중복 데이터 패킷(duplicate data packet)의 가능성을 포함한다는 이야기입니다.(그림d) 다행히 rdt2.2는 이미 패킷이 중복되었을 경우를 처리하기 위한 sequence number의 기능을 가지고 있습니다. 재밌는 점은 프로토콜 rdt3.0은 기능적으로 매우 정확한 프로토콜임에도 불구하고 오늘날의 고속 네트워크에서 만족스러운 성능을 보여주지 못한다는 점입니다. 이유는 ‘전송-후-대기(Stop-and-Wait)’방식이기 때문입니다. 이를 위해서 pipelining이 도입되었고 이는 다음과 같은 성질을 가진다. sequence number의 범위가 증가한다. 왜냐하면 각각의 패킷이 서로 다른 시퀀스 넘버를 가져야하기 때문이다. 리시버 사이드는 하나 이상의 패킷을 버퍼해야 한다. 제대로 받은 패킷들에 대한 버퍼링이 필요하다. 시퀀스 넘버의 범위는 유실되고 손상되고 지연된 패킷들에 따라 결정된다. 이를 위해 Go-Back-N, selective repeat이라는 두가지 파이프라인 에러 리커버리 접근이 있다. Go-Back-N(GBN)누적 ACK, 단일 타이머GBN 방식은 단일한 타이머를 사용한다.만약 1번 패킷까지만 도착을 했고 2번 패킷이 도착을 하지 않았으면, 리시버는 2번부터 계속해서 날아오는 패킷들을 죄다 버리고 전체 타이머가 다 되어 2번이 날아오기를 기다린다.그리고 2번 이후로 날아오는 패킷마다 ACK1만 보내 내가 1까지 밖에 못받았음을 알린다. Selective Repeat(SR)개별 ACK, 개별 타이머SR 방식은 패킷마다 신경을 쓴다.만약 2번 패킷이 전달되지 않았다면 3번부터 오는 패킷들을 전부 버퍼해 두고 2번 패킷에 대한 타이머가 타임아웃되어 다시 전송을 해 주면 버퍼해두었던 모든 패킷을 한꺼번에 어플리케이션 레이어로 보내주고 2번 패킷에 대한 ACK를 보낸다. 4. The Network Layer: Data PlaneOverview of Network LayerForwarding and Routing: The Data and Control Planes네트워크 레이어가 하는 일은 간단히 말하면 아주 쉽다.바로 보내는 host로 부터 받는 host로 패킷을 이동시키는 것이다.이를 위해서는 다음과 같은 두가지 중요한 네트워크 레이어의 기능을 알아야 한다. Forwarding: 패킷이 라우터의 인풋링크에 도착하면, 라우터는 패킷을 적합한 output link에 옮겨야 한다. 즉, 패킷이 다음 라우터로 가는 링크를 가르키게 해야한다. 또한 다른 호스트로 패킷이 이동하지 못하도록 막아야 한다. 이는 네트워크 레이어의 data plane 에서 이루어진다. Routing: 네트워크 레이어의 control plane 에서 이루어지는 것으로 routing algorithm을 통해 다음에 어떤 라우터로 갈지를 결정한다. 운전자를 예로 들면 운전자가 각각의 갈림길에서 어느 길로 갈지를 순간순간 결정하는 것이 forwarding 이고 routing은 목적지로의 여행을 계획하는 프로세스로 볼 수 있다. Control Plane: The Traditional Approach네트워크 레이어의 기존의 Control Plane에서는 routing algorithm이 모든 라우터에서 실행되어 포워딩과 라우팅 기능이 모두 라우터 안에 내장되어 있었다.때문에 모든 포워딩 테이블들을 관리하기 위해서 물리적인 라우터에 관여해야 했다. Control Plane: The SDN Approach현대의 네트워크 레이어의 컨트롤 플레인의 경우 원격의 컨트롤러가 포워딩 테이블을 계산하고 각 라우터에 배포하는 식이다.이를 통해 컨트롤 플레인의 라우팅 기능이 라우터의 물리적인 부분에서 독립되어 라우팅 디바이스는 단순히 포워딩 기능만을 담당하게 되었다.이러한 SDN의 개념은 포워딩 테이블을 계산하는 컨트롤러가 소프트웨어로 구축이되어 네트워크의 개선 가능성을 높였다.이러한 SDN 기술은 오픈소스로 배포되어 많은 사람들이 효과적인 네트워킹 방식에 대해 논의를 지속적으로 하여 기술 향상성이 기대된다. 5. The Network Layer: Control PlaneRouting Algorithms송신자에서 수신자까지 좋은 길을 찾아내는 routing 알고리즘을 배운다.여기서 좋은 path란 말은 least coast를 말한다. 라우팅 알고리즘의 구분 centralized routing인가 decentralized routing인가? centralized routing algorithm완벽하고 네트워크 전체의 이해를 기반으로 least coast를 결정한다. decentralized routing algorithmleast coast path에 대한 계산이 라우터들마다 저만의 방식으로 반복적으로 수행되는 알고리즘이다. static routing algorithms인가 dynamic routing algorithms인가?static routing algorithm은 라우팅이 매우 천천히 진행된다.가끔은 인간의 간섭으로 진행되기도 한다. dynamic routing algoritms은 현재 연결상태에 따라 매우 다이나믹하게 routing path가 바뀐다. load-sensitive인가 load-insensitive인가?load-sensitive에서는 현재 연결의 혼잡도에 따라 cost가 매우 다이내믹 하게 바뀐다. The Link State(LS) Routing AlgorithmLink State Algorithms에서는 네트워크 위상과 코스트가 모두 알려져 있다.때문에 link state broadcast algorithm이라고도 불린다.즉, 때문에 이 모든 값들은 LS알고리즘의 input으로 들어갈 수 있다. WorkFlow모든 노드가 최적의 길을 알고있다고 한다.하나의 노드에서 각각의 모든 노드에 이르는 least coast path를 구하는 식으로 테이블을 그려나가며각 반복마다 전 노드 추가에 대한 반복을 기준으로 가장 least cost가 작은 노드를 추가하여 다시 반복을 실행한다.모든 테이블을 완성하였다면 이를 기반으로 Least cost Path를 그리고 forwarding table을 완성한다. The Distance-Vector Routing AlgorithmsLS 알고리즘이 전체 네트워크에 대한 정보를 사용하는 반면, distance-vector(DV) algorithms은 반복적이고, 비동기적이고, 분산적이다.이것은 각 노드가 주변의 하나 혹은 여러개의 직접 붙어있는 노드에서 정보를 받아온다는 점에서 분산적이다.또한 이렇게 계산된 정보를 다시 이웃의 노드로 전달하는 것을 더 이상 노드 사이에 정보 교환이 필요없는 시점까지 반복한다는 점에서 반복적이다.또한 각 계산과정에서 모든 노드가 필요하지 않다는 점에서 비동기적이다. 이는 centralized algorithm 보다 훨씬 흥미롭다. 기본적인 작동 원리는예를 들어 x노드에서 y노드 까지의 least cost는 x에서 v로 갈때의 코스트와 v에서 y로 갈때의 least cost의 합중 가장 작은 값이라는 bellman-ford의 방정식에 입각한다. 7. Wireless and Mobile NetworksWIFI : 802.11 WIRELESS LANSThe 802.11 MAC ProtocolAP 혹은 디바이스를 다중접속 채널을 나누는 무선 스테이션이라고 칭한다.무선 연결시 충돌된 연결을 피하기 위해서 다양한 기술들을 사용하는데802.11 Wireless LAN에서는 CSMA/AC 기술을 이용한다.CSMA/CA란 Carrier Sense Multiple Access / Avoiding Collision의 약어로각 스테이션이 데이터 전송 전에 채널을 센싱하고 채널이 바쁘면 데이터를 전송하지 않아 충돌을 막는 방법을 일컷는다. Dealing with Hidden Terminals: RTS and CTSRTS와 CTS를 통해 네트워크 사이의 충돌을 막는다. 한 호스트가 AP에게 데이터를 받기 위해 RTS Frame을 보낸다이 RTS Frame에는 데이터 프레임을 보낼때 소요되는 총 시간과 ACK 프레임을 받기 위해 필요한 총 시간을 명시한다. AP가 RTS 프레임을 받으면 CTS 프레임을 broadcasting 해 줌으로써 응답한다.이러한 CTS 프레임은 전송자에게 데이터 프레임 전송을 시작하도록 허락하고 그 동안 다른 호스트들이 그 시간동안 데이터를 전송하지 못하도록 한다. AP가 원하는 데이터를 다 받으면 ACK 프레임 을 broadcasting 하여 전송이 완료되었음을 알린다. 다른 호스트는 ACK프레임을 전송받음과 동시에 AP로의 접근 제한이 풀리게 된다. RTS: Request to Send CTS: Clear To Send RTS와 CTS 프레임을 사용하면 다음과 같은 두가지 중요한 성과를 얻을 수 있다.첫째로, 채널이 확보되고 난 다음에 데이터 프레임을 전송하므로 hidden station problem을 해결한다.둘째로, RTS와 CTS 프레임은 매우 짧으므로 이 두 프레임을 전송하면서 발생하는 충돌은 아주 짧은 시간동안만 발생 가능하다. RTS와 CTS 프레임을 전송하고 난 뒤에는 뒤따라 데이터와 ACK 프레임들이 충돌없이 전송되어야 한다. 8. Security in Computer Networks인터넷에서 secure communication을 원하는 경우는 수없이 많다.전쟁 서신부터 연애편지, 사업 거래 등 많은 요소에서 보안을 필요로 하고, 이를 할 수 있는 방법을 배운다.먼저 기초적인 암호기술을 배우고 4개의 layer에 대해서 먼저 application layer에서 부터의 안전한 protocol에 대해 배운다. What is Network security?다음과 같은 조건이 만족되어야 한다. Confidentiality오직 송신자와 수신자만이 전송된 메세지의 내용을 알 수 있어야 한다.중간에 도청자가 메세지를 가로체더라도 이것이 암호화되어있어 도청자에 의해 해독되지 못해야 한다.이를 위해 우리는 간단한 암호화 기술을 배운다. Message integrity전송된 메세지의 내용이 중간에 변형되지 않아야 한다.이건은 data link protocol에 의해 제공될 수 있다. End point authentication전송자와 수신자가 서로 상대방이 누구인지 알아야 한다. Operational security대부분의 기관들의 네트워크가 공용 인터넷에 연결되어 있는 만큼 이러한 네트워크가 공격받을 수 있다.이러한 네트워크의 보안이 잘 지켜져야 한다.firewall이 기관의 네트워크와 공용 네트워크 사이에 있어서 접근하고 나가는 패킷들을 관리해야 한다. 중간 침입자는 다음과 같은 기능을 할 수 있다.eavesdropping / 조작 메세지 및 데이터 메세지를 가로체거나 복제할 수 있다.modification, insertion, or deletion of messages or message content Principles of Cryptography암호화 되기 전 메세지를 plaintext 혹은 cleartext라고 한다.함호화를 위해 사용한 알고리즘을 encryption algorithm이라 하며, 암호화된 메세지를 ciphertext라 한다.요즘의 경우 암호화 기술은 그 자체로 누구에게나 잘 알려져 있는데 이를 해독하기 위해서는 비밀스런 정보인 키값이 필요하다.암호화 기술에 키값을 넣으면 plaintext가 나오게 된다. Symmatrcic Key Cryptography엘리스가 자신의 private key로 암호화해서 보내면 밥은 자신의 private key로 해독하여 메세지를 읽는다.두 key는 symmetric하다. Public Key Encryption엘리스가 밥에게 메세지를 보낼 때 밥의 공개키로 암호화를 해서 보내고 밥은 이를 열때 밥의 private key로 해독한다. Message Integrity and Digital SignatureCryptographic Hash FunctionsHash function이 입력 메세지를 받으면, 고정된 사이즈의 스트링 H(m)을 계산해 낸다.(Hash)Cryptographic Hash Function은 다음과 같은 성질을 가진다.다른 메세지를 Hash Function에 넣고 같은 Hash값을 가지는 경우가 반드시 있다.이러한 성질은 intruder가 한 메세지를 다른것으로 만드는 것을 불가능하게 만든다. 어떤 메세지가 있을때 단순히 checksum 방식을 이용하여 메세지를 변형하였을때 같은 hash를 가지는 메세지를 쉽게 찾을 수 있기 때문에 메세지를 변형하기 쉽다. 하지만 Hash Function을 이용하면 intruder가 같은 Hash를 가지는 메세지를 찾는 것이 거의 불가능해 진다.즉, hash를 이용할 경우가 더 좋은 message integrity를 가진다. 비트코인비트코인이란?데이터 마이닝을 통해 새로운 블록들이 마만들어고 이것은 25개의 비트코인을 만들어 낸다.디지털 화폐로 매우 신뢰도 있고, 합법적으로 되고 있다. 비트코인을 어떻게 트래킹 하는가?여기서 블록체인의 개념이 나온다.비트코인이 생성되면 비트코인을 가진 모든 사용자들에게 알려지게 된다.모든 사람들이 다 이 정보를 볼 수 있다.영속적이고 신뢰할 수 있는 정보인지 어떻게 하는가 해쉬를 만들어 데이터 마이닝을 한다.해쉬는 만들기 어려운 것이 아니다.한번 이걸 만들면 즉각적으로 블록과 연결이 된다.해쉬는 일종의 판별자이다-secure, permanent 마이닝을 통해 데이터는 안전하게 되고 영속적으로 된다. 블록체인의 핵심은 중앙집권화된 단체를 없애는 것이다.모든 참여자들이 모든 거래에 대해 ㄱ알게하고 각 모든 거래는 그 정보를 구성하는 판별자를 가지고 있다. 퍼블릭 블록체인퍼블릭 키를 사용한다.너무 많은 에너지를 사용한다. private 블록체인개인 키를 사용한다. 블록체인을 사용하면 매우 보안이 높고 효율적인 데이터 교환을 할 수 있지만 블록체인 자체를 통제하는 데 어려움이 있게 때문에 이를 통제하기 위해 노력한다.주로 금융 기관에서 블록체인을 적용하려고 노력하고 있다. 블록체인에 각종 정보를 담아 널리 퍼뜨릴 수 있느 가능성이 있다.의료사업에 있어서도 현재는 나의 모든 의료정보를 병원이나 다른 의료 기관에서 들고 있지만 이는 그다지 합리적이지 못하다.블록체인을 통해서 이러한 보든 정보들을 사용자가 직접 가질 수 있다. 블록체인 1시초블록체인 2.0스마트카 등등블록체인 3.0인텔리전스 기반 Blockchain Application현재 기관들이 block chain을 도입하면 많은 부분들이 급변하게 된다. 왜 블록체인이 좋은가?p2pscalableblock 없이는 아무것도 바꾸지 못한다. private하다면 접속하는데 private key가 필요하기 때문에 Buisiness Modelinitiate -&gt; design -&gt; strengthen -&gt; implement 여기서 디자이닝 모델에 집중한다.현재 금융 시장에서 돌아가는 방식을 토대로 앞으로 이러한 시장에 블록체인 기술을 통해 어떤 방식의 통화흐름을 만들어낼 것인가? 블록체인의 정보들이 FTA 과정을 통해 분석될 수 있고, 이 내용을 통해 각 국의 경제정보를 얻을 수 있어 이를 통해 새로운 비즈니스가 가능해 진다.블록체인을 통해 모든 정보가 투명해 질 수 있다. 의료정보에 쉽게 접근가능 - 정보가 투명해 졌기 때문예를 들어 의료 정보들은 각 의료센터마다 분산되어 있기 때문에 누구나 접근할 수 있는 정보가 아니다.하지만 블록체인 기술을 통해 분산된 지역에서의 모든 정보들이 누구든지 접근할 수 있는 형태가 되기 때문에 가능하다. 프로슈머들이 훌륭하게 활동할 수 있다. ad-hoc기기가 라우터의 역할 까지 하는 등 센서 네트워크가 이런 것이 많다.독립 단말끼리 외부의 도움없이 자기들 만으로 자율적인 임시적 망을 구성함을 뜻함ㅇ 동적 토폴로지 이동이 자유롭기 때문에 네트워크 토폴로지가 동적으로 변함ㅇ 유연한 망 구성 임시 망의 구성은 각 이동단말이 서로 가까이 있을 때에 만 통신망을 구성ㅇ 중앙 제어 없음 (자율 망 구성 능력) 어떠한 중앙 제어나 표준 지원 서비스의 도움 없이 임시로 망을 구성.ㅇ 정보 전달 방식 일대일 다중 홉 라우팅(Multihop Routing) 방식으로 전달ㅇ 각 노드 역할 다양성 Mesh network에서는 각 노드가 메시지를 보내거나 받을 수 있으며 라우터 역할도 가능ㅇ Self-healing (자율 고장 치유 능력) 하나의 연결이 끊어져도 network는 자동적으로 다른 연결로 메세지를 전송할 수 있음ㅇ 신호 강도 각 노드가 가까워 질수록 신호가 매우 좋아짐 . 예를들면, 거리가 반으로 줄어들면 신호는 4배로 좋아짐ㅇ 노드 추가/탈퇴 유연성 간단하게 노드들이 추가,탈퇴할 수가 있음 Industry 4.04차 산업은 생산공정에서의 자동화와 데이터 교환의 흐름을 일컷는다.이 용어는 cyber-physical system와 IoT 그리고 클라우드 컴퓨팅을 포함하는 개념이다.4차 산업혁명을 통해 이른바 스마트 팩토리라는 개념이 생겨나고 모듈화 되고 구조화된 스마트 팩토리를 통해 Cyber Physical System은 물리적 공정을 감독하고, 실제 세계의 모형을 본떠 decentralized된 의사결정을 내릴 수 있게 되었다. Over the Internet of Things, cyber-physical systems communicate and cooperate with each other and with humans in real time, and via the Internet of Services, both internal and cross-organizational services are offered and used by participants of the value chain.[1]block chain기술 - p2p big data를 포괄한다.IoTsmart machine한정된 컴퓨팅 자원만을 이용한다.clustering of things using cloud computing Ubiquitousmake smart space Layering Architecture새로운 platform을 만들기 위한 구조를 설계하는 법을 배울 것이다.모든 플랫폼은 이러한 layer를 기반으로 설계된다. Five LayerApplication LayerTransport Layer - TCPNetwork Layer - IPData Link Layer - WLANPhysical Layer 여기서 Application, Transport, Network, DataLink는 Software의 범주에 속한다.Network, Data Link 를 middleware에 속한다.Physical Layer는 Hardware를 의미한다. History Of Computer Network80년대distributed computing을 사용하였다이 경우에는 매우 한정적인 computing resources를 가지고 일을 하였다. 90년대mobile computing 에 대한 관심이 높아졌다.모바일 컴퓨팅의 경우는 단지 nomadic한 네트워크 통신을 하였다면유비쿼터스 시대에는 상당히 스마트한 환경을 기반으로 한다. 2000년대IoT + big data analytics 유비쿼터스 컴퓨팅 VS 모바일 컴퓨팅Mobile Computing모바일 컴퓨팅모바일 컴퓨팅은 단순히 서버에서 클라이언트로의 네트워크를 의미한다.base station에서 다른 스마트 기기로 정보를 전송한다. 유비쿼터스 컴퓨팅Two Entities sensors actuators유비쿼터스 에서의 네트워크는 peer to peer를 의미한다. 또는 센서 네트워크p2p ad-hoc network, mesh network Contextformal data 와 informal data를 모두 포함한다.이러한 기술을 통해 유비쿼터스 컴퓨팅은 reasoning과 inferencing, learning이 가능해 진다.센세들이 단순한 컴퓨터 데이터가 아닌 context를 수집하기 때문이다.-&gt; context awarenesspeer는 바로 인터넷에 적합하지 못함 반드시 gateway를 거쳐야. IoT단순 sensor와 actuator만 가지고는 reasoning inferencing, learning 등을 할 수 없다.여기에는 반드시 gateway가 들어가야 한다.Ex) 스마트카 등이 gateway의 일종이다.유비쿼터스 컴퓨팅의 기초는 localized service라는 것이다.이 기술을 통해 우리는 당면한 문제를 중앙집중된 처리를 하는 것이 아니라 주변 네트워크 자원을 이용하여 해결한다.이를 통해 통신 네트워크 자원을 아낄 수 있게 된다.더 적은 센서와 actuator를 사용하기 위해 더 똑똑한 IoT가 필요하게 되었다.IoT란 센서와 actuator 네트워크를 모두 사용한 일종의 기기를 의미한다.사용하는 통신의 기술에는 WLAN, ZGBEE,ZWAVE,LTE등이 있다.SK의 경우 여기에 LTE를 이용하고, KT 는 WLAN, LTE,를 이용한다. LG의 경우는 ZGBEE,ZIWAVE lte의 경우impossible to make clustering entities for smart space스마트폰이 지역적 통신망에 접근하는 유일한 방법은 wifi를 이용하는 것이다.즉 lte는 유비쿼터스 컴퓨팅에 적합하지 않은 통신 방법이다. vertical handofflte to wifi or wifi to bluetooth 회사들은 zgbee와 zwave방식을 더 선호한다. - 왜 그런지는 다음에 securityp.726 - wep Home NetworkSecurity VS privacyAuthentication이 매우 중요해 졌다.이를 위해 PKI같은 기술들을 사용하게 된다. EnergyZEB(Zero Energy Building)을 만들기 위해서 다음과 같은 기술이 필요하다.a. renewable energyb. Energy IoTex) Smart switch의 경우 센서와 액츄에이터의 역할을 같이 한다.c. HEMS - Home Energy Management Systemd. ESS - Energy Storage System. ServiceCostPerformanceReliabilitySafetySecurityReliabilityScabiability Introduction Of Data AnalyticsBig Data Analyticstraditionally / SPSS, RFuture oriented / python, php, 하둡 Crawling필요한 데이터를 긁어오는 것Supervised Learninglearning with labeled examplesx값과, y값이 이 정해져 있다.어떤 데이터가 들어가서 어떤 데이터가 나오는지 안다 Unsupervised Learninggoogle news groupingword clustering어떤 값인지 모르고 데이터의 특성에 따라 분류한다. Data Visulalization Toolspython librarymatplotlibflask processdata gatheringpreprocessingmodelingtestingvisualization Start Data Analytics“프로그램인 Tableauphthon+TensorFlow(구글 라이브러리)” Data Analytics R/D EnvironmentMain ToolTableauPhython with PycharmTensorflow Three Types of Communication Unicastone to one communication Multicast만약 UDP방식을 채택하게 되면 만약 하나의 패킷이 다른 유저에게 전달되지 않았을 경우재 요청을 하면 다른 모든 사용자에게 요청을 날리게 된다. QOS(Quality Of Service)사용자의 품질이 좋지 않으면 환불하는 등의 정책을 편다.link layer protocolto resolve wired network - ethernet (CSMA(Multiple Access)/CD(Collision Detection) )다 연결되어 잇기 때문에 colision을 다 detect할 수 있다.collistion detection wireless network - wifi(CSMA/CA(Collision Avoidance))hidden node problem이 발생한다.연결되지 않은 부분이 있기 때문이. detect colision할 수 없다.collision avoidance Zigbee bluetooth Zigwave","link":"/2018/01/14/컴퓨터-네트워크/"},{"title":"심리학 개론","text":"심리학의 본질과 이해심리학이란 무엇인가심리학이란 인간의 행동이나 정신 과정에 대한 과학적 연구를 하는 학문이다.Psyche(영혼) + Logos(연구) ‘영혼에 대한 연구’ 인간의 정신 과정과 행동에 관한 과학적 연구인간행동의 포괄적인 설명을 목표로 하였고 즉, “인간들은 왜 그렇게 행동하는가?”에 대한 질문을 한다. 심리학의 역사심리학의 역사는 철학과 과학에서 시작되었으며, 19세기 후반 마음의 연구에 과학적 방법을 사용하면서 하나의 독립적인 학문으로 성장하였다.‘사유’로서 진리, 진실에 대한 답을 얻었다.(철학적이었다.) - 무검증 1920년대 초직접 관찰이 불가능한 마음에 대한 연구보다 관찰 가능한 행동에 대한 연구를 시작하였다.갈등이나 분노와 같은 정신적 경험에 대해 연구하기 보다 음주나 공격적 행동과 같은 관찰 가능한 명백한 행동에 대해 연구하기 시작하였다.즉, 1920년대의 심리학은 행동의 과학적 연구로 정의할 수 있다. 다음과 같은 두가지 측면을 고려하여 심리학을 정의할 수 있다. 심리학은 인간행동의 포괄적인 설명을 그 목표로 하고 있다. 심리학이 과학이 되기 위해서는 엄격한 정의, 부정하게 규정된 절차, 그리고 결과의 항상성을 강조하는 일반화된 과학적 방법론을 따라야 한다. 심리학의 근원심리학의 역사적 근원은 철학과 과학에 있다.19세기 후반 학자들이 마음의 연구에 과학적인 방법을 사용하면서 심리학은 비로소 하나의 독립적인 과학적 학문으로 자리를 잡았다. 심리학의 철학적 근원심리학의 역사는 소크라테스를 전후로 나뉜다.소크라테스는 질문법으로 상대의 무지를 깨닫게 하였으며, 이성의 힘을 강조하였다. 플라톤은 지식의 원천 면에서 감각을 의심하였다.물 속에서 굽어보이는 막대기를 예를 들어 왜곡된 지각을 설명하였다.인간은 원래 지식을 가지고 태어난다고 믿었으며, 추론이 이러한 지식에 접근할 수 있게 한다고 믿었다. - 합리주의꿈, 지각, 정신질환 등을 연구하기 위해 이성을 사용하였다. - 이성주의 아리스토텔레스는 경험주의 철학을 강조하여 감각 경험을 플라톤보다 중요하게 받아들였다.아리스토텔레스는 뇌보다 심장이 더 민감하게 반응한다는 논리로 인간이 정서적인 경험을 더 강하게 받아들인다고 하였다.또한, 심리학적 주제에 대해 최초로 형식을 갖추어 깊이 생각하였다. 성 어거스틴은 고백에서 자기분석을 통해 기억과 정서 동기에 대해 기술하였으며, 이성과 동물적 열정, 성욕 사이의 지속적 갈등에 대한 통찰을 제시하였다.이성을 심리적 연구에 사용했으나 과학적 방법은 사용하지 않았다. 베이컨은 오감을 통해서 지식획득을 강조한 아랍 과학자의 영향을 받았다.권위에 대항한 경험주의를 철학자들에게 강조하였다.증명, 체계적 관찰 등을 장려하여 현대 과학적 태도를 취했다.경험주의를 강조함으로써 신학자들과 충돌하였다. 데카르트는 최초의 현대적 이성주의자이자 수학자, 철학자, 과학자 였다.분명하게 증명되지 않은 모든 것을 의심하였다.방법서설 : “나는 생각한다. 고로 나는 존재한다.”종교지도자의 주장을 맹목적으로 받아들이는 것에 반대하였다. 로크는 베이컨의 경험주의적 사상을 추종하였다.그는 백지설을 내세우며 감각을 통해 얻은 인생 경험으로 지식을 채운다고 설명하였으며, 지식이란 인생 경험을 통해 얻어지는 것이라 하였다.경험주의(nuture) - 이성주의(nature, 본성) 칸트는 합리주의와 경험주의의 절충을 이루어 낸다.“지식이란 물리적 환경의 감각적 조직화와 이해의 생득적 정신기제에 의한 결과물”이라고 보았다.예를 들어 인간은 태어난 곳의 언어 경험에 의해 특정한 말을 하게 되는데, 말하는 능력과 언어는 타고난 두뇌기제에 의존하므로 경험하지 못한 다른 언어를 구사할 수 없다. 그런데 인간은 생득적 언어기제를 통해 다른 환경에서 다른 언어의 학습과 이해도 가능하다는 것이다.하지만, 심리학이 과학이라는 것을 부정하였으며, 정신은 직접 관찰, 측정, 조작할 수 없다는 주장을 펼쳤다. 심리학의 과학적 근원헬름홀츠는 허벅지와 발에 자극을 가해 반응한 속도를 측정하여 신경자극이 순간적인 것이 아니라는 것을 보여주었다. 플루랑스는 특정 뇌 부위의 손상이 운동기능에 부조화를 일으킨다는 것을 발견하였고, 브로카는 인간의 뇌손상이 언어 능력을 상실한는 사례를 통해 뇌와 심리적 과정의 본질에 대한 과학적 탐구를 하였다. 페히너는 물질적 자극과 정신적 경험 간의 관계를 측정함으로써 (예를 들어 밝기, 소음의 역치 등) 심리학이 과학적으로 연구될 수 없다고 믿었던 당대 통념을 깨놓게 된다. 개인차 심리학사람들 간의 지능, 성격 신체적 특성의 다양성커텔 - 시각, 청각, 신체적 기술 등 다양한 검사를 기술하였다.정신검사라는 단어를 사용하였고, 최초의 심리학 교수이다. 초기 심리학구조주의 심리학최초의 심리학 학판인 구조주의는 19세기에 생겨났다.구조주의자들은 마음을 구성 요소로 분석하고, 그 구성 요소가 어떻게 상호작용하는가를 발견하려고 하였다.즉, 정신을 구성하는 요소와 내용을 밝히려고 시도하였다. 구조주의는 최초로 등장한 심리학파이면서 동시에 가장 빨리 그 자취를 감춘 학파인데, 이는 구조주의 학파의 연구가 연구실에 제한되었기 때문이다. 분석적 내성법정신을 구성하는 심상, 느낌, 감각을 분석하는 방법이다. 기능주의 심리학어떤 자극이 사람들에게 어떻게 영향을 미치는가분석적 내성법이 불가능한 대상 즉, 어린아이, 정신장애인, 동물에 대해서는 구조주의 심리학을 적용할 수 없다.구조주의 심리학자들이 맛에대한 정신적 구성 요소를 알고자 했다면, 기능주의 심리학자들은 맛을 구별하는 능력이 행동에 미치는 영향을 탐구하였다.기능주의 심리학자들은 인간이 갖고 있는 의식의 내용이 아니라 인간이 보고 느끼고 생각하는 것의 심리적 기능을 연구 대상으로 삼아야 한다고 주장하였다.ex) 듀이는 이러한 이론을 교육현장에 적용하였다. 행동주의 심리학행동주의 심리학의 창시자로 볼 수 있는 왓슨은 정신이 심리학을 연구하기 위한 적절한 대상이라는 생각에 반대하였다.직접 실험이나 관찰이 불가능한 정신 경험을 연구하는 데 반대하였다. 행동주의 심리학자들은 모든 행동을 조건 형성의 결과로 보고 인간 이해의 기본 공식을 자극과 반응의 관계로 규정하였다.또한 왓슨은 행동에 미치는 환경의 영향력을 주용시하였다. 특히, 아동들의 행동에 미치는 환경의 영향력을 믿었는데, 다음과 같은 말에 그런 내용이 잘 녹아난다.“나에게 건강한 유아와 그들을 잘 자라게 할 수 있는 환경만 제공해 준다면, 나는 무작위로 그들 중 한 명을택하여 내가 원하는 어떤 방면의 전문가도 될게 할 수 있다.” 유전보다 환경을 가조한다. / 관찰 및 추정 가능한 사건 또는 행동만을 연구 대상으로 삼았다. 행태주의 심리학행태주의 심리학은 ‘게슈탈트’ 즉, “전체는 부분의 합이 아니다”를 강조한다.이것은 마음을 그 구성요소로 분석하려는 구조주의 심리학자들을 반박하는 것으로인간은 어떤 대상을 부분의 조합이 아닌 전체로 인식한다고 주장하였으며, 어떤 내용을 요소로 다시 나누면 원래의 내용은 존재하지 않으며 이 요소를 다시 재결합 하여도 원래대로 돌릴 수 없다고 말한다.즉, 의식의 내용을 구성 요소로 분석하면 원래의 내용은 사라지고, 이 요소를 다시 결합한다 해도 원래대로 돌릴 수 없다는 것이다. 행태주의 심리학자들은 인지는 일련의 개별적인 감각 이상의 것이라고 말하며 학습, 기억 문제해결 등의 지적 활동에서 지각 중심적인 해석을 강조한다.이는 인지심리학의 발달에 많은 영향을 끼치게 된다. 정신분석프로이트의 정신분석은 무의식을 심리학에 포함시킨 최초의 연구이다.프로이트의 사례연구는 대개 성, 공격성과 관련된 무의식적 충동들이 인간행동의 가장 강력한 동인이라고 얘기한다.성과 같은 무의식에 의하여 동기화 된다고 주장하여 대중에게 충격을 주었다.또한, 아동 초기의 경험들이 성격발달에 가장 중요한 요인이라는 주장을 한다. 정신결정론 - 사람의 행동은 정상이든 비정상이든 간에 의식하지 못하는 심리적 동기(무의식)에 영향을 받게 됨.프로이트의 정신분석은 무의식이 명확한 원인이 없는 행동들을 설명하는 데 너무 쉽게 사용된다는 점과 실험을 통한 측정과정이 없다는 비판을 받는다.뿐만 아니라 환자들의 면담과정 기록 자료를 근거로 사용하여 심리적 장애상태의 소수 사례를 일반화 시킨다는 지적이 있다. 현대 심리학의 관점행동주의적 관점왓슨의 방법론적 행돈주의를 계승하여 급진적 행동주의가 나타나게 된다.인간의 심리 상태를 관찰 가능한 행동을 통해 객관적으로 연구함정서, 느낌, 사고 등과 같이 직접 관찰하기 어려운 현상에 대해서도 심리학적 연구 필요성 주장하였다.스키너 “바람직한 행동에 대해 긍정적 강화를 제공함으로써 시민을 조절하는 행동주의자들이 이상적인 사회를 만든다.” 정신분석적 관점프로이트로 대표되는 정신분석적 관점은 인간의 행동이나 정신 과정을 본능과 무의식으로 설명하려 한다.대표적인 학자로 아들러와 융이 있다.인간의 행동을 본능과 무의식으로 설명하였으며, 무의식의 과정을 설명하기 위해 노력하였다. 사고, 공포, 갈등 등의 본질은 파악할 수 없으며, 무의식적 과정은 존재하여 인간행동에 영향을 미친다고 주장한다.생리적 추동의 중요성을 무시하였으며, 유아기 경험 및 무의식을 강조하였다. 인본주의적 관점매슬로와 로저스는 인간은 자유의지를 가지고 있으며 무의식적인 동기와 환경적 자극에 의해 움직이는 존재가 아니다.인간의 자유의지와 자아실현에 대한 욕구에 집중하였으며, “모든 사람의 잠재력 실현”현재의 느낌과 사고와 같은 개인의 주관적 경험을 강조하였다.현대 심리학 연구에 가장 크게 영향을 미쳤으며, 인간은 스스로 자신을 통제할 능력을 가지고 있는 자유로운 행위자로 간주한다. 인지적 관점(인지 심리학)인간은 수동적으로 자극을 지각하는 것이 아니라, 능동적으로 지각한다고 주장한다.그것ㅇ르 다시 새로운 형태나 항목으로 변경한다고 한다.외부에서 받아들이는 정보를 사람들이 어떻게 받아들이고 처리하는가를 연구하였다.인간의 정보처리과정에 관심 생리심리학적 관점생물학적 견지에서 인간을 이해 심리학의 분야이론심리학학습심리학세상 배우는 원리를 학습심리학 발달심리학전생에 발달을 연구하는 발달 심리학 인지심리학 응용심리학새로운 분야법정 심리학법 제도와 관련된 분야 스포츠 심리학선수들의 수행을 향상시키는데 적용 신경심리학기능적으로 문제가 있는 뇌의 영역을 파악 심리학의 연구 방법심리학 연구의 단계연구 환경개인의 실제 환경, 통제된 연구실 한계행동은 직접 관찰할 수 있지만, 개인의 정신과정은 관찰할 수 없다.인간의 많은 활동은 매우 개인적이다.내적인 사건(추론, 창조, 꿈 등)을 포함한다.-&gt; 정신과정을 직접 관찰할 수는 없지만, 정신과정의 연구는 매우 중요한 주제이고, 심리학 연구기술의 발전을 가져왔다. 심리학의 과학 연구는 문제 선정, 연구 방법 설계, 데이터 수집 및 분석, 결론 도출, 결과 발표의 과정을거친다.연구 문제의 선정연구 주제는 어떤 현상에 대한 의문으로 선택하며 이러한 질문들은 과학적으로 가능한 것이어야 한다. 가설 설정과 조작적 정의가설은 둘 또는 그 이상의 변인 간의 관계성에 대한 추측이다.어떤 개념을 측정 가능하게 정의하는 것을 조작정 정의라고 한다. 연구 방법 결정과 데이터 수집연구방법은 크게 기술적 연구와 실험연구로 나뉘게 된다.기술적 연구는 사례연구, 자연적 관찰, 조사법과 같은 방법으로 실험을 수행하기가 불가능한 경우에 사용한다.실험연구는 변인 간 인과관계를 설명하는 데 사용된다. 데이터 수집 방법실험연구에서는 표본의 반응을 측정함으로써 수집하고, 기술적 연구에서는 설문조사나 질문지를 통해 데이터를 수집한다.데이터 분석과 결론 도출 연구 결과 보고 연구 단계가설변인조작적 정의어떤 개념을 측정가능하게 정의하는 것‘공부 시간’은 ‘일정 시간’동안 실제 공부한 양 횡단적 연구와 종단적 연구횡단적 연구 VS 종단적 연구횡단적 연구 / 단일 시점에서 수행하는 연구종단적 연구 / 동일한 대상으로 일정 기간 수행하는 연구 실험 관찰 인과관계와 상관관계인과관계란 어떤 변인이 다른 변인의 변화를 이야기하는 것이며, 상관관계는 어떤 한 변인이 변화할 때 다른 변인도 함께 변화하는 것을 말한다. 상관관계정적상관 / 한 변인이 증가함에 따라 다른 변인도 증가하는 관계이다.부적상관 / 한 변인이 증가함에 따라 다른 변인이 감소하는 관계이다. 심리학을 비롯한 사회과학에서 상관관계와 인과관계를 명확하게 구분하는 것은 매우 중료하다.그렇지 않으면 두 변인관의 관계가 잘못 해석될 수 있기 때문이다.심리학에서는 독립변수에 처치를 가한 유무에 따른 결과를 비교하는 경우가 많다. 연구 설계실험 연구실험법은 변인 간 인과관계를 규명하기 위하여 사용한다.표본의 반응을 측정함으로써 수집한다. 기술적 연구조작적 정의연구자의 추론이나 조작 없이, 어떤 행동이 일어나고 있으며 어떤 양과 빈도로 발생하고 있는지를 수량화하는 것이다.설문조사나 질문지를 통해 데이터를 수집한다. 자연적 관찰자연적 관찰이란 자연적 환경에서 관심 있는 변인을 관찰하고 기록하는 방법이다. -이점-실험상황이 아닌 자연 상황추후 연구에 대한 아이디어를 얻을 수 있다실험 연구가 불가능한 상황에서 실험 연구의 대안이 될 수 있다.ex) 유아의 불안행동 -문제점-시간과 비용이 많이 발생한다.인과관계의 어려움이 있다.가외변인을 통제할 수 없다.대상자의 편향이 나타난다.관찰 대상자가 관찰자의 존재를 알아차리고 평소와 다르게 행동할 가능성이 있다.신뢰도문제가 생긴다 -&gt; 관찰자가 행동을 정확하게 관찰햇다는 것을 보장하기 위해 두명 이상의 관찰자가 동시에 관찰한 후 비교해 보는 관찰자간 비교가 필요하다 조사법(Survey Method)심리학 연구에서 가장 흔하게 사용되는 방법이다.연구자는 모집단에서 표본을 추출하여 조사하고 그 결과로 전집의 특성을 추론하는 방식이다.조사를 통해 행동, 의견 및 태도, 인구통계학적 변인을 광범위하게 수집할 수 있다. 접집을 모두 조사하는 경우와 표본을 추출하여 조사하는 경우가 있는데전집을 모두 조사하는 센서스의 경우 시행하기 어렵고 무선표집(random sampling)을 통한 모집단에서 표본 추출을 통해 조사를 하는 경우가 많다. -정보를 얻는 방식-면접법, 전화조사법, 질문지법 -장점-1)다량의 데이터2)적은 비용3)빠른 시간 -단점-1)대표성이 없는 표본 또는 잘못 작성된 질문 문항에 의해 조사 결과가 영향을 받을 수 있다.2)조사 대상자의 태도가 결과에 영향을 주 수 있다3)대상자가 연구자의 의도에 순응하여 반응하거나, 자기 자신을 좀 더 좋게 보이도록 거짓 반응을 하거나, 잘못된 기억에 의하여 반응할 수 있다. 상관연구 사례연구(Case Study)사례연구란 한 개인이나 집단 또는 조직을 대상으로 어떤 문제나 특성을 심층적으로 조사, 분석하는 연구이다.대표적으로 프로이트의 정신분석이론의 사례들이 이에 해당되며, 임상심리학에서 유용하게 사용된다.(개인의 행동 특징에 관심을 두기 때문) 사례연구는 한 개인이나 집단을 심도 있게 관찰한다는 측면에서 자연적 관찰의 한 유형으로 볼 수 있다. 문헌 연구(Archival Research)문헌연구란 다른 연구자가 수행한 연구를 분석하거나 역사적 기록을 살펴보는 방식이다. -이점-1) 다량의 데이터가 존재하기 때문에 추세, 관계성 및 결과에 대해 더 잘 알 수 있다.2) 비용이 적게 든다. -단점-1) 필요한 데이터를 마음대로 수집하기 어렵다.2) 일정 시기의 데이터가 누락되어 있는 경우가 있다.3) 선행 연구를 신뢰할 수 없는 경우가 있다. 연구의 타당도와 신뢰도타당도측정하고자 의도한 것을 실제로 측정해 낸 정도를 의미한다.내적 타당도관찰한 결과에 대해서 인과관계를 확신할 수 있는가를 말한다. 외적 타당도연구 결과를 다른 사람, 다른 환경에 일반화 시킬 수 있느냐의 문제이다.외적 타당도는 전집 타당도와 생태학적 타당도의 측면에서 검토하여야 한다.전집 타당도 / 연구 결과를 다른 피험자에게 일반화할 수 있느냐생태학적 타당도 / 실험 상황이나 조건과 유사한 다른 상황 및 환경에 대하여 일반화할 수 있느냐 -내적 타당도를 향상시키는 방법-가외변인의 통제와 무선할당을 통해 내적 타당도를 향상시킬 수 있다. -외적 타당도를 향상시키는 방법-전집 타당도의 경우 전집의 특성을 충분히 반영하고 있는 표본을 표집함으로써 어느 정도 극복할 수 있다.주로, 무선표집을 통하여 전집 타당도를 확보한다. -내적 타당도를 위협하는 요인-피험자 특성, 외적 사건, 피험자 성숙, 피험자 학습효과, 측정도구의 변화, 평균으로의 회귀, 피험자 상실, 선택-성숙 상호작용, 실험자 편파 -외적 타당도를 위협하는 요인-1)표본의 대표성 : 표본이 전집을 대표하지 못하는 경우2)피험자의 반응성 : 피험자들이 평소와 다른 행동과 반응을 보이는 경우 신뢰도우리가 조사한 값이 얼마나 믿을만 한가에 대한 것이다.신뢰도는 행동 측정의 인관성을 의미한다.즉, 동일한 대상을 반복 측정하면 동일한 값을 얻어야 한다는 것이다. -검사-재검사 신뢰도-짧은 시간 간격 동안 연속해서 같은 검사를 두 번 실시한다. -동형검사 신뢰도-문항내용은 다르지만 측정 내용, 문항 수, 문항 형식, 난이도 등이 같은 두 개의 동형 검사를 제작하여 동일한 대상에게 연속적으로 실시하는 것이다. -반분 신뢰도-피험자에게 한 번의 검사를 실시한 후 적절하게 평가도구를 반분하여 분할된 각 부분을 독립된 검사라고 여기고 실시한다. 연구의 윤리연구 수행 과정에서의 윤리1) 연구 참여에 대한 동의가 이루어져야 한다.2) 피험자를 속여야 한느 경우 연구의 과학적 가치 측면에서 정당해야 하며, 다른 대안이 있을 수 없을 때에만 제한적으로 사용해야 한다.3) 동물의 인도적인 보호와 사용심리학 실험에서 동물의 사용은 동물 실험 이외의 대안이 없을 때에만 가능하다.연구 결과 출판에서의 윤리1) 자료의 조작 및 표절을 하면 안 된다.2) 연구 자료를 중복으로 출판하면 안된다. 감각과 지각감각이란 시각, 청각, 후각, 미각, 촉각 과정으로 즉각적이고, 원초적이고 직접적인 반면, 지각이란 사람이 느낀 감각을 어떻게 받아들이느냐에 대한 것으로 선택적이고 조직적이고 해석적이다. 외부 세계의 물리적 자극을 내면화 하는 과정의 가장 초기 단계에는 외부로부터 유입되는 자극의 물리적 특성을 신경전달 신호로 변환하는 감각수용기가 존재한다. 인간이 지각하는 다양한 자극의 물리적 특성은 반드시 그 특성이 일대일로 지각되지는 않는다. 감각과 지각의 측정방법과 원리베버의 법칙과 최소 식별 차이자극 변화를 탐지하기 위한 자극 강도 변화의 최소값은 그 자극의 원래 강도와 비례한다.최소식별 차이: 자극 강도의 탐지는 물리적 자극 간의 절대적 차이가 아닌 기준 자극의 변화량에 의존하는 데 이와 같은 자극 변별을 위한 상대적인 변화량을 최소식별차이라고 정의한다.감각역치와 신호탐지이론감각역치: 탐지를 의식적으로 보고 할 수 있는 물리적 자극의 강도이다.감각역치는 측정의 대상이 되는 각 개인마다 개인차가 있으며, 자극에 대한 탐지 보고의 유무와 실제 자극의 존재 유무를 고려해 개인의 민감도를 측정하는 방법이 신호탐지이론이다.점화 현상과 역하지각역하지각(subliminal perception): 물리적 자극은 존재하지만 그 강도가 역치 이하인 자극점화 효과는 의식적으로 그 존재를 보고하지 못하는 자극들이라도 일정 수준의 지각적 처리가 일어나는 현상이다. 상향식 처리물리적 속성의 단서가 가장 낮은 수준으로부터 높은 수준으로 이동하는 처리단계로 감각 정보가 수용기세포를 통해 입력되어 뇌로 전달되어 해석되는 일방향적인 과정이다.ex) 책상을 지각하는 경우 시각 과정의 기능적 이해시각 정보의 조직화와 게슈탈트 원리시각 체계가 시각정보를 조직화하여 사물의 모양을 파악하는 과정을 관찰함으로써 이해할 수 있다. 지각의 이해외부 세계에 존재하는 압도적인 감각 정보의 양을 고려할 때 경우에 따라서는 정보의 선별적 처리가 불가피하다는 것에 동의하지만 이러한 관점은 인간의 정보 처리 능력에는 한계가 있으며, 따라서 매 순간 가장 중요한 정보들만 선택적으로 처리함으로써 효율적 정보 처리를 달성할 수 있다는 맥락에서 이해될 수 있다.지각의 기능 주의 과정을 통해 어느 입력 정보가 처리되어야 하고 어느 입력 정보가 버려져야 하는지에 관한 결정을 내린다. 대상이 어디에 위치하는가를 결정할 수 있다. 지각 체계는 내가 지각하고 있는 대상이 정확하게 무엇인지 결정할 수 있어야 한다. 재인된 대상의 결정적 특성을 추상적으로 도식할 수 있어야 한다. 지각적 항등성지각 체계는 대상의 본질적 특징을 개념적으로 파악하여야 한다. 학습학습의 정의학습이란 경험을 통해 얻는 행동과 지식에서의 비교적 영속적인 변화이다.행동주의 에서는 고전적 조건화, 조작적 조건화, 조형 등의 원리를 활용하여 학습을 시키고,인지주의 에서는 관찰학습, 모방학습, 통찰학습, 잠재학습 등을 이용한다. 고전적 조건화고전적 조건화는 흔히 반응 조건화 혹은 파블로프 조건화로 불린다.고전적 조건화에서는 처음에 어떠한 기능도 하지 않던 자극이 특정 반응을 유출할 수 있는 능력을 가지게 된다. 고전적 반응의 형성고전적 조건화를 시도하기 위해서는 먼저 반사반응을 유발시키는 자극을 찾아야 하는데 이를 무조건 자극(UnConditioned Stimulus)이라고 한다.무조건 자극에 의해 자동적으로 유발되는 반응을 무조건 반응(UnConditioned Response)이라고 한다. 고전적 조건화를 형성하기 위한 다음 단계는 무조건 자극과 중립 자극을 서로 조건화 시키는 과정이다.이 같은 연합과정을 여러 차례반복하게 되면 중립 자극은 결구구 무조건 자극이 없어도 반응을 유발시킬 수 있게 되는데 이 중립 자극을 조건 자극이라고 하며, 이 자극에 의해 유발되는 반응을 조건 반응이라고 한다. 시간을 어떻게 배치하는 가에 따라 다음과 같은 다섯 가지 유형의 조건화 과정이 있다.지연 조건화두가지 종류가 있는데 하나는 중립 자극을 먼저 제시하여 일정 시간을 유지한 후 제거함과 동시에 무조건 자극을 제시하는 방법이며, 하나는 중립 자극을 제시하고 있는 중에 무조건 자극을 제시함으로써 두 자극을 동시에 제시하여 일정 시간이 지난 후 동시에 제거하는 방법이다. 흔적 조건화중립 자극의 철회와 무조건 자극의 제시 사이에 어느 정도의 시간 간격이 있는 것을 말한다.이 방법은 시간 간격이 짧은 경우에만 효과적이라고 할 수 있다. 동시 조건화중립 자극과 무조건 자극을 동시에 제시하였다가 동시에 제거하는 것인데, 이 방법은 일반적으로 효과적이지 못한 것으로 알려져 있다. 후진 조건화무조건 자극을 먼저 제시하고 조건 자극을 나중에 제시하는 것으로, 앞의 방법들에 비해 조건화가 가장 형성되기 어렵다.고차적 조건화어떤 중립 자극이 고전적 조건화 과정을 통해 조건 자극이 되었을 때, 이 조건 자극을 또 다른 중립 자극과 반복적으로 연합하면 그 중립 자극도 조건 반응을 일으킬 수 있는 또 하나의 조건 자극이 될 수 있다. 이러한 현상을 이차적 조건화라고 한다. 소거와 자발적 회복소거: 무조건 자극이 조건 자극과 연합되지 않음으로써 조건 자극이 반응을 일으키지 못하는 현상이다.소거 과정을 통하여 일단 조건 자극이 능력을 상실한 것으로 보이더라도 어느 정도 시간이 지난 후 조건 자극을 제시하면 다시 조건 반응이 일어난다.소거 후에 아전의 조건 자극을 다시 제시하면 이러한 현상이 일반적으로 나타나는데 이것을 자발적 회복이라고 한다.자극 일반화와 변별자극 일반화란 어떤 자극이 일단 조건 자극으로서 형성되고 나면, 이 자극과 유사한 다른 자극들도 무조건 자극과 연합된 적이 없음에도 조건 반응을 알 수 있다.ex) 자라보고 놀란 가슴 솥뚜껑 보고 놀란다. 조작적 조건화조작적 조건화의 원리행동이 그 결과에 의해 증가되거나 약화되는 절차를 의미한다.사람들이 바람직한 결과를 이끌어 내기 위해 단지 어떤 자극에 수동적으로 반응하는 것이 아니라 환경에 능동적인 ‘조작’을 가한다는 의미에서 나왔다. 정적강화와 부적강화정적 강화어떤 특정한 행동 뒤에 즉각적으로 주어지는 자극으로 인해 이후 그 행동의 빈도가 증가하는 과정이다.여기서 행동의 빈도를 증가시킨 자극을 강화인이라고 한다.ex) 어머니의 심부름을 한 어린이에게 과자를 선물로 줌으로써 계속 심부름을 잘 하게 됨. 부적 강화행동의 결과로 어떤 자극이 없어짐으로써 이후 그행동의 빈도가 증가하는 과정을 말한다.ex) 더울때 문을 여는 행동도피 행동 / 어떤 혐오 자극이 이미 존재하고 있을 때 특정 행동을 함으로써 그 혐오 자극을 제거하는 경우를 말한다.회피행동 / 혐오 자극이 현재 존재하고 있지는 않지만 미리 어떤 행동을 함으로써 혐오적인 상황이 닥치지 않게 하는 경우를 말한다. 강화인의 종류미래의 반응이 증가할 수만 있다면 무엇이라도 강화인이 될 수 있다.정적 강화 및 부적 강화에서 행동의 빈도를 증가시키는 역할을 하는 강화인에는 여러가지가 있다. 무조건 강화인(일차적 강화인)특별한 경험 없이도 유기체의 행동을 증가시키는 강화인이다.ex) 음식, 물, 공기 등 조건화된 강화인(이차적 강화인)일차적 강화인과 연합됨으로써 생긴다.ex) 돈 등 강화 스케줄강화인이 어떤 행동을 형성하고 유지하는 데 중요한 역할을 하는 것은 사실이지만 강화 스케줄에 따라 행동의 학습 속도, 패턴, 지속성 등은 달라진다.즉, 어떤 행동 후에 나오는 강화인이 어떤 방식으로 제공되느냐에 관한 것이다. 계속적 강화그 행동이 나올 때마다 매번 강화인을 제공하는 것. 간헐적 강화행동이 일어날 때마다 매번 강화가 주어지지 않는 경우를 말한다. 비율 스케줄과 간격 스케줄로 나뉜다. 비율 스케줄은 특정 반응의 횟수를 기반으로 강화가 주어지는 것으로 고정 비율과 변동 비율 스케줄이 있다.고정 비율 스케줄/n 번째의 반응마다 강화인이 주어지는 스케줄변동 비율 스케줄/정확하게 몇번째인지는 모르지만 평균적으로 n번째에 강화인이 주어지는 스케줄. 간격 스케줄은 특정 시간이 지난 후에 나오는 반응에 대해서만 강화인이 주어지는 경우로 고정간격 스케줄과 변동간격스케줄로 나뉜다.고정 간격 스케줄 / n초가 지난 후에 나오는 첫번째 반응에 대해서만 강화인이 주어진다.ex) 30초 스케줄에서는 30초가 경과하기 전에 나온 반응은 아무런 강화를 받지 못하고 30초가 지난 후 천 번째 반응에 강화가 주어지면 그 시점에서 다시 30초가 지난 후의 첫 번째 반응에 강화가 주어지는 식으로 진행된다.변동 간격 스케줄 / 정확히 n초는 아니지만 평균적으로 n초가 지난 이후에 나온 첫번째 반응에 강화인이 주어진다. -&gt; 고정비율과 고정 간격 스케줄에서는 강화를 받은 후 일시적으로 반응이 중단되는 특성이 있다. 그 이유는 강화인에 대한 예측이 어느 정도 가능하기 때문이다. 이에 비해 변동비율과 변동간격스케줄에서는 반응이 중단되지 않고 지속적으로 나오는 특성이 있는데, 이는 강화인의 제공에 대한 예측이 불가능하기 때문이다.그리고 일반적으로 비율 스케줄이 간격 스케줄보다 더 높은 방응률을 가져온다. 소거강화인의 제공이 감소함에 따라 그 행동의 빈도도 감소하여 소거가 이루어진다.일반적으로 간헐적 강환느 계속적 강화보다 소거가 잘 되지 않는 특징을 가지고 있다. 처벌처벌이란 특정 행동 뒤에 즉각적으로 따라오는 자극의 변화 때문에 이후의 행동 빈도가 감소하는 과정을 말한다.여기서 행동의 빈도를 감소시키는 자극의 변화를 처벌인이라고 한다.처벌인은 무조건 처벌인과 조건화된 처벌인이 있다. 무조건 처벌인무조건 처벌인은 특정 경험이 없는 유기체에게도 처벌인으로서 효과를 지닌 것들을 말한다.조건화된 처벌인무조건 처벌인과 반복적으로 연합되어 처벌인으로서의 역할을 하게 되는 것이다. 처벌은 정적 처벌과 부적 처벌로 나누어 진다.정적 처벌이란 어떤 자극이 주어짐으로써 행동이 감소하게 되는 경우이고부적 처벌은 어떤 자극이 없어짐으로써 행동이 감소하게 되는 것을 말한다. 효과적인 처벌-반응이 일어난 후 즉각적으로 처벌이 주어져야 한다.-반응이 나올 때마다 매번 처벌을 하는 것이 효과적이다.-처벌의 강도는 처음부터 아주 강한 것이 좋다.-처벌받는 행동에 대해 대안적 행동이 있을 때 처벌의 효과는 커진다.-처벌 받는 행동보다 대안행동을 제시해야 한다. 동기와 정서동기의 개념인간은 항상 무엇인가를 하고 이쏙, 또 하고자 한다. 이러한 행동은 대부분 그 이유가 있게 마련인데 이를 동기라고 한다.동기는 동기의 소재에 따라 내적 동기와 외적 동기로 나뉘게 된다.-왜 그런 행동을 하는 것일까?-그 사람은 왜 그런 선택을 했을까?-그는 왜 그렇게 공부를 열심히 할까? 왜 행동의 원인에 대해 알고자 하는가?1) 행동의 원인이 무엇이냐에 따라 그 행동에 대해 적절히 대처할 수 있다.2) 사물이나 현상에 대해 이해하고자 하는 것은 인간의 본질적 욕구이다. 동기의 개념을 사용하는 이유는 다음과 같다. 다양한 행동을 설명하기 위해서 행동을 생물학적으로 설명하기 위해서 행동으로 개인의 상태를 설명하기 위해서 행동에 대한 책임 소재를 밝히기 위해서 역경에 대한 도전을 설명하기 위해서 생리적 동기욕구헐의 추동이론에 따르면 생리적 박탈과 결핍이 생물학적 욕구를 생성하는 데 그 욕구가 계속 충족되지 않으면 생리적 추동이 생성된다.그러므로 욕구란 유기체가 생명을 유지하고 성장하며 안녕을 도모하는 데 필수불가결한 조건이라고 할 수 있다.욕구가 좌절되면 생물학적, 심리적 안녕이 방해를 받게 된다. Hull의 추동이론1) 생물학적 박탈과 결핍으로 인한 생물학적 욕구 생성2) 추동이란, 생물학적 결핍에 기인하는 심리적 불편함(긴장감이나 불안감)3) 추동 에너지는 유기체가 생리적 욕구를 해결하는 행동을 하도록 촉구. 동기화 상태동기화 상태는 이러한 방해를 받기 전에 유기체가 행동하도록 만드는 것이며,동기화 상태는 음식 박탈이나, 수면, 공기 온도 등 기본적인 생리적 욕구에서 나올 수 있다.은것은 생물학적 체계와 동기화된 행동 간의 직접적인 고리를 만들어 주었으며, 동질정체와 부적 피드백이라는 두 가지 개념을 도출하는 기반이 된다. 동질 정체유기체는 내외 환경에 직면하여 안정적인 내적 상태를 유지하려는 신체적 경향성을 가지고 있다.이러한 생리적 안정 상태의 유지기제를 동질정체라고 한다. 부적 피드백추동에 의해 활성화된 행동을 부적 피드백이 정지시킨다.생리적 욕구가 필요 이상으로 채워지기 전에 부적 피드백이 신호를 보낸다.투입에 의한 산출이 그 투입을 제어하는 시스템을 의미한다. 갈증 배고픔 성 행동 공격성 심리적 동기앞서 살펴본 생리적 동기는 인간이나 동물 모두 가지고 있다. 생리적 동기에 의존하여 삶을 보다 원활하게 영위해 가는 것이다.그러나 인간은 더 고차원적인 형태의 심리적 동기를 추구한다. 자율성 추구자율성은 인간이 행동을 시작하고 통제할 때 자기 스스로 선택하고 결정하는 경험을 원하는 심리적 욕구를 말한다. 자율성 상태를 판단하기 위한 세 가지 기준 행동의 원인이 자신에게 있는지 혹은 외부에 있는지의 여부 행동이 자신의 의지에 따라 이루어졌는지의 여부 선택 가능한 대안이 얼마나 있었는가의 여부 타율성이란?외부의 힘이 특정한 사고나 감정 혹은 행동 방식을 강요하는 경우 자신의 역량 확인역량이란 자신에게 가장 알맞은 도전을 추구하고 완성하여 능력을 확인하고자 하는 심리적 욕구이다. 관계 추구관계에 대한 욕구는 다른 사람과 정서적 유대감을 가지고 애착을 형성하고자 하는 심리적 욕구를 말한다.이러한 관계는 이익과 손해를 초월하여 서로를 염려하고 배려하는 관계다. 이렇나 관계욕구의 해소는 가족 내에서 가장 먼저 이루어진다. 관계의 양보다는 질이 중요하다는 것이다.우리가 바람직한 삶을 누리기 위해서는 우선 생리적 욕구를 해결하는 것이 중요하다.인간은 자율성을 추구하고, 자신의 역량을 확인하면서, 다른 사람과 바람직한 관계를 형성할 때 능동적인 삶을 산다고 할 수 있다. 정서인간이 경험하는 가장 기본적인 느낌에는 강증과 배고픔뿐만 아니라 즐거움이나 분노와 같은 정서도 포함된다. 동기와 정서를 구별해 주는 차이점은 다음과 같다. 정서는 주로 외부 요인에 의해 유발되는 반면, 동기는 주로 내부 요인에 의해 유발된다. 동기는 주로 특정 욕구에 의해 유발되는 반면, 정서는 광범위한 종류의 자극에 의해 유발된다. 정서의 기능정서적 행동과 표현에는 적어도 다음과 같은 일곱 가지의 기능이 있다.이렇나 특성은 유기체로 하여금 복잡하게 변화하는 환경에 적응할 수 있도록 돕는 역할을 한다. 위기에 대처하기 위하여 자율신경 반응을 이끌어 낸다. 특별한 지역 조건에 알맞은 반응을 하도록 한다. 목표를 이루기 위해 행동하도록 동기화시킨다. 타인에게 자신의 의도를 전달한다. 사회적 유대를 증가시킨다. 사건에 대한 기억과 평가에 영향을 미친다. 특정 기억의 저장을 향상시킨다. 정서의 표현 정서 표현은 생득적이다?시각 장애를 가진 아기가 성숙함에 따라 정서와 관련된 표현이 자연스레 나타남으로 보아 누군가에게 배운것이 아니라 생득적으로 표현법을 알고 있다는 주장. 정서 표현은 학습되었다?정서적 표현의 일부는 학습된 것이다.ex) 솔직한 감정을 표현하는 것에 대한 문화적 민감성 차이, 정서표현 중 의사소통 수단으로 사용되는 것은 대다수가 학습된 것. 진화론적 의미하등 동물과 인간의 정서 표현에는 유사점이 많다.성인과 유아의 정서 표현이 비슷하다.선천적 시각 장애 아동과 정상인의 정상표현이 유사하다.서로 다른 문화간의 정서 표현에 공통점이 많다. 정서 이론 제임스-랑게 이론어떤 상황에서 신체적 변화가 먼저 오고 그 변화를 지각하게 될 때 특정한 정서를 느낀다고 주장.즉, 정서는 어떤 행동의 원인이 아니라 어떤 상황에서 일어난 신체반응에 대한 지각이라고 주장.ex) 슬프기 때문에 눈물을 흘리는 것이 아니라 눈물을 흘리기 때문에 슬프다는 이론 캐넌-바드 이론.정서에서 중심적인 역할을 하는 것은 뇌의 시상이라고 주장하며 제임스-랑게 이론을 반박하였다.자극이 시상에 전달되면, 정서적 경험과 신체적 변화를 동시에 유발한다고 주장한다. 이와 같은 주장은 뇌와 신체를 연결하는 신경 절단 후에도 정서를 경험함을 보이는 실험을 통해 증명된다.또한 제임스-랑게 처럼 신체 변화가 먼저 오고 그 변화를 지각하는 것은 신체 반응의 속도 문제가 있다고 주장한다.예를 들어 위협적인 상황잉나 분노를 느끼게 하는 상황에서 경험하는 정서를 설명하기에 너무 느리다고 주장한다. 인지평가이론(샥터-싱어 이론)그 정서를 경험하게 된 상황에 대한 평가가 정서적 경험에 상당한 영향을 미친다고 주장.신체의 생리적 반응에 대한 인지적 해성을 중요시 한다.정서적 각성의 효과적절한 수준의 정서적 각성은 생활 속에서 많은 경우 어떤 일을 수행하는 데 도움이 된다.그러나 정서적 각성의 정도가 너무 높을 때에는 반대되는 현상을 초래할 수 있다. 기억과 사고기억 이론기억이란?과거의 경험으로 부터 얻은 정보와 지식을 유지하고 현재에 되살려 주어진 과제에 맞춰 사용 할 수 있도록 하는 수단부호화, 저장, 인출의 세 가지 과정으로 이루어진다.부호화(excoding)감각 정보가 표상(representation)으로 전환되는 과정이다. 감각을 받아들이고 머리에 남기는 과정인지과정 혹은 정보 처리 과정의 한 형태로, 청각, 시각, 촉각 등 감각을 통해 들어오는 정보를 처리하고 저장하기 위해 그 정보를 유의미하게 만들고, 장기기억에 저장되어 있는 기존의 정보와 연결하고 결합하는 과정이러한 과정을 통해 정본느 작업기억에서 장기기억으로 전환저장해당 내용을 저장함인출머리 속의 정보를 과제 수행을 위해 이끌어내는 과정작업 기억어떤 내용을 받아들였을 때 이를 일시적으로 저장하는 기억회상 과제기존에 가지고 있었던 정보를 특별한 단서 없이도 자유롭게 꺼내 쓸 수 있는 과제재인 과제단서를 제시하고 기억된 정보와 일치하는 가를 판단하는 요구외현적 기억머리 속에 있는 것을 의식적으로 머리 속에서 찾아보고 끄집어냄.암묵적 기억의식적 의도적으로 기억하려 한 적이 없음에도 불구하고 과거 경험을 통해 기억이 살아나는 기억 전통적 기억 모형애트스킨과 쉬프린은 기억을 세 단계로 구분한 기억 모형을 제시하였다. 감각 저장소감각기관을 통해 들어온 정보가 극도로 짧은 시간만 머무는 기억 저장소 단기 저장소감각 기억에 비해 정보가 머무르는 시간은 상대적으로 길지만 기억 가능한 정보의 양이 매우 적은 것 장기 저장소무한대에 가까운 양의 정보를 오랜 시간 영구적으로 저장하는 기억 저아소 대안적 기억 모형크레이크와 로크하트는 기억이 용량 및 파지 시간 등에 따라 단계별로 분리되어 있기보다는 부호화와 인출의 단계에서 정보가 얼마나 깊이 있게 처리되는지에 따라 그용량과 지속 시간 등이 결정된다고 하였다. 한편 배들리는 저장소적 기능을 강조한 과거의 관점과는 달리 기억 정보의 흘므을 제어하는 중앙 집행기를 포함시켜 저장소의 정보를 능동적으로 활성화하고 유지하는 과정을 중요하게 부각시켰다.기억 현상을 명확하게 설명함으로써 가장 합리적인 모형으로 각광 받고 있다. 처리 과정으로서의 기억기억 공고화가설공고화 과정은 암송과 정보의 조직화에 의한 기존 정보와 새로운 정보의 합을 의미한다.단기기억장치 속의 새로운 정보가 암송과 조직화에 의해 안정된 상태로 장기기억 장치에 저장되는 현상을 의미한다.예를들어 스콰이어는 전기충격치료를 받은 환자들이 경험하는 일시적인 기억상실증을 조사하였는데, 전기충격 치료가 행해진 시기 전후에 환자가 보고한 정보들이 비교적 부정확함을 보여주어, 전기충격으로 인한 정보 연합 과정의 방해가 기억상실의 직접적인 원인임을 밝혀내었다.암송에빙하우스는 반복적인 암송이 기억을 공고화 시키는 데 큰 효과가 있음을 발견하였다.규칙적인 시간간격을 두고 여러 번 행해지는 분산학습에서 기억 증진 효과가 큰 것이 밝혀졌다.조직화정보의 조직화는 암송과 더불어 학습 효과를 극대화하는데 도움이 된다.또한 좀 더 깊은 수준의 공고화로 이어진다. 유사한 것들끼리 범주로 묶는 범주화 과정 기억 항목들이 가지는 특성들을 서로 연결시켜 임의의 상호작용 관계를 부여한다. 이미 익히 알고 있던 지식 항목들과 암기해야 할 완전히 새로운 항목들을 서로 연합시켜 이미 알고 있던 항목을 인출 단서로 사용하는 방식. 친숙한 지형 지물에 기억해야 할 항목을 연관시킨다. 머리글자를 이용하기. 인출스턴버그는 단기기억에서의 인출 특징을 조사하여 다음과 같은 사실을 얻었다.기억 항목의 수가 증가할수록 반응 시간이 점차 증가하였는데, 이는 단기기억 내 저장된 정보를 인출하는 과정은 기억 항목 전체를 한꺼번에 인출하는 것이 아니라 하나하나식 인출하는 순차적 처리방식을 따름을 시사한다.여기서 유의할 점은 기억 항목 내에서 속한 위치는 반응 시간에 영향을 미치지 않는 것으로 보아 기억된 항목의 인출은 순차적이되 일단 인출 과정이 시작되면 기억 항목 전체를 인출하기 전까지는 종료되지 않는 전체적 순차처리 과정임을 의미한다. 망각 과정과 기억 왜곡간섭 모형 쇠잔 모형 지식 표상 인지와 사고일반적인 문제 해결 과정문제란 목표와 현실 사이의 갭. 문제의 인식 문제의 정의 문제 해결을 위한 전략 구성. 문제에 대한 정보 조직화 자원 할당 해결 여부 점검 문제 해결의 평가 단계 알고리즘과 어림법알고리즘어림법 통찰과 갖춤새통찰문제 해결 과정 중 해결에 결정적인 역할을 하는 방법을 갑작스럽게 발견하거나 이해하는 현상.의사결정 태도와 태도변화태도란?마음의 경향성을 의미한다.태도가 중요한 이유행동에 영향을 미치는 중요한 심리변수이며 행동을 예측하거나, 변화시키려고 할때 가장 많이 거론되는 요인이다.태도의 3요소인지적 요소 / 내가 아는 것을 통해 태도가 변할 수 있다. 상대적으로 쉽게 변할 수 있다.정서적 요소 / 대상에 대해서 좋아하는가 그렇지 않은가이다. 인지적 요소에 비해 훨씬 더 오래 남고 잘 바뀌지 않는다. ex) 마케팅 에서도 인지적 요소보다 정소적 요소에 집중하는 것이 그래서 중요하다.행동적 요소 / 나의 태도와 내 행동을 일치시키는가에 대한 것이다. 내 태도와 행동이 항상 일치하지는 않는다.태도의 생성 요인유전적 요인학습에 의한 태도 형성 연합에 의한 획득 강화에 의한 획득 모방에 의한 획득(관찰 학습) 일관성 동학에 의한 태도 형성사람들은 자신의 태도와 행동이 다르다면 둘 중하나를 포기하게 된다. 손익계산에 의한 태도 형성 태도의 강도많은 정보를 가질 수록 태도가 강화 된다.대상에 대한 태도는 잘 변하지 않는다. 사회적 규범 태도변화의 두 이론인지 부조화 이론나의 행동이 태도와 다르면 태도가 달라진다.과거에 했던 노력이나 고생을 미화시켜 지금 보상받으려는 심리가 있다.ex) 누군가를 채용할때 힘들게 해야 그 사람이 회사에 들어왔을때 뿌듯해 한다. 정교화가능성 모델권위가 있는 사람이거나 중요한 사람이 말을 하면 그 태도를 주입할 수 있다.지식이 있는 사람이 설명 or 그 사람과 관련성을 높여서 설명(집단에 대한 정보가 아니라 나에 대한 정보를 받을 때 달라진다.) 발달심리학발달심리학의 핵심 질문들발달의 연속성발달이라는 것이 점진적으로 진행이 되는 것인지 혹은 급격하게 변화하는 것인가에 대한 논의이다인간이 작은 양적인 변화들을 통해 점진적으로 천천히 바뀌어 나간다고 주장하는 설이 있는가 하면, 발달의 특정 시기 즉 발달 단계별로 새로운 패턴이 출현한다고 보는 견해가 있다.또한, 환경이 발달에 끼치는 영향이 연속적인지 혹은 특정 시기의 경험이 발달에 결정적인가에 하는 문제인데 즉, 결정적 혹은 민감한 시기가 있는가 에 관한 문제이다. 예를 들면 한 개인이 사춘기에 들어가 기존과 상반된 행동 패턴을 보이는 경우또, 청소년기의 특정 시기(민감하고 결정적인 시기)에 특이한 경험을 겪어 그것이 발달에 큰 영향을 미치는 경우 등이 논쟁의 주제가 된다. 발달의 원인발달이 유전에 의한 것인가 아니면 환경에 의한 것인가?오늘날 심리하자들은 이 둘을 따로 구분해서 논의하는 것이 적절치 않다고 판단을 내렸다. 개인차의 문제개인차의 원인은 무엇이고 개인적 특성은 어느정도 안정적인가? 유아, 아동 청소년기의 발달이 시기에 이루어지는 신체, 감각 및 운동 발달을 살펴본 다음, 인지 발달, 사회성 발달을 살펴본다. 신체, 감각 및 운동 발달영유아기 의 신체의 발달은 미약한 시력과 청력을 가지고 맛 또한 구분할 수 있다.이런 신생아는 몇몇 반사 를 가지는데, 예를들면 알굴에 닿는 사물 쪽으로 머리와 입이 향한다던가 입 안에 있는 물체를 빠는 등의 반사이다.이 시기의 운동 능력의 발달은 그 유무에 따라 자극을 능동적으로 취사선택을 할 수 있는지가 정해지기 때문에 매우 중요하다.운동 능력이 없는 시기의 신생아는 시청각을 통해서만 대상을 이해하게 된다. 전학령기 에 들어선 2세 경의 아동은 지각능력이 크게 향상된다.이때 몸을 좀 더 잘 통제할 수 있게된다. 학령기 에 접어들면 아동의 감각 능력은 성인 수준만큼 가능하다.또한 움직임을 더 잘 통제할 수 있게 되고, 청소년기의 시작 과 함께 급진적인 변화를 경험하게 된다.이차 성징 으로 인해 자신을 초기 성인으로 보기 시작하고 발달 속도에 따라 인기와 자신감을 가지느냐 혹은 불안을 경험할 수도 있다. 인지 발달피아제의 인지 발달 이론아동의 자연적인 성숙 능력과 환경과의 상호작용을 강조한다.아동이 생물학적 요잉닝나 환경적 자극에 대해 수동적으로 반응하는 존재가 아니라 발달에 능동적으로 참여하는 존재 로 보았다.경험을 통해 아동은 자신이 경험하는 세계를 조직화해서 물리적 및 사회적 세상이 어떻게 작동하는지에 대한 이론을 구성한다. =&gt; 도식화 동화: 새로운 사건을 기존의 도식에 동화시키는 과정즉, 새로운 사건이나 대상을 접할 때 아동은 그것을 기존의 도식을 통해서 이해하고자 한다. 아동이 성숙해 감에 따라 그들의 사고 및 추론 능력이 질적으로 다른 일련의 단계를 거쳐 진행된다. /피아제의 인지 발달 단계/감각운동기 에는 자아를 행위의 주체로 인식하고 의도적으로 행동하기 시작한다.또한 대상의 영속성 개념을 획득하여, 눈에 보이지 않아도 대상은 계속해서 존재한다는 것을 깨닫는다. 전조작기 에서는 언어사용을 학습한다.하지만 사고는 여전히 자기중심적이기 때문에 다른 사람의 관점을 취하는 데 어려움을 겪는다. 구체적 조작기 에는 사물과 사건에 대해 논리적으로 사고할 수 있다.또한 수, 양, 무게에 대한 보존 개념을 획득한다.여러개의 사물을 특징에 따라 분류하고 크기와 같은 하나의 차원에서 그들을 나열할 수 있다. 형식적 조작기 에는 추상적인 명제에 대해 논리적으로 사고하고 가설을 체계적으로 검증할 수 있다.또한, 가상적인 것 미래 그리고 이념적인 문제에 대해 관심을 가지기 시작한다. 비고츠키의 사회문화적 이론아동의 사고가 좀 더 능력있는 사람들과의 대화를 통해 발달 한다고 주장. 근접발달영역: 발달 영역은 아이가 외부의 도움 없이 혼자서 문제를 해결할 수 있는 영역이고, 발달은 미발달 영역이 근접발달영영기 되고 그 다음 최종적으로 발달 영여이 되는 과정을 거친다. 발달과 관련하여 교육과 같은 환경적인 요인이 가장 중요한 부분은 근접발달영역이다. 전생애 발달 관점과 성인기 발달 이론전 생애 발달심리학적 관점인간의 발달이 그 전 생애를 통해 영위된다. 에릭슨과 레빈슨의 이론에릭슨신체 나이에 따라 발달해야 할 발달 과제들이 있고 이것이 순차적으로 이루어지지 못하면 다음 발달과제에 영향을 받는다.인간 발달이 전 생에에 걸쳐 지속되고 개인뿐만 아니라 사회역사적 맥락 역시 인간 발달에서 매우 중요하다.점성적 원칙 기본적 특질들의 각각의 조합은 육체적, 인지적, 정서적, 그리고 사회적 발달로 인해 위기를 넘기게 될 때 보다 우위의 단계로 넘어간다.이 우위의 단계들은 대각선을 구성한다. 각각의 우위 단계들은 그 단계 나름의 성숙의 위기에까지 수직적으로 전진해야만 하는 선행 단계가 있다. 각각의 위기는 계속되는 위기가 출현할 때마다 그 당시의 우세한 갈등의 새로운 수준가지 전진해야만 한다. 에릭슨의 심리사회적 발달 이론 단계 및 연령 심리사회적 위기 발달 과업 1단계 : 0~1.5세 신뢰 대 불신 어머니에 대한 애착으로 타인에 대한 신뢰의 기초가 됨 2단계 : 1.5~3세 자율성 대 수치심과 의심 자기와 환경에 대한 기본적인 통제력을 획득 3단계 : 3~6세 주도성 대 죄책감 목적 지향적이고 방향성을 획득하는 것 4단계 : 6세~사춘기 근면성 대 열등감 사회적, 신체적, 학업적 기술을 발달시키는 것 5단계 : 청소년기 정체성 대 역할 혼돈 아동에서 성인으로 이행하는 것으로, 정체감을 발달시키는 것 6단계 : 성인초기 친밀감 대 고립감 사랑 및 우정같은 친밀한 유대를 형성하는 것 7단계 : 중년기 생산성 대 침체성 가족, 직업 및 사회와 관련된 인생의 목표를 수행하는 것으로 미래의 세대와 관련된 관심사 발달 8단계 : 노년기 자아통합 대 절망 자신의 인생을 되돌아보며 그 의미를 수용하는 것 레빈슨성인기의 발달에 관한 종합적인 이론을 제시하였다.인생을 계절의 개념으로 접근한다.질적으로 다른 네 개의 계절이 20년 정도 지속된다고 보았다. 인생은 아동 청소년기, 성인 초기, 성인 중기, 성인 후기 라는 질적으로 다른 네 개의 계절이 존재한다. 인생 구조는 다음과 같은 세 변수로 구성되어 있다. 개인에게 심리적으로 중요한 사회문화적 세계 숨겨져 있거나 현재 가장 부각된 자아의 구성 요소들 개인이 현재 참여하고 있는 활동들 성인 초기 전환기 에는 중요한 두개의 과제가 있는데 바로 청소년기의 인생 구조를 마무리 짓고 성인 이전기를 떠나는 것 과 성인 세계로 예비적인 발걸음을 내디든 것 이다.성인 세계의 가능성을 탐색하고 그 안에서 참여자로서 자신을 상상해보고 시험해본다. 성인 입문기 는 보통 22세에 시작해서 6년 정도 지속되며젊은이들은 자아와 성인 세계를 연결해 줄 수 있는 최초의 인생구조를 형성하고 그것을 시험해 보아야 한다.자신의 삶의 중심을 태어날 때부터 속한 가족의 어린이 위치에서 자신이 새롭게 구성한 가정에 기반한 풋내기 성인의 위치로 전환해야 한다.이때는 성인으로서의 자신을 구체적으로 정의하며 직업, 사랑 관계, 삶의 양식, 가치들에 관한 최초의 선택 을 하고, 더불어 살기 위한 노력을 하는 것이다.이때 필요한 자세는 느긋하고 대안들에 개방적이고 깊은 개입을 피하는 것이다. 30대 전환기 에는 과거를 재평가하고 미래를 생각해 볼 수 있는 5~6년의 시간을 가질 수 있다.내 인생에서 내가 한 것은 무엇이고, 내가 하고자 원했던 것은 무엇인가 를 생각하고 고민한다.이때는 20대의 탐색적인 자질은 사라지고 더욱 긴박감을 가지게 된다.30대 전환기는 성인 초기 내에서 좀 더 만족스러운 인생 구조를 만들어 내기 위한 두 번재 기회다. 위의 두 단계를 합쳐 초심자 단계 라고 하며 다음과 같은 중요한 발달과제 들이 있다. 꿈을 형성하고 인생구조 안에 그 꿈을 배치하기 멘토 관계를 맺기(5~6년 선배) 직업을 선택해서 이력을 쌓아 나가기 사랑 관계를 맺어 결혼하고 가족을 이루기 레빈슨 이론의 확인사항 및 한계 각 시기가 시작하고 끝나는 연령이 비교적 안정되어 있다. 인생구조의 발달 과정상 현재의 인생 구조가 아무리 적응적이라고 하더라도 그 유효기간은 최대 7년을 넘지 못한다. 이론의 보편성에 문제가 있다.이 이론은 여성과 소수민족이 배제되었다는 한계가 있다. 남성중심적인 관점에서 이루어 졌다. 성격과 개인차성격의 이해성격의 정의 - 시험 출제 독특성성격은 한 개인을 특징짓는 독특한 면이 그 핵심이다. 일관성성격은 여러 상황에서 비교적 일관성 있게 나타나는 행동 및 사고방식이다. 환경과 상호작용성격은 개인이 환경에 적응해 나가는 과정에서 나타나는 행동양식이다. 성격의 요소성격은 내면적인 특성만 있는 것이 아니라 다른 사람이나 환경과 상호작용을 하는 과정에서 타인에게 보이는 측면을 포함한다.내가 생각하는 나의 모습이 아니라 다른 사람이 보는 나의 모습이 나를 설명한다.페르소나(남이 보는 나)성격이 문제가 되는 것은 내가 생각하는 나와 다른사람이 보는 내가 다를 때 발생한다. 성격심리학의 목표 개인차를 파악한다의미있고 안정된 사람들 간의 개인차를 파악한다. 미래의 사람의 행동을 예측한다한 개인의 행동바익을 있는 기대로 기술하고 지금까지 축적된 행동 방식을 토대로 미래에 그 사람의 행동을 예측하는 것이다$$B(Behaviour)=P(Personality) * E(Environment)$$ 특정한 사고, 행동, 정서가 나타나는 기저를 알아내어 설명하고 이해한다.사람들의 차이를 유발하는 요인을 파악하여 특정한 사고, 행동, 정서가 나타나는 기저를 알아내어 설명하고 이해한다. 성격이론특성이론유형론체액론: 히포크라테스가 주창하였으며, 피에따라 사람의 성격을 나눈다. 체격론: 크래츠머는 체형에 따라 쇠약형, 비만형, 근육형, 이상신체형으로 나누고 이 체형에 따라 성격이 결정된다고 보았다. 체질론: 셀돈은 신체 유형에 따른 체질론을 제안하였다.내배엽형, 중배엽형, 외배엽형 특질론특질: 특질이란 한 사람을 다른 사람과 비교적 영속적으로 구분해주는 일관된 심리적 경향성 이다. 올포트특질을 다양한 종류의 자극에 같거나 유사한 방식으로 반응하는 경향 또는 성향으로 정의하였다. 커텔: 특질을 행동의 객관적 관찰에서 추론되는 가설적 또는 상상적 구성 개념으로 보았다.또한 특질은 성격의 기본 요소이며 행동을 예언하는 데 매우 중요한 요인이라고 간주하였다. 표면 특질 - 인간의 행동 중에서 겉으로 보기에 한데 붂을 수 잇는 특성들을 말한다.예를들어 타인을 비방하기, 욕하기, 타인에 대한 공격성 등이 있다. 원천 특질 - 표면적인 행동의 결정원인이 되는 기저변인을 가리킨다.원천 특질은 훨씬 안정적이며 영속적인 단일 성격요인이고 하나의 원천 특질이 여러 표면 특질들과 관련된다.16가지 근원 특질을 성격요인(Personal Factor)이라고 하였는데, 이들을 측정하는 검사인 16PF가 그것이다. 아이젱크3가지 축으로 사람의 성격을 설명외향성, 신경증 성향, 정신병 성향 외향성: 외향성사교적이고 충동적, 친구많고 모험적내향성조용하고 내성적이고 말수가 적고 신중 신경증 성향: 정서적으로 불안정하고 변덕스러우며 걱정, 불안, 우울, 낮은 자존감, 긴장, 수줍음 등의 특징 정신병 성향: 공격적, 차가움, 자기중심적 등 아이젱크는 왜 이러한 성격 차원들이 나타난ㄴ지에 관심을 가지고 연구를 수행하였다.주로 성격 차원의 생물학적 기초를 밝히는 데 관심을 가지고 잇었다. 사회속의 개인사회적 지각내가 생각하는 나, 타인이 생각하는 나, 나를 이렇게 생각할것이다라고 생각하는 나 사이의 상관관계는 0에 가깝다.사람들은 내가 생각하는 대로 다른사람이 생각할 것이라고 생각한다. 자기자기에 대한 지식이나 신념=&gt; 자기 개념 William James의 자기론주체적인 자기 - 내가 생각하는 나객체적인 자기 - 다른 사람이 생각하는 자기 Higgins 의 자기불일치이론현실적 자기와 이상적 자기 사이의 차이가 생기게 된다.의무적 자기 - 내가 가진 속성에 의해서 생기는 자기 즉, 내가 생각하는 나와 타인이 보는 나 사이에는 차이가 생기기 마련이나, 이 간격이 작으면 작을 수록 더 행복한 삶을 영위할 확률이 높아진다. 자기고양 관련 동기자아존중감, 자기고양편향, 자기 불구화전략, 인상관리이론 자기 불구화 전략: 실패할 수 밖에 없는 이유를 찾아 합리화 시키려고 한다. 인상관리이론: 타인에게 늘 좋은 이미지를 심어주고 싶다. 자기 유지 동기자기가치 확인 이론: 내가 인정받을 존재란 것을 타인을 통해서 확인받고싶어 한다. 자기확증이론: 내가 어떤 사람인가를 확인받고 싶어하는 동기, 성과물을 통해 확증받고 싶어함 자기개념의 근원쿨리 - 거울속에 비친 자기: 중요한 타인이 자신에게 하는 행동을 통해서 자기개념을 형성한다다른 사람들의 지각에 따라 자기에 대한 인식이 달라지고 그럼으로써 자기개념도 변하게 된다. 사회비교이론: 사람들은 자신의 능력 수준과 태도의 정당성을 정확히 평가하려는 동기를 가지고 있다.비교를 통해서 나온 결과에 따라 자신에 대한 자기개념을 형성하게 된다. 자기의 기능자기는 자신과 관련된 정보를 처리하고 세상을 이해하는 데 기초가 된다. 자기참조효과: 타인들의 특징이 자기와 관련될 때 그러한 특징들을 더 잘 기억하게 된다.ex) 시끄러운 교실에서도 선생님이 부르는 자기 이름을 다른 사람의 이름보다 더 잘 알아듣는다. 자기중심적 사고: 자기와 관련된 정보를 중시하고 다른 사람들도 자기처럼 생각할 것이라고 믿는다.또한 자신을 가능한 한 긍정적으로 보려는 강한 경향성을 가지고 있다.사람들은 다양한 상황에 따라 서로 다른 행동을 보일 수 있지만, 그것은 상황에 따른 것이지 내면적으로는 일관적인 특성을 가지고 있다고 생각한다. 자기의 문화 차이자기 관련 개념은 특정 개인이 속한 사회문화적 맥락 속에서 만들어지는 산물이다. 동양 - 상호의존적 자기서양 - 독립적 자기 사람들은 나의 행동만을 보고 판단을 한다.나의 의도는 나만이 알고있다. 홉스테드의 문화구분의 4차원동양사회: 집단주의적 문화권집단에 속한 사람들이 서로서로를 돌봄으로써 그집단에 대한 충성심을 함양하는 문화로, 개인의 욕구나 독립성 보다는 집단의 목표와 구성훤들 간의 조화와 화합을 강조하는 특징이 있다. 서양사회: 개인주의적 문화권자기 자신뿐만 아니라 직접적으로 관련된 가족을 돌보는 것을 촉진시키는 문화로 개인의 독립성과 자율성을 가조하는 특징을 가지고 있다. 마커스와 키타야마문화를 독립적 자기와 상호의존적 자기를 추구하는 문화로 구분 독립적 자기를 추구하는 문화: 북미와 서유럽 등이 있다.자기 실현을 삶의 최대 목표로 생각하며 독립적이고 안정된 자기를 확립하기 위해 노력한다.이처럼 안정된 자기로부터 자신의 삶을 일관적으로 영위하는 것이 곧 성숙한 사람의 모습으로 간주한다. 상호의존적 자기를 추구하는 문화: 중국, 한국 일본과 같이 유교적 특성이 강한 문화권의 사람들같은 집단이나 지역에 속하는 사람들과 원만한 관계를 유지하고자 한다.개인적 욕망을 추구하기보다는 그렇나 욕망의 절제 속에서 자신에게 주어진 사회적 역할과 책임을 다하는 데서 삶의 의미를 찾고자 한다. 귀인귀인이란 행동의 원인을 설명하기 위해서 거치는 과정이다. 귀인의 일반적 특성사람들은 모든 일에 대해서 원인을 찾지 않고 기대에 미치지 못했거나 특이한 일이 일어났을 때 혹은 고통스럽거나 불쾌한 사건이 발생했을 때 원인을 찾게 된다. 귀인의 차원내재적 요인vs외적인 요인: 행위의 원인을 행위자의 내적인 요소에서 찾을 것이냐 외적인 요소에서 찾을 것이냐 안정성 차원: 행위의 원인이 ㅣ시간적 측면에서 안정적인가 불안정한가 통제 가능성 차원: 어던 원인을 개인이 통제할 수 있는가 혹은 없는가 귀인에서의 편향들기본적 귀인 오류: 상황적 혹은 외적인 요인을 과소평가하고 성향적 혹은 내적 요인을 과대평가하는 경향성 행위자-관찰자 편향(조망의 차이): 다른 사람의 행동을 성향적인 요인에 귀인하려는 반면, 자신의 행동은 상황적인 요인에 귀인하는 경향행위자는 자신의 행동을 보지 못하고 상황을 보기 때문에 자신의 행동을 이러한 외적인 요소에 귀인하게 된다. 이기적 편향: 성공은 자기의 공적이고 실패는 다른 사람이나 상황의 탓이라고 보는 경향이렇나 이기적 편향은 집단적인 수준에서 발생하는데 우리는 자신이 속한 집단을 보호하는 식으로 귀인을 한다. 귀인에서의 문화 차이기본적 귀인 오류의 경우 미국인들은 오류를 범하는 경향을 보이는 반면 동아시아 인들은 그렇지 않았다. 왜나하면 맥락과 상황에 좀 더 민감하게 반응하기 때문이다. 태도한 개인이 어떤 대상에게 가지고 있는 체계적인 느낌이나 신념어떤 대상에 대해 판단하는 기준이 되기 때문에 매우 중요햐다.기업의 경우도 고객의 제품에 대한 태도가 매출에 직접적인 영향을 미친다.때문, 사람들의 태도를 컨트롤 할 수 있다면, 이를 바꿀 수 있다. 태도의 3요소인지적요소: 태도 대상에 대한 생각과 신념이다. 내가 대상에 대해 많이 알면 알 수록 그에 대한 평가가 바뀌지 않는다.하지만 정서적인 평가보다는 인지적인 평가가 훨씬 바뀌기 쉽다. 정서적 요소: 태도 대상에 대한 느낌이나 호불호를 포함하는 평가적 반응, 정서적 측면은 인지적 요소가 사라진 후에도 지속적으로 영향을 미침. 행동적 요소: 태도 대상에 대해 가지고 있는 평가와 같은 방향으로 행동하기를 원한다. 태도의 형성유전적 요인, 학습, 인관성 동인, 손익계산 유전적 요인: 특정 대상에 대한 두려움, 사형 제도, 이혼, 사회주의에 대한 태도도 유전적 요인에 기인하는 것이 많다. 학습에의한 태도 형성: 모든 학습의 원리가 태도를 형성하는 데 기여한다.고전적 조건형성을 통해 사람들은 어떤 대상을 특정 인지와 정서와 연합한다.연합, 강화, 모방ex) 연합에 의한 획득 - 광고/모델에 대한 긍정적인 이미지를 다른 상품과 연계시켜 긍정적 이미지를 연상시킴. 모방에 의한 획득: 나와 많은 시간을 함께 하는 시간이 많은 사람들을 보고 배움 매스컴이나 책에의 단순 노출 효과: 하나의 형태가 특정 대상에 반복적으로 노출되어 친숙성이 높아지면 그 대상에 긍정적인 태도를 가지게 된다. Heider의 균형이론: 사람들은 특정 태도 대상에 대해서 자신이 좋아하는 사람과 같은 태도를 갖고 싫어하는 사람과는 다른 태도를 갖고자 하는 경향이 있다. 합리화 이론 - 불균형 상태를 합리화를 통해 정당화한다. 태도의 변화인지부조화이론: 사람들은 자신의 태도와 행동 간의 일관성을 유지하고자 하기 때문에 일치하는 행동을 함으로써 인지적으로 조화로운 상태를 유지하고자 한다. 불충분한 정당화, 노력의 정당화, 위선 유도 전략, 의사결정후의 부조화 자기지각이론: 사람들은 자신의 태도를 확신할 수 없는 상황에서 자신의 행동을 되돌아보고 상황을 고려하여 태도를 추론한다. 합리적 설득 요청: 의사전달자, 메시지(메시지의 형태에따라), 청중요인에 달려있음 행동을 통한 태도 변화: 문간에 발 들여놓기 기법사소한 요구 들어준 사람은 이후 더 큰 요구 들어줄 가능성이 높다.면전에 문 기법처음에 매우 큰 요구를 해서 거절하면 좀 더 작은 요구를 했을 때 들어줄 가능성 높음 대인 관계대인간 매력근접성: 내 가까이 있는 사람들일수록 매력이 더 높아 보인다.신체적 매력: 신체적인 매력을 가지고 있는 경우가 더 좋은 성과를 낸다. 이는 단순히 이성간에만 작동하는 것이 아니라 동성간에도 작동을 한다. 유사성: 나이, 사회 경제적 수준, 학력, 취미 등이 유사할수록 관계를 시작하고 오래 지속할 확률이 높아진다. 보상성: 자신에게 없는 것을 가진 사람에게 느껴지는 매력 상호성: 내가 좋아하는 사람을 만나는 것이 행복한가, 자신을 좋아하는 사람을 만나는 것이 행복한가 사회적 영향다른 사람들의 행위에 의해 유발된 행동의 변화 동조대세를 따른다.다른 사람들의 행동이나 의견을 자발적으로 받아들이는 현상. 소수자 효과소수의 주장이 일관적이고 강력해야 함. 복종/특정 권위를 가진 사람을 만나는 순간 그에 복종하려는 경향이 나타난다. 방관자 효과주변의 사람들이 많을 수록 도움 행동이 감소한다.공동책임 무책임, 내 주변의 많은 사람들이 있기 때문에 그에 대한 책임을 회피하는 현상이다. 집단 역학집단 수행사회적 촉진: 다른 사람이 있을 때 수행 수준이 높은 현상 사회적 태만: 개인이 어느 정도 노력했는지 확인할 수 없는 경우에 사람들은 개인적인 상황에서보다 덜 노력하는 경향이 있다.특정 과업을 수행하기 위해 팀 전체의 노력이 필요한 경우 집단의사결정: 집단 극화집단 전체의 의사결정은 개인적 의사결정의 평균보다 더 극단적으로 일어나는 현상 집단 사고: 응집성 강한 집단에 몰입함으로써 대안적 사고에 대한 충분한 검토 없이 성급하게 만장일치에 도달하려는 사고방식을 일컷는다. 몰개성화: 군중이 개인을 완전히 변형시켜, 그 개인은 자신의 개성을 상실하고 몰개성화되어 완전히 비이성적으로 된다는 것이다.군중이 개인에게 미치는 가장 극적인 영향, 평소와 달리 매우 폭력적인 성향을 보임높은 수준의 흥분과 익명성이 존재할 때 이러한 상태가 발생할 가능성이 높으며,평상시에 억제 상태에 놓여 있는 충동적인 행동들을 풀어놓는다. 심리측정과 평가심리평가의 이해심리 검사짧은 시간안에 타인을 이해하고 비교해 볼 수 있다.심리 평가진단지 이외의 관찰이라던지 면담등을 통해 개인을 이해한다. 심리검사법심리 검사한 개인을 포괄적으로 이해하기는 어렵다.면담법 행동평가법실제 관찰가능한 행동을 통해 그 사람을 추론하는 것자연관찰, 자기관찰, 유사관찰, 참여관찰법 등내가 추론한 내용을 적는 것이 아니라 철저히 객관적인 관찰만을 적고 추후 추론을 한다. 심리검사가 갖춰야 할 사항신뢰도반복측정 했을 때 같은 결과가 나옴 타당도내가 실제 알고 싶은 것을 제대로 측정하고 알 수 있도록 측정하였는가?ex) 내용 타당도, 준개 타당도, 구성 타당도 지능검사","link":"/2018/01/14/심리학-개론/"}],"tags":[{"name":"angular","slug":"angular","link":"/tags/angular/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"business strategy","slug":"business-strategy","link":"/tags/business-strategy/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"fuzzy","slug":"fuzzy","link":"/tags/fuzzy/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"neural network","slug":"neural-network","link":"/tags/neural-network/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"socket.io","slug":"socket-io","link":"/tags/socket-io/"},{"name":"rxjs","slug":"rxjs","link":"/tags/rxjs/"},{"name":"ddd","slug":"ddd","link":"/tags/ddd/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"dep","slug":"dep","link":"/tags/dep/"},{"name":"direnv","slug":"direnv","link":"/tags/direnv/"},{"name":"ejs","slug":"ejs","link":"/tags/ejs/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"bch","slug":"bch","link":"/tags/bch/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"cqrs","slug":"cqrs","link":"/tags/cqrs/"},{"name":"event sourcing","slug":"event-sourcing","link":"/tags/event-sourcing/"},{"name":"blockchain","slug":"blockchain","link":"/tags/blockchain/"},{"name":"tech","slug":"tech","link":"/tags/tech/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"cloudformation","slug":"cloudformation","link":"/tags/cloudformation/"},{"name":"aws-cli","slug":"aws-cli","link":"/tags/aws-cli/"},{"name":"aws cli","slug":"aws-cli","link":"/tags/aws-cli/"},{"name":"dex","slug":"dex","link":"/tags/dex/"},{"name":"ethereum","slug":"ethereum","link":"/tags/ethereum/"},{"name":"graphql","slug":"graphql","link":"/tags/graphql/"},{"name":"machine learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"iost","slug":"iost","link":"/tags/iost/"},{"name":"pyqt","slug":"pyqt","link":"/tags/pyqt/"},{"name":"qt","slug":"qt","link":"/tags/qt/"},{"name":"redux","slug":"redux","link":"/tags/redux/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"grpc","slug":"grpc","link":"/tags/grpc/"},{"name":"hbs","slug":"hbs","link":"/tags/hbs/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"email","slug":"email","link":"/tags/email/"},{"name":"pitch","slug":"pitch","link":"/tags/pitch/"},{"name":"business","slug":"business","link":"/tags/business/"},{"name":"sales","slug":"sales","link":"/tags/sales/"},{"name":"hyperwallet","slug":"hyperwallet","link":"/tags/hyperwallet/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"marketing","slug":"marketing","link":"/tags/marketing/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"nestjs","slug":"nestjs","link":"/tags/nestjs/"},{"name":"swagger","slug":"swagger","link":"/tags/swagger/"},{"name":"rabbitmq","slug":"rabbitmq","link":"/tags/rabbitmq/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"scss","slug":"scss","link":"/tags/scss/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"rest","slug":"rest","link":"/tags/rest/"},{"name":"논어","slug":"논어","link":"/tags/논어/"},{"name":"oop","slug":"oop","link":"/tags/oop/"},{"name":"books","slug":"books","link":"/tags/books/"},{"name":"essay","slug":"essay","link":"/tags/essay/"},{"name":"raspberry","slug":"raspberry","link":"/tags/raspberry/"},{"name":"trend","slug":"trend","link":"/tags/trend/"},{"name":"movie","slug":"movie","link":"/tags/movie/"},{"name":"os","slug":"os","link":"/tags/os/"},{"name":"db","slug":"db","link":"/tags/db/"},{"name":"data structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"stock market","slug":"stock-market","link":"/tags/stock-market/"},{"name":"computer architecture","slug":"computer-architecture","link":"/tags/computer-architecture/"},{"name":"philosophy","slug":"philosophy","link":"/tags/philosophy/"},{"name":"computer structure","slug":"computer-structure","link":"/tags/computer-structure/"},{"name":"liberal art","slug":"liberal-art","link":"/tags/liberal-art/"},{"name":"book","slug":"book","link":"/tags/book/"},{"name":"stripe","slug":"stripe","link":"/tags/stripe/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"elastic stack","slug":"elastic-stack","link":"/tags/elastic-stack/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"kubernetes","slug":"kubernetes","link":"/tags/kubernetes/"},{"name":"nuxt","slug":"nuxt","link":"/tags/nuxt/"},{"name":"supertest","slug":"supertest","link":"/tags/supertest/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"design pattern","slug":"design-pattern","link":"/tags/design-pattern/"},{"name":"DDD","slug":"ddd","link":"/tags/ddd/"},{"name":"ecomonics","slug":"ecomonics","link":"/tags/ecomonics/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"history","slug":"history","link":"/tags/history/"},{"name":"computer network","slug":"computer-network","link":"/tags/computer-network/"},{"name":"psycology","slug":"psycology","link":"/tags/psycology/"}],"categories":[{"name":"angular 강의","slug":"angular-강의","link":"/categories/angular-강의/"},{"name":"nodejs 강의","slug":"nodejs-강의","link":"/categories/nodejs-강의/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"nodejs","slug":"nodejs","link":"/categories/nodejs/"},{"name":"C 언어 강의","slug":"c-언어-강의","link":"/categories/c-언어-강의/"},{"name":"c","slug":"c","link":"/categories/c/"},{"name":"direnv","slug":"direnv","link":"/categories/direnv/"},{"name":"ejs","slug":"ejs","link":"/categories/ejs/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"bch","slug":"bch","link":"/categories/bch/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"express","slug":"ejs/express","link":"/categories/ejs/express/"},{"name":"aws","slug":"aws","link":"/categories/aws/"},{"name":"aws-cli","slug":"aws-cli","link":"/categories/aws-cli/"},{"name":"aws cli","slug":"aws-cli","link":"/categories/aws-cli/"},{"name":"dex","slug":"dex","link":"/categories/dex/"},{"name":"ethereum","slug":"ethereum","link":"/categories/ethereum/"},{"name":"lambda","slug":"aws/lambda","link":"/categories/aws/lambda/"},{"name":"graphql","slug":"graphql","link":"/categories/graphql/"},{"name":"machine learning","slug":"machine-learning","link":"/categories/machine-learning/"},{"name":"cloudformation","slug":"aws/cloudformation","link":"/categories/aws/cloudformation/"},{"name":"mac","slug":"mac","link":"/categories/mac/"},{"name":"iost","slug":"iost","link":"/categories/iost/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"redux","slug":"redux","link":"/categories/redux/"},{"name":"blockchain","slug":"dex/blockchain","link":"/categories/dex/blockchain/"},{"name":"ubuntu","slug":"ubuntu","link":"/categories/ubuntu/"},{"name":"blockchain","slug":"ethereum/blockchain","link":"/categories/ethereum/blockchain/"},{"name":"go","slug":"go","link":"/categories/go/"},{"name":"hbs","slug":"hbs","link":"/categories/hbs/"},{"name":"git 강의","slug":"git-강의","link":"/categories/git-강의/"},{"name":"email","slug":"email","link":"/categories/email/"},{"name":"hyperwallet","slug":"hyperwallet","link":"/categories/hyperwallet/"},{"name":"java 강의","slug":"java-강의","link":"/categories/java-강의/"},{"name":"blockchain","slug":"blockchain","link":"/categories/blockchain/"},{"name":"pyqt","slug":"python/pyqt","link":"/categories/python/pyqt/"},{"name":"marketing","slug":"marketing","link":"/categories/marketing/"},{"name":"mongodb 강의","slug":"mongodb-강의","link":"/categories/mongodb-강의/"},{"name":"mysql 강의","slug":"mysql-강의","link":"/categories/mysql-강의/"},{"name":"Mysql 강의","slug":"mysql-강의","link":"/categories/mysql-강의/"},{"name":"pitch","slug":"email/pitch","link":"/categories/email/pitch/"},{"name":"nestjs","slug":"nestjs","link":"/categories/nestjs/"},{"name":"rabbitmq","slug":"rabbitmq","link":"/categories/rabbitmq/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"nodejs","slug":"ubuntu/nodejs","link":"/categories/ubuntu/nodejs/"},{"name":"vscode","slug":"vscode","link":"/categories/vscode/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"rest","slug":"rest","link":"/categories/rest/"},{"name":"top","slug":"top","link":"/categories/top/"},{"name":"sales","slug":"email/pitch/sales","link":"/categories/email/pitch/sales/"},{"name":"운영체제 강의","slug":"운영체제-강의","link":"/categories/운영체제-강의/"},{"name":"자료구조 강의","slug":"자료구조-강의","link":"/categories/자료구조-강의/"},{"name":"stock market","slug":"stock-market","link":"/categories/stock-market/"},{"name":"essay","slug":"essay","link":"/categories/essay/"},{"name":"컴퓨터 구조 강의","slug":"컴퓨터-구조-강의","link":"/categories/컴퓨터-구조-강의/"},{"name":"business","slug":"email/pitch/sales/business","link":"/categories/email/pitch/sales/business/"},{"name":"stripe","slug":"stripe","link":"/categories/stripe/"},{"name":"학습법","slug":"학습법","link":"/categories/학습법/"},{"name":"elastic stack","slug":"elastic-stack","link":"/categories/elastic-stack/"},{"name":"nginx","slug":"nginx","link":"/categories/nginx/"},{"name":"kubernetes","slug":"kubernetes","link":"/categories/kubernetes/"},{"name":"next","slug":"next","link":"/categories/next/"},{"name":"supertest","slug":"supertest","link":"/categories/supertest/"},{"name":"economics","slug":"economics","link":"/categories/economics/"},{"name":"typescript","slug":"supertest/typescript","link":"/categories/supertest/typescript/"},{"name":"마케팅 강의록","slug":"마케팅-강의록","link":"/categories/마케팅-강의록/"}]}