<!DOCTYPE html>
<html class="has-navbar-fixed-top">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Jake.Lee&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="google-site-verification" content="PgpnJMuvO-IqYWyFljnyr-tusLhJUz1VRMmECenJyHE">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">






<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="/css/style.css">
<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>

</head>

<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">Categories</a>
            
            <a class="navbar-item " href="/tags">Tags</a>
            
            <a class="navbar-item " href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" href="https://github.com/frontalnh">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

        <section class="section">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6354931397950820",
    enable_page_level_ads: true
  });
</script>

    <div class="container">
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/02/운영체제-운영체제란-무엇인가/" itemprop="url">
                운영체제 | 운영체제란 무엇인가?
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-02T13:17:12.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/운영체제-강의/">운영체제 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                29 minutes read (About 4359 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#운영체제가-하는-일은-무엇인가">운영체제가 하는 일은 무엇인가?</a></li>
<li><a href="#컴퓨터-시스템은-어떻게-구성되어-있는가">컴퓨터 시스템은 어떻게 구성되어 있는가?</a><ul>
<li><a href="#컴퓨터-시스템의-동작">컴퓨터 시스템의 동작</a></li>
<li><a href="#저장-장치의-구조">저장 장치의 구조</a></li>
<li><a href="#입출력-구조">입출력 구조</a></li>
</ul>
</li>
<li><a href="#단일-처리기-시스템에서-다중-처리기-시스템으로">단일 처리기 시스템에서 다중 처리기 시스템으로</a><ul>
<li><a href="#단일-처리기-시스템">단일 처리기 시스템</a></li>
</ul>
</li>
<li><a href="#운영체제의-구조">운영체제의 구조</a></li>
<li><a href="#운영체제는-어떤-방식으로-작업을-처리하는가">운영체제는 어떤 방식으로 작업을 처리하는가?</a></li>
<li><a href="#프로세스-관리">프로세스 관리</a></li>
<li><a href="#메모리-관리">메모리 관리</a></li>
<li><a href="#저장-장치-관리">저장 장치 관리</a></li>
<li><a href="#보호와-보안">보호와 보안</a></li>
<li><a href="#분산-시스템">분산 시스템</a></li>
</ul>
<!-- tocstop -->
<h1><span id="운영체제가-하는-일은-무엇인가">운영체제가 하는 일은 무엇인가?</span></h1><p>운영체제란 컴퓨터 하드웨어를 관리하는 프로그램입니다.<br>운영체제는 사용자의 관점에서 혹은 시스템 적인 관점에서 보는가에 따라 그 존재 목적이 달리 설명될 수 있습니다.</p>
<p>사용자의 관점에서의 운영체제는 바로 한낱 고철덩어리에 불과한 컴퓨터를 사람이 사용하기 쉽게 여러가지 일들을 수행해 주는 역할을 한다고 볼 수 있다.<br>이 경우 운영체제는 주로 사용의 편리와 자원의 이용 간에 적절히 조화를 이루도록 설계된다.</p>
<p>시스템의 관점에서 운영체제는 하드웨어와 가장 밀접한 프로그램이라고 볼 수 있다. 컴퓨터 시스템은 특정 문제를 해결하기 위해 필요한 여러가지 자원들을 사용하는데(가령 CPU 시간, 메모리 공간, 파일 저장 공간, 입출력 장치 등) 운영체제는 <strong>이러한 자원의 관리자로써 동작</strong> 하여 <strong>자원 할당자</strong> 역할을 수행한다.</p>
<p>결과적으로, 운영체제를 명확히 정의하는 것은 매우 어렵지만 컴퓨터라는 순수 하드웨어를 보다 쉽게 사용하기 위한 다양한 응용 프로그램들을 원활하게 동작시키기 위해 입출력 장치의 통제와 같은 공통적인 연산과 CPU, 메모리 공간 등의 컴퓨터 자원을 제어하고 할당하는 기능을 하는 하나의 소프트웨어라고 정의할 수 있을 것 같다. 또한, 운영체제는 컴퓨터에서 항상 실행되는 프로그램(일반적으로 <strong>커널</strong>)으로 운영체제를 제외한 다른 모든 프로그램은 응용 프로그램으로 부른다.</p>
<h1><span id="컴퓨터-시스템은-어떻게-구성되어-있는가">컴퓨터 시스템은 어떻게 구성되어 있는가?</span></h1><p>컴퓨터 시스템의 동작을 배우기 전에 컴퓨터 시스템의 구조에 대해 간략하게 알아봅시다.</p>
<h2><span id="컴퓨터-시스템의-동작">컴퓨터 시스템의 동작</span></h2><p>현대의 컴퓨터 시스템은 공유 메모리에 대한 접근을 제공하는 공통 버스를 통해 연결된 <strong>여러 개의 장치 제어기</strong> 와 <strong>하나 이상의 CPU</strong> 로 구성되어 있다. 각 <strong>장치 제어기는 특정 장치(가령 디스크 드라이브, 오디오 장치, 비디오 디스플레이 등)를 관리</strong> 하며, CPU와 장치 제어기는 메모리 사이클을 얻기 위해 경쟁하면서 병행 실행될 수 있다.</p>
<p>컴퓨터를 구동시킬 때는 가장 먼저 흔히 <strong>펌웨어</strong> 로 알려져 있는 컴퓨터 내의 읽기 전용 메모리(ROM)에 저장된 <strong>부트스트랩 프로그램</strong> 을 실행한다.<br>부트스트랩 프로그램은 CPU 레지스터로 부터 장치 제어기, 메모리 내용 등을 포함한 시스템의 모든 면을 초기화 하고 운영체제의 커널을 찾아 메모리에 적재한다.<br>적재가 완료되면 운영체제는 init과 같은 초기 프로세스를 동작하고 사건이 발생하기를 기다린다.</p>
<p>기본적으로 운영체제는 이렇게 사건을 기반으로 동작하게 되는데, 이러한 사건의 발생 사실을 <strong>인터럽트</strong> 에 의해 통보받을 수 있다.<br>하드웨어는 언제든지 <strong>시스템 버스</strong> 를 통해 인터럽트를 발생시킬 수 있고, 소프트웨어는 <strong>시스템 호출</strong> 을 통해 인터럽트를 발생시킬 수 있다.</p>
<p>인터럽트가 발생되면 적절한 서비스 루틴으로 전달하고 이 루틴은 이어 인터럽트 고유의 핸들러를 호출한다.</p>
<h2><span id="저장-장치의-구조">저장 장치의 구조</span></h2><p>컴퓨터가 프로그램을 실행하기 위해서는 프로그램이 반드시 <strong>주 메모리(RAM)</strong> 에 있어야 한다.<br>컴퓨터가 명령어를 실행한다는 것은 이 메모리로 부터 레지스터로 워드를 옮기는 적재(load) 과정을 통해 이루어 지며, 적재된 명령어는 명령 레지스터에 저장되고 명령이 해독되어 메모리에서 피연산자를 인출하여 내부 레지스터에 저장되도록 유발할 수 있다. 여기서 메모리 장치는 단지 연속적인 메모리 주소만을 인식하며 메모리는 주소값의 구체적인 생김새 등에는 관계없이 단지 주소값을 저장만 하고 있다.</p>
<p>이상적으로는 프로그램과 데이터가 주 메모리 안에 영구히 존재한다면 좋지만, 메모리는 용량이 너무 작고 전원이 공급되지 않으면 내용을 잃어버리는 휘발성 저장장치이기 때문에 반드시 보조 저장장치에 프로그램과 데이터를 보관해야 한다. 이러한 보조 저장장치로는 주로 <strong>자기 디스크</strong> 등이 쓰인다.</p>
<p>이러한 저장 장치의 구조는 하나의 계층으로 구성되며 저장 장치 구조의 최상단인 레지스터 부터 캐시, 주 메모리 순으로 내려 가면서 가격은 저렴해 지고 속도는 느려지는 피라미드형 구조를 보인다.</p>
<h2><span id="입출력-구조">입출력 구조</span></h2><p>컴퓨터에 입력을 하고 또 출력 값을 받아오기 위해 다양한 입출력 장치들이 연결될 수 있으며, 범용 컴퓨터 시스템은 공통 버스에 의해 연결된 여러 개의 장치 제어기와 CPU 들로 구성된다.<br>장치 제어기는 자신이 제어하는 주변장치와 자신의 로컬 버퍼 저장장치 사이의 데이터 전송을 담당하며, 통상적으로 운영체제는 장치 제어기 마다 <strong>장치 드라이버</strong> 를 가지고 있는데, 이 장치 드라이버는 장치 제어기의 동작을 이해하고 운영체제의 다른 부분에게 장치에 대한 일관된 인터페이스를 제공한다.</p>
<p>장치-&gt;장치 제어기-&gt;장치 드라이버-&gt;운영 체제<br>로 이어지는 입출력의 흐름은 <strong>인터럽트</strong> 를 기반으로 이루어진다. 먼저, 장치 제어기는 취할 동작을 결정하고 장치에 연산이 완료되었으면 인터럽트를 이용하여 장치 드라이버에 통보한다. 그러면 장치 드라이버는 제어를 운영체제에게 반환하는 방식이다. 하지만 이러한 인터럽트 구동방식은 대량의 데이터를 전송하는 데에는 높은 오버헤드를 초래하였으며, 이를 해결하기 위해 <strong>직접 메모리 접근(DMA)</strong> 장치가 사용된다. 이를 통해 장치 제어기는 CPU의 개입 없이 메모리로 부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송한다. 즉, 장치 제어기가 전송 작업을 실행하고 있는 동안 CPU는 다른 작업을 실행할 수 있다.</p>
<h1><span id="단일-처리기-시스템에서-다중-처리기-시스템으로">단일 처리기 시스템에서 다중 처리기 시스템으로</span></h1><p>컴퓨터 시스템은 사용된 범용 처리기(CPU)의 개수에 따라 <strong>단일 처리기 시스템</strong> 과 <strong>다중 처리기 시스템</strong> 으로 나누어 집니다.<br>하나의 CPU를 가지는 경우를 단일 처리기 시스템, 1개 이상의 CPU를 가지는 컴퓨터 시스템의 경우를 다중 처리기 시스템이라고 합니다.</p>
<p>하나의 CPU를 가질 때 보다 여러개의 CPU를 가지면 무엇이 좋을까요?</p>
<p>먼저, 시스템의 <strong>처리량이 증가</strong> 합니다.<br>여러 개의 CPU를 가지게 되면 컴퓨터가 여러개의 일들을 동시에 처리할 수 있기 때문에 같은 시간동안 많은 양을 처리하게 되어 시스템의 처리량이 증가합니다.</p>
<p><strong>비용이 절감됩니다.</strong><br>컴퓨터 하나에는 많은 주변 장치, 저장 장치, 전원 장치 등이 필요합니다.<br>5대의 하나의 CPU를 사용하는 컴퓨터를 제작하는 것 보다 5개의 CPU를 가진 컴퓨터 한대를 제작하는 것이 많은 디바이스와 리소스를 공유해서 이용하기 때문에 <strong>규모의 경제</strong> 가 나타나고 저렴한 비용으로 시스템을 만들 수 있습니다.</p>
<p><strong>믿을 수 있습니다. 즉, 신뢰도가 올라갑니다.</strong><br>CPU 하나가 고장나더라고 시스템이 정지하지 않고 살아남은 하드웨어 수준에 비례하여 지속적으로 서비스가 동작하는 것은 <strong>우아한 퇴보</strong> 라고 합니다.<br>어떤 시스템은 하나의 구성요소의 고장에도 불구하고 시스템을 동작할 수 있기에  <strong>결함 허용</strong> 적이라고 불리며, 다중 처리기 시스템은 하나의 CPU가 고장나도 안정적으로 시스템이 동작하므로 단일 처리기 시스템에 비해 신뢰도가 높은 시스템을 구축할 수 있습니다.</p>
<p>이러한 다중 처리 시스템의 경우 각 처리기에 일이 할당되는 방식에 따라 <strong>비대칭적 다중 처리</strong> 와 <strong>대칭적 다중 처리</strong> 로 구분되는데, 비대칭적 다중 처리의 경우 하나의 주 처리기가 시스템을 제어하고 다른 처리기들이 복종하는 시스템이며, 대칭적 다중 처리의 경우 모든 처리기가 동등한 업무를 수행하는 방식이며 현대에는 대부분 대칭적 다중 처리가 이용된다.</p>
<h2><span id="단일-처리기-시스템">단일 처리기 시스템</span></h2><p>하나의 주 CPU를 사용하는 시스템으로</p>
<h1><span id="운영체제의-구조">운영체제의 구조</span></h1><p>컴퓨터 시스템의 구성과 구조를 알아 보았으므로 이제는 본격적으로 운영체제에 대해 알아 보겠습니다.<br>운영체제의 가장 중요한 측면은 다중 프로그램(multi program)을 할 수 있는 능력입니다. 만약, 한명의 사용자가 컴퓨터를 사용한다면 아무리 노력해도 컴퓨터를 효과적으로 사용하여 모든 처리기를 바쁘게 유지시킬 수 없을 겁니다. CPU가 잠시라도 쉬면 서둘러 다른 업무를 시켜서 쉬지않고 일을 하도록 하는 <strong>다중 프로그래밍</strong> 은 CPU가 항상 하나의 작업을 수행하도록 조정함으로써 CPU의 이용률을 높여줍니다.</p>
<p>이러한 다중 프로그래밍의 기본적인 동작 원리는 다음과 같습니다.<br>먼저 <strong>한 번에 여러 작업을 메모리에 적재하고, 운영체제는 메모리에 있는 작업 중 하나를 선택해서 실행합니다.</strong> 만약 이 작업이 어떤 일을 기다려야 한다면 CPU는 다른 작업으로 전환하여 다른 작업을 진행합니다. 이러한 다중 프로그래밍 시스템은 시스템 자원을 효율적으로 이용할 환경을 제공하지만 사용자와 컴퓨터 시스템이 상호작용을 할 수는 없는데, 이를 확장한 <strong>시분할(multi tasking)</strong> 을 통해 이를 해결할 수 있습니다. 시분할 시스템에서는 CPU가 다수의 작업을 서로 교대로 실행하지만 매우 빈번하게 교대를 일으킴으로써 프로그램이 동작하는 동안 사용자와 상호작용이 가능해 지기에, 시분할 프로그램은 <strong>대화식 혹은 hands on(실제 조작 가능한)</strong> 컴퓨터 시스템을 필요로 하며, 각 사용자에게 시분할 되는 컴퓨터의 작은 부분을 제공하기 위해 CPU 스케줄링과 다중 프로그래밍을 사용합니다.</p>
<p>시분할과 다중 프로그래밍 운영체제에서는 메모리에 여러 작업이 동시에 유지되어야 하는데, 일반적으로 주 기억장치(RAM)은 사이즈가 너무 작기 때문에 메모리에 들어가지 못한 작업들을 디스크의 <strong>작업 풀</strong> 에 보관된다. 이런 작업 풀에서 어떤 프로그램을 메모리에 적재할 지 선택하는 것을 <strong>CPU 스케줄링</strong> 이라고 한다.</p>
<p>또 다른 방법 중 하나는 <strong>가상 메모리</strong> 를 이용하는 것이다. 이것은 프로그램의 일부만이 메모리에 존재해도 작업을 실행을 허용하는 개념이기에, 프로그램 전체가 주 메모리에 적재되지 않아도 프로그램이 시작되고, 또 주 메모리의 전체 사이즈보다 큰 규모의 프로그램도 실행 할 수 있게 해 주는 중요한 개념이다. 이런 <strong>가상 메모리</strong> 는 주 메모리를 크고 균등한 저장장치의 배열로 추상화하여 사용자에게 보이는 <strong>논리 메모리</strong> 를 실제 물리 메모리로부터 분리시켜 주며, 이를 통해 프로그래머를 메모리 저장장치의 한계로부터 자유롭게 해 준다.</p>
<h1><span id="운영체제는-어떤-방식으로-작업을-처리하는가">운영체제는 어떤 방식으로 작업을 처리하는가?</span></h1><p>현대의 운영체제는 <strong>인터럽트 구동식</strong> 으로 무언가 일이 일어나야만 동작을 한다. 사건은 트랩 혹은 인터럽트에 의해 발생하며 여기서 <strong>트랩</strong> 이란 오류 혹으 사용자 프로그램의 운영체제 서비스 실행 요청에 의해 유발되는 소프트웨어의 실행에 의해 생성된 인터럽트이다. 때문에 운영체제는 수많은 인터럽트들을 계속해서 처리해야 하며, 이중 하나만 잘못되어도 시스템이 정지한다면 그 시스템은 매우 불완전하다고 볼 수 있다.<br>올바르게 설계된 운영체제는 잘못된 또는 악의적인 프로그램이 부정확하게 실행되지 않도록 보장해야 한다.</p>
<p>이렇게 안정성 있는 운영체제를 위해 운영체제 내에는 다양한 안정 장치들이 있는데 그중 하나가 <strong>이중 동작 모드</strong> 이다.<br>이중 동작 모드란 운영체제의 적절한 동작을 보장하기 위해서 운영체제 코드와 사용자가 작성한 코드의 실행을 구분하는 것이다. 이렇게 구분된 각각의 명령은 독립된 동작모드인 <strong>사용자 모드</strong> 와 <strong>커널 모드 혹은 특권 모드</strong> 로 나뉘어 실행되게 된다. 만약 <strong>트랩</strong> 이나 <strong>인터럽트</strong> 가 발생할 때마다 하드웨어는 사용자 모드에서 커널 모드로 전환한다.</p>
<p>또다른 안전장치는 <strong>타이머</strong> 인데, 이는 사용자의 프로그램이 무한루프에 빠져 동작하지 않게 되어 운영체제로 통제권이 돌아오지 않는 경우를 막기 위해 특정 시간이 지나면 제어가 자동으로 운영체제로 넘어가게 하는 기능이다.<br>타이머가 인터럽트를 발생시키면 제어는 자동적으로 운영체제로 넘어가게 된다.</p>
<h1><span id="프로세스-관리">프로세스 관리</span></h1><p>실행중인 프로그램을 <strong>프로세스</strong> 라 하며, 프로세스가 끝나면 운영체제는 재사용 할 수 있는 자원을 회수하게 된다.<br>여기서 프로그램 자체는 <strong>프로세스</strong> 가 아니다. 하나의 프로그램은 디스크에 저장된 파일의 내용과 같이 수동적인 개체인 반면, 프로세스는 다음 실행할 명령을 지정하는 <strong>프로그램 카운터</strong> 를 가진 능동적인 개체이다.<br>운영체제는 프로세스 관리와 관련하여 다음과 같은 활동을 수행한다.</p>
<ol>
<li>사용자 프로세스와 시스템 프로세스의 생성과 제거</li>
<li>프로세스의 일시 중지와 재싱행</li>
<li>프로세스 동기화를 위한 기법 제공</li>
<li>프로세스 통신을 위한 기법 제공</li>
</ol>
<h1><span id="메모리-관리">메모리 관리</span></h1><p>메모리는 컴퓨터 시스템에서 매우 중요한 부분이며, 운영체제는 이러한 메모리를 관리하며 다음과 같은 일을 담당한다.</p>
<ol>
<li>현재 메모리의 어느 부분이 사용되고 있으며, 누구에 의해 사용되고 있는지를 추적</li>
<li>어떤 프로세스들을 메모리에 적재할 것이며 제거할 것인가?</li>
<li>메모리 공간을 할당하고 회수</li>
</ol>
<h1><span id="저장-장치-관리">저장 장치 관리</span></h1><h1><span id="보호와-보안">보호와 보안</span></h1><h1><span id="분산-시스템">분산 시스템</span></h1><hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/29/진정한-아름다움이란-무엇인가/" itemprop="url">
                아름다움이란 단어가 빛바랜 오늘, 진정한 아름다움이란 무엇인가?
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-29T14:28:08.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/essay/">essay</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                13 minutes read (About 1915 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="진정한-아름다움이란-무엇인가">진정한 아름다움이란 무엇인가?</span></h1><p>요즘 시대에 ‘아름다움’이란 너무도 상업적인 목적 또 하나의 유희이자 쾌락으로써 소비되고 있습니다.<br>하지만, 예로부터 ‘아름다움’ 이란 많은 철학자들이 하나의 ‘이상’ 으로 추구해 왔던 개념이었고 인간이 추구해야 할 숭고한 가치로 고려되어 왔습니다.<br>오늘 글에서는 ‘아름다움’이란 의미가 점차 가벼워 지고 퇴색되어 가는 요즘 시대에 진정한 ‘아름다움’ 이란 무엇이며 올바른 아름다움의 추구란 무엇인가에 대해 생각해 보도록 하겠습니다.</p>
<p><strong>‘아름다움’이란 무엇일까요?</strong><br>고대의 피타고라스 학파는 아름다움이란 비례와 조화, 균형이며, 수적으로 표현이 가능한 대상으로 보았습니다. 완벽한 굴곡을 자랑하는 도자기 혹은 이상적인 신체 비율의 가진 사람의 신체처럼 사물 혹은 사람이 가지는 그 고유의 비례와 조화의 미 그 자체를 ‘아름다움’이라 이야기 했습니다. 요즘 말하는 ‘8등신 황금비율’과 같은 말들도 어느정도는 고대 시대의 아름다움의 척도에 부합한다고 볼 수 있습니다. 이처럼 옛날 사람들은 오늘날 우리가 생각하는 것 보다는 훨씬 객관적인 하나의 성질로써 ‘아름다움’을 보았습니다. 중세에 들어서도 사물 혹은 사람의 성질 로서의 ‘아름다움’의 개념은 연장되어 왔습니다. 참된 아름다움 이란 감각기관이나 상상에 의한 것이 아니라 이성에 의해 파악되는 정신적인 것으로 규정하고, ‘아름다움’ 이란 철저히 객관적인 성질로써 이해되었습니다.</p>
<p><strong>하지만,</strong> 근대에 들어서면서 이러한 ‘객관적인 성질’로서의 아름다움에 대한 인식에 큰 변화가 생기게 됩니다. ‘아름다움’ 이란 대상의 성질일 수 있지만, 이것은 대상을 인식하는 우리의 주관이 느끼는 것이라는 생각이 널리 퍼지게 되었습니다. 고대의 미가 단순히 균형, 조화를 추구했다면, 근대의 아름다움 에서는 이를 특정짓는 것이 없이 오로지 우리가 주관적으로 느끼는 것 이라는 것이지요. 가령 아무리 완벽한 자태를 뽐내는 도자기가 있더라도 우리가 이 도자기를 보고 감동을 느끼고 아름답다고 느끼지 않는다면 그 도자기는 더 이상 우리에게 아름다운 것이 아닙니다. 수천년이 지나 칠이 벗겨지고 부수어진 도자기가 우리에게 옛 선조들의 아름다움을 알 수 있게 해주고 우리 마음 속에 아름답다는 감정을 불러 일으킨다면 그 도자기는 그 외관에 상관없이 우리에게 아름다울 수 있는 것이지요.</p>
<p>철학자 칸트는 이러한 근대의 아름다움에 대한 개념을 다음과 같이 얘기합니다.</p>
<blockquote>
<p>“미란 결코 객관적인 것이 아니며, 인식적 의미를 지니지 않는다. 우리의 마음 속에 미적 즐거움을 일으키는 대상들의 형식은 객관적이나, 그것은 개념적으로 파악될 수 없다. 그것이 객관적 성질을 지니는 것이 아니라 우리의 마음 속에 미적 즐거움을 환기시킬 수 있도록 구성된 것을 뿐이다. 하지만 미를 일으키는 과정에서 일련의 공통점을 가진다.”</p>
</blockquote>
<p>이러한 근대의 아름다움의 개념의 현재 우리 삶의 많은 부분에 녹아 있습니다. 오랜 기간 훈련을 통해 짓 무르고 갈라진 ‘김연아’ 선수의 발을 보면서 많은 사람들이 아름다움을 느끼는 것도 이러한 주관적 의미에서의 아름다움이라고 볼 수 있습니다.</p>
<h1><span id="아름다움이란-가질-수-있는-것일까">아름다움이란 가질 수 있는 것일까?</span></h1><p><strong>현대의 많은 사람들은 ‘아름다움’을 가지기 위해 많은 활동을 합니다.</strong> 외적인 아름다움을 가꾸기 위해 성형수술을 하기도 하고 헬스장을 다니고 운동을 하며 다이어트를 하기도 하면서 ‘아름다움’을 소유하기 위해 많은 노력을 기울입니다.</p>
<p>하지만, 이런 많은 활동이 궁극적으로 우리 모두에게 ‘아름다움’을 가지게 해 줄까요?<br>근대 이후의 많은 철학자들이 말하는 결론은 ‘아니오’입니다.</p>
<p><strong>왜 우리는 아무리 노력해도 아름다움을 소유할 수 없을까요?</strong><br>위에서 말했듯이 ‘아름다움’이란 객관적인 성질이 아닌 우리 마음 속에 미적 즐거움을 환기시킬 수 있어야 합니다. 즉, 진정한 아름다움이란 모든 사람들이 많은 다양한 의미로 나에게 아름다운 감정을 느껴야 이루어 지는 것이지요. 그것이 외적인 아름다움이던 혹은 내적인 아름다움일 수 있고, 몇몇 사람들이 나의 외적 혹은 내적 아름다움에 공감할 수 있을 지 모르지만 궁극적인 ‘아름다움’을 소유하는 것에는 한계가 있을 수 밖에 없습니다.</p>
<h1><span id="아름다움은-소유하는-것이-아니라-추구하는-것">아름다움은 소유하는 것이 아니라 추구하는 것</span></h1><blockquote>
<p>그렇다면 우리는 아름다워 질 수 없는 것일까요? 아름다움을 소유하지 못한다면 우리에게 무슨 낙이 있을까요?</p>
</blockquote>
<p>위의 질문에 현대의 많은 철학자들은 이렇게 말합니다.<br><strong>“아름다움을 얻을 수 있는 최고의 지름길은 미를 소유하는 것이 아닌 추구하는 것에 목적을 두는 것이다.”</strong></p>
<p>아름 다움 자체를 소유하기 위해 노력한다면 돌아오는 것은 실패 뿐을 것입니다. 모든 형태의 아름다움 모든 사람들이 공감할 수 있는 궁극적 아름다움을 가지는 것은 사실상 불가능 하기 때문이지요. 이런 노력은 모두 실패로 귀결될 수 밖에 없습니다.</p>
<p><strong>아름다움이 주는 즐거움을 누릴 수 있는 최고의 방법은 ‘아름다움을 추구’하는 것입니다.</strong><br>오늘 보다 나은 나를 만들기 위해 노력하고, 누군가를 가슴속 깊이 사랑하고, 나의 주권 또 내 주변 사람들의 자유와 주권에 대한 관심, 즉 나와 이 세계를 아름답게 하고자 하는 노력과 그런 아름다움에 대한 추구를 통해 아름다움이 주는 진정한 즐거움을 알 수 있을 것이라 믿습니다.</p>
<p>이 글을 읽는 독자님도 오늘 하루 ‘아름다움’을 가지지 못한 나를 채찍질 하기 보다 하루 하루 나와 내 주변 사람들의 아름다움을 추구하는 멋진 인생을 살아가 아름다움이 주는 진정한 즐거움을 향유할 수 있기를 기원합니다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/28/blockchain-trend/" itemprop="url">
                Blockchain trend
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-28T05:07:29.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/blockchain/">blockchain</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                15 minutes read (About 2288 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p><strong>Blockchain technology for enterprise service</strong></p>
<p>건강 보험 등 이력에 대한 불변의 상태기록을 원하는 비즈니스에서는 상당히 유용하게 사용될 수 있다.</p>
<p>인센티브의 경우 네트워크 망을 유지하고 서비스에서 인센티브를 제공하는 기능을 어떻게 활용 가능한가?</p>
<p><strong>Case1 분산 원장으로써의 블록체인</strong></p>
<p>롯데카드 -&gt; 블록체인 기반 생체 인증</p>
<p>삼성페이에서 로그인 정보를 다른 쪽에도 유지하기 위해 사용 =&gt;</p>
<p><strong>Case2 스마트 컨트랙트로써의 블록체인</strong></p>
<p>현대카드 포인트 페이먼트를 스마트 컨트랙트로 구성</p>
<p>제일 큰 문제는 성능문제. =&gt; 추가로 컨센서스를 만드는 작업 등</p>
<p>신한금융 =&gt; 인증서 발급 로직을 스마트 컨트랙트로 구성</p>
<p>금융보안원, 금융 결제원 =&gt; 폰뱅킹 및 은행 송금 시스템</p>
<p>은행 송금 시스템을 블록체인화, 기존에는 중앙 시스템이 모든 은행의 거래 내역을 다 처리하고 매일 한번씩 정산하여 데이터베이스를 맞추는 식으로 햇었음</p>
<p>이 경우 스마트 컨트랙을 통해 했는데 역시 성능문제가 생겼음</p>
<p>여기서 가장 중요한 점은 고객 데이터는 데이터베이스에 올라갈 수 없음</p>
<p>때문에 블록체인과 외부 디비가 어떤 식으로 연동하는 것이 매우 중요한 포인트임</p>
<p><strong>고객의 주요 쟁점</strong></p>
<ol>
<li>퍼포먼스 컨트랙트 내부 병렬화에 대한 요구가 나온다. 보통 컨트랙트 내에서 락을 걸어서 처리를 하는데 이 경우 처리가 빠르게 일어나지 못함</li>
<li>privacy개인정보를 올리려면 어떻게? =&gt; 난스 만들어라</li>
<li>Multi chain</li>
<li>익명 기술</li>
<li>파이널리티 가령 블록이 생성되어 트랜잭션이 만들어 지더라도 블럭이 폐기되면 다시 뒤로 돌아가기 때문에 고객의 지갑이 변동되는 문제가 생기며 이는 매우 큰 이슈이다,</li>
</ol>
<p><strong>블록체인 비즈니스 활용 Tip</strong></p>
<p>사이드 체인을 유지하고 퍼블릭 네트워크와 연동하는 형태로 많이 서비스를 하게 된다.</p>
<p>이렇게 하면 기존 서비스의 품질을 해치지 않으면서도 블록체인을 적용할 수 있다.</p>
<p>가령 포인트를 적립시킨다고 하면 별도 사이드 체인을 만들어서 포인트를 등록하고 해당 체인을 다른 퍼블릭체인과 연동하여 포인트를 유통시킬 수 있다.</p>
<p>즉 이더 송금 수수료를 한번만 이용하지만 여러 거래를 별도 사이드체인에서 동작시키고 퍼블릭체인과 연동함으로써 해결이 가능하다.</p>
<p>Ex) aergo =&gt; 블록체인 sass 서비스</p>
<p><strong>업그레이드 가능한 스마트 컨트랙트</strong></p>
<p>투명성, 위변조 불가성</p>
<p>왜 업그레이드 가능한 스마트 컨트랙트가 필요한가?</p>
<ol>
<li>배포 후 취약점이 발견되면 수정이 가능하다.</li>
<li>비즈니스 로직이 수정 불가하기 때문에 겪게 되는 불편함이 있다.</li>
</ol>
<p>Delegate call 특정 컨트랙트를 통해 다른 컨트랙트를 실행시킴</p>
<p>조건</p>
<p>업그레이드로 스마트 컨트랙트 주소 안변함데이터 마이그레이션 없이 데이터보존여러 스마트 컨트랙을 한번에 배포</p>
<p>Proxy contract 를 만들어 버전관리를 하고 유저는 proxy contract 로 전달하고 proxy contract는 최신버전의 contract로 명령을 전달한다.</p>
<p>Registry contract upgrade Earl =&gt; 업그레이드하고자 하는 proxy contract의 주소를 받아온다. registry contract 모두를 업그레이드 하기 위해 registry contract를 실행시킨다.</p>
<p>스마트 컨트랙트 버전관리 툴</p>
<ol>
<li>deploy</li>
<li>Registry contract 가 없으면 registry contract 배포</li>
</ol>
<p>업그레이 가능한 스마트 컨트랙트의 이점</p>
<p>유저 입장에서는 스마트 컨트랙트 주소가 고정됨, 버전 정볼르 생각하지 않고 특정 호출만 계속 함개발자 입장에서는 모든 데이터가 그대로 유지되고 재사용 되게 됨업그레이드가 매우 편리함.</p>
<p><strong>Token Model Design Process</strong></p>
<p>토큰 모델이랑 탈중앙화 네트워크의 보이지 않는 손이다.</p>
<p>토큰이라는 인센티브를 가지고 경제가 어떻게 굴러가는지를 설계한다.</p>
<p>게임 이론</p>
<p>주어진 게임의 규칙에서 최선의 전략을 찾는 이론</p>
<p>메커니즘 디자인</p>
<p>모든 플레이어가 게임에 충실하게 참여를 했을 때 이를 원하는 방향으로 굴러가게 하기 위한 메커니즘에 대한 디자인</p>
<p>어떻게 기존의 경제 시장에서 토큰 모델을 적용시킬 것인가?</p>
<p><strong>메커니즘 디자인의 기초</strong></p>
<p>Agent 행동 주체</p>
<p>Type agent의 사적인 정보</p>
<p>Decision 가능한 사회적 결과의 집합</p>
<p>Utility function 에이전트가 특정 결과에 대해 얻는 효용</p>
<p>Decision function agent의 각 행동을 종합한 결정 규칙</p>
<p>Transfer function agent의 행동에 따라서 받거나 내야하는 돈</p>
<p>Social choice function</p>
<p>가령 마을에 쓰레기 처리장을 짓는 문제를 생각해 보자.</p>
<p>제일 쉬운 방법은 누군가가 모든 사람들에게 의견을 물어보는 것이다.</p>
<p>여기서 transfer function 은 agent의 type 에따라서 받거나 내야하는 돈의 규칙이다.</p>
<p>메커니즘의 특성</p>
<p>Efficiency</p>
<p>최대 다수의 최대 행복</p>
<p>trustfulness</p>
<p>모든 에이전트의 균형 전략이 자신의 type을 솔직하게 보고하는 것일때</p>
<p>Budget balanced</p>
<p>agent의 type이 바뀌더라도 메커니즘이 transfer function으로 얻는 수입이 일정할 때</p>
<p><strong>메커니즘을 최적화 문제로 정의할 수 있다!!</strong></p>
<p><strong>메커니즘 최적화 적용</strong></p>
<p>가령 서울의 평균 기온을 블록체인에 기록하는 메커니즘을 만든다고 해보자</p>
<ol>
<li>오라클 선출 =&gt; 신뢰할 수 있는 외부 데이터를 선정한다.</li>
<li>Shelling coin 많은 사람들이 준 값들의 중간값을 실제값으로 정한다.</li>
</ol>
<p>계속해서 decision function 과 transfer function 을 바꾸어 보면서 실 데이터를 분석하여 효율적인 메커니즘을 도출해 내야 한다.</p>
<p><strong>토큰 모델 디자인 프로세스</strong></p>
<p>agents와 목표 행동 정의최적화 문제 설정반복메커니즘 규칙 설정규칙 변경결과 추론제약조건 변경</p>
<p><strong>예시 - steemit</strong></p>
<p>Object =&gt; 좋은 글의 공급을 극대화</p>
<p>Constraint =&gt; 초보 작가들이 글을 쓰기가 쉬워야 함, 독자들은 글을 쓸 때 돈을 내지 않아야 함 등</p>
<p>Decision =&gt; 추천수에 스팀 파워 가중치를 계산해 퀄리티로 인정함</p>
<p>Transfer =&gt;</p>
<p><strong>더 나은 설계를 위해 필요한 것들</strong></p>
<p>좋은 규칙의 집합, 패턴실제 돌아가는 프로젝트에서 나오는 실증 데이터복잡한 메커니즘의 정량적 추론을 위한 시뮬레이션 툴</p>
<p><strong>토큰 디자인 패턴</strong></p>
<p>Incentive, curation , judgement, governance</p>
<p><strong>메커니즘 디자인의 한계</strong></p>
<p>닫힌 시스템을 가정한 설계이기 때문에 경쟁 프로토콜, 암호화폐 시장 등 외부 요소는 고려하지 못하기에</p>
<p>블록체인과 같은 완벽하게 공개된 플랫폼 내에서 어떤 사이드 이펙트가 나올지 알 수 없다.</p>
<p><strong>토큰 디자이너를 위한 팁</strong></p>
<ol>
<li>플레이어가 아니라 디자이너처럼 생각하라.</li>
<li>목적과 제약조건 정의만 잘해도 반은 먹고 들어간다. =&gt; 토큰 가치 상승이 목적인가 이중 지불 방지가 목적인가, 목적과 제약조건만 확실하다면 솔루션은 얼마든지 바꿀 수 있음</li>
<li>솔루션을 decision function 과 transfer function 으로 바꾼다.</li>
<li>알고 있는 패턴이 풍부해야 문제를 잘 풀어나갈 수 있다.</li>
</ol>
<p><strong>화폐가치와 메커니즘 디자인은 어떻게 결합될 것인가</strong></p>
<p><strong>IOT에서의 블록체인</strong></p>
<p>오프라인 데이터의 위변조를 막기 위해 가량 씨씨티비의 경우 해당 영상의 해시값을 저장하여 블록체인에 저장하고 추후 검증이 필요한 경우 해당 해시와 비교를 통해 할 수 있따.</p>
<p>Digital forensic =&gt; 영상 데이터의 법정에서 신뢰를 얻을 수 있음</p>
<p>가령 자율주행차의 경우 수동으로 운전을 했는가 혹은 자동으로 운동을 했는가가 과실에 매우 중요하다. 이를 블록체인에 실시간으로 저장하면 이를 막을 수 있다.</p>
<p><strong>DAICO 모델 - 블록체인 위에서 ico 플랫폼</strong></p>
<p>메커니즘</p>
<p>하스켈</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/28/getting-started-with-redux/" itemprop="url">
                getting started with redux
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-28T05:02:33.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/redux/">redux</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                5 minutes read (About 798 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h2><span id="flux-란">Flux 란?</span></h2><p>flux 는 하나의 개발 철학이며 기존의 MVC 모델이나 양방향 데이터 바인딩에 대한 대안으로 제안된 개념이다.</p>
<p>flux에는 다음과 같은 3가지 개념이 있다.</p>
<ol>
<li>action</li>
<li>dispatcher</li>
<li>stores</li>
</ol>
<p>action은 시스템 전체의 상태변화를 묘사하는 다양한 형태의 행위이다. 가령 마우스 클릭이나 axios 요청 등의 행위들이 여기에 포함될 수 있다.</p>
<p>이러한 일련의 action들의 모음으로 시스템이 흘러가며 이를 통해 일관된 행동 양상을 유지하고 시스템의 다음 행보를 예측이 가능하게 된다.</p>
<p>일반적인 flux의 플로우는 다음과 같다.</p>
<ol>
<li>store는 action의 변화를 인지하도록 준비한다.</li>
<li>action이 dispatcher를 통해 dispatch 된다.</li>
<li>dispatcher는 store의 subscriber에게 변화를 알린다.</li>
<li>store는 해당하는 action에 따라 상태를 업데이트한다.</li>
<li>어플리케이션의 view는 해당 상태의 변화에 따라 업데이트 된다.</li>
<li>다음 액션이 실행될 수 있다.</li>
</ol>
<p>이렇게 시스템 전체가 일련의 action의 나열로 이루어짐에 따라 개발자들은 다음 시스템의 상태를 예상가능하게 되고 개발자의 통제 내에서 모든 시스템 변화가 이루어 질 수 있게 된다. 여기서 중요한 점은 모든 action이 순차적으로 이루어진다는 것이다.</p>
<p>이는 기존의 양방향 데이터바인딩 시스템과 매우 대조적인데 양방향 시스템에서는 모든 데이터가 실시간으로 변화하고 있기에 일관된 데이터의 변화 방향을 인지할 수 없지만 시스템의 순간순간의 상태는 각 액션 사이의 상태값의 변화이기에 모든 순간의 상태값에 대해 인지할 수 있다.</p>
<h2><span id="redux">Redux</span></h2><p>리덕스란 이러한 flux 패턴의 하나의 구현체이며 단 하나의 스토어를 가진다는 점에서 플럭스와 차이가 있다.</p>
<p>가령 요리책을 다루는 app의 경우 redux 스토어는 모든 요리방법들의 리스트와 상세 내역을 가지게 된다.</p>
<p>여기서 액션이란 요리방법을 추가하고 특정 레시피에 재료를 추가하는 행위라 할 수 있겠다.</p>
<p>실제 비즈니스 로직에서는 이런 다양한 액션들을 묶어서 사용자가 사용하는 수준으로 만들어줄 필요가 생기고 그것이</p>
<p><strong>action</strong></p>
<p>액션은 애플리케이션에서 스토어로 보내는 데이터 묶음이며, 스토어의 유일한 정보원이다.</p>
<p>store.dispatch()</p>
<p>액션의 종류</p>
<p>{</p>
<p>type: COMPLETE_TODO,</p>
<p>index: 5</p>
<p>}</p>
<p><strong>리듀서</strong></p>
<p>이전 상태와 액션을 받아 다음 상태를 반환하는 순수 함수이다.</p>
<p>(prevState, action)</p>
<p><strong>스토어</strong></p>
<p>액션과 리듀서를 함께 가져오는 객체이다.</p>
<p>createStore(_action) =&gt; store</p>
<p>store.dispatch(_action)</p>
<p><strong>프로세스</strong></p>
<ol>
<li>Create actionDescribe what happens</li>
<li>store.dispatch(action)</li>
<li>Redux store executes reducer function</li>
<li>Root reducer makes one state tree by merging reducer outputs</li>
<li>Store.subscribe(listener) =&gt; call all listener</li>
</ol>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-정렬-sorting/" itemprop="url">
                자료구조 | 정렬(sorting)
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T11:38:10.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                6 minutes read (About 876 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="개요">개요</span></h1><p>컴퓨터 안에는 수십 수만가지의 데이터 들이 있으며, 이러한 수많은 데이터들을 잘 정리하고 보관하는 것은 빠른 데이터 찾기와 데이터 추가 및 삭제 등의 작업의 효율에 매우 큰 영향을 미친다. 때문에 컴퓨터의 많은 자료들을 효율적으로 분류하고 원하는 자료를 찾고 추가 하기 위해서는 ‘정렬’에 대해 알아야 할 필요가 있다.</p>
<p>본 강의에서 <strong>리스트</strong> 란 하나 이상의 필드로 된 레코드의 집합이라는 의미로 사용하며, 이때 코드를 서로 구별하기 위해 사용되는 필드를 <strong>키</strong> 라고 한다.</p>
<h1><span id="일반적인-자료의-탐색-방법">일반적인 자료의 탐색 방법</span></h1><p>흔히 리스트를 탐색하는 가장 직관적인 방법은 앞에서 부터 차례대로 비교하면서 자료를 분류하는 것이다.<br>프로그래밍에서 for 문을 사용하여 리스트의 제일 앞에서 부터 뒤까지 훑어 가면서 equal 문을 통해 데이터를 찾는 작업은 매우 흔한 프로그래밍의 구현이다.</p>
<p>이렇게 어떤 리스트의 왼편에서 오른편으로 차례대로 데이터를 찾는 것을 <strong>순차 탐색</strong> 이라고 한다.</p>
<p>다음 C 언어로 순차탐색 프로그램을 구현한 코드이다.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(Element elements[], <span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">sizeof</span>(*elements) / <span class="keyword">sizeof</span>(elements[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"address of the elements: "</span> &lt;&lt; elements &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"count is: "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elements[i].key == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Element element1 = &#123;<span class="string">"123"</span>&#125;;</span><br><span class="line">    Element element2 = &#123;<span class="string">"namhoon"</span>&#125;;</span><br><span class="line">    Element elements[] = &#123;element1, element2&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = seqSearch(elements, <span class="string">"namhoon"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위 프로그램을 살펴보면 for 문을 돌면서 n 개의 레코드를 탐색하는 평균은 (n+1)/2 이므로, O(n)의 시간복잡도를 가진다.</p>
<p>만약 어떤 리스트가 정렬된 순차 리스트라면 이런 순차 탐색 말고 <strong>이원 탐색</strong> 을 사용하여 자료를 찾을 수 있으며 이 경우 시간 복잡도는 O(logn) 이다.</p>
<h1><span id="정렬의-종류">정렬의 종류</span></h1><h2><span id="삽입-정렬">삽입 정렬</span></h2><p>i 개의 정렬된 레코드에 새로운 레코드를 끼워넣어 i+1 개의 정렬된 레코드 리스트를 만드는 정렬 방법이다.</p>
<p>아래 프로그램은 C로 구현한 insert 함수이다.</p>
<p><img src="/images/삽입정렬시Insert함수의개념도.png" alt="삽입 정렬 시 insert 함수의 개념도"></p>
<p>정렬된 리스트 a[1:i] 에 e 원소를 집어넣어 a[1:i+1]의 리스트를 만들어 내는 함수이다.</p>
<p>index 역할을 하는 i가 점차 작아지면서 a[i].key가 e.key 보다 큰 경우 한칸씩 우측으로 밀어내고, a[i].key가 e.key 보다 작아지는 i 값에서 a[i+1]에 e를 넣어준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void insert(element e, element a[], int i)&#123;</span><br><span class="line">  a[0]=e;</span><br><span class="line">  while(e.key&lt;a[i].key)&#123;</span><br><span class="line">    a[i+1] = a[i];</span><br><span class="line">    i--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  a[i+1] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>아래 함수는 insert 함수를 활용하여 삽입정렬을 하는 프로그램이다.</p>
<p><img src="../images/삽입정렬의개념도.png" alt="삽입 정렬의 개념도"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void insertionSort(element a[], int n)&#123;</span><br><span class="line">  int j;</span><br><span class="line">  for(j=2;j&lt;=n;j++)&#123;</span><br><span class="line">    element temp = a[j];</span><br><span class="line">    insert(temp, a, j-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="병합정렬merge-sort">병합정렬(Merge Sort)</span></h2><p>병합정렬은 입력 리스트를 길이가 1인 n 개의 정렬될 서브트리로 간주하는 것으로 시작합니다.</p>
<p>아래 merge 함수는 두개의 서로 다른 리스트를 병합하는 것을 보여줍니다.</p>
<p><img src="\images\merge개념도.png" alt="합병 정렬을 위한 merge 함수 개념도"></p>
<p><img src="\images\병합정렬의개념도.png" alt="병합 정렬의 개념도"></p>
<p>merge sort 의 각 단계는 O(n) 의 시간이 걸리고 logn 번의 단계가 적용되므로 O(nlogn) 의 복잡도를 가집니다.</p>
<p><strong>Time Complexity: O(nlogn)</strong></p>
<p>또한 각 병합과정에서 새로운 배열이 필요하므로 inplace sort가 아니다.</p>
<h2><span id="퀵-정렬quick-sort">퀵 정렬(Quick Sort)</span></h2><p>퀵 정렬은 앞서 살펴본 정렬법 중에서 가장 좋은 평균 성능을 가지고 있다.<br>퀵 정렬의 순서는 먼저 피벗 레코드를 선택하여 피벗의 왼쪽에는 레코드 키들이 피벗의 키보다 작거나 같고 피벗의 오른쪽에는 레코드 키들이 피벗의 키보다 크거나 같도록 하는 방법을 사용한다. 최종적으로는 피벗의 왼쪽에 있는 레코드들과 피벗의 오른쪽에 있는 레코드들이 서로 독립적으로 정렬이 된다.</p>
<p><img src="/images\퀵정렬의개념도.png" alt="퀵정렬의 개념도"></p>
<p>다음은 퀵 정렬을 수행하는 프로그램이다.<br>i와 j가 각각 왼쪽과 오른쪽에서 가운데 방향으로 진행하며, a[i].key는 pivot 보다 커질 때까지 a[j].key는 pivot 보다 작아질 때 까지<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void quickSort(element a[], int left, int right)&#123;</span><br><span class="line">  int pivot,i,j;</span><br><span class="line">  pivot = a[left].key;</span><br><span class="line">  do&#123;</span><br><span class="line">    do j++;while(a[i].key&lt;pivot);</span><br><span class="line">    do j--;while(a[j].key&gt;pivot);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="히프정렬">히프정렬</span></h2><p><img src="\images\히프정렬을위한Adjust함수.png" alt="히프 정렬을 위한 adjust 함수"></p>
<p><img src="\images\히프정렬의개념도.png" alt="히프 정렬의 개념도"></p>
<p><img src="배열에서의히프정렬.png" alt="배열에서의 히프 정렬"></p>
<p>히프 정렬에서는 최대 길이 [log_2(n+1)] 을 가지고 adjust를 n-1번 호출한다.</p>
<p>즉, O(nlogn) 이다.</p>
<h2><span id="버블-정렬">버블 정렬</span></h2><p><img src="\images\버블정렬의개념도.png" alt="버블 정렬의 개념도"></p>
<h2><span id="선택-정렬">선택 정렬</span></h2><p><img src="\images\선택정렬의개념도.png" alt="선택 정렬의 개념도"></p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-히프(Heap)/" itemprop="url">
                자료구조 | 히프 구조
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T11:34:03.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                5 minutes read (About 763 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="히프heap란">히프(heap)란?</span></h1><p>히프는 우선순위 큐를 구현하는 데 자주 사용된다. 우선순위 큐에서는 우선순위가 가장 높은(또는 낮은) 원소를 먼저 삭제한다.<br>히프에 대한 설명을 하기 전에 최대 트리와 최소 트리에 대한 설명을 먼저 진행한다.</p>
<p><strong>최대 트리</strong> 란 각 노드의 키 값이 그 자식의 키 값보다 작지 않은 트리이며,<br><strong>최소 트리</strong> 란 각 노드의 키 값이 그 자식의 키 값보다 크지 않은 트리를 말한다.</p>
<p>여기서 <strong>최대 히프</strong> 란 최대 트리이면서 완전 이진트리이며, <strong>최소 히프</strong> 란 최소 트리이면서 완전 이진트리를 의미한다.</p>
<p>이러한 최대 히프 및 최소 히프에서는 부모를 쉽게 찾아 삽입이 가능하다.</p>
<p>히프의 생성은 C를 통하여 다음과 같이 구현한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_ELEMENTS 200</span><br><span class="line">#define HEAP_FULL(n) (n==MAX_ELEMENTS-1)</span><br><span class="line">#define HEAP_EMPTY(n) (!n)</span><br><span class="line">typedef struct&#123;</span><br><span class="line">  int key;</span><br><span class="line">  &#125; element;</span><br><span class="line"></span><br><span class="line">element heap[MAX_ELEMENTS];</span><br><span class="line">int n=0;</span><br></pre></td></tr></table></figure></p>
<h1><span id="최대-히프에서의-삽입">최대 히프에서의 삽입</span></h1><p>최대 히프에서 원소를 삽입하는 경우 추가되는 원소가 가장 아래부터 루트 쪽으로 올라가는 bubbling up 기법이 사용된다.<br>다음은 최대 히프에서의 원소의 삽입을 구현한 C 프로그램이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define MAX_ELEMENTS 200 /*최대 히프 크기 +1*/</span><br><span class="line">#define HEAP_FULL(n) (n == MAX_ELEMENTS-1)</span><br><span class="line">#define HEAP_EMPTY(n) (!n)</span><br><span class="line"></span><br><span class="line">typedef struct element&#123;</span><br><span class="line">  int key;</span><br><span class="line">&#125;element;</span><br><span class="line"></span><br><span class="line">element heap[MAX_ELEMENTS];</span><br><span class="line">int n=0;</span><br><span class="line"></span><br><span class="line">void push(element item, int *n)</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  if(HEAP_FULL(*n))&#123;</span><br><span class="line">    fprintf(stderr, &quot;The heap is full. \n&quot;);</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  i = ++(*n);</span><br><span class="line">  while ((i != 1) &amp;&amp; (item.key &gt; heap[i/2].key))&#123;</span><br><span class="line">    heap[i] = heap[i/2];</span><br><span class="line">    i /= 2;</span><br><span class="line">  &#125;</span><br><span class="line">  heap[i] = item;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct element node1 = &#123;7&#125;;</span><br><span class="line">    struct element node2 = &#123;16&#125;;</span><br><span class="line">    struct element node3 = &#123;49&#125;;</span><br><span class="line">    struct element node4 = &#123;82&#125;;</span><br><span class="line">    struct element node5 = &#123;5&#125;;</span><br><span class="line">    struct element node6 = &#123;31&#125;;</span><br><span class="line">    struct element node7 = &#123;6&#125;;</span><br><span class="line">    struct element node8 = &#123;2&#125;;</span><br><span class="line">    struct element node9 = &#123;44&#125;;</span><br><span class="line">    push(node1, &amp;n);</span><br><span class="line">    push(node2, &amp;n);</span><br><span class="line">    push(node3, &amp;n);</span><br><span class="line">    push(node4, &amp;n);</span><br><span class="line">    push(node5, &amp;n);</span><br><span class="line">    push(node6, &amp;n);</span><br><span class="line">    push(node7, &amp;n);</span><br><span class="line">    push(node8, &amp;n);</span><br><span class="line">    push(node9, &amp;n);</span><br><span class="line">    for(int k=1;k&lt;10;k++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,heap[k].key);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="\images\최대히프에서의삽입.png" alt="최대 히프에서의 삽입"></p>
<h1><span id="최대-히프에서의-삭제">최대 히프에서의 삭제</span></h1><p>최대 히프에서 원소의 삭제는 제일 위에서 이루어 진다.<br>먼저, 키값이 가장 큰 원소를 삭제하고 마지막 원소를 제거하고 두 자식 노드중 큰 값이 위로 올라가고 아래를 메꾸는 방식으로 진행된다.<br>최대 히프의 삭제를 구현한 프로그램은 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">element pop(int *n)</span><br><span class="line">&#123;</span><br><span class="line">  int parent, child;</span><br><span class="line">  element item, temp;</span><br><span class="line">  if(HEAP_EMPTY(*n))&#123;</span><br><span class="line">    fprintf(stderr, &quot;The heap is empty\n&quot;);</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  item=heap[1];</span><br><span class="line">  temp = heap[(*n)--];</span><br><span class="line">  parent = 1;</span><br><span class="line">  child = 2;</span><br><span class="line">  while(child &lt;= *n)&#123;</span><br><span class="line">    if((child &lt; *n) &amp;&amp; (heap[child].key &lt; heap[child+1].key))</span><br><span class="line">      child++;</span><br><span class="line">    if(temp.key &gt; heap[child].key) break;</span><br><span class="line">    heap[parent] = heap[child];</span><br><span class="line">    parent = child;</span><br><span class="line">    child *= 2;</span><br><span class="line">  &#125;</span><br><span class="line">  heap[parent] = temp;</span><br><span class="line">  return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="\images\최대히프에서의삭제개념도.png" alt="최대 히프에서의 삭제 개념도"></p>
<h1><span id="b-히프">B - 히프</span></h1><p>B - 히프란 최소 트리의 집합이다.</p>
<p><img src="\images\b히프.png" alt="B 히프"></p>
<p><img src="\images\b히프에서의삽입.png" alt="B 히프에서의 삽입"></p>
<p><img src="\images\b히프에서의삭제.png" alt="B 히프에서의 삭제"></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-트리/" itemprop="url">
                자료구조 | 트리(Tree)
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T11:28:13.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                17 minutes read (About 2475 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#트리tree란">트리(tree)란?</a></li>
<li><a href="#이진-트리">이진 트리</a><ul>
<li><a href="#이진-트리-순회">이진 트리 순회</a></li>
<li><a href="#예제">예제</a></li>
</ul>
</li>
<li><a href="#스레드-이진-트리">스레드 이진 트리</a></li>
<li><a href="#이원-탐색-트리bst-binary-search-tree">이원 탐색 트리(BST, Binary Search Tree)</a><ul>
<li><a href="#이원-탐색트리의-탐색">이원 탐색트리의 탐색</a></li>
<li><a href="#insertion-in-bst">INSERTION IN BST</a></li>
<li><a href="#deletion-in-bst">DELETION IN BST</a></li>
</ul>
</li>
<li><a href="#선택-트리">선택 트리</a><ul>
<li><a href="#승자-트리">승자 트리</a></li>
<li><a href="#패자-트리">패자 트리</a></li>
</ul>
</li>
<li><a href="#분리-집합의-표현">분리 집합의 표현</a></li>
<li><a href="#이진-트리의-개수-계산">이진 트리의 개수 계산</a></li>
<li><a href="#avl-트리">AVL 트리</a><ul>
<li><a href="#avl-트리에서의-삽입">AVL 트리에서의 삽입</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="트리tree란">트리(tree)란?</span></h1><p>트리 구조란 정보의 항목들이 가지로 연결될 수 있게 데이터가 조작되는 것이며, 가계표, 족보, 왕조의 나열 등에서 쉽게 찾아볼 수 있다.<br>가계표를 예를 들어 설명을 하면 최 상단에 조부모님이 계시고 그 아래로 아버지와 어머니, 동생 친척들이 쭉 나열이 되는데, 이러한 조직 체계를 트리를 통해 나타낼 수 있다.</p>
<p>트리 구조에서 <strong>노드</strong> 란 각 항목들을 의미하며 한 정보 아이템에서 다른 노드로 뻗어진 가지를 포함한 개념이다.<br>각 노드는 아래로 계속해서 가지를 뻗어나갈 수 있는데, <strong>한 노드에서 뻗어져 나간 가지들(서브트리)</strong> 의 수를 그 노드의 <strong>차수</strong> 라고 부른다.<br>또한, 차수가 0인 노드를 <strong>리프 혹은 단말 노드</strong> 라고 부르며, 뻗어나간 구조의 상위의 노드를 아래 노드의 <strong>부모(parent)</strong> 라 하고 아래 노드를 상위 노드의 <strong>자식(child)</strong> 이라고 부른다. 또한 한 노드에서 뻗어져 나온 병렬관계의 노드를 서로의 <strong>형제(sibling)</strong> 이라고 부른다.</p>
<p>특정 노드의 차수와 구분하여 <strong>트리의 차수</strong> 트리에 있는 노드의 최대 차수를 말한다.</p>
<h1><span id="이진-트리">이진 트리</span></h1><p>다시 가계표의 예를 들면 한 부모 밑에는 수많은 자식들이 생길 수 있으나, 컴퓨터가 이를 처리하는 시점에서 특정 부모노드 아래에 숫자를 알 수 없는 자식들이 존재하게 된다면 포인터 필드가 가변적이기에 효율적으로 메모리를 사용할 수 없다. 이 때문에 일정한 크기의 노드를 사용하기 위한 트리의 표현법이 나타나게 되었고, 한 노드가 가지만을 가지도록 만들어진 트리를 <strong>이진 트리</strong> 라고 한다.</p>
<p>제일 위의 노드(root)로 부터 2배씩 증가하며 가지들이 뻗어나와 크리스마스 트리 형태를 띄는 형태를 이진트리라고 부르며 모든 노드들이 규칙적으로 2개씩 가지를 쳐 나가 각 층의 노드가 꽉꽉 들어차면 이를 <strong>포화 이진 트리</strong> 라고 한다.<br><strong>깊이가 k인 포화 이진트리의 노드 수는 (2^k-1)개</strong> 이다.</p>
<p>컴퓨터에서는 이러한 이진트리를 메모리에 저장할 방법을 찾게 되었고 최 상단 노드부터 차례로 메모리에 저장을 하게 되면 포화 이진트리가 아닌 대부분의 이진트리에서는 메모리 중간 중간이 비게 되어 효율적인 메모리 사용에 어려움을 겪게 되었는데, 이를 해결하기 위해 열결표현 방식을 사용하여 각 노드가 다른 노드의 링크를 연결하여 포인터를 들고 있는 방식으로 저장하게 되었다.</p>
<p><strong>어떠한 트리도 이진 트리로 표현할 수 있다.</strong></p>
<p>다음은 C 언어를 이용한 이진 트리의 구현이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/*node 구조체로 *treePointer 라는 별칭 선언*/</span><br><span class="line">typedef struct node *treePointer;</span><br><span class="line">/*node 구조체를 선언한다.*/</span><br><span class="line">typedef struct node&#123;</span><br><span class="line">  char data;</span><br><span class="line">  treePointer leftChild, rightChild;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line">treePointer createNode(char newData)</span><br><span class="line">&#123;</span><br><span class="line">  treePointer newNode = (treePointer)malloc(sizeof(node));</span><br><span class="line">  newNode-&gt;leftChild = NULL;</span><br><span class="line">  newNode-&gt;rightChild = NULL;</span><br><span class="line">  newNode-&gt;data = newData;</span><br><span class="line"></span><br><span class="line">  return newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inorder(treePointer ptr)</span><br><span class="line">&#123;</span><br><span class="line">  if(ptr)&#123;</span><br><span class="line">    inorder(ptr-&gt;leftChild);</span><br><span class="line">    printf(&quot;%c&quot;, (*ptr).data);</span><br><span class="line">    inorder(ptr-&gt;rightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*추가된 노드를 출력하는 부분*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    treePointer nodeA = createNode(&apos;A&apos;);</span><br><span class="line">    treePointer nodeB = createNode(&apos;B&apos;);</span><br><span class="line">    treePointer nodeC = createNode(&apos;C&apos;);</span><br><span class="line">    treePointer nodeD = createNode(&apos;D&apos;);</span><br><span class="line">    treePointer nodeE = createNode(&apos;E&apos;);</span><br><span class="line">    treePointer nodeF = createNode(&apos;F&apos;);</span><br><span class="line">    treePointer nodeG = createNode(&apos;G&apos;);</span><br><span class="line">    treePointer nodeH = createNode(&apos;H&apos;);</span><br><span class="line"></span><br><span class="line">    (*nodeA).leftChild=nodeB;</span><br><span class="line">    (*nodeA).rightChild=nodeC;</span><br><span class="line">    (*nodeB).leftChild=nodeD;</span><br><span class="line">    (*nodeB).rightChild=nodeE;</span><br><span class="line">    (*nodeD).rightChild=nodeG;</span><br><span class="line">    (*nodeC).leftChild=nodeF;</span><br><span class="line">    (*nodeF).rightChild=nodeH;</span><br><span class="line">    inorder(nodeA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="이진-트리-순회">이진 트리 순회</span></h2><p>앞서 설명한 이진 트리를 조회하기 위해서 다양한 방법을 사용하는데, 한 노드에서 왼쪽으로 이동(L), 오른쪽으로 이동(R), 노드 방문(V) 의 순서에 따라 중위 순회, 후위 순회, 전위 순회로 구분한다.</p>
<p>먼저 <strong>전위 순회(preorder traversal)</strong> 는 이름 그대로 노드를 먼저 방문하는 경우 즉, VLR의 순서로 노드를 방문하는 경우이다.<br><strong>후위 순회(postorder traversal)</strong> 은 노드를 제일 마직막에 방문하는 경우 즉, LRV의 순서로 노드를 방문하는 경우이다.<br><strong>중위 순회</strong> 란 노드를 중간에 방문하는 경우 즉, LVR의 순서로 노드를 방문하는 경우이다.</p>
<p>중위 순회를 하는 경우를 C 코드로 나타내면 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void inorder(treePointer ptr)</span><br><span class="line">&#123;</span><br><span class="line">  if(ptr)&#123;</span><br><span class="line">    inorder(ptr-&gt;leftChild);</span><br><span class="line">    printf(&quot;%c&quot;, (*ptr).data);</span><br><span class="line">    inorder(ptr-&gt;rightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위의 코드를 살펴보면 반복법이 아닌 순환법을 이용하여 즉, 스택의 도움 없이 순회를 진행하는데 이는 스택을 이용하여 스택에 노드를 저장하고 제거하는 방식으로도 순회가 가능하다. 이러한 순회를 <strong>반복적 중위 순회</strong> 라고 하며 이를 C 코드로 구현하면 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void iterInorder(treePointer ptr)&#123;</span><br><span class="line">  int top = -1; /*스택 초기화*/</span><br><span class="line">  treePointer stack[MAX_STACK_SIZE];</span><br><span class="line">  for(;;)&#123;</span><br><span class="line">    for(;node;node=node-&gt;leftChild)</span><br><span class="line">      push(node);/*스택에 삽입*/</span><br><span class="line"></span><br><span class="line">    node=pop();/*스택에서 제거*/</span><br><span class="line">    if(!node)/*스택이 비어있는 경우 중지*/</span><br><span class="line">      break;</span><br><span class="line">    printf(&quot;%d&quot;, node-&gt;data);</span><br><span class="line">    node=node-&gt;rightChild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="예제">예제</span></h2><p>이진 트리에서 리프 노드의 수를 세는 C 함수를 작성하여라.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int totalCount=0;</span><br><span class="line">void countLeaf(treePointer ptr)&#123;</span><br><span class="line">  if(ptr&amp;&amp;(!(*ptr).leftChild)&amp;&amp;(!(*ptr).rightChild))&#123;</span><br><span class="line">    totalCount++;</span><br><span class="line">    printf(&quot;\n리프 노드: %c, count:%d\n&quot;, (*ptr).data, totalCount);</span><br><span class="line">  &#125;</span><br><span class="line">  if(ptr)&#123;</span><br><span class="line">    countLeaf((*ptr).leftChild);</span><br><span class="line">    printf(&quot;%c&quot;,(*ptr).data);</span><br><span class="line">    countLeaf((*ptr).rightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="스레드-이진-트리">스레드 이진 트리</span></h1><p>2n개의 링크 중 n+1개가 null link 이므로 효율성이 떨어지는 문제가 생기게 되고 이를 해결하기 위해 null link에 포인터를 넣어 다른 노드의 링크를 거는 것을 <strong>스레드</strong> 라고 한다.</p>
<h1><span id="이원-탐색-트리bst-binary-search-tree">이원 탐색 트리(BST, Binary Search Tree)</span></h1><p>이원 탐색 트리는 탐색, 삽입, 삭제 연산에 있어서 지금까지 공부했던 어떤 자료 구조보다도 성능이 좋다.<br>이원 탐색트리의 모든 원소는 키를 가지고 <strong>어떤 두 원소도 동일한 키를 갖지 않으며</strong>, <strong>왼쪽 서브트리가 존재한다면 그 키들은 루트의 키보다 작고 오른쪽 서브트리가 존재한다면 루트의 키보다 크다</strong>. 또한, <strong>왼쪽과 오른쪽 서브트리도 모두 이원탐색 트리이다.</strong></p>
<h2><span id="이원-탐색트리의-탐색">이원 탐색트리의 탐색</span></h2><p>탐색은 루트부터 시작하여 루트와 키 값이 같다면 탐색은 종료된다. 탐색하고자 하는 키 값이 루트의 키보다 작다면 왼쪽 서브트리를 탐색하고 크다면 오른쪽 서브트리를 탐색한다. 왼쪽과 오른쪽 서브트리는 모두 이원탐색 트리이므로 각각을 다시 탐색하는 순환 탐색 방식을 사용한다.</p>
<p>다음은 이원 탐색 트리의 순환적 탐색을 구현한 프로그램이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">element * search(treePointer tree, int key)&#123;</span><br><span class="line">  if(!root) return NULL;</span><br><span class="line">  if(k == root-&gt;data.key) return &amp;(root-&gt;data);</span><br><span class="line">  if(k&lt;root-&gt;data.key)</span><br><span class="line">    return search(root-&gt;leftChild, k);</span><br><span class="line">  return search(root-&gt;rightChild, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>아래는 동일한 기능의 반복 함수로 구현한 프로그램이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">element* iterSearch(treePointer tree, int k)</span><br><span class="line">&#123;</span><br><span class="line">  white(tree)&#123;</span><br><span class="line">    if(k==tree-&gt;data.key) return &amp;(tree-&gt;data);</span><br><span class="line">    if(k&lt;tree-&gt;data.key)</span><br><span class="line">      tree = tree-&gt;leftChild;</span><br><span class="line">    else</span><br><span class="line">      tree = tree-&gt;rightChild;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Time Complexity: O(h)</strong></p>
<p>BST 에서의 찾는 시간은 찾고자 하는 노드의 높이만큼 분기를 수행하므로 O(h) 이다.</p>
<h2><span id="insertion-in-bst">INSERTION IN BST</span></h2><p><img src="\images\이원탐색트리에서의삽입개념도.png" alt="이원 탐색 트리에서의 삽입 개념도"></p>
<p><strong>Time Complexity: O(h)</strong></p>
<p>BST 에서의 삭제는 search 후에 단순 삽입으로 search 시의 time complexity와 같은 complexity 를 가진다.</p>
<h2><span id="deletion-in-bst">DELETION IN BST</span></h2><p><img src="\images\이진탐색트리에서의삭제개념도.png" alt="이진 탐색 트리에서의 삭제 개념도"></p>
<p><strong>Time Complexity: O(h)</strong></p>
<p>BST 에서의 삭제는 다음과 같이 진행된다.</p>
<ol>
<li>BST에서 해당 노드를 찾음</li>
<li>해당 노드를 삭제하고, maximum value in left subchild 로 대체 하거나 혹은 minimum in right subchild 로 대체한다.</li>
<li>대체된 노드에 대한 삭제를 진행한다. 이 경우 해당 노드는 차수가 0이거나 혹은 1 이므로 삭제는 매우 간편하다.</li>
</ol>
<p>위의 각 과정별로 시간 소모를 생각해 보면, 노드를 찾는데에 O(h), 삭제하고 서브 트리에서 값을 찾는데에 O(h) 삭제에 1 이므로 BST 에서 deletion 시에 time Complexity 는 O(h) 이다.</p>
<h1><span id="선택-트리">선택 트리</span></h1><h2><span id="승자-트리">승자 트리</span></h2><p>다음은 8개의 런(k=8) 을 가진 승자 트리의 개념도 입니다.</p>
<p><img src="\images\선택트리의개념도.png" alt="선택 트리의 개념도"></p>
<h2><span id="패자-트리">패자 트리</span></h2><p>다음은 위의 승자 트리에 대응하는 패자 트리의 개념도 입니다.</p>
<p><img src="\images\패자트리의개념도.png" alt="패자 트리의 개념도"></p>
<h1><span id="분리-집합의-표현">분리 집합의 표현</span></h1><h1><span id="이진-트리의-개수-계산">이진 트리의 개수 계산</span></h1><h1><span id="avl-트리">AVL 트리</span></h1><p>AVL 트리란 균형 이진 트리의 한 종류이며, 이원 탐색트리가 항상 완전 이진트리로 유지되도록 한 트리입니다.</p>
<p><strong>탐색, 삽입, 삭제 시간: O(logn)</strong></p>
<p>AVL 트리에서 각 노드는 <strong>균형 인자(balance factor)</strong> 를 가지는데, 이는 왼쪽 트리의 높이에서 오른쪽 트리의 높이를 뺀 값으로 높이의 균형도를 나타냅니다.</p>
<p><strong>balance factor = h_L - h_R</strong></p>
<p>AVL 트리에서는 어떤 서브트리 T 에서도 BF(T) 의 절대값은 1 이하입니다.</p>
<h2><span id="avl-트리에서의-삽입">AVL 트리에서의 삽입</span></h2><p><strong>LL rotation</strong></p>
<p><img src="\images\lL로테이션.png" alt="LL 로테이션"></p>
<p><strong>RR rotation</strong><br><strong>LR rotation</strong></p>
<p><img src="\images\lR로테이션.png" alt="LR 로테이션"></p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-강의-09-우선순위-큐/" itemprop="url">
                자료구조 강의 09. 우선순위 큐
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T11:07:13.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                5 minutes read (About 739 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#1-한쪽-끝과-양쪽-끝-우선순위-큐">1. 한쪽 끝과 양쪽 끝 우선순위 큐</a></li>
<li><a href="#좌향-트리">좌향 트리</a></li>
<li><a href="#이항히프b-heap">이항히프(B-Heap)</a></li>
</ul>
<!-- tocstop -->
<h1><span id="1-한쪽-끝과-양쪽-끝-우선순위-큐">1. 한쪽 끝과 양쪽 끝 우선순위 큐</span></h1><p><strong>우선순위 큐(priority queue)</strong> 는 각 원소가 연관된 우선순위를 갖고 있는 원소들의 모임이다.<br>가령 시스템의 작업 우선도를 설정해 줄 때에는 작업들을 우선 순위에 따라 분류해야 하며, 2개의 서버로 이루어진 시스템의 경우에 하나의 시스템이 사고로 인해 종료되는 경우 반대쪽 서버로 그 작업 내역들이 병합되어야 하는데 이러한 경우 우선순위 큐를 통해 두 작업 리스트를 병합해야 한다.</p>
<p>이러한 우선순위 큐 <strong>한쪽 끝 우선순위 큐</strong> 와 <strong>양쪽 끝 우선순위 큐</strong> 가 있으며, 한쪽 끝 우선순위 큐는 <strong>최대 우선순위 큐</strong> 와 <strong>최소 우선순위 큐</strong> 로 나뉜다.</p>
<p><strong>최소 우선순위 큐</strong> 에 의해 지원되는 연산은 다음과 같다.<br>SP1. 최소 우선순위를 가진 원소의 반환<br>SP2. 임의 우선순위를 가진 원소의 삽입<br>SP3. 최소 우선순위를 가진 원소의 삭제</p>
<p>이러한 우선순위 큐를 잘 표현하기 위한 고전적인 자료 구조로써 <strong>히프(heap)</strong> 를 사용한다.</p>
<p>양쪽 끝 우선순위 큐는 최소 우선순위 큐와 최대 우선순위 큐가 하나로 합해진 최소-최대 우선순위 큐이다.</p>
<p>실제 활용도 측면에서, 양쪽 끝 우선순위 큐는 네트워크 버퍼를 구현하는 데 사용되는데 네트워크 링크를 통해 전송되기를 원하는 패킷들을 가지고 있는 경우 가장 높은 우선순위를 가진 패킷이 전송되고 삭제 되는 <strong>최대 삭제</strong> 가 행해지는 반면, 네트워크 내의 다른 곳으로 부터 새로운 패킷이 도착하였는데 버퍼가 가득 차 있다면 우선 순위가 가장 낮은 패킷을 지우는 <strong>최소 삭제</strong> 가 일어나게 된다. 이처럼 작업 큐의 양쪽에서 삽입과 삭제가 가능한 큐를 양쪽 끝 우선순위 큐라고 부른다.</p>
<h1><span id="좌향-트리">좌향 트리</span></h1><p>좌향트리는 합병성 우선순위 큐의 효율적 구현을 제공한다.<br>좌향 트리의 종류에는 HBLT(Height Biased Leftist Tree)와 WBLT(Weight Biased Leftist Tree)가 있는데, 일반적으로 HBLT를 좌향트리하고 부른다.</p>
<h1><span id="이항히프b-heap">이항히프(B-Heap)</span></h1><p>좌향 트리에서 지원되는 것과 같은 기능을 수행한다. 개별적인 연산을 수행하는 데 걸리는 시간보다 우선순위 큐의 순차를 수행하는데 걸리는 시점에 관심이 있다.<br>이항 히프란 최소 트리의 집합이며, 최소 트리 가운데 최소값을 갖는 트리를 가리키는 하나의 포인터가 가르키게 된다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/컴퓨터-구조-강의-프로세서/" itemprop="url">
                컴퓨터 구조 | 프로세서
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T10:51:27.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/컴퓨터-구조-강의/">컴퓨터 구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                2 minutes read (About 302 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#파이프라이닝에-대한-개관">파이프라이닝에 대한 개관</a></li>
</ul>
<!-- tocstop -->
<p>명령어 집합 구조가 구현의 여러 가지 측면을 어떻게 결정 하는지, 또 여러가지 구현 전략이 클럭 속도와 CPI에 어떻게 영향을 미치는지 살펴볼 기회를 갖게 될 것이다.<br>명령어 종류에 관계없이 어떤 명령어 던지 처음 두 단계는 다음과 같이 동일하다.</p>
<ol>
<li>프로그램 카운터(PC)를 프로그램이 저장된 메모리로 보내어 메모리로부터 명령어를 가져온다.</li>
<li>읽은 레지스터를 선택하는 명령어 필드를 사용하여 하나 또는 두 개의 레지스터를 읽는다.</li>
</ol>
<h1><span id="파이프라이닝에-대한-개관">파이프라이닝에 대한 개관</span></h1><p>파이프라이닝이란 여러 명령어가 중첩되어 실행되는 구현기술로써 기존의 단일 사이클 구조에서는 ALU 등 여러 장치가 다른 명령어를 실행하는 동안에는 동작하지 않는 것이 효율이 매우 떨어지기에 각 명령어를 처리할 수 있는 자원이 존재한다면 이를 병렬로 실행시켜 처리량을 올리는 기술이다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-강의-01-기본-개념/" itemprop="url">
                자료구조 강의 01. 기본 개념
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T10:29:33.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                3 minutes read (About 449 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#개요-시스템-생명-주기">개요: 시스템 생명 주기</a></li>
<li><a href="#포인터와-동적-메모리-할당">포인터와 동적 메모리 할당</a></li>
<li><a href="#알고리즘-명세">알고리즘 명세</a></li>
<li><a href="#데이터-추상화">데이터 추상화</a></li>
<li><a href="#성능-분석">성능 분석</a><ul>
<li><a href="#공간-복잡도">공간 복잡도</a></li>
<li><a href="#시간-복잡도">시간 복잡도</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="개요-시스템-생명-주기">개요: 시스템 생명 주기</span></h1><h1><span id="포인터와-동적-메모리-할당">포인터와 동적 메모리 할당</span></h1><h1><span id="알고리즘-명세">알고리즘 명세</span></h1><h1><span id="데이터-추상화">데이터 추상화</span></h1><h1><span id="성능-분석">성능 분석</span></h1><p>본 강의의 목적 중 하나는 프로그램에 대한 평가 능력을 향상시키는 것이다.<br>프로그램의 판단함에 있어서 다양한 기준이 있지만, 크게는 컴퓨터와 상관 없이 시공간의 추산에 초점을 두는 <strong>성능 분석(performance analysis)</strong> 과 컴퓨터에 의존적인 실행 시간을 얻어내는 <strong>성능 측정(performance measurement)</strong> 이 있다.</p>
<p>이번 강의 에서는 성능 측정은 배제하고 성능 분석에 초점을 두어 강의를 진행하며 성능 분석은 다음의 두 복잡도로 분석을 진행한다.</p>
<ol>
<li>공간 복잡도</li>
<li>시간 복잡도</li>
</ol>
<h2><span id="공간-복잡도">공간 복잡도</span></h2><p>공간 복잡도의 정의는 프로그램을 실행시켜 완료하는 데 필요로 하는 공간의 양으로, 실제 메모리를 차지하는 양을 나타낸다. 각 각의 변수가 얼마나 많은 메모리를 차지하는 지 등을 다루며 이러한 공간 복잡도는 <strong>고정 공간 요구</strong> 및 <strong>가변 공간 요구</strong> 로 나뉘게 된다.</p>
<p><strong><em>고정 공간 요구</em></strong><br>프로그램 입출력의 횟수나 크기에 관계없는 공간 요구를 의미한다.<br>가령 명렁어 공간, 단순 변수, 상수 고정 크기의 구조화 변수 등을 포함한다.</p>
<p><strong><em>가변 공간 요구</em></strong><br>해결하고자 하는 문제의 특정 인스턴스 I에 의존하는 크기를 가진 구조화 변수들을 위해 필요로 하는 공간이다.</p>
<h2><span id="시간-복잡도">시간 복잡도</span></h2><p>컴파일 시간과 실행 시간을 합한 것이다.</p>

                        
    </div>
    
            
</article>



        
    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/page/12/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/page/14/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/">1</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/12/">12</a></li>
        
        <li><a class="pagination-link is-current" href="/page/13/">13</a></li>
        
        <li><a class="pagination-link" href="/page/14/">14</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/23/">23</a></li>
        
    </ul>
</nav>
    
    </div>
</section>

            <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 Jake.Lee 이남훈&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" href="https://github.com/frontalnh">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
                <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        //plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110077250-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-110077250-2');
</script>


    


<script src="/js/script.js"></script>

                    
                        <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
                            
</body>

</html>