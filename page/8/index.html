<!DOCTYPE html>
<html class="has-navbar-fixed-top">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Jake.Lee&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="google-site-verification" content="PgpnJMuvO-IqYWyFljnyr-tusLhJUz1VRMmECenJyHE">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">






<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="/css/style.css">
<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>

</head>

<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">Categories</a>
            
            <a class="navbar-item " href="/tags">Tags</a>
            
            <a class="navbar-item " href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" href="https://github.com/frontalnh">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

        <section class="section">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6354931397950820",
    enable_page_level_ads: true
  });
</script>

    <div class="container">
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/22/event-sourcing-and-cqrs/" itemprop="url">
                Event Sourcing And CQRS
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-22T04:51:07.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                8 minutes read (About 1244 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="event-sourcing">Event Sourcing</span></h1><p>이벤트 소싱이란 기존의 관계형 데이터베이스의 저장 방식과 달리 데이터 저장을 수많은 이벤트들을 묶음으로 저장하는 것을 의미한다.<br>사실 event sourcing 이란 사실 현실에서는 너무도 흔한 방법이다. 가령 회계장부를 기록한다고 할때 우리는 회사의 보유 자금을 현재 상태만을 기록하는 것이 아니라 과거 매출, 비용 등의 합산으로 계산한다. 그래야 과거의 정보가 투명하게 공개되고 다양한 재무 데이터의 활용이 가능하기 때문이다. 이처럼 실제 행위의 집합들을 저장하는 방식을 event sourcing이라 한다.</p>
<p>하지만, 다음과 같은 경우를 생각해보자<br>만약 과거의 데이터를 수정해야 할 일이 생긴다면 어떨까?<br>이 경우도 실제 회계에서 하는 방법과 같은 원칙을 따른다. 바로 과거의 특정 기록으로 돌아가 해당 부분만을 수정하고 뒤를 전부 다시 작성하는 것이다. 이는 매우 비효율 적이어 보이지만 데이터 그 자체가 매우 중요한 회계에서는 너무도 당연한 진리이다.</p>
<p>이는 데이터 혹은 이벤틀의 삭제에도 영향을 주는데, event soucing에서는 원칙적으로 delete가 없다. 이는 회계장부 작성과도 그 흐름을 동일시 하는데, 가령 회계장부를 작성할 때에는 잘못된 정보를 기입하면 그 후에 그를 상쇄시키는 추가적인 기록을 추가한다. 그래야만 누군가가 고의로 데이터를 조작했는데와 같은 정보들을 유추할 수 있기 때문이다. 동일한 논리가 event sourcing에서도 적용된다.</p>
<p><strong>왜 이런 event sourcing이 현대 software에서 중요하게 되었을까?</strong></p>
<p>그것은 바로 현대 사회에서 데이터의 가치가 너무도 중요하기 때문이다. 과거 쇼핑몰에서는 고객이 단순히 구매 혹은 판매 등의 정보만을 기록한 반면 요즘 사회에서는 장바구니에 물건을 넣었다 빼는 빈도와 주기 시기 등에 대한 데이터를 활용하여 각종 비즈니스 정책들이 결정되며 이 모든 사소한 행위 데이터를 기록하는 것은 너무도 중요하고 그것이 event sourcing의 필요성이다.</p>
<p>이처럼 event sourcing을 통한다면, 특정 시기의 정확한 상황을 재현할 수 있는데, 가령 우리가 역사를 기록하는 것과 같은 원리이다. 특정 시기의 단편적 정보가 아닌 그 시기에 일어나는 일련의 사건들을 정확히 재구현 할 수 있을때 즉, 마치 타임머신을 타고 여행하듯이 정치 사회 경제에 대한 총체적인 재구성을 통해서만 그 시기의 명확한 사회적 상황을 알 수 있다. 이처럼 비즈니스 세계에서도 event sourcing을 통해 과거의 특정 상황에 대한 명확한 인사이트를 가질 수 있다.</p>
<p>이러한 event sourcing 은 소프트웨어 테스트 시에도 활용될 수 있다.<br>가령, 기존의 모든 테스트 행위를 event로 기록해 놓으면, 개발이 완료된 뒤에 정확히 같은 테스트를 수천번이고 반복해서 수행해 볼 수 있다.<br>가령 보험 서비스의 경우에 A 라는 사람의 주소가 바뀌면 Manager가 해당 주소가 바뀜을 알리고 회계부서, 지급 부서 등 많은 부서에 해당 사실을 알리고 로직을 처리해야 한다. 하지만 event 를 사용하면 그저 Manager는 쿨하게 “A의 주소가 바뀜!” 만을 외치면 기타 여러 부서에서 주의깊게 관찰하고 있다가 이벤트가 발생하면 그에 맞는 로직을 스스로가 처리하여 Manager의 독립성이 높아지게 된다.</p>
<p>그 순서는 다음과 같다.</p>
<ol>
<li>Command 발생</li>
<li>Command Hander에 발생한 Command를 전달하고 event 발생</li>
<li>aggregation 변형</li>
</ol>
<h2><span id="cqrs-패턴이란">CQRS 패턴이란?</span></h2><p>위와 같은 event sourcing에 있어 데이터의 읽기와 쓰기는 너무도 다른 기능이다. 쓰기의 경우 특정 이벤트를 저장하는 아주 단순한 로직인데 반해 읽기의 경우 읽기의 구간 특정 시기의 스냅샷과 같은 복잡한 로직이 동반되는 경우가 다반사 이다.</p>
<p>CQRS에서는 이렇게 이벤트의 저장과 읽기를 위해 두 종류의 명령을 내리는데 하나는 데이터를 저장하는 <code>Command</code> 와 이벤트를 읽어 오는 <code>query</code> 이다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/22/나만의-발자국을-남겨라/" itemprop="url">
                나만의 발자국을 남겨라
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-21T23:36:42.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                5 minutes read (About 766 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>나는 벤저민 프랭클린을 참 좋아한다.</p>
<p>철저한 자기관리와 건국의 아버지로 알려진 프랭클린, 나는 그의 자기 관리를 위한 노력이나 훌륭한 일을 하려 하는 긍지보다 다른 부분에 집중하고자 한다.</p>
<p>그것은 바로 그는 변치않는 신념과 스스로에 대한 믿음으로 묵묵히 자신의 길을 걸었다는 것이다.</p>
<p>주변의 시선과 자신이 처한 환경, 미래에 대한 불안에 대해 그는 거의 언급하지 않았다.</p>
<p>그저 자신이 처한 환경에서 조금 더 나아질 수 있는 방법을 찾았고, 끊임없이 내가 필요하고 더 나은 사람이 되기위해 정진해 나갔다.</p>
<p>인생을 살아가는 정도라는 것이 무의미해 지고, 한치앞을 내다 볼 수 없는 오늘의 사회에는 더욱더 가장 본받아야 할 점이 아닌가 생각된다.</p>
<p>흔히 인생을 살아나가는 것은 눈덮힌 산을 오르는 것에 비유된다.</p>
<p>가장 연륜있고, 실력있는 선구자는 우리를 앞서 오르고 대부분의 우리는 선구자가 남긴 발자국을 따라 오르며 끊임없이 내가 올바른 발걸음을 디뎠는지 생각한다.</p>
<p>내 눈앞의 수많은 발자국을 보며 어느 길이 가장 쉽고 효과적인 길인지를 가늠하려 하고, 내가 걸어온 발자국을 보며 산턱 언저리에서 후회와 불안에 이따금 뒤돌아 우두커니 서있는 것이다.</p>
<p>하지만, 정말 산을 잘 오르는 사람들은 오로지 정상만을 바라보고 오를 뿐이다.</p>
<p>우리 앞을 지나간 선구자는 물론 도움이 될 수 있지만, 그 사람이 어떤 상황에 있었는지 그때의 날씨는 어땠는지 우리는 알지 못하며, 가장 올바른 선택은 목적지에 시선을 던져두고 나를 믿고 신중하게 한걸음 한걸음을 옮기는 것인 것을 그들은 잘 아는 것이다.</p>
<p>요즘 세상을 무한 경쟁사회라고 한다.</p>
<p>주변을 달려가는 수많은 주자들을 바라보며 조바심을 느끼게 만드는 사회에서 많은 사람들이 고작 한치 앞에 있는 사람을 꽁무니 만을 쫓게도 되고, 한발작 뒤에 있는 주자들을 보며 가끔은 안도하기도 할 것이다.</p>
<p>이 글을 쓰는 필자도 또 마음을 다잡고자 이런글을 쓰는지 모른다.</p>
<p>오늘 하루도 앞서나가는 자에대한 조바심을 뒤따라 오는 자에 대한 오만함을 내려놓고 정상만을 바라보며 누구의 발자국도 아닌 나의 발자국을 남길 수 있는 하루, 내면의 단단함이 더해지는 하루가 되기를 바란다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/21/c-언어-상수와-기본-자료형/" itemprop="url">
                C 언어 | 상수와 기본 자료형
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-21T01:25:42.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/c-언어-강의/">C 언어 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                9 minutes read (About 1391 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="자료형이란-무엇인가요">자료형이란 무엇인가요?</span></h1><p>자료형이란 데이터를 표현하는 기준이 되며, <strong>정수형 자료형</strong>, 혹은 <strong>실수형 자료형</strong> 인지 등의 데이터의 표현 기준을 정해주고, 명확한 데이터의 크기를 알려줌으로써 메모리에 보다 효과적으로 자료가 저장될 수 있도록 해줍니다.</p>
<p>대표적인 자료형으로는 char, int, float, double 등이 있으며 각각 1바이트, 4바이트, 4바이트, 8바이트의 크기를 가집니다.</p>
<p>이러한 자료형의 크기를 구하는 연산자로는 <strong>sizeof()</strong> 함수가 있으며 다음과 같이 사용합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = 1</span><br><span class="line">numSize = sizeof(num)</span><br></pre></td></tr></table></figure></p>
<p>우리가 컴퓨터에서 표현하는 자료는 앞서 말했듯이 정수와 실수의 큰 기준으로 나뉘게 되며, 여기서 실수형을 표현하는 경우 정확도 향상을 위해 <strong>float 이 아닌 double을 사용</strong> 합니다.</p>
<h1><span id="또-어떤-자료형들이-있나요">또 어떤 자료형들이 있나요?</span></h1><p>C 프로그래밍 시에 자료형 앞에 unsigned와 같은 키워드가 붙은 것을 많이 보았을 겁니다.<br>이 것은 바로 해당 자료형이 unsigned로 나타내는 것을 의미하며 즉, 음수를 구분하지는 못하지만 2배 더 큰 숫자까지 나타낼 수 있게 해주는 것을 의미합니다.</p>
<p>그밖에, 문자를 표현하기 위한 char 자료형이 있는데 이는 ASCII 코드에 의거하여 문자를 나타내는 것을 의미합니다.<br>이러한 ASCII 코드는 1바이트 즉 256가지의 문자를 표현하며, 기본적으로 컴퓨터 내에서 정수형 자료형으로 나타내어 지므로, 정수형 표현과 문자형 표현이 모두 가능합니다.</p>
<p>가령 다음의 예제를 살펴봅시다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char examplChar = &quot;a&quot;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d&quot;, examplChar)</span><br></pre></td></tr></table></figure></p>
<p>이 경우 문자 a의 정수형 표현을 ASCII 코드표에서 찾아 나타내어 줍니다.</p>
<h1><span id="상수란-무엇인가요">상수란 무엇인가요?</span></h1><p>상수는 int, double에 근거한 것으로 메모리 내에 이름이 없는 literal 상수와 이름이 있는 symbolic 상수로 구분됩니다.<br>이러한 상수는 한번 선언되면 그 값이 바뀔 수 없으며, 만약 이름이 있는 symbolic 상수로 선언되는 경우 이름은 대문자와 아래바 <code>_</code> 로 구성되는 것이 일반적입니다.</p>
<p>다음의 예는 literal 상수의 예를 보여줍니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int exampleNum = 5 + 6</span><br></pre></td></tr></table></figure></p>
<p>이렇게 literal 상수는 별도의 선언이 없이 값을 나타내며, 위의 경우 5와 6은 literal 상수입니다.</p>
<p>다음은 symbolic 상수의 예를 나타냅니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int MAGIC_NUMBER = 1</span><br></pre></td></tr></table></figure></p>
<p>이렇게 기본 자료형 int 앞에 const 키워드를 붙여 줌으로써 symbolic 상수를 선언하며, 선언과 동시에 초기화가 되어야 합니다.</p>
<p><strong>만약 상수에 자료형을 지정해 주고 싶다면 어떻게 할까요?</strong></p>
<p>다음은 상수 자료형에 float 으로 표기를 지정해 주는 예를 나타냅니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long exampleNum = 5.1235L</span><br></pre></td></tr></table></figure></p>
<p>이처럼 상수의 뒤에 U, L, UL, LL, F 등을 나타냄으로써 자료형을 알려줄 수 있습니다.</p>
<h1><span id="자료형-형-변환">자료형 형 변환</span></h1><p>이렇게 한번 선언된 자료형은 프로그래밍 도중에 변경될 수 있으며 이것을 <strong>형 변환</strong> 이라고 합니다.</p>
<p>형변환 에는 자동으로 형이 변환되는 <strong>자동 형 변환</strong> 과 사용자가 형을 변환해 주는 <strong>강제 형 변환</strong> 이 있습니다.</p>
<p>먼저 자동 형 변환은 보통 자료형을 일치시켜 계산해야 하는 경우 또는 대입 시에 강제로 형 변환이 되는 경우, 연산 시 빠른 연산을 위해 CPU 에서 자동으로 변환이 되는 경우가 있습니다.</p>
<p>먼저 자료형 일치를 위한 자동 형 변환의 예를 살펴봅시다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num1 = 5</span><br><span class="line">double num2 = 5.6235</span><br><span class="line">double result = num1 + num2</span><br></pre></td></tr></table></figure></p>
<p>위의 예의 경우 num1 과 num2 는 다른 자료형을 가졌기 때문에, 덧셈연산이 불가능 합니다.<br>이렇게 되면 컴퓨터는 자동으로 num1 과 num2 중 하나의 자료형에 맞추어 연산을 진행하게 되는데, 그 판단의 근거는 <strong>정확도를 높이는 방향</strong> 으로 진행된다는 것 입니다.</p>
<p>위 예의 경우 num1 과 num2 가 int 형으로 변환되어 계산이 된다면 큰 오차가 생기므로 적은 오차범위를 가지도록 둘 다 double 형으로 변환이 되어 계산이 되게 됩니다.</p>
<p>다음 예는 대입의 과정에서 자동 형 변환이 일어나는 경우입니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num1 = 129</span><br><span class="line">char result = num1</span><br></pre></td></tr></table></figure></p>
<p>num1 은 int 형으로 선언이 되었지만 char 자료형에 할당됨에 따라 4바이트에서 1바이트로 그 크기가 줄어들게 됩니다.<br>이 경우에는 최상위 바이트의 손실이 일어나게 되며 이 경우 00000000 00000000 00000000 10000001 에서 10000001 로 바뀌게 되어 부호가 바뀌게 되는 문제가 생깁니다.</p>
<p>다음은 <strong>강제 형 변환</strong> 의 예를 살펴봅시다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num1 = 5</span><br><span class="line">int num2 = 10</span><br><span class="line">double result</span><br><span class="line"></span><br><span class="line">result = (double)num1/num2</span><br></pre></td></tr></table></figure></p>
<p>위 예는 num1과 num2의 연산을 통해 얻은 0.5를 double로 강제 형 변환 시켜주어 result에 할당하는 예를 보여줍니다.<br>이처럼 (자료형) 키워드를 앞에 붙여줌으로써 강제로 해당 자료형을 바꾸어 줄 수 있습니다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/20/z_루소의-사회계약론-사회의-권위는-어떻게-생겨나는가/" itemprop="url">
                루소의 사회계약론, 사회의 권위는 어떻게 생겨나는가?
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-20T01:44:24.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                13 minutes read (About 1957 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>루소의 [사회계약론]은 밖으로 표출된 정치 현실의 차원에서 문제를 제기하는 대신 정치적 질서의 기반, 다시 말해 그것의 배후의 메커니즘에 대한 원리적 접근을 시도하며, 나아가 정치적 권력 또는 권위의 정당성은 어떻게 획득되는가를 다루고 있다.</p>
<p>루소는 ‘폭력’이 최초의 노예를 만들어 내었고, 그 노예들의 비열함이 노예상태를 영속시킨다고 보았다.<br>사람은 사실 인간이기 이전에 동물로써 힘에 굴복하는 것은 어떻게 보면 불가피한 행위이기에 강한자가 약한자를 노예로 삼는 것을 막을 방법 따위는 없었다. 그것이 ‘자연의 법칙’ 이었고, 모든 생물학적 생태계의 ‘약육강식’의 법칙을 따르는 자연스러운 일이었다. 또, 약한자가 비열함을 벗어내는 방법은 목숨을 담보로한 도전 밖에 없었으며, 대부분의 경우는 죽음으로 귀결되었기에 노예상태는 영속되었다.</p>
<p>하지만, ‘힘과 권위’ 라는 것은 사실 시간이 지나면 사라지게 되는 것이고, 과거의 강한 힘을 가진 사람들도 늙고 노쇠해짐에 따라 과거의 모든 영광은 뒤로하고 냉혹한 자연의 질서에 굴복되어 버리기에, 대부분의 사람들은 대체로 좋은 결말을 맞이할 수 없는것이 현실이었다. 이렇게 시간이 지남에 따라 사람들은 이렇게 무자비한 ‘동물의 법칙’을 벗어나 상호간의 약속을 통해 삶의 질을 올릴 수 있는 방법을 찾게 되었고, 여기서 최초의 ‘사회 계약’ 이 이루어 지게 되었고, <strong>공동체</strong> 라는 개념이 생겨나게 되었다.</p>
<p>공동체를 구성하는 각 구성원의 신체와 재산을 방어하고 ‘인간다운 삶’을 보장받기 위해 서로와 서로 사이에 계약을 하게 되고, 이를 통해 ‘공공의 힘’을 가지게 되어 각 개인은 그러한 ‘공공의 힘’으로 부터 보호 받고 자기 자신의 의지에 따라 한 ‘계약’ 에게만 복종함으로써 각 개인은 타인에게 복종을 하지 않는 자유로운 삶을 보장받을 수 있게 되었다. 즉, 과거처럼 ‘힘’에 의해 누군가의 노예가 되지 않을 수 있고, 자신이 혼자서 생존하기 어려운 많은 제약 속에서도 최소한의 인간적인 삶을 보장받게 되었으며, 이러한 공동체의 구성원들의 집합적인 의미로 <strong>국민</strong>, 주권에 참여하는 개인이라는 뜻에서 <strong>시민</strong>, 국가의 법률에 종속된다는 의미로 <strong>신민</strong> 이라는 용어들이 생겨나게 되었다.</p>
<p>사회의 계약이 강화됨에 따라 개인적인 인격은 사라지고, 이 결합행위는 하나의 집합적인 법인체 즉, 도시국가, 공화국을 만들게 된다.<br>이렇게 다수가 결합하여 한 단체를 이루면 누구도 그 단체를 공격하기 전에는 한 사람의 구성원도 해칠 수 없기에 각 구성원은 완벽한 동맹을 이루게 되고, 이런 굳건한 동맹관계가 원활히 수행되기 위해서는 각 개인이 지켜야할 많은 것들이 있었으며, 이에 따라 각 개인의 ‘자연적 신분’에서 ‘시민’ 으로 이행되었다. 이 과정에서 과거에는 볼 수 없었던 <strong>도덕성</strong> 을 부여되었고, 이는 사회적으로 큰 변화의 시작이었다.</p>
<p>오늘날 대부분의 사람들이 인간이라면 태어날 때 부터 당연하게 여겨질 것이라 생각되는 이 <strong>도덕성</strong> 은 사실 인류가 모두 비극적인 결말을 맞이하지 않기 위한 서로간의 약속이자 비자연적이고 인위적인 단지 <strong>하나의 규약</strong> 에 불과하였으나, 오늘날에는 사회의 탄탄한 기반으로 거듭났고, 이는 <strong>사회 계약</strong> 의 기본적인 토대로써 다음과 같은 목적성을 가지게 된다.</p>
<blockquote>
<p>자연적 평등을 파괴하는 것이 아니라 반대로 인간들 사이에 자연적으로 생겨날 수 있는 육체적 불평등을 도덕적이고 합법적인 평등으로 대치한다는 것,<br>그리고 인간은 체력 또는 재능에 있어 불평등할 수 있는 만큼 계약에 의해 그리고 법으로써 모두가 평등하게 된다.</p>
</blockquote>
<p>이렇게 사회 계약론은 모두에게 이득이 되는 최고의 계약이라 생각될 수 있지만, 그 이면에는 다양한 문제들이 존재한다.</p>
<p>사실 과거의 생태계에서 가진자와 가지지 못한 자의는 그렇게 크지 않았으며, 그 이유는 역설적이게도 ‘약육강식’의 법칙이 존재했기 때문이다.<br>동물은 시간이 지나면 자연스럽게 쇠퇴하게 되고 과거 가지지 못했던 자는 ‘무력’을 통해 때로는 ‘약탈’ 과 ‘살해’를 통해 가진자의 재산을 빼앗아 올 수 있었다.<br>또, 무리에서 도태되거나 약자인 개체는 때로는 무리에 의해 강제로 살해되기도 하고 스스로 경쟁력이 가지지 못하는 개체를 과감히 제거함으로써 사회 전체의 생산성을 유지하고 살벌한 긴장속에서 살아 나갔다.</p>
<p>하지만, 현대 사회의 ‘사회 계약’을 대변하는 ‘법’은 실제로 항상 유산자에게는 유익하고 무산자에게는 해로울 수 밖에 없다.<br>애초에 이 계약이란 개인이 가진 재산을 타인으로 부터 보호하기 위함이며 누군가의 범법행위가 이루어지지 않는 이상 개인이 가진 재산은 그 사람의 힘과 재능에 관계없이 오랜 시간이 지나도 유지될 수 있다. 이 재산은 세습이라는 형태로 계속해서 누적될 수 있지만, 가진게 없고 지킬게 없는 사람들에게 ‘약탈’ 과 ‘탈취’ 를 막는 ‘법률’은 사실 큰 도움이 되지 못하는 것이 현실이기 때문이다.</p>
<p>오늘날 민주 사회에서 이런 ‘사회 계약’의 이면은 충분히 극복될 수 있으며, 이는 무산자에게 유산자가 될 수 있는 동등한 기회를 제공함과, 사회 계약을 유지하기 위한 유산자의 사회적 기여를 강화함으로써 실현되고 있다.</p>
<p>‘유산자’ 는 우리의 공동체가 자신의 재산을 지켜주고 과거 야생에서 시간이 지남에 따라 잔혹한 결말을 맞이하지 않게 해 주는 것에 대한 감사와 시민으로써의 책임감을 가져야 하며, 누구보다 체제를 지켜나가고 무산자와의 합의점에 이르기 위해 체제를 지키기 위한 경제적 사회적 비용을 제공해야 할 의무가 있음을 의식해야 하며, 무산자라면 우리 공동체가 제공하는 무궁한 기회를 통해 성장해 나가고 훗날 공동체의 훌륭한 시민이 되기 위해 정진해 나가야 할 것이다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/17/z_domain-driven-design/" itemprop="url">
                Domain Driven Design 이란 무엇인가?
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-17T11:23:49.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                28 minutes read (About 4255 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="domain-driven-design-이란-무엇인가">Domain Driven Design 이란 무엇인가</span></h1><h2><span id="what-is-domain">What is domain?</span></h2><p>도메인의 사전적 의미는 “정보와 활동의 영역” 을 말하며, 흔히 프로그래머들에게는 어플리케이션 내의 로직들이 관여하는 정보와 활동의 영역이라고 받아들여 집니다.<br>가령, 어떤 웹 서비스를 만들 때 회원을 가입하고, 회원을 탈퇴하는 일련의 작업은 “회원” 과 관련된 일련의 작업들이며 여기서 “회원” 이라는 도메인이 있다고 볼 수 있습니다.</p>
<p>또 다른 용어로써 “domain layer” 와 “domain login” 이라는 용어가 있습니다. 이는 개발자들에게 일종의 “business logic” 과 동등한 것으로 받아들여져 왔습니다. 이러한 business login 은 비즈니스 주체들(가령 회원, 결제 등) 이 어떤 모델링 된 데이터를 생성하거나 변경하기 위해 서로간에 약속한 높은 수준의 규칙들을 의미합니다.</p>
<h2><span id="ddddomain-driven-desing">DDD(Domain Driven Desing)</span></h2><p>도메인 주도 디자인이란 개발을 함에 있어 위에서 설명한 도메인이 중심이 되는 개발 방식을 말하며, 그 목적은 소프트웨어의 연관된 부분들을 연결하여 계속 해서 진화하는 새로운 모델을 만들어 나가 복잡한 어플리케이션을 만드는 것을 쉽게 해 주는 것에 있습니다.<br>DDD의 핵심적인 목표는 Loose Coupling, High Cohesion 으로 각 도메인이 연결성이 적고 높은 정도로 연관되어 보다 가벼운 설계를 위해 탄생하였습니다.</p>
<p><strong>다음은 DDD의 세가지 주요 원리입니다.</strong></p>
<ol>
<li>핵심 도메인과 그 기능에 집중하라.</li>
<li>도메인의 모델의 정교하게 구축하라.</li>
<li>어플리케이션 모델을 발전시키고 새롭게 생기는 도메인 관련 이슈를 해결하기 위해 도메인 전문가와 끊임없이 협력하라.</li>
</ol>
<h2><span id="strategic-design">Strategic Design</span></h2><p>소프트웨어를 디자인 할 때 객체를 기준으로 디자인을 진행하는 것은 Object Oriented Design 이라고 하는데, 이러한 관점에서 볼 때 Strategic Design은 OOD가 잘 이루어진 것으로 볼 수 있습니다.</p>
<p>Strategic Design이란 Context 에 대해 생각하고 이를 기준으로 디자인을 하는 것을 말합니다.</p>
<p>여기서 Context란 무엇일까요?</p>
<p>Context 란 특정 객체 혹은 상황이 벌어지는 주변 환경을 말합니다. 가장 쉬운 예로 가게 안에 접시에 담긴 피자와 혹은 길에 버려진 피자를 생각해 봅시다. 같은 피자이지만 피자가 매장 안의 접시에 있는지 혹은 길에 있는지에 따라 유료, 무료의 차이가 생기게 되고 사실상 다른 것으로 간주될 수 있습니다. 이처럼 같은 사물이나 행동 양상이 벌어지는 상황에 집중하여 디자인을 하는 것이 Strategic Design 의 핵심이라고 할 수 있다.</p>
<p>Strategic Design을 이해하기 위해 간단한 예로 주택을 짓는 경우를 생각해 봅시다. 우리가 원하는 집을 짓기 위해서 우리가 하는 행동 절차는 다음과 같습니다.</p>
<ol>
<li>어떤 주택을 지을지 생각을 해 본다.</li>
<li>그런 뒤에 우리는 <strong>Domain Expert</strong> 즉, 이 경우 집 전문가와 상의를 한다.</li>
<li>주택을 지을 때 어떤 핵심적인 가치에 집중하여 집을 지을지를 선택합니다. 가령 헛간이 넓어야 한다던가, 수영장이 커야 한다던가 중점적인 사항을 명시합니다.</li>
<li>그 뒤 우리는 이미 지어진 다른 집들을 최대한 많이 조사하여 마음속에서 원하는 집의 형상을 떠올려 봅니다.</li>
<li>그런 뒤에 우리는 그 형상을 실제 집으로 만들어 내기 위해 모델링을 하고</li>
<li>이를 토대로 구체적인 설계도를 그려 나갑니다. 이 설계도에는 집의 아주 구체적인 부분들이 명시되게 됩니다.</li>
</ol>
<p>이렇게 DDD를 통한 설계 과정에서 사용되는 용어는 다음과 같습니다.</p>
<p>먼저 집 전체에 대한 설계의 전체를 우리는 <strong>domain</strong> 이라고 부르며, 커다란 집의 각각의 부분 집합인 헛간, 농장, 수영장 등 큰 파트들을 <strong>subdomain</strong> 이라고 부릅니다. 또 각각의 subdomain에 대해 각 subdomain의 문맥적 상황을 <strong>bounded context</strong> 라고 부르며, 실제 subdomain의 구체적인 형상을 나타내는 것을 <strong>domain model</strong> 이라고 부릅니다.</p>
<p>여기서 <strong>bounded context</strong> 가 가지는 의미는 바로 특정 모델이 어떤 bounded context 에 속하는 가에 따라서 다른 의미를 가지기 때문입니다.<br>가령, 주택 건축시에 정문에서 caretaker라는 모델이 있다면 이는 바로 경비원을 말하는 것일 겁니다. 하지만 caretaker라는 단어가 메인 주거 건물 안에서 가지는 의미는 이와 다를 수 있습니다.</p>
<p>이 내용을 간단히 정리하면 다음과 같습니다.</p>
<p><strong>Context</strong><br>의미를 결정하는 것 처럼 보이는 단어 나 문장이 나타나는 설정으로, 모델에 관한 문장은 context 안에서만 이해될 수 있다.<br>주택을 구성하는 각 부분 구간들에 대한 환경을 말한다.</p>
<p><strong>Model</strong><br>도메인의 특정 양상을 묘사한느 추상화 시스템으로 도메인과 관련된 문제를 해결하는 데 사용된다.</p>
<p><strong>Ubiquitous Language</strong><br>소프트웨어를 만들기 위해서는 많은 사람들이 원활히 소통해야 하고 여기에는 다양한 용어들이 사용된다. </p>
<p>가령, 기획자, 디자이너, 개발자가 모인 자리에서 각자 서로의 언어로 대화를 한다면 이는 원활한 커뮤니케이션을 심각하게 저해하게 된다.</p>
<p>이 경우에 필요한 것이 Ubiquitous Language이며 이는 domain model 을 둘러싼 언어구조를 말한다.</p>
<p>이 언어는 팀 전체가 각각의 업무 파트에서 공통적으로 사용될 수 있어야 하며, 실제 개발의 측면에서 모든 기획자, 디자이너, 개발자가 공통된 어휘를 사용해야 서로간에 이견이 없을 것이며 이러한 공통된 어휘를 ubiquitous language라고 합니다.</p>
<p><strong>Bounded Context</strong><br>위에서 설명한 Context에 대한 구체적인 설명으로, 특정 모델이 정의되고 적용될 수 있는 영역을 이야기 합니다.<br>주택을 짓는 경우에 빗대어 생각해 볼 때, Bounded Context는 주택 전체를 구성하는 헛간, 농장, 수영장, 메인 주택 등의 큰 요소들 각각을 둘러싼 상황을 의미합니다.<br>특정 모델은 어떤 bounded context에 놓이는가에 따라 다르게 이해될 수 있습니다.<br>실제 소프트웨어를 구축함에서의 예를 들면 가령 sales를 담당한하는 subdomain이 있을 수 있고, 이를 지원하는 support와 accounting 라는 subdomain 이 존재할 수 있습니다. 이러한 각각의 subdomain이 놓인 환경인 bounded context 내에서 특정 모델 <strong>customer</strong> 가 보여지는 시각은 매우 상이할 수 있습니다. sales 팀에서 고객을 보는 시각은 주로 사회적 관심사, 좋아하는 것, 욕구 등의 것일 겁니다. 하지만 accounting의 측면에서는 사용자는 그저 하나의 계정으로써 그 사람의 결제정보 만이 중요한 정보일 수 있습니다. 즉 각기 다른 bounded context에서 ubiquitous language는 비록 표현은 같지만 다른 의미를 가지게 됩니다.</p>
<p><strong>Context Map</strong><br>각 bounded context들 사이의 관계를 말하며 즉, 주택 건축시에 헛간, 뒷간, 수영장 등 큰 요소들이 어떤식으로 서로 연관이 되어 있는지를 나타낸다.</p>
<p><strong>Domain Model</strong><br>Domain Model 이란 실제 세계를 반영하는 구체적인 설계로, 주택 건축시에 주택을 구성하는 메인 주택의 구체적인 설계도를 말한다.</p>
<p><img src="..\images\strategicDesign의ProblemSpace와SolutionSpace.png" alt="strategic design의 Problem Space와 Solution Space"></p>
<h2><span id="tactical-design">Tactical Design</span></h2><p><img src="..\images\tacticalDesign.png" alt="Tactical Design"></p>
<p>Tactical Design Tool 들은 세부적인 사항을 구현하는 것을 위해 필요하며, 주로 Bounded Context 내의 구성 요소들을 관리합니다.<br>이것은 개발상의 실제적인 표준을 제공하는데 services, entities, repositories, factories 와 같은 소프트웨어 디렉토리 구조들에 익숙한 개발자들이 많을 것인데, 이 모든 것은 전부 DDD에서 나온 개념입니다. 이러한 Tactical Design은 Strategic Design과 달리 개발을 진행하는 과정에서 계속해서 바뀌고 개선됩니다.</p>
<h2><span id="model-driven-design-and-service">Model Driven Design And Service</span></h2><p><img src="..\images\modelDrivenDesign.png" alt="Model Driven Design"></p>
<p>Tactical Design을 이해하기 위한 Model Driven Design은 위와 같다.<br>실제 구현은 모델 수준에서 이루어 지고 쉽게 비유하자면 당신의 소프트웨어 전체 즉, domain을 하나의 세계로 표현한다면 각 나라는 subdomain에 해당되고 각 subdomain은 각 나라의 언어인 ubiquitous language를 사용하게 됩니다. 이렇게 각 subdomain은 하나의 Service로 구현되게 됩니다.</p>
<h2><span id="layered-architecture">Layered Architecture</span></h2><p>layered Architecture란 쉽게 말하면 모든 프로세스를 업무순서로 쪼게어 층을 나누어 수행하는 것이다.<br>가령 맥도날드의 예를 들어보자. 맥도날드에서는 각 종업원들이 맡은 업무를 충실하게 수행하여 아주 효과적으로 업무를 처리한다. 만약 맥도날드의 종업원들이 요리, 계산, 서빙 등 많은 업무를 업무 분담 없이 하게 된다면 분명히 큰 혼란이 초래되고 손님들은 오랜시간 동안 기다려야 하고 형편없는 음식을 먹게 될 것이다. 하지만 맥도날드는 손님을 응대하는 계산원, 주문을 전달하고 컨트롤 하는 중간 매개인, 전체 프로세스에 필요한 인프라를 제공하는 요리사, 사장, 매니저, 필요한 재료들을 보관하는 창고 등으로 구성되어 빠르고 효과적으로 일을 처리한다.</p>
<p>소프트웨어에서도 마찬가지로 고객을 응대하는 request handler, 이를 중재하는 controller, 각종 중요한 비즈니스 로직을 처리하는 business, 다양한 자료구조 등으로 구성되어 클라이언트에 보다 빨리, 조직적으로, 잘 응대할수 있게 되었고, 이에 따라 보다 유연하고 지속가능한 소프트웨어를 구축할 수 있게 되었으며, 각 파트는 자신의 역할을 충실히 수행하고 필요한 경우 여러번 재사용 될 수 있게 된다.</p>
<h2><span id="value-object">Value Object</span></h2><p>소프트웨어의 모델을 구성하는 수치에 대한 객체이며 훌륭한 디자인을 위한 가장 중요한 요소 중의 하나이다.<br>가령 소프트웨어 내에 화폐를 취급하는 객체가 있다면, 이는 화폐에 관한 모든 처리를 누군가의 도움 없이 스스로 잘 처리할 수 있어야 한다.<br>단위 환산, 표현법 변경 등 다양한 도메인 로직을 가져야 하며, 스스로 옳바른 값인지 validate 할 수 있어야 할 뿐 아니라 값이 제 3자에 의해 변하지 않고 일관성을 유지해야 한다.</p>
<p>가령 string 객체를 생각해 보자. 이 객체는 문자 어레이를 다루는 value object로써 substring 등의 다양한 기능을 수행하기 때문에 이를 일일히 정의할 필요가 없어져 ubiquitous language 로 소프트웨어의 표현을 간단하게 하고 보강해 준다.</p>
<h2><span id="entity">Entity</span></h2><p>기존의 attributes 를 기준으로 정의되었던 전통적인 객체와 달리, 연속성의 일관된 스레드에 의해 식별되는 객체이다.<br>일반적인 개발자들이 이 개념에 대해 알고 있다. Entity는 Value Object로 구성되며 대표적인 예로 db에 있는 row들의 예를 들 수 있다.<br>Entity는 identified id 를 가지고 business logic을 구현한다.</p>
<h2><span id="aggregate-와-domain-events">Aggregate 와 Domain Events</span></h2><p>aggregates는 entities의 집합이다. 가령 cutomer, customerInfo, address 라는 세가지 종류의 entities를 생각해 보자. 사실 이 모든 정보는 customer라는 주제로 뭉칠 수 있으며, 여기서 핵심이 되는 entitiy인 customer는 이 세 entities가 이루는 aggregates의 root entity가 된다. 이렇게 되면, 다른 외부 객체는 aggregate 내의 객체로 직접 접근할 수 없고, 하나의 aggregate root item 즉 customer 에만 접근이 가능하며, 이를 통해 해당 aggregate 내에 명령을 전달해야 한다. 이는 실제 프로그래밍에 자주 쓰이는 디자인 패턴 중의 하나이다.</p>
<p>더욱 간편한 예로는 포스트와 댓글의 관계, 질문과 답변의 관계 등이 있다.</p>
<p>여기서 <strong>Domain Event</strong> 라는 개념에 대해 살표보자.<br>domain event는 모델의 특정 행동과 관련된 이벤트인데, Aggregate 사이의 일관성을 유지하는데에 사용될 수 있다.<br>가령 사용자의 주소가 바뀌면 주문 내용도 바뀌어야 하는데, 순서를 살펴보면 사용자의 주소가 바뀌면 같은 aggregate내에 있는 사용자 정보가 바뀌게 되고 이러한 aggregate의 변화는 주문과 관련된 aggregate의 변화를 촉구하기 위해 domain event를 발생시켜 상호간의 정보의 일치를 이룬다.</p>
<h2><span id="factories">Factories</span></h2><p>Factories는 복잡한 entity 혹은 aggregate를 생성하는 것을 담당한다.<br>가령 엔진과 부속품을 넣으면 자동차가 나오는 공장과 같이 특정 정보를 factory에 보내면 결과로 aggregate 혹은 entity를 만들어주게 되고, 그 안에서 벌어지는 일에 대해서는 개발자들이 더 이상 신경을 쓰지 않아도 되고, 하나의 모듈로써 사용할 수 있다.</p>
<h2><span id="repositories">Repositories</span></h2><p>일반적인 저장소와 달리 특정 aggregate에 보다 신속하게 접근하고 aggregate 단위로 데이터를 처리할 수 있게 해 준다.<br>가령 위의 예처럼 customer 가 root entity로 있는 aggregate의 경우 1개의 repo를 만들게 되고, 사용자는 더 이상 기존의 db에서 고객 이름, 나이, 생년 등을 조합해서 사용하지 않고 repo에 aggregate를 통으로 저장해서 보다 쉽게 정보에 접근하고 정보를 변경할 수 있다.</p>
<h2><span id="ddd를-통해-얻을-수-있는것">DDD를 통해 얻을 수 있는것</span></h2><p>Domain-driven design also heavily emphasizes the ever-more-popular practice of continuous integration, which asks the entire development team to use one shared code repository and push commits to it daily (if not multiple times a day). An automatic process executes at the end of the work day, which checks the integrity of the entire code base, running automated unit tests, regression tests, and the like, to quickly detect any potential problems that may have been introduced in the latest commits.</p>
<h2><span id="ddd-구현">DDD 구현</span></h2><h3><span id="어떻게-domain-expert와-협의할-것인가">어떻게 domain expert와 협의할 것인가</span></h3><p>과거에 Use Case Diagram, Sequence Diagram 등 많을 것을 썻다.<br>때로는 ER Diagram도 사용했다.</p>
<p>하지만 요즘에는 이런 옛 방법을 사용하지 않고, Event Storming을 한다.</p>
<p>이것은 strategic design 을 위해 도메인 모델을 만들기 위한 연습이다.<br>개발 전문가와 domain 전문가가 만나서 브레인 스토밍을 통해 각 도메인에서 어떤 내용들이 필요할지에 대한 직관을 기른다.</p>
<h3><span id="진행-단계">진행 단계</span></h3><ol>
<li>domain expert 와 개발 전문가와 함께 서로간의 질문을 하는 미팅 시간을 가진다.</li>
<li>포스트잇에 색깔에 따라 events, commands, policies, processes, errors, roles, aggregates, etc 등을 적어 놓는다.<br>본 미팅은 event storming 이므로 이벤트를 시간의 순서에 따라 어플리케이션에서 발생 가능한 주요한 이벤트들을 나열한다.<br>가령 쇼핑몰의 경우 상품 열람 =&gt; 상품 구매 =&gt; 상품 배송 =&gt; 배송 완료 처럼 디테일한 이벤트들을 순서대로 나열한다.</li>
<li>다음은 이러한 이벤트들의 포스트잇 주변에 연관된 system action, user action 등을 쭉 붙인다.</li>
<li>이러한 과정이 마무리 되면 이제 bounded context 를 찾을 시간이다.<br>나열된 리스트를 보면 어느정도 분리된 subdomain 들이 보이게 되는데 가령 catalog, payments, delivery 등의 subdomain이 될 수 있다.</li>
</ol>
<hr>
<p><a href="https://www.youtube.com/watch?v=wD-d0oZI4YM&amp;list=PLZBNtT95PIW3BPNYF5pYOi4MJjg_boXCG" target="_blank" rel="noopener">참고자료 - Alpha Code 동영상 강의</a></p>
<p><strong><strong> all images are from Alpha Code Lecture Above </strong></strong></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/14/z_어떻게-상사를-대할-것인가/" itemprop="url">
                어떻게 상사를 대할 것인가?
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-14T10:41:48.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                6 minutes read (About 869 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>오늘은 조직생활과 관련하여 많은 사람들이 겪고 있는 직장 상사와의 갈등에 대해 생각해보고자 한다.</p>
<p>많은 사람들이 직장생활의 가장 큰 어려움으로 상사와의 갈등을 꼽고 있다. 과연 세상의 모든 상사들은 다 나쁜 사람인가? 라는 생각이 든다.</p>
<p>본 글은 어디까지나 사회생활에 대한 필자의 주관적인 생각만을 적어보는 것으로 본 글이 직장 내 상사와의 갈등에 대한 일반적인 해안은 결코 되지 못하는 것을 인지하고 있음을 먼저 밝히고 글을 시작한다.</p>
<p>직장 상사를 대하는 태도 대한 일반적인 관념은 어떠한가 부터 생각해 보자.</p>
<p>흔히 직장상사를 이야기 할때 ‘모신다’ 혹은 ‘사수’, ‘배운다’ 등의 단어가 일반적이다.</p>
<p>사실 이런 단어는 벌써부터 직장 상사와 나의 관계가 상/하 관계 혹은 갑/을 관계, 선임자/후임자의 수직적인 관계라고 화자 스스로가 생각하는 경우 사용된다.</p>
<p>따라서 후임자는 직장 상사의 말에 최대한 맞추려고 하고, 직장 상사가 나를 한 없이 착하고, 성실한 그런 ‘직원’ 이자 ‘후임자’로 보여지기를 원한다.</p>
<p>하지만, 이런 태도는 과연 현명한 처신일까?</p>
<p>과연 직장 상사는 ‘후임자’, ‘하급자’ 를 필요로 하고 훌륭한 ‘을’이 필요한 것일까?</p>
<p>이에 대한 필자의 생각은 ‘아니다’ 이다.</p>
<p>기업은 더 이상 학교이자 가정이 아니며 ‘하급자’, ‘직원’ 보다는 <strong>비즈니스 파트너</strong> 가 필요한 것이다.</p>
<p>착하고 말잘듣는 직원보다는, 좀 쌀쌀 맞더라도 잘난 <strong>나</strong> 와 그래도 잘 합을 맞출 수 있는 <strong>파트너</strong> 가 되어 주기를 원한다.</p>
<p>선임자가 상대방을 <strong>후임자</strong> 가 아닌 <strong>파트너</strong> 로 인정하게 되는 순간 선임자는 선임으로써의 <strong>버팀목</strong> 이 되어주어야 한다는 책임감을 덜어내고 인간 대 인간으로써 함께 협력하여 일을 해 나갈 수 있기 때문이다.</p>
<p>사실 남자라면 누구나 공감하겠지만 수직문화의 끝을 보여주는 군대에서는 이런 장면들을 많이 보아왔을 것이다.</p>
<p>항상 착하기만 하고 저 친구 정말 고생하는구나 하는 후임과 동기들은 어디까지나 보호해야할 대상이며 나의 아랫사람으로 많은 경우 힘든일은 혼자 다하면서도 정작 인정은 받지 못하는 많은 병사들이 있는 반면, 좀 뺀질거리더라도 눈치 빠르고 소신있는 병사들은 <strong>전우</strong> 로써 인정을 받는 경우는 아주 흔한 일이다.</p>
<p>인생을 살아가면서 언제나 우리는 조직의 한 가운데에 놓여있게 된다.</p>
<p>필자를 비롯한 이 글을 읽는 독자들도 당돌하고 일 좀 하는 <strong>비즈니스 파트너</strong> 로써 상급자의 도움이 필요없는 믿을만한 파트너로 거듭나 훌륭한 사회의 조직원으로 거듭난다면 더할나위 없이 좋은 일일 것이다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/14/go-language-시작하기/" itemprop="url">
                go language 시작하기
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-14T04:45:04.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                7 minutes read (About 1111 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="설치하기">설치하기</span></h1><p>Go 는 패키지 매니저가 없으며 VCS에서 직접 받아와서 라이브러리를 사용합니다.</p>
<p>먼저, 다음 페이지에서 window 용 Go 를 설치해줍니다.</p>
<p><a href="https://golang.org/dl/" target="_blank" rel="noopener">공식 다운로드 사이트</a></p>
<p>설치가 완료 되었다면. 아래와 같은 구조로 디렉터리를 만들어 줍니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Go/</span><br><span class="line">  bin/</span><br><span class="line">  pkg/</span><br><span class="line">  src/</span><br></pre></td></tr></table></figure></p>
<h1><span id="maingo-만들기">main.go 만들기</span></h1><p><strong>main.go</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main //namespace declaration 하는 부분으로 기능과 논리들을 그룹화시켜준다.</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot; // format의 약자로 standard lib에 있다.</span><br><span class="line"></span><br><span class="line">// 여기서 main 은 keyword 로써 해당 함수가 라이브러리가 아닌 어플리케이션으로 동작함을 나타낸다.</span><br><span class="line">// go 어플리케이션이 여기서 시작된다.</span><br><span class="line">// func는 function을 선언하는 keyword 이다.</span><br><span class="line">func main() &#123;</span><br><span class="line">  fmt.Println(&quot;Hello, World&quot;) //여기서 println의 앞의 P가 대문자 인데, 이는 외부 라이브러리에서 가져왔음을 의미한다.</span><br><span class="line">                              // 같은 원리로 함수를 선언할때 대문자로 시작하면 외부에서 접근이 가능한 것이다.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>실행하기</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure></p>
<p><strong>빌드하기</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go build # 실행가능한 binary 파일을 만들어 준다.</span><br><span class="line">이 경우 파일명이 아니라 폴더 명으로 파일이 생성된다.</span><br><span class="line">./go-study</span><br><span class="line"></span><br><span class="line">윈도우용 빌드</span><br><span class="line">GOOS=windows go build -o main.exe main.go</span><br></pre></td></tr></table></figure></p>
<h1><span id="슬라이스">슬라이스</span></h1><p>슬라이스는 배열의 값을 가리킵니다(point). 그리고 배열의 길이를 가지고 있습니다.</p>
<p>[]T 는 타입 T 를 가지는 요소의 슬라이스(slice) 입니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    p := []int&#123;2, 3, 5, 7, 11, 13&#125;</span><br><span class="line">    fmt.Println(&quot;p ==&quot;, p)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; len(p); i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;p[%d] == %d\n&quot;,</span><br><span class="line">            i, p[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="레인지">레인지</span></h1><p>for 반복문에서 range 를 사용하면 슬라이스나 맵을 순회(iterates)할 수 있습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i, v := range pow &#123;</span><br><span class="line">        fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>_ 를 이용해서 인덱스(index)나 값(value)를 무시할 수 있습니다.</p>
<p>만약 인덱스만 필요하다면 “ <code>, value</code> ” 부분을 다 제거하면 됩니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    pow := make([]int, 10)</span><br><span class="line">    for i := range pow &#123;</span><br><span class="line">        pow[i] = 1 &lt;&lt; uint(i)</span><br><span class="line">    &#125;</span><br><span class="line">    for _, value := range pow &#123;</span><br><span class="line">        fmt.Printf(&quot;%d\n&quot;, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="맵">맵</span></h1><p>맵은 값에 키를 지정합니다.</p>
<p>맵은 반드시 사용하기 전에 make 를 명시해야합니다. (주의: new 가 아닙니다)</p>
<p>make 를 수행하지 않은 nil 에는 값을 할당할 수 없습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">    Lat, Long float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m map[string]Vertex</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    m = make(map[string]Vertex)</span><br><span class="line">    m[&quot;Bell Labs&quot;] = Vertex&#123;</span><br><span class="line">        40.68433, -74.39967,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m[&quot;Bell Labs&quot;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>맵 리터럴 (Map literals)</strong><br>맵 리터럴은 구조체 리터럴과 비슷하지만 key 를 반드시 지정해야 합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">    Lat, Long float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m = map[string]Vertex&#123;</span><br><span class="line">    &quot;Bell Labs&quot;: Vertex&#123;</span><br><span class="line">        40.68433, -74.39967,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;Google&quot;: Vertex&#123;</span><br><span class="line">        37.42202, -122.08408,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>다양한 함수<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    m := make(map[string]int)</span><br><span class="line"></span><br><span class="line">    m[&quot;Answer&quot;] = 42</span><br><span class="line">    fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])</span><br><span class="line"></span><br><span class="line">    m[&quot;Answer&quot;] = 48</span><br><span class="line">    fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])</span><br><span class="line"></span><br><span class="line">    delete(m, &quot;Answer&quot;)</span><br><span class="line">    fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])</span><br><span class="line"></span><br><span class="line">    v, ok := m[&quot;Answer&quot;]</span><br><span class="line">    fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="switch">switch</span></h1><p>다른 일반적인 언어를 아는 분이라면 switch 에 대해서 잘 알 것입니다.</p>
<p>다른 언어와 다른점은 case의 코드 실행을 마치면 알아서 break를 한다는 점입니다.</p>
<p>( fallthrough 로 끝나는 case는 스스로 break를 하지 않습니다 )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Print(&quot;Go runs on &quot;)</span><br><span class="line">    switch os := runtime.GOOS; os &#123;</span><br><span class="line">    case &quot;darwin&quot;:</span><br><span class="line">        fmt.Println(&quot;OS X.&quot;)</span><br><span class="line">    case &quot;linux&quot;:</span><br><span class="line">        fmt.Println(&quot;Linux.&quot;)</span><br><span class="line">    default:</span><br><span class="line">        // freebsd, openbsd,</span><br><span class="line">        // plan9, windows...</span><br><span class="line">        fmt.Printf(&quot;%s.&quot;, os)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="메소드">메소드</span></h1><p>고에는 클래스가 없습니다. 하지만 메소드를 구조체(struct)에 붙일 수 있습니다.</p>
<p>메소드 리시버(method receiver) 는 func 키워드와 메소드의 이름 사이에 인자로 들어갑니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">    X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Abs() float64 &#123;</span><br><span class="line">    return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    v := &amp;Vertex&#123;3, 4&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="인터페이스">인터페이스</span></h1><p>인터페이스는 메소드의 집합으로 정의됩니다.</p>
<p>그 메소드들의 구현되어 있는 타입의 값은 모두 인터페이스 타입의 값이 될 수 있습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Abser interface &#123;</span><br><span class="line">    Abs() float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var a Abser</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    v := Vertex&#123;3, 4&#125;</span><br><span class="line"></span><br><span class="line">    a = f  // a MyFloat implements Abser</span><br><span class="line">    a = &amp;v // a *Vertex implements Abser</span><br><span class="line">    a = v  // a Vertex, does NOT</span><br><span class="line">    // implement Abser</span><br><span class="line"></span><br><span class="line">    fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MyFloat float64</span><br><span class="line"></span><br><span class="line">func (f MyFloat) Abs() float64 &#123;</span><br><span class="line">    if f &lt; 0 &#123;</span><br><span class="line">        return float64(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    return float64(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">    X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Abs() float64 &#123;</span><br><span class="line">    return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br></pre></td></tr></table></figure></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/13/영화-인썸니아-insomnia/" itemprop="url">
                영화 인썸니아(Insomnia)
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-13T01:04:07.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                7 minutes read (About 991 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>살면서 누구나 한번쯤은 돌이킬 수 없는 잘못된 결정으로 인한 실수를 진실을 왜곡함으로써 해결하고 싶은 강한 욕망에 휩싸이는 순간이 있다.<br>가장 사소한 예로, 학창시절 선생님이 교실에서 어떤 잘못을 저지른 사람에게 자백을 요구하는 훈계를 듣는 경우는 사실 누구나 한번쯤은 있었던 경험일 것이다. 나는 항상 그 상황에서 진짜 잘못을 저지른 사람은 어떤 마음일까 하는 생각을 하고 했다. 그 상황이 나에게는 그저 귀찮은 일인 반면 그 당사자에게는 얼마나 큰 마음의 짐이 될까를 생각해보면 생각만으로도 암담한 일이 아닐 수 없었다.</p>
<p>인간은 누구나 실수를 하기에 많은 사람들이 이런 욕망에 휩싸일 수 있고, 두가지 선택지만을 가진다. 진실을 밝히는가 혹은 진실을 숨기는가.</p>
<p>많은 경우에 전자의 선택지는 너무도 큰 희생이 필요할 수 있다. 내가 일생동안 살아온 나의 신념을 배반하는 감당할 수 없는 실수로 내 인생을 송두리 째 바꾸어 놓을 것만 같고, 다시는 회생할 수 없을 것 같은 암담한 미래가 그려진다. 반면, 두번째 선택지는 너무도 달콤하다. 나의 실수를 없던 것으로 하는것. 그것은 마치 시간을 되돌리는 것처럼 단 한번만 진실을 감추면 모든 문제가 해결 될 것만 같다.</p>
<p>사실 이런 이야기는 영화나 책속에나 나올법 한 일이라고 생각할 수 있지만, 사실 사회의 많은 곳들에서 흔히 일어나는 일중 하나이다. 대부분의 부패한 정치인 혹은 기업가, 범죄자들도 많은 경우 선량하고 옳바른 선택을 할 수 있었던 시절이 있었을 것이라 생각하고 또 누군가는 과거의 단 한번의 잘못된 처신을 평생을 후회하며 열심히 살아가고 있을지도 모른다.</p>
<p>이 영화는 그런 감당할수 없을 것 같은 실수에 대처하는 한 잘나가던 경찰의 이야기를 다룬다.<br>평생을 신념에 입각해서 살았고, 훌륭한 경찰로 살았지만, 단 한번의 선택으로 최악의 상황으로 치닫게 되며, 그러한 심적 부담과 ‘백야’ 라는 극중 설정으로 인해 불면증을 않아 점점 더 판단력을 잃어간다.<br>이러한 설정은 현실의 상황을 너무도 잘 반영한다. 진실을 은닉한 것에 대한 엄청난 마음의 부담은 그 사람에게 제대로된 판단을 할 힘을 앗아가고 결국 거짓의 구렁텅이로 빠져버리게 되는 것이다.</p>
<p>결국 영화는 우리가 살면서 겪을 이런 상황들에 대한 가장 쉽고 유일한 선택지를 제시하고 있다.</p>
<p>그것은 바로 “모든 진실을 밝히고 실수를 감내하는 것” 그리고 “최악의 상황에서도 옳바르게 행동할 판단력을 잃지 않는것”이다.</p>
<p>그 어떤 순간에서도 한치앞의 달콤한 유혹을 뿌리치고 진실로 삶을대하는 것이 남은 인생을 위한 최고의 선택지이며, 실수를 할 수 밖에 없는 인간으로써 모든 결정적인 실수에 대한 책임을 감내하고 살아야 하는 것은 인간의 숙명이기에 최악의 상황에서도 판단력을 잃지않고 올바른 선택을 할 수 있는 용기와 힘을 가지도록 노력해야 할 것이다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/12/z_블록체인이란-무엇인가/" itemprop="url">
                블록체인이란 무엇인가?
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-12T03:53:09.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                29 minutes read (About 4396 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="블록체인의-탄생">블록체인의 탄생</span></h1><p>현대 사회에서 기술의 발전의 가장 큰 흐름은 바로 <strong>atom world</strong> 를 <strong>bit world</strong> 로 옮기려 한다는 것이다.<br>모든 실제 세계의 정보와 행동 양식 더 넘어서는 시장 그 자체에 이르기 까지 모든 atom world 즉, 실제 세계의 모든 것을 컴퓨터 사이의 네트워크로 구성되는 bit world 에 밀어 넣으려는 다양한 시도들이 계속되었다.</p>
<p>흔히, Database 즉, 데이터를 넣기위한 저장공간은 실제로 현대사회에서 모든 권리를 대변하고 있다.<br>은행의 돈, 국가에서 개인의 신분 등 모든 중요한 정보들은 database 내에 존재하고 실제가 어떻게 되었든 <strong>database 안의 내용이 곧 진리인 사회속에서 우리는 살아가고 있다.</strong> 심지어는 database에 명확하게 들어가지 못하는 많은 정보들은 그 가치를 잃어가는 사회이기도 하다.</p>
<p>하지만, 이렇게 모든 현실 세계의 데이터를 database라는 꽉막힌 틀이 쑤셔넣는 것은 상당한 노력을 필요로 하는 일이고, 심지어 이러한 데이터베이스는 단지 하나의 컴퓨터에 존재하는 bit 덩어리에 불과하기 때문에 사람들이 서로가 소통해서 문제를 해결하듯이 database와 database 사이에서 원활하게 정보를 교류하여 문제를 빠르게 처리하는 것은 매우 어렵다.</p>
<p>각 database는 서로 다른 형태로 존재하고 때문에 우리는 유사한 정보를 수도없이 많이 컴퓨터에게 가르쳐 주어야 한다.<br>흔한 예로 우리는 수많은 사이트에 수도없이 많이 같은 주소를 입력하고, 정부에서 민원을 처리하는 경우 각 부서를 옮겨다니면서 수십번씩 이름과 개인 정보를 입력하는 수고를 들여서 일을 처리해야 한다. 이는 너무나도 비효율적인 시스템이 아닐 수 없다.</p>
<p>시간이 지나고 우리는 이렇게 유연하지 못한 database의 홍수 속에서 어떻게 각각의 database를 통합하여 보다 유연하고 효율적인 데이터의 흐름을 만들어 낼 수 있을지 고민하게 되고 3가지의 해안을 제시하게 되었다.</p>
<p><strong>1.Diverse peers model</strong><br>첫번째 방법은 단순히 컴퓨터와 컴퓨터를 연결하는 것이다.<br>흔히 오늘날에는 결제를 하기 위해 쇼핑몰과 통신하고, 쇼핑몰은 은행과 은행은 다시 국세청과 정보를 교환해야 한다.<br>이렇게 하나의 단순 작업을 처리하기 위해서 각 peer들이 계속해서 통신을 해야하고 매일매일 소프트웨어를 업그레이드해야 할 뿐만 아니라 버그에도 매우 취약하다.</p>
<p>또 하나의 심각한 문제는 무엇이 진짜인지를 알 수 없다는 것이다.<br>진리는 존재하지 않고 각 peer 들 내부의 database의 수치값만이 존재하기 때문에 정보가 일관되지 않은 경우가 빈번하게 일어난다.<br>가령 내가 쇼핑몰에서 물건을 주문과 결제를했는데 쇼핑몰 내의 database에서 내가 결제한 정보가 없다고 선언해 버린다면 우리는 대처할 수 있는 방법이 사실상 거의 없다고 보아도 무관하다.<br>또 A 업체와 B 업체가 거래를 하려고 하는데 서로가 가진 재고량과 주문, 발송량이 일치하지 않는 경우 심각한 문제를 초래하게 된다.</p>
<p><strong>2.Hub and Spoke</strong><br>두번째 방법은 이렇게 어려움 프로세스를 맡아줄 중앙 허브를 두는 것이다.<br>많은 peer들이 직접 서로가 1:1 로 수십번 정보의 일관성을 흐리지 않고 정보를 교환하는 것은 매우 어렵기 때문에 이 모든 일을 다 처리해줄 마법같은 서비스들이 등장하게 되었다. 가령 결제사라던가 전자인증정보 시스템, VISA 처럼 수많은 peer들과 올바로 통신하고 데이터의 일관성을 보장해주는 중앙기관이 생기고 나머지 모든 peer는 이러한 중앙기관에 의존해 업무를 처리하는 것이다.</p>
<p>사실상 이러한 시스템은 자연적 독점기업이라고 보아도 무방하다. 이렇게 수많은 peer 들이 정보를 교환하는데 이 중앙 기업은 technical cost 라는 명목으로 막대한 부를 축적하고 당신의 신용과 정보에 대한 완벽한 통제권을 가지고 있다. 이는 전혀 민주적이지 못하며 VISA 사의 경우 전 세계 거래의 1% 라는 천문학적인 수입을 올릴 수 있는 시스템이 완성되는 것이다.</p>
<p><strong>3.Protocol - if you can find them</strong><br>프로토콜은 궁극의 유니콘 같은 존재이다. 최적의 프로토콜을 찾으면 이러한 database의 완벽한 통합을 할 수 있겠지만, 현실 세계에서는 아무도 그런 프로토콜을 가지고 있지 못하다.<br>HTTP, HTML, SMTP 등 많은 standard 들이 생겨나게 되었지만 아직 많은 한계들이 보인다.<br>가령 slack 이나 Gchat의 경우 각 플랫폼 내의 사용자들이 서로간에 소통할 수 있도록 기존의 프로토콜사용하여 훌륭하게 동작시키고 있지만, 각 기업들 사이에 데이터를 교환하는 것은 불가능하다. 왜냐하면 각 기업이 어떤 프로토콜을 사용하는지를 공개하지 않기 때문이다. 때문에, 모든 서비스에 접근하여 중재역할을 하기 위해서는 각 게이트웨이를 해킹하는 수밖에는 없다.</p>
<p>블록체인은 위의 세가지 해안이 극복하지 못하는 많은 부분을 해결해 줄 해안으로 떠올랐고 그것이 블록체인의 시작이다.</p>
<p><a href="https://media.consensys.net/programmable-blockchains-in-context-ethereum-s-future-cd8451eb421e" target="_blank" rel="noopener">참고자료 - Programmable Blockchains in Context: Ethereum’s Future by vinay gupta</a></p>
<h1><span id="블록체인이란-무엇인가요">블록체인이란 무엇인가요?</span></h1><p>블록체인이란 수많은 컴퓨터들을 연결하여 모든 컴퓨터가 동일한 체인 형태의 정보 리스트를 가지도록 하는 분산 컴퓨팅 기반의 데이터 위변조 기술이다.<br>이 때 저장하고자 하는 데이터는 작은 정보들의 집합인 블록으로 구성되고 각 블록들이 서로 연결고리를 가지게 하여 누구도 중간 블록을 수정할 수 없고, 변경의 결과를 열람할 수 있게된다.</p>
<p>이러한 블록체인의 가장 큰 특징은 바로 분산 노드의 운영자가 임의로 데이터를 조작하지 못한다는 것이다.<br>가령 기존의 데이터베이스의 경우 데이터베이스의 관리자가 손쉽게 데이터베이스를 조작할 수 있었고, 악한 마음을 가진다면 이를 기정사실화 하여 각종 보안 문제들에 휘말리게 된다. 하지만 블록체인의 경우 각 블록들이 수정되면 전체 연결고리가 깨어지게 되어 근본적으로 기존의 데이터를 수정하지 못하도록 고안되었기에 데이터베이스 관리자가 모든 권한을 가졌던 기존의 중앙집권적 권력체계가 무너지게 된다고 볼 수 있기에 보다 민주적인 형태의 데이터 저장 기술로 칭송받고 있다.</p>
<p>이러한 분산 시스템을 운영함에 있어 가장 큰 문제 중 하나는 <strong>비잔틴 장군 문제(Byzantine General Problems)</strong> 이다.<br>여기서는 적군의 도시를 공격하려는 비잔티움 제국군의 여러 부대가 지리적으로 떨어진 상태에서 각 부대의 지휘관들이 (중간에 잡힐지도 모르는) 전령을 통해 교신하면서 공격 계획을 함께 세우는 상황을 가정하고 있습니다. 이 부대의 지휘관 중 일부에는 배신자가 섞여있을 수 있고, 배신자는 규칙을 충실히 따르는 충직한 지휘관들과 달리 규칙에 얽매이지 않고 마음대로 행동할 수 있다. 이 때 배신자의 존재에도 불구하고 충직한 지휘관들이 동일한 공격 계획을 세우기 위해서는 충직한 지휘관들의 수가 얼마나 있어야 하며, 이 지휘관들이 어떤 규칙을 따라 교신해야 하는지에 대한 문제가 비잔티움 장군 문제이다.</p>
<p>블록체인 기술은 이러한 비잔틴 장군 문제를 최초로 해결하였으며 비잔틴 장군 문제에 대한 내성이 있다는 의미로 <strong>비잔틴 장애 허용(BFT)</strong> 시스템 중의 하나이다.</p>
<h1><span id="블록체인-플랫폼-이더리움-백서에-대한-설명">블록체인 플랫폼 이더리움 백서에 대한 설명</span></h1><p>현대 가상화폐의 근간이 되는 블록체인 기술의 핵심은 시간의 흐름에 따른 각 노드의 상태를 저장하는 UTXO(Unspent Transaction Output) 를 모두 저장하는 것이다.<br>각 트랜잭션은 k개의 input을 가지고 각 입력은 UTXO에 대한 레퍼런스를 가지며 특정 노드의 상태는 이러한 UTXO의 리스트로 구성된다.</p>
<p>블록은 10분 간격으로 생성되며, 각 블록은 <strong>timestamp, nonce, hash of previous block, transaction list</strong> 로 구성되며 블록을 생성하기 위한 과정을 <strong>채굴(mining)</strong> 이라고 하며 다음의 단계에 따라 진행된다.</p>
<ol>
<li>이전 블록의 해시값 검사</li>
<li>블록의 timestamp가 이전 블록의 것보다 크고 2시간이 경과하지 않은지 검사</li>
<li>POW</li>
<li>상태집합 S 의 S[0] 에 이전 블록의 마지막 상태값을 저장</li>
<li>0 ~ n-1 의 모든 i에 대해 S[i+1] = APPLY(S[i], TX[i]) 를 수행</li>
<li>마지막 블록에 상태값 S[n] 를 등록</li>
</ol>
<p>위 과정을 완료한 뒤에 해당 블록의 헤더를 해싱하고 그 해시를 풀기 위한 nonce를 무작위값을 계속 대입하면서 구함. = &gt; mining</p>
<h2><span id="블록의-구조">블록의 구조</span></h2><p>블록은 위에서 언급했듯이 <strong>timestamp, nonce, hash of previous block, transaction list</strong> 로 구성되는데, 이 중에서 transaction list는 블록 데이터 부분에 저장되고 나머지는 블록 헤더에 저장이된다. 또, 블록 헤더에는 블록데이터에 대한 해시값이 저장되는데, 이 해시값은 <strong>머클트리</strong> 형태로 저장된 트랜잭션 리스트의 root hash의 값으로 하나의 트랜잭션이라도 조작되면 이 값이 바뀌게 되어 블록이 변질되었음을 알 수 있게 된다.</p>
<p>여기서 <strong>머클트리</strong> 란, 가령 n 개의 트랜잭션이 있다면 높이가 log(n)인 이진트리 형태로 구성되며, 각 부모는 자식의 해시를 가지게 되어 하나의 트랜잭션만 바뀌어도 수많은 노드의 해시값이 바뀌게 되는 트리이다.</p>
<p>이러한 블록들은 level DB 에 bloack hash 를 키로 블록 데이터를 value로 저장됩니다.<br>이러한 db의 종류는 block_hash db, block_number db, transaction db 등이 있습니다.</p>
<h2><span id="보안의-원리">보안의 원리</span></h2><p>블록체인은 어떠한 원리로 보안을 유지하는가?</p>
<p>먼저 다음과 같은 경우를 통해 블록체인을 훼손하는 경우를 생각해 보자.<br>먼저 가장 마지막 블록번호가 270번 블록이라고 하자.</p>
<ol>
<li>사용자가 특정 상인에게 100BTC 를 입금한다.</li>
<li>상인이 사용자에게 디지털 재화를 전송한다(순식간에 전송 가능하다고 전재한다.)</li>
<li>사용자가 스스로에게 100BTC를 입금한다.</li>
</ol>
<p>이 경우 블록체인은 3의 트랜잭션을 보 정상적인 state에 있지 않은 utxo라 판단하게 되고 사용자의 블록체인은 따로 분기되게 된다.<br>만약 그 동안 1시간이 경과하였다면 하지만 그와 동시에 다른 사용자들은 계속해서 블록을 생성하여 271~275까지 많은양의 블록을 생성한 상태이고 그들이 가리키는 해시값은 사용자의 270번 블록이 아닌 블록체인의 270번 블록을 가리키게 되고 사용자의 노드는 기존 블록체인에서 분리되게 된다.</p>
<h2><span id="이더리움">이더리움</span></h2><p>이더리움의 기본 단위는 account 이며, EOA(External Owned Account) 와 Contract 두 종류의 account 가 있습니다.</p>
<p>EOA 는 메세지를 보내는 주체이며 message에 의해 contract가 조작됩니다.<br>여기서 message는 가상의 객체이며 송/수신자 정보와 데이터, eth 양 등의 정보를 담고 있습니다.ㄴ</p>
<p>Contract가 Call 을 수행할때 생성됩니다.</p>
<h1><span id="블록체인의-비잔틴-장군-문제-해결">블록체인의 비잔틴 장군 문제 해결</span></h1><p>블록체인에서는 모든 정보를 블록이라는 정보 뭉치의 연결로 보고 각 블록에는 암호화된 해시값이 있어 다음 블록을 가리키고 있는 형태로 구성되어 있습니다.<br>또한 다음 블록이 생성되기 위해서는 참여하는 노드의 절반이상이 해당 노드가 올바른 노드라고 판단해야 다음 블록이 연결될 수 있기 때문에, 악의적인 목적을 가진 노드가 몇 개 존재한다고 하더라도 안정적으로 동작을 함을 말합니다.</p>
<h1><span id="합의-알고리즘">합의 알고리즘</span></h1><h2><span id="pow">POW</span></h2><p>새로운 화폐가 생성되는 과정(조폐)에서, 생성자들(채굴자들)에게 “일을 했다는 것을 증명(proof of work)”하는 것을 강제하여 화폐의 가치와 보안을 보장하는 방식이다.</p>
<p>분산 네트워크에서는 조폐 과정에서 누가 얼마의 새 화폐를 받을지를 결정할 중앙 권력이 없기 때문에 모든 참여자들이 자동적으로 동의할 수 있는 방법이 필요하다. 이때 일방향함수인 해시 함수가 계산(검산)하기는 쉽지만 역을 구하는 것(채굴)은 어렵다는 것에 착안하여, 모든 참여자가 해시 함수를 계산해서 가장 먼저 계산한 사람이 새 화폐를 받아가게 하는 것.</p>
<p>최초로 상업적 성공을 거둔 암호화폐 비트코인의 경우, 블록체인의 다음 블록을 캐기 위한 해시 함수의 입력값에 거래내역을 담은 블록체인의 최신값을 연동시켜서, 송금과 조폐 양 기능과 보안을 동시에 해결하였다.</p>
<p>나무 위키 참조</p>
<h2><span id="pos">POS</span></h2><p>암호화폐에서 proof-of-stake의 이니셜. 가치 증명, 또는 지분 증명으로 번역된다.</p>
<p>POW와는 근본적으로 다른 조폐 개념으로, 신규 코인을 발행할 때 이미 기존에 코인을 가지고 있던 사람들에게 전체 대비 각각의 소지량의 비율만큼을 지급하는 방식이다. 즉 암호화폐하면 으레 생각하는 채굴이 없다! 단, 현실적으로 액수에 관계없이 코인을 보유한 모든 지갑에 일괄적으로 %를 더하는 것은 불가능하므로, 조폐 과정에 참여하고 싶은 사람들이 일정 액수를 걸고(stake), 렌덤하게 추첨하여 참여자들 중 한명에게 다음 블록 보상(신규 코인)이 돌아가는 방식을 쓴다. 당연히 더 많이 걸수록 당첨 확률이 늘어난다. 참여에 필요한 최소 액수가 적어도 한화 수억원 어치이므로, 일반인들은 마이닝 풀과 유사한 개념인 스테이크 풀에 코인을 위탁해서 추첨에 참여한다.</p>
<p>얼핏 들으면 돈놓고 돈먹는 헤괴한 시스템으로 보일 수 있으나, 코인캡의 등락 없이는 신규 코인이 잔뜩 발행돼도 개당 가격이 내려가므로 각 코인 소유자들의 자산 가치는 동일하게 유지됨을 알 수 있다. 특정 집단이 과반수를 차지할 경우 그들의 지분이 계속 늘어나는 폐해가 벌어질 수 있으나, 채굴의 51%공격과 마찬가지로 당사자들의 이해관계 때문에 자정능력을 가진다. 채굴(POW) 대비 가장 큰 장점은 채굴에 들어가는 막대한 양의 에너지 낭비 없이 조폐와 거래를 운용할 수 있다는 점이다. 단점은 탈중앙화된 신규 코인은 이런 식으로 발행하기가 쉽지 않다는 점.</p>
<p>퀀텀(Qtum) 등에서 POS를 채택하고 있다.</p>
<p>POW와 POS 외에 POI라는 기술도 있다.</p>
<p>나무위키 참조</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/11/이더리움-crowd-sale/" itemprop="url">
                이더리움 crowd sale
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-11T04:19:57.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                4 minutes read (About 528 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="토큰-생성">토큰 생성</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.20;</span><br><span class="line"></span><br><span class="line">contract MyToken &#123;</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">    /* This creates an array with all balances */</span><br><span class="line">    mapping (address =&gt; uint256) public balanceOf;</span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint8 public decimals;</span><br><span class="line">    /* Initializes contract with initial supply tokens to the creator of the contract */</span><br><span class="line">    function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public &#123;</span><br><span class="line">        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens</span><br><span class="line">        name = tokenName;                                   // Set the name for display purposes</span><br><span class="line">        symbol = tokenSymbol;                               // Set the symbol for display purposes</span><br><span class="line">        decimals = decimalUnits;                            // Amount of decimals for display purposes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Send coins */</span><br><span class="line">    function transfer(address _to, uint256 _value) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= _value);           // Check if the sender has enough</span><br><span class="line">        require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // Check for overflows</span><br><span class="line">        balanceOf[msg.sender] -= _value;                    // Subtract from the sender</span><br><span class="line">        balanceOf[_to] += _value;                           // Add the same to the recipient</span><br><span class="line">        /* Notify anyone listening that this transfer took place */</span><br><span class="line">        emit Transfer(msg.sender, _to, _value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>먼저 crowd sale을 진행하기 전에 crowd sale에서 사용할 토큰을 생성하고, crowd sale의 shares address에 등록해 준다.</p>
<h1><span id="crowd-sale-contract">crowd sale contract</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">interface token &#123;</span><br><span class="line">    function transfer(address receiver, uint amount) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Crowdsale &#123;</span><br><span class="line">    address public beneficiary;</span><br><span class="line">    uint public fundingGoal;</span><br><span class="line">    uint public amountRaised;</span><br><span class="line">    uint public deadline; //마감 기한</span><br><span class="line">    uint public price;</span><br><span class="line">    token public tokenReward;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    bool fundingGoalReached = false;</span><br><span class="line">    bool crowdsaleClosed = false;</span><br><span class="line"></span><br><span class="line">    event GoalReached(address recipient, uint totalAmountRaised);</span><br><span class="line">    event FundTransfer(address backer, uint amount, bool isContribution);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructor function</span><br><span class="line">     *</span><br><span class="line">     * Setup the owner</span><br><span class="line">     */</span><br><span class="line">    function Crowdsale(</span><br><span class="line">        address ifSuccessfulSendTo, //</span><br><span class="line">        uint fundingGoalInEthers, //이더 단위의 모금 목표액</span><br><span class="line">        uint durationInMinutes, //분 단위의 모금 기간</span><br><span class="line">        uint etherCostOfEachToken, //각 토큰 당 단위 가격(이더 기준)</span><br><span class="line">        address addressOfTokenUsedAsReward //모금의 보상으로 주어질 위에서 만든 토큰의 주소</span><br><span class="line">    ) public &#123;</span><br><span class="line">        beneficiary = ifSuccessfulSendTo;</span><br><span class="line">        fundingGoal = fundingGoalInEthers * 1 ether;</span><br><span class="line">        deadline = now + durationInMinutes * 1 minutes;</span><br><span class="line">        price = etherCostOfEachToken * 1 ether;</span><br><span class="line">        tokenReward = token(addressOfTokenUsedAsReward);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Fallback function</span><br><span class="line">     *</span><br><span class="line">     * The function without name is the default function that is called whenever anyone sends funds to a contract</span><br><span class="line">     */</span><br><span class="line">    function () payable public &#123;</span><br><span class="line">        require(!crowdsaleClosed);</span><br><span class="line">        uint amount = msg.value;</span><br><span class="line">        balanceOf[msg.sender] += amount;</span><br><span class="line">        amountRaised += amount;</span><br><span class="line">        tokenReward.transfer(msg.sender, amount / price);</span><br><span class="line">        emit FundTransfer(msg.sender, amount, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier afterDeadline() &#123; if (now &gt;= deadline) _; &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Check if goal was reached</span><br><span class="line">     *</span><br><span class="line">     * Checks if the goal or time limit has been reached and ends the campaign</span><br><span class="line">     */</span><br><span class="line">    function checkGoalReached() afterDeadline public &#123;</span><br><span class="line">        if (amountRaised &gt;= fundingGoal)&#123;</span><br><span class="line">            fundingGoalReached = true;</span><br><span class="line">            emit GoalReached(beneficiary, amountRaised);</span><br><span class="line">        &#125;</span><br><span class="line">        crowdsaleClosed = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Withdraw the funds</span><br><span class="line">     *</span><br><span class="line">     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,</span><br><span class="line">     * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw</span><br><span class="line">     * the amount they contributed.</span><br><span class="line">     */</span><br><span class="line">    function safeWithdrawal() afterDeadline public &#123;</span><br><span class="line">        if (!fundingGoalReached) &#123;</span><br><span class="line">            uint amount = balanceOf[msg.sender];</span><br><span class="line">            balanceOf[msg.sender] = 0;</span><br><span class="line">            if (amount &gt; 0) &#123;</span><br><span class="line">                if (msg.sender.send(amount)) &#123;</span><br><span class="line">                    emit FundTransfer(msg.sender, amount, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    balanceOf[msg.sender] = amount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (fundingGoalReached &amp;&amp; beneficiary == msg.sender) &#123;</span><br><span class="line">            if (beneficiary.send(amountRaised)) &#123;</span><br><span class="line">                emit FundTransfer(beneficiary, amountRaised, false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //If we fail to send the funds to beneficiary, unlock funders balance</span><br><span class="line">                fundingGoalReached = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                        
    </div>
    
            
</article>



        
    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/page/7/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/page/9/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/">1</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/7/">7</a></li>
        
        <li><a class="pagination-link is-current" href="/page/8/">8</a></li>
        
        <li><a class="pagination-link" href="/page/9/">9</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/22/">22</a></li>
        
    </ul>
</nav>
    
    </div>
</section>

            <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 Jake.Lee 이남훈&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" href="https://github.com/frontalnh">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
                <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        //plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110077250-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-110077250-2');
</script>


    


<script src="/js/script.js"></script>

                    
                        <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
                            
</body>

</html>