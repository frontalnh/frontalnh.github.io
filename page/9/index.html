<!DOCTYPE html>
<html class="has-navbar-fixed-top">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Jake.Lee&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="google-site-verification" content="PgpnJMuvO-IqYWyFljnyr-tusLhJUz1VRMmECenJyHE">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">






<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="/css/style.css">
<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>

</head>

<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">Categories</a>
            
            <a class="navbar-item " href="/tags">Tags</a>
            
            <a class="navbar-item " href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" href="https://github.com/frontalnh">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

        <section class="section">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6354931397950820",
    enable_page_level_ads: true
  });
</script>

    <div class="container">
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/30/dep을-통한-go-패키지-관리/" itemprop="url">
                go - dep을 통한 go 패키지 관리
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-30T01:22:04.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                a few seconds read (About 101 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h2><span id="installation">Installation</span></h2><p><strong>윈도우</strong><br><a href="https://github.com/golang/dep/releases" target="_blank" rel="noopener">https://github.com/golang/dep/releases</a></p>
<p>위 링크를 통해 설치를 진행한 뒤 해당 .exe 파일을 go rootpath의 bin 폴더 안에 넣어준다.</p>
<h2><span id="프로젝트-폴더-포팅">프로젝트 폴더 포팅</span></h2><p>dep을 사용하기 위해서는 반드시 다음과 같은 구조로 폴더를 만들고 포팅해야 한다.<br>GOPATH/src/github.com/directory/projectname</p>
<h2><span id="download">download</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep ensure</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://golang.github.io/dep/docs/introduction.html" target="_blank" rel="noopener">참조</a></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/24/grpc-시작하기/" itemprop="url">
                gRPC 시작하기
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-24T05:30:03.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                3 minutes read (About 448 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="grpc란-무엇인이며-어떻게-동작하는가">GRPC란 무엇인이며 어떻게 동작하는가?</span></h1><p>GRPC란 google에서 제공하는 rpc 프로토콜 프레임워크이다.<br>이를 통해 간편하게 클라이언트와 서버 간에 rpc 통신을 할 수 있게 해준다.</p>
<p>grpc의 간략한 동작 순서는 다음과 같다.</p>
<ul>
<li>서버에서 grpc server가 listen을 하고 있다.</li>
<li>클라이언트에서 gRPC stub을 통해 서비스에 접근한다.</li>
<li>서버에서 gRPC stub 명령을 받아 수행 후 클라이언트에 반환해 준다.</li>
</ul>
<p>gRPC를 통해 간편하게 server를 만들어 listen을 수행하고, 이를 호출하는 client 프로그램을 만들어 RPC 통신을 한다.</p>
<h3><span id="rpc-통신이란">RPC 통신이란?</span></h3><p>Remote Procedure Call 의 약어로 다른 컴퓨터에 있는 특정 method를 마치 자신의 컴퓨터에 있는 것처럼 호출하는 것으로 분산 어플리케이션과 서비스를 만드는데 중요한 역할을 한다.</p>
<p>grpc에서는 데이터 전송을 위한 marshal를 위해 protocall buffer를 사용한다.</p>
<h3><span id="protocall-buffer란">protocall buffer란?</span></h3><p>protocall buffer란 어떤 언어와 플랫폼에서도 사용가능하고 확장성이 좋으며, 통신 프로토콜이나 데이터 저장등에 사용하기 위해 정형화된 데이터를 serializing 할 수 있는 좋은 방법이다.<br>protocall buffer 에서는 serialize 하고자 하는 구조체가 .proto 파일에 메세지의 형태로써 정의되어야 한다.</p>
<p>이러한 .proto file은 protoc 컴파일러를 통하여 접근 가능한 객체로 변환되고, 각 언어에 맞는 protoc가 존재한다.</p>
<p><strong>.proto 파일의 예</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">message Person &#123;</span><br><span class="line">  required string name = 1;</span><br><span class="line">  required int32 id = 2;</span><br><span class="line">  optional string email = 3;</span><br><span class="line"></span><br><span class="line">  enum PhoneType &#123;</span><br><span class="line">    MOBILE = 0;</span><br><span class="line">    HOME = 1;</span><br><span class="line">    WORK = 2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    required string number = 1;</span><br><span class="line">    optional PhoneType type = 2 [default = HOME];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phone = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/22/event-sourcing-and-cqrs/" itemprop="url">
                Event Sourcing And CQRS
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-22T04:51:07.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                8 minutes read (About 1244 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="event-sourcing">Event Sourcing</span></h1><p>이벤트 소싱이란 기존의 관계형 데이터베이스의 저장 방식과 달리 데이터 저장을 수많은 이벤트들을 묶음으로 저장하는 것을 의미한다.<br>사실 event sourcing 이란 사실 현실에서는 너무도 흔한 방법이다. 가령 회계장부를 기록한다고 할때 우리는 회사의 보유 자금을 현재 상태만을 기록하는 것이 아니라 과거 매출, 비용 등의 합산으로 계산한다. 그래야 과거의 정보가 투명하게 공개되고 다양한 재무 데이터의 활용이 가능하기 때문이다. 이처럼 실제 행위의 집합들을 저장하는 방식을 event sourcing이라 한다.</p>
<p>하지만, 다음과 같은 경우를 생각해보자<br>만약 과거의 데이터를 수정해야 할 일이 생긴다면 어떨까?<br>이 경우도 실제 회계에서 하는 방법과 같은 원칙을 따른다. 바로 과거의 특정 기록으로 돌아가 해당 부분만을 수정하고 뒤를 전부 다시 작성하는 것이다. 이는 매우 비효율 적이어 보이지만 데이터 그 자체가 매우 중요한 회계에서는 너무도 당연한 진리이다.</p>
<p>이는 데이터 혹은 이벤틀의 삭제에도 영향을 주는데, event soucing에서는 원칙적으로 delete가 없다. 이는 회계장부 작성과도 그 흐름을 동일시 하는데, 가령 회계장부를 작성할 때에는 잘못된 정보를 기입하면 그 후에 그를 상쇄시키는 추가적인 기록을 추가한다. 그래야만 누군가가 고의로 데이터를 조작했는데와 같은 정보들을 유추할 수 있기 때문이다. 동일한 논리가 event sourcing에서도 적용된다.</p>
<p><strong>왜 이런 event sourcing이 현대 software에서 중요하게 되었을까?</strong></p>
<p>그것은 바로 현대 사회에서 데이터의 가치가 너무도 중요하기 때문이다. 과거 쇼핑몰에서는 고객이 단순히 구매 혹은 판매 등의 정보만을 기록한 반면 요즘 사회에서는 장바구니에 물건을 넣었다 빼는 빈도와 주기 시기 등에 대한 데이터를 활용하여 각종 비즈니스 정책들이 결정되며 이 모든 사소한 행위 데이터를 기록하는 것은 너무도 중요하고 그것이 event sourcing의 필요성이다.</p>
<p>이처럼 event sourcing을 통한다면, 특정 시기의 정확한 상황을 재현할 수 있는데, 가령 우리가 역사를 기록하는 것과 같은 원리이다. 특정 시기의 단편적 정보가 아닌 그 시기에 일어나는 일련의 사건들을 정확히 재구현 할 수 있을때 즉, 마치 타임머신을 타고 여행하듯이 정치 사회 경제에 대한 총체적인 재구성을 통해서만 그 시기의 명확한 사회적 상황을 알 수 있다. 이처럼 비즈니스 세계에서도 event sourcing을 통해 과거의 특정 상황에 대한 명확한 인사이트를 가질 수 있다.</p>
<p>이러한 event sourcing 은 소프트웨어 테스트 시에도 활용될 수 있다.<br>가령, 기존의 모든 테스트 행위를 event로 기록해 놓으면, 개발이 완료된 뒤에 정확히 같은 테스트를 수천번이고 반복해서 수행해 볼 수 있다.<br>가령 보험 서비스의 경우에 A 라는 사람의 주소가 바뀌면 Manager가 해당 주소가 바뀜을 알리고 회계부서, 지급 부서 등 많은 부서에 해당 사실을 알리고 로직을 처리해야 한다. 하지만 event 를 사용하면 그저 Manager는 쿨하게 “A의 주소가 바뀜!” 만을 외치면 기타 여러 부서에서 주의깊게 관찰하고 있다가 이벤트가 발생하면 그에 맞는 로직을 스스로가 처리하여 Manager의 독립성이 높아지게 된다.</p>
<p>그 순서는 다음과 같다.</p>
<ol>
<li>Command 발생</li>
<li>Command Hander에 발생한 Command를 전달하고 event 발생</li>
<li>aggregation 변형</li>
</ol>
<h2><span id="cqrs-패턴이란">CQRS 패턴이란?</span></h2><p>위와 같은 event sourcing에 있어 데이터의 읽기와 쓰기는 너무도 다른 기능이다. 쓰기의 경우 특정 이벤트를 저장하는 아주 단순한 로직인데 반해 읽기의 경우 읽기의 구간 특정 시기의 스냅샷과 같은 복잡한 로직이 동반되는 경우가 다반사 이다.</p>
<p>CQRS에서는 이렇게 이벤트의 저장과 읽기를 위해 두 종류의 명령을 내리는데 하나는 데이터를 저장하는 <code>Command</code> 와 이벤트를 읽어 오는 <code>query</code> 이다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/22/나만의-발자국을-남겨라/" itemprop="url">
                나만의 발자국을 남겨라
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-21T23:36:42.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                5 minutes read (About 766 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>나는 벤저민 프랭클린을 참 좋아한다.</p>
<p>철저한 자기관리와 건국의 아버지로 알려진 프랭클린, 나는 그의 자기 관리를 위한 노력이나 훌륭한 일을 하려 하는 긍지보다 다른 부분에 집중하고자 한다.</p>
<p>그것은 바로 그는 변치않는 신념과 스스로에 대한 믿음으로 묵묵히 자신의 길을 걸었다는 것이다.</p>
<p>주변의 시선과 자신이 처한 환경, 미래에 대한 불안에 대해 그는 거의 언급하지 않았다.</p>
<p>그저 자신이 처한 환경에서 조금 더 나아질 수 있는 방법을 찾았고, 끊임없이 내가 필요하고 더 나은 사람이 되기위해 정진해 나갔다.</p>
<p>인생을 살아가는 정도라는 것이 무의미해 지고, 한치앞을 내다 볼 수 없는 오늘의 사회에는 더욱더 가장 본받아야 할 점이 아닌가 생각된다.</p>
<p>흔히 인생을 살아나가는 것은 눈덮힌 산을 오르는 것에 비유된다.</p>
<p>가장 연륜있고, 실력있는 선구자는 우리를 앞서 오르고 대부분의 우리는 선구자가 남긴 발자국을 따라 오르며 끊임없이 내가 올바른 발걸음을 디뎠는지 생각한다.</p>
<p>내 눈앞의 수많은 발자국을 보며 어느 길이 가장 쉽고 효과적인 길인지를 가늠하려 하고, 내가 걸어온 발자국을 보며 산턱 언저리에서 후회와 불안에 이따금 뒤돌아 우두커니 서있는 것이다.</p>
<p>하지만, 정말 산을 잘 오르는 사람들은 오로지 정상만을 바라보고 오를 뿐이다.</p>
<p>우리 앞을 지나간 선구자는 물론 도움이 될 수 있지만, 그 사람이 어떤 상황에 있었는지 그때의 날씨는 어땠는지 우리는 알지 못하며, 가장 올바른 선택은 목적지에 시선을 던져두고 나를 믿고 신중하게 한걸음 한걸음을 옮기는 것인 것을 그들은 잘 아는 것이다.</p>
<p>요즘 세상을 무한 경쟁사회라고 한다.</p>
<p>주변을 달려가는 수많은 주자들을 바라보며 조바심을 느끼게 만드는 사회에서 많은 사람들이 고작 한치 앞에 있는 사람을 꽁무니 만을 쫓게도 되고, 한발작 뒤에 있는 주자들을 보며 가끔은 안도하기도 할 것이다.</p>
<p>이 글을 쓰는 필자도 또 마음을 다잡고자 이런글을 쓰는지 모른다.</p>
<p>오늘 하루도 앞서나가는 자에대한 조바심을 뒤따라 오는 자에 대한 오만함을 내려놓고 정상만을 바라보며 누구의 발자국도 아닌 나의 발자국을 남길 수 있는 하루, 내면의 단단함이 더해지는 하루가 되기를 바란다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/21/c-언어-상수와-기본-자료형/" itemprop="url">
                C 언어 | 상수와 기본 자료형
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-21T01:25:42.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/c-언어-강의/">C 언어 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                9 minutes read (About 1391 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="자료형이란-무엇인가요">자료형이란 무엇인가요?</span></h1><p>자료형이란 데이터를 표현하는 기준이 되며, <strong>정수형 자료형</strong>, 혹은 <strong>실수형 자료형</strong> 인지 등의 데이터의 표현 기준을 정해주고, 명확한 데이터의 크기를 알려줌으로써 메모리에 보다 효과적으로 자료가 저장될 수 있도록 해줍니다.</p>
<p>대표적인 자료형으로는 char, int, float, double 등이 있으며 각각 1바이트, 4바이트, 4바이트, 8바이트의 크기를 가집니다.</p>
<p>이러한 자료형의 크기를 구하는 연산자로는 <strong>sizeof()</strong> 함수가 있으며 다음과 같이 사용합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num = 1</span><br><span class="line">numSize = sizeof(num)</span><br></pre></td></tr></table></figure></p>
<p>우리가 컴퓨터에서 표현하는 자료는 앞서 말했듯이 정수와 실수의 큰 기준으로 나뉘게 되며, 여기서 실수형을 표현하는 경우 정확도 향상을 위해 <strong>float 이 아닌 double을 사용</strong> 합니다.</p>
<h1><span id="또-어떤-자료형들이-있나요">또 어떤 자료형들이 있나요?</span></h1><p>C 프로그래밍 시에 자료형 앞에 unsigned와 같은 키워드가 붙은 것을 많이 보았을 겁니다.<br>이 것은 바로 해당 자료형이 unsigned로 나타내는 것을 의미하며 즉, 음수를 구분하지는 못하지만 2배 더 큰 숫자까지 나타낼 수 있게 해주는 것을 의미합니다.</p>
<p>그밖에, 문자를 표현하기 위한 char 자료형이 있는데 이는 ASCII 코드에 의거하여 문자를 나타내는 것을 의미합니다.<br>이러한 ASCII 코드는 1바이트 즉 256가지의 문자를 표현하며, 기본적으로 컴퓨터 내에서 정수형 자료형으로 나타내어 지므로, 정수형 표현과 문자형 표현이 모두 가능합니다.</p>
<p>가령 다음의 예제를 살펴봅시다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char examplChar = &quot;a&quot;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d&quot;, examplChar)</span><br></pre></td></tr></table></figure></p>
<p>이 경우 문자 a의 정수형 표현을 ASCII 코드표에서 찾아 나타내어 줍니다.</p>
<h1><span id="상수란-무엇인가요">상수란 무엇인가요?</span></h1><p>상수는 int, double에 근거한 것으로 메모리 내에 이름이 없는 literal 상수와 이름이 있는 symbolic 상수로 구분됩니다.<br>이러한 상수는 한번 선언되면 그 값이 바뀔 수 없으며, 만약 이름이 있는 symbolic 상수로 선언되는 경우 이름은 대문자와 아래바 <code>_</code> 로 구성되는 것이 일반적입니다.</p>
<p>다음의 예는 literal 상수의 예를 보여줍니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int exampleNum = 5 + 6</span><br></pre></td></tr></table></figure></p>
<p>이렇게 literal 상수는 별도의 선언이 없이 값을 나타내며, 위의 경우 5와 6은 literal 상수입니다.</p>
<p>다음은 symbolic 상수의 예를 나타냅니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int MAGIC_NUMBER = 1</span><br></pre></td></tr></table></figure></p>
<p>이렇게 기본 자료형 int 앞에 const 키워드를 붙여 줌으로써 symbolic 상수를 선언하며, 선언과 동시에 초기화가 되어야 합니다.</p>
<p><strong>만약 상수에 자료형을 지정해 주고 싶다면 어떻게 할까요?</strong></p>
<p>다음은 상수 자료형에 float 으로 표기를 지정해 주는 예를 나타냅니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long exampleNum = 5.1235L</span><br></pre></td></tr></table></figure></p>
<p>이처럼 상수의 뒤에 U, L, UL, LL, F 등을 나타냄으로써 자료형을 알려줄 수 있습니다.</p>
<h1><span id="자료형-형-변환">자료형 형 변환</span></h1><p>이렇게 한번 선언된 자료형은 프로그래밍 도중에 변경될 수 있으며 이것을 <strong>형 변환</strong> 이라고 합니다.</p>
<p>형변환 에는 자동으로 형이 변환되는 <strong>자동 형 변환</strong> 과 사용자가 형을 변환해 주는 <strong>강제 형 변환</strong> 이 있습니다.</p>
<p>먼저 자동 형 변환은 보통 자료형을 일치시켜 계산해야 하는 경우 또는 대입 시에 강제로 형 변환이 되는 경우, 연산 시 빠른 연산을 위해 CPU 에서 자동으로 변환이 되는 경우가 있습니다.</p>
<p>먼저 자료형 일치를 위한 자동 형 변환의 예를 살펴봅시다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num1 = 5</span><br><span class="line">double num2 = 5.6235</span><br><span class="line">double result = num1 + num2</span><br></pre></td></tr></table></figure></p>
<p>위의 예의 경우 num1 과 num2 는 다른 자료형을 가졌기 때문에, 덧셈연산이 불가능 합니다.<br>이렇게 되면 컴퓨터는 자동으로 num1 과 num2 중 하나의 자료형에 맞추어 연산을 진행하게 되는데, 그 판단의 근거는 <strong>정확도를 높이는 방향</strong> 으로 진행된다는 것 입니다.</p>
<p>위 예의 경우 num1 과 num2 가 int 형으로 변환되어 계산이 된다면 큰 오차가 생기므로 적은 오차범위를 가지도록 둘 다 double 형으로 변환이 되어 계산이 되게 됩니다.</p>
<p>다음 예는 대입의 과정에서 자동 형 변환이 일어나는 경우입니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num1 = 129</span><br><span class="line">char result = num1</span><br></pre></td></tr></table></figure></p>
<p>num1 은 int 형으로 선언이 되었지만 char 자료형에 할당됨에 따라 4바이트에서 1바이트로 그 크기가 줄어들게 됩니다.<br>이 경우에는 최상위 바이트의 손실이 일어나게 되며 이 경우 00000000 00000000 00000000 10000001 에서 10000001 로 바뀌게 되어 부호가 바뀌게 되는 문제가 생깁니다.</p>
<p>다음은 <strong>강제 형 변환</strong> 의 예를 살펴봅시다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num1 = 5</span><br><span class="line">int num2 = 10</span><br><span class="line">double result</span><br><span class="line"></span><br><span class="line">result = (double)num1/num2</span><br></pre></td></tr></table></figure></p>
<p>위 예는 num1과 num2의 연산을 통해 얻은 0.5를 double로 강제 형 변환 시켜주어 result에 할당하는 예를 보여줍니다.<br>이처럼 (자료형) 키워드를 앞에 붙여줌으로써 강제로 해당 자료형을 바꾸어 줄 수 있습니다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/20/z_루소의-사회계약론-사회의-권위는-어떻게-생겨나는가/" itemprop="url">
                루소의 사회계약론, 사회의 권위는 어떻게 생겨나는가?
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-20T01:44:24.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                13 minutes read (About 1957 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>루소의 [사회계약론]은 밖으로 표출된 정치 현실의 차원에서 문제를 제기하는 대신 정치적 질서의 기반, 다시 말해 그것의 배후의 메커니즘에 대한 원리적 접근을 시도하며, 나아가 정치적 권력 또는 권위의 정당성은 어떻게 획득되는가를 다루고 있다.</p>
<p>루소는 ‘폭력’이 최초의 노예를 만들어 내었고, 그 노예들의 비열함이 노예상태를 영속시킨다고 보았다.<br>사람은 사실 인간이기 이전에 동물로써 힘에 굴복하는 것은 어떻게 보면 불가피한 행위이기에 강한자가 약한자를 노예로 삼는 것을 막을 방법 따위는 없었다. 그것이 ‘자연의 법칙’ 이었고, 모든 생물학적 생태계의 ‘약육강식’의 법칙을 따르는 자연스러운 일이었다. 또, 약한자가 비열함을 벗어내는 방법은 목숨을 담보로한 도전 밖에 없었으며, 대부분의 경우는 죽음으로 귀결되었기에 노예상태는 영속되었다.</p>
<p>하지만, ‘힘과 권위’ 라는 것은 사실 시간이 지나면 사라지게 되는 것이고, 과거의 강한 힘을 가진 사람들도 늙고 노쇠해짐에 따라 과거의 모든 영광은 뒤로하고 냉혹한 자연의 질서에 굴복되어 버리기에, 대부분의 사람들은 대체로 좋은 결말을 맞이할 수 없는것이 현실이었다. 이렇게 시간이 지남에 따라 사람들은 이렇게 무자비한 ‘동물의 법칙’을 벗어나 상호간의 약속을 통해 삶의 질을 올릴 수 있는 방법을 찾게 되었고, 여기서 최초의 ‘사회 계약’ 이 이루어 지게 되었고, <strong>공동체</strong> 라는 개념이 생겨나게 되었다.</p>
<p>공동체를 구성하는 각 구성원의 신체와 재산을 방어하고 ‘인간다운 삶’을 보장받기 위해 서로와 서로 사이에 계약을 하게 되고, 이를 통해 ‘공공의 힘’을 가지게 되어 각 개인은 그러한 ‘공공의 힘’으로 부터 보호 받고 자기 자신의 의지에 따라 한 ‘계약’ 에게만 복종함으로써 각 개인은 타인에게 복종을 하지 않는 자유로운 삶을 보장받을 수 있게 되었다. 즉, 과거처럼 ‘힘’에 의해 누군가의 노예가 되지 않을 수 있고, 자신이 혼자서 생존하기 어려운 많은 제약 속에서도 최소한의 인간적인 삶을 보장받게 되었으며, 이러한 공동체의 구성원들의 집합적인 의미로 <strong>국민</strong>, 주권에 참여하는 개인이라는 뜻에서 <strong>시민</strong>, 국가의 법률에 종속된다는 의미로 <strong>신민</strong> 이라는 용어들이 생겨나게 되었다.</p>
<p>사회의 계약이 강화됨에 따라 개인적인 인격은 사라지고, 이 결합행위는 하나의 집합적인 법인체 즉, 도시국가, 공화국을 만들게 된다.<br>이렇게 다수가 결합하여 한 단체를 이루면 누구도 그 단체를 공격하기 전에는 한 사람의 구성원도 해칠 수 없기에 각 구성원은 완벽한 동맹을 이루게 되고, 이런 굳건한 동맹관계가 원활히 수행되기 위해서는 각 개인이 지켜야할 많은 것들이 있었으며, 이에 따라 각 개인의 ‘자연적 신분’에서 ‘시민’ 으로 이행되었다. 이 과정에서 과거에는 볼 수 없었던 <strong>도덕성</strong> 을 부여되었고, 이는 사회적으로 큰 변화의 시작이었다.</p>
<p>오늘날 대부분의 사람들이 인간이라면 태어날 때 부터 당연하게 여겨질 것이라 생각되는 이 <strong>도덕성</strong> 은 사실 인류가 모두 비극적인 결말을 맞이하지 않기 위한 서로간의 약속이자 비자연적이고 인위적인 단지 <strong>하나의 규약</strong> 에 불과하였으나, 오늘날에는 사회의 탄탄한 기반으로 거듭났고, 이는 <strong>사회 계약</strong> 의 기본적인 토대로써 다음과 같은 목적성을 가지게 된다.</p>
<blockquote>
<p>자연적 평등을 파괴하는 것이 아니라 반대로 인간들 사이에 자연적으로 생겨날 수 있는 육체적 불평등을 도덕적이고 합법적인 평등으로 대치한다는 것,<br>그리고 인간은 체력 또는 재능에 있어 불평등할 수 있는 만큼 계약에 의해 그리고 법으로써 모두가 평등하게 된다.</p>
</blockquote>
<p>이렇게 사회 계약론은 모두에게 이득이 되는 최고의 계약이라 생각될 수 있지만, 그 이면에는 다양한 문제들이 존재한다.</p>
<p>사실 과거의 생태계에서 가진자와 가지지 못한 자의는 그렇게 크지 않았으며, 그 이유는 역설적이게도 ‘약육강식’의 법칙이 존재했기 때문이다.<br>동물은 시간이 지나면 자연스럽게 쇠퇴하게 되고 과거 가지지 못했던 자는 ‘무력’을 통해 때로는 ‘약탈’ 과 ‘살해’를 통해 가진자의 재산을 빼앗아 올 수 있었다.<br>또, 무리에서 도태되거나 약자인 개체는 때로는 무리에 의해 강제로 살해되기도 하고 스스로 경쟁력이 가지지 못하는 개체를 과감히 제거함으로써 사회 전체의 생산성을 유지하고 살벌한 긴장속에서 살아 나갔다.</p>
<p>하지만, 현대 사회의 ‘사회 계약’을 대변하는 ‘법’은 실제로 항상 유산자에게는 유익하고 무산자에게는 해로울 수 밖에 없다.<br>애초에 이 계약이란 개인이 가진 재산을 타인으로 부터 보호하기 위함이며 누군가의 범법행위가 이루어지지 않는 이상 개인이 가진 재산은 그 사람의 힘과 재능에 관계없이 오랜 시간이 지나도 유지될 수 있다. 이 재산은 세습이라는 형태로 계속해서 누적될 수 있지만, 가진게 없고 지킬게 없는 사람들에게 ‘약탈’ 과 ‘탈취’ 를 막는 ‘법률’은 사실 큰 도움이 되지 못하는 것이 현실이기 때문이다.</p>
<p>오늘날 민주 사회에서 이런 ‘사회 계약’의 이면은 충분히 극복될 수 있으며, 이는 무산자에게 유산자가 될 수 있는 동등한 기회를 제공함과, 사회 계약을 유지하기 위한 유산자의 사회적 기여를 강화함으로써 실현되고 있다.</p>
<p>‘유산자’ 는 우리의 공동체가 자신의 재산을 지켜주고 과거 야생에서 시간이 지남에 따라 잔혹한 결말을 맞이하지 않게 해 주는 것에 대한 감사와 시민으로써의 책임감을 가져야 하며, 누구보다 체제를 지켜나가고 무산자와의 합의점에 이르기 위해 체제를 지키기 위한 경제적 사회적 비용을 제공해야 할 의무가 있음을 의식해야 하며, 무산자라면 우리 공동체가 제공하는 무궁한 기회를 통해 성장해 나가고 훗날 공동체의 훌륭한 시민이 되기 위해 정진해 나가야 할 것이다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/17/z_domain-driven-design/" itemprop="url">
                Domain Driven Design 이란 무엇인가?
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-17T11:23:49.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                28 minutes read (About 4255 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="domain-driven-design-이란-무엇인가">Domain Driven Design 이란 무엇인가</span></h1><h2><span id="what-is-domain">What is domain?</span></h2><p>도메인의 사전적 의미는 “정보와 활동의 영역” 을 말하며, 흔히 프로그래머들에게는 어플리케이션 내의 로직들이 관여하는 정보와 활동의 영역이라고 받아들여 집니다.<br>가령, 어떤 웹 서비스를 만들 때 회원을 가입하고, 회원을 탈퇴하는 일련의 작업은 “회원” 과 관련된 일련의 작업들이며 여기서 “회원” 이라는 도메인이 있다고 볼 수 있습니다.</p>
<p>또 다른 용어로써 “domain layer” 와 “domain login” 이라는 용어가 있습니다. 이는 개발자들에게 일종의 “business logic” 과 동등한 것으로 받아들여져 왔습니다. 이러한 business login 은 비즈니스 주체들(가령 회원, 결제 등) 이 어떤 모델링 된 데이터를 생성하거나 변경하기 위해 서로간에 약속한 높은 수준의 규칙들을 의미합니다.</p>
<h2><span id="ddddomain-driven-desing">DDD(Domain Driven Desing)</span></h2><p>도메인 주도 디자인이란 개발을 함에 있어 위에서 설명한 도메인이 중심이 되는 개발 방식을 말하며, 그 목적은 소프트웨어의 연관된 부분들을 연결하여 계속 해서 진화하는 새로운 모델을 만들어 나가 복잡한 어플리케이션을 만드는 것을 쉽게 해 주는 것에 있습니다.<br>DDD의 핵심적인 목표는 Loose Coupling, High Cohesion 으로 각 도메인이 연결성이 적고 높은 정도로 연관되어 보다 가벼운 설계를 위해 탄생하였습니다.</p>
<p><strong>다음은 DDD의 세가지 주요 원리입니다.</strong></p>
<ol>
<li>핵심 도메인과 그 기능에 집중하라.</li>
<li>도메인의 모델의 정교하게 구축하라.</li>
<li>어플리케이션 모델을 발전시키고 새롭게 생기는 도메인 관련 이슈를 해결하기 위해 도메인 전문가와 끊임없이 협력하라.</li>
</ol>
<h2><span id="strategic-design">Strategic Design</span></h2><p>소프트웨어를 디자인 할 때 객체를 기준으로 디자인을 진행하는 것은 Object Oriented Design 이라고 하는데, 이러한 관점에서 볼 때 Strategic Design은 OOD가 잘 이루어진 것으로 볼 수 있습니다.</p>
<p>Strategic Design이란 Context 에 대해 생각하고 이를 기준으로 디자인을 하는 것을 말합니다.</p>
<p>여기서 Context란 무엇일까요?</p>
<p>Context 란 특정 객체 혹은 상황이 벌어지는 주변 환경을 말합니다. 가장 쉬운 예로 가게 안에 접시에 담긴 피자와 혹은 길에 버려진 피자를 생각해 봅시다. 같은 피자이지만 피자가 매장 안의 접시에 있는지 혹은 길에 있는지에 따라 유료, 무료의 차이가 생기게 되고 사실상 다른 것으로 간주될 수 있습니다. 이처럼 같은 사물이나 행동 양상이 벌어지는 상황에 집중하여 디자인을 하는 것이 Strategic Design 의 핵심이라고 할 수 있다.</p>
<p>Strategic Design을 이해하기 위해 간단한 예로 주택을 짓는 경우를 생각해 봅시다. 우리가 원하는 집을 짓기 위해서 우리가 하는 행동 절차는 다음과 같습니다.</p>
<ol>
<li>어떤 주택을 지을지 생각을 해 본다.</li>
<li>그런 뒤에 우리는 <strong>Domain Expert</strong> 즉, 이 경우 집 전문가와 상의를 한다.</li>
<li>주택을 지을 때 어떤 핵심적인 가치에 집중하여 집을 지을지를 선택합니다. 가령 헛간이 넓어야 한다던가, 수영장이 커야 한다던가 중점적인 사항을 명시합니다.</li>
<li>그 뒤 우리는 이미 지어진 다른 집들을 최대한 많이 조사하여 마음속에서 원하는 집의 형상을 떠올려 봅니다.</li>
<li>그런 뒤에 우리는 그 형상을 실제 집으로 만들어 내기 위해 모델링을 하고</li>
<li>이를 토대로 구체적인 설계도를 그려 나갑니다. 이 설계도에는 집의 아주 구체적인 부분들이 명시되게 됩니다.</li>
</ol>
<p>이렇게 DDD를 통한 설계 과정에서 사용되는 용어는 다음과 같습니다.</p>
<p>먼저 집 전체에 대한 설계의 전체를 우리는 <strong>domain</strong> 이라고 부르며, 커다란 집의 각각의 부분 집합인 헛간, 농장, 수영장 등 큰 파트들을 <strong>subdomain</strong> 이라고 부릅니다. 또 각각의 subdomain에 대해 각 subdomain의 문맥적 상황을 <strong>bounded context</strong> 라고 부르며, 실제 subdomain의 구체적인 형상을 나타내는 것을 <strong>domain model</strong> 이라고 부릅니다.</p>
<p>여기서 <strong>bounded context</strong> 가 가지는 의미는 바로 특정 모델이 어떤 bounded context 에 속하는 가에 따라서 다른 의미를 가지기 때문입니다.<br>가령, 주택 건축시에 정문에서 caretaker라는 모델이 있다면 이는 바로 경비원을 말하는 것일 겁니다. 하지만 caretaker라는 단어가 메인 주거 건물 안에서 가지는 의미는 이와 다를 수 있습니다.</p>
<p>이 내용을 간단히 정리하면 다음과 같습니다.</p>
<p><strong>Context</strong><br>의미를 결정하는 것 처럼 보이는 단어 나 문장이 나타나는 설정으로, 모델에 관한 문장은 context 안에서만 이해될 수 있다.<br>주택을 구성하는 각 부분 구간들에 대한 환경을 말한다.</p>
<p><strong>Model</strong><br>도메인의 특정 양상을 묘사한느 추상화 시스템으로 도메인과 관련된 문제를 해결하는 데 사용된다.</p>
<p><strong>Ubiquitous Language</strong><br>소프트웨어를 만들기 위해서는 많은 사람들이 원활히 소통해야 하고 여기에는 다양한 용어들이 사용된다. </p>
<p>가령, 기획자, 디자이너, 개발자가 모인 자리에서 각자 서로의 언어로 대화를 한다면 이는 원활한 커뮤니케이션을 심각하게 저해하게 된다.</p>
<p>이 경우에 필요한 것이 Ubiquitous Language이며 이는 domain model 을 둘러싼 언어구조를 말한다.</p>
<p>이 언어는 팀 전체가 각각의 업무 파트에서 공통적으로 사용될 수 있어야 하며, 실제 개발의 측면에서 모든 기획자, 디자이너, 개발자가 공통된 어휘를 사용해야 서로간에 이견이 없을 것이며 이러한 공통된 어휘를 ubiquitous language라고 합니다.</p>
<p><strong>Bounded Context</strong><br>위에서 설명한 Context에 대한 구체적인 설명으로, 특정 모델이 정의되고 적용될 수 있는 영역을 이야기 합니다.<br>주택을 짓는 경우에 빗대어 생각해 볼 때, Bounded Context는 주택 전체를 구성하는 헛간, 농장, 수영장, 메인 주택 등의 큰 요소들 각각을 둘러싼 상황을 의미합니다.<br>특정 모델은 어떤 bounded context에 놓이는가에 따라 다르게 이해될 수 있습니다.<br>실제 소프트웨어를 구축함에서의 예를 들면 가령 sales를 담당한하는 subdomain이 있을 수 있고, 이를 지원하는 support와 accounting 라는 subdomain 이 존재할 수 있습니다. 이러한 각각의 subdomain이 놓인 환경인 bounded context 내에서 특정 모델 <strong>customer</strong> 가 보여지는 시각은 매우 상이할 수 있습니다. sales 팀에서 고객을 보는 시각은 주로 사회적 관심사, 좋아하는 것, 욕구 등의 것일 겁니다. 하지만 accounting의 측면에서는 사용자는 그저 하나의 계정으로써 그 사람의 결제정보 만이 중요한 정보일 수 있습니다. 즉 각기 다른 bounded context에서 ubiquitous language는 비록 표현은 같지만 다른 의미를 가지게 됩니다.</p>
<p><strong>Context Map</strong><br>각 bounded context들 사이의 관계를 말하며 즉, 주택 건축시에 헛간, 뒷간, 수영장 등 큰 요소들이 어떤식으로 서로 연관이 되어 있는지를 나타낸다.</p>
<p><strong>Domain Model</strong><br>Domain Model 이란 실제 세계를 반영하는 구체적인 설계로, 주택 건축시에 주택을 구성하는 메인 주택의 구체적인 설계도를 말한다.</p>
<p><img src="..\images\strategicDesign의ProblemSpace와SolutionSpace.png" alt="strategic design의 Problem Space와 Solution Space"></p>
<h2><span id="tactical-design">Tactical Design</span></h2><p><img src="..\images\tacticalDesign.png" alt="Tactical Design"></p>
<p>Tactical Design Tool 들은 세부적인 사항을 구현하는 것을 위해 필요하며, 주로 Bounded Context 내의 구성 요소들을 관리합니다.<br>이것은 개발상의 실제적인 표준을 제공하는데 services, entities, repositories, factories 와 같은 소프트웨어 디렉토리 구조들에 익숙한 개발자들이 많을 것인데, 이 모든 것은 전부 DDD에서 나온 개념입니다. 이러한 Tactical Design은 Strategic Design과 달리 개발을 진행하는 과정에서 계속해서 바뀌고 개선됩니다.</p>
<h2><span id="model-driven-design-and-service">Model Driven Design And Service</span></h2><p><img src="..\images\modelDrivenDesign.png" alt="Model Driven Design"></p>
<p>Tactical Design을 이해하기 위한 Model Driven Design은 위와 같다.<br>실제 구현은 모델 수준에서 이루어 지고 쉽게 비유하자면 당신의 소프트웨어 전체 즉, domain을 하나의 세계로 표현한다면 각 나라는 subdomain에 해당되고 각 subdomain은 각 나라의 언어인 ubiquitous language를 사용하게 됩니다. 이렇게 각 subdomain은 하나의 Service로 구현되게 됩니다.</p>
<h2><span id="layered-architecture">Layered Architecture</span></h2><p>layered Architecture란 쉽게 말하면 모든 프로세스를 업무순서로 쪼게어 층을 나누어 수행하는 것이다.<br>가령 맥도날드의 예를 들어보자. 맥도날드에서는 각 종업원들이 맡은 업무를 충실하게 수행하여 아주 효과적으로 업무를 처리한다. 만약 맥도날드의 종업원들이 요리, 계산, 서빙 등 많은 업무를 업무 분담 없이 하게 된다면 분명히 큰 혼란이 초래되고 손님들은 오랜시간 동안 기다려야 하고 형편없는 음식을 먹게 될 것이다. 하지만 맥도날드는 손님을 응대하는 계산원, 주문을 전달하고 컨트롤 하는 중간 매개인, 전체 프로세스에 필요한 인프라를 제공하는 요리사, 사장, 매니저, 필요한 재료들을 보관하는 창고 등으로 구성되어 빠르고 효과적으로 일을 처리한다.</p>
<p>소프트웨어에서도 마찬가지로 고객을 응대하는 request handler, 이를 중재하는 controller, 각종 중요한 비즈니스 로직을 처리하는 business, 다양한 자료구조 등으로 구성되어 클라이언트에 보다 빨리, 조직적으로, 잘 응대할수 있게 되었고, 이에 따라 보다 유연하고 지속가능한 소프트웨어를 구축할 수 있게 되었으며, 각 파트는 자신의 역할을 충실히 수행하고 필요한 경우 여러번 재사용 될 수 있게 된다.</p>
<h2><span id="value-object">Value Object</span></h2><p>소프트웨어의 모델을 구성하는 수치에 대한 객체이며 훌륭한 디자인을 위한 가장 중요한 요소 중의 하나이다.<br>가령 소프트웨어 내에 화폐를 취급하는 객체가 있다면, 이는 화폐에 관한 모든 처리를 누군가의 도움 없이 스스로 잘 처리할 수 있어야 한다.<br>단위 환산, 표현법 변경 등 다양한 도메인 로직을 가져야 하며, 스스로 옳바른 값인지 validate 할 수 있어야 할 뿐 아니라 값이 제 3자에 의해 변하지 않고 일관성을 유지해야 한다.</p>
<p>가령 string 객체를 생각해 보자. 이 객체는 문자 어레이를 다루는 value object로써 substring 등의 다양한 기능을 수행하기 때문에 이를 일일히 정의할 필요가 없어져 ubiquitous language 로 소프트웨어의 표현을 간단하게 하고 보강해 준다.</p>
<h2><span id="entity">Entity</span></h2><p>기존의 attributes 를 기준으로 정의되었던 전통적인 객체와 달리, 연속성의 일관된 스레드에 의해 식별되는 객체이다.<br>일반적인 개발자들이 이 개념에 대해 알고 있다. Entity는 Value Object로 구성되며 대표적인 예로 db에 있는 row들의 예를 들 수 있다.<br>Entity는 identified id 를 가지고 business logic을 구현한다.</p>
<h2><span id="aggregate-와-domain-events">Aggregate 와 Domain Events</span></h2><p>aggregates는 entities의 집합이다. 가령 cutomer, customerInfo, address 라는 세가지 종류의 entities를 생각해 보자. 사실 이 모든 정보는 customer라는 주제로 뭉칠 수 있으며, 여기서 핵심이 되는 entitiy인 customer는 이 세 entities가 이루는 aggregates의 root entity가 된다. 이렇게 되면, 다른 외부 객체는 aggregate 내의 객체로 직접 접근할 수 없고, 하나의 aggregate root item 즉 customer 에만 접근이 가능하며, 이를 통해 해당 aggregate 내에 명령을 전달해야 한다. 이는 실제 프로그래밍에 자주 쓰이는 디자인 패턴 중의 하나이다.</p>
<p>더욱 간편한 예로는 포스트와 댓글의 관계, 질문과 답변의 관계 등이 있다.</p>
<p>여기서 <strong>Domain Event</strong> 라는 개념에 대해 살표보자.<br>domain event는 모델의 특정 행동과 관련된 이벤트인데, Aggregate 사이의 일관성을 유지하는데에 사용될 수 있다.<br>가령 사용자의 주소가 바뀌면 주문 내용도 바뀌어야 하는데, 순서를 살펴보면 사용자의 주소가 바뀌면 같은 aggregate내에 있는 사용자 정보가 바뀌게 되고 이러한 aggregate의 변화는 주문과 관련된 aggregate의 변화를 촉구하기 위해 domain event를 발생시켜 상호간의 정보의 일치를 이룬다.</p>
<h2><span id="factories">Factories</span></h2><p>Factories는 복잡한 entity 혹은 aggregate를 생성하는 것을 담당한다.<br>가령 엔진과 부속품을 넣으면 자동차가 나오는 공장과 같이 특정 정보를 factory에 보내면 결과로 aggregate 혹은 entity를 만들어주게 되고, 그 안에서 벌어지는 일에 대해서는 개발자들이 더 이상 신경을 쓰지 않아도 되고, 하나의 모듈로써 사용할 수 있다.</p>
<h2><span id="repositories">Repositories</span></h2><p>일반적인 저장소와 달리 특정 aggregate에 보다 신속하게 접근하고 aggregate 단위로 데이터를 처리할 수 있게 해 준다.<br>가령 위의 예처럼 customer 가 root entity로 있는 aggregate의 경우 1개의 repo를 만들게 되고, 사용자는 더 이상 기존의 db에서 고객 이름, 나이, 생년 등을 조합해서 사용하지 않고 repo에 aggregate를 통으로 저장해서 보다 쉽게 정보에 접근하고 정보를 변경할 수 있다.</p>
<h2><span id="ddd를-통해-얻을-수-있는것">DDD를 통해 얻을 수 있는것</span></h2><p>Domain-driven design also heavily emphasizes the ever-more-popular practice of continuous integration, which asks the entire development team to use one shared code repository and push commits to it daily (if not multiple times a day). An automatic process executes at the end of the work day, which checks the integrity of the entire code base, running automated unit tests, regression tests, and the like, to quickly detect any potential problems that may have been introduced in the latest commits.</p>
<h2><span id="ddd-구현">DDD 구현</span></h2><h3><span id="어떻게-domain-expert와-협의할-것인가">어떻게 domain expert와 협의할 것인가</span></h3><p>과거에 Use Case Diagram, Sequence Diagram 등 많을 것을 썻다.<br>때로는 ER Diagram도 사용했다.</p>
<p>하지만 요즘에는 이런 옛 방법을 사용하지 않고, Event Storming을 한다.</p>
<p>이것은 strategic design 을 위해 도메인 모델을 만들기 위한 연습이다.<br>개발 전문가와 domain 전문가가 만나서 브레인 스토밍을 통해 각 도메인에서 어떤 내용들이 필요할지에 대한 직관을 기른다.</p>
<h3><span id="진행-단계">진행 단계</span></h3><ol>
<li>domain expert 와 개발 전문가와 함께 서로간의 질문을 하는 미팅 시간을 가진다.</li>
<li>포스트잇에 색깔에 따라 events, commands, policies, processes, errors, roles, aggregates, etc 등을 적어 놓는다.<br>본 미팅은 event storming 이므로 이벤트를 시간의 순서에 따라 어플리케이션에서 발생 가능한 주요한 이벤트들을 나열한다.<br>가령 쇼핑몰의 경우 상품 열람 =&gt; 상품 구매 =&gt; 상품 배송 =&gt; 배송 완료 처럼 디테일한 이벤트들을 순서대로 나열한다.</li>
<li>다음은 이러한 이벤트들의 포스트잇 주변에 연관된 system action, user action 등을 쭉 붙인다.</li>
<li>이러한 과정이 마무리 되면 이제 bounded context 를 찾을 시간이다.<br>나열된 리스트를 보면 어느정도 분리된 subdomain 들이 보이게 되는데 가령 catalog, payments, delivery 등의 subdomain이 될 수 있다.</li>
</ol>
<hr>
<p><a href="https://www.youtube.com/watch?v=wD-d0oZI4YM&amp;list=PLZBNtT95PIW3BPNYF5pYOi4MJjg_boXCG" target="_blank" rel="noopener">참고자료 - Alpha Code 동영상 강의</a></p>
<p><strong><strong> all images are from Alpha Code Lecture Above </strong></strong></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/14/z_어떻게-상사를-대할-것인가/" itemprop="url">
                어떻게 상사를 대할 것인가?
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-14T10:41:48.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                6 minutes read (About 869 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>오늘은 조직생활과 관련하여 많은 사람들이 겪고 있는 직장 상사와의 갈등에 대해 생각해보고자 한다.</p>
<p>많은 사람들이 직장생활의 가장 큰 어려움으로 상사와의 갈등을 꼽고 있다. 과연 세상의 모든 상사들은 다 나쁜 사람인가? 라는 생각이 든다.</p>
<p>본 글은 어디까지나 사회생활에 대한 필자의 주관적인 생각만을 적어보는 것으로 본 글이 직장 내 상사와의 갈등에 대한 일반적인 해안은 결코 되지 못하는 것을 인지하고 있음을 먼저 밝히고 글을 시작한다.</p>
<p>직장 상사를 대하는 태도 대한 일반적인 관념은 어떠한가 부터 생각해 보자.</p>
<p>흔히 직장상사를 이야기 할때 ‘모신다’ 혹은 ‘사수’, ‘배운다’ 등의 단어가 일반적이다.</p>
<p>사실 이런 단어는 벌써부터 직장 상사와 나의 관계가 상/하 관계 혹은 갑/을 관계, 선임자/후임자의 수직적인 관계라고 화자 스스로가 생각하는 경우 사용된다.</p>
<p>따라서 후임자는 직장 상사의 말에 최대한 맞추려고 하고, 직장 상사가 나를 한 없이 착하고, 성실한 그런 ‘직원’ 이자 ‘후임자’로 보여지기를 원한다.</p>
<p>하지만, 이런 태도는 과연 현명한 처신일까?</p>
<p>과연 직장 상사는 ‘후임자’, ‘하급자’ 를 필요로 하고 훌륭한 ‘을’이 필요한 것일까?</p>
<p>이에 대한 필자의 생각은 ‘아니다’ 이다.</p>
<p>기업은 더 이상 학교이자 가정이 아니며 ‘하급자’, ‘직원’ 보다는 <strong>비즈니스 파트너</strong> 가 필요한 것이다.</p>
<p>착하고 말잘듣는 직원보다는, 좀 쌀쌀 맞더라도 잘난 <strong>나</strong> 와 그래도 잘 합을 맞출 수 있는 <strong>파트너</strong> 가 되어 주기를 원한다.</p>
<p>선임자가 상대방을 <strong>후임자</strong> 가 아닌 <strong>파트너</strong> 로 인정하게 되는 순간 선임자는 선임으로써의 <strong>버팀목</strong> 이 되어주어야 한다는 책임감을 덜어내고 인간 대 인간으로써 함께 협력하여 일을 해 나갈 수 있기 때문이다.</p>
<p>사실 남자라면 누구나 공감하겠지만 수직문화의 끝을 보여주는 군대에서는 이런 장면들을 많이 보아왔을 것이다.</p>
<p>항상 착하기만 하고 저 친구 정말 고생하는구나 하는 후임과 동기들은 어디까지나 보호해야할 대상이며 나의 아랫사람으로 많은 경우 힘든일은 혼자 다하면서도 정작 인정은 받지 못하는 많은 병사들이 있는 반면, 좀 뺀질거리더라도 눈치 빠르고 소신있는 병사들은 <strong>전우</strong> 로써 인정을 받는 경우는 아주 흔한 일이다.</p>
<p>인생을 살아가면서 언제나 우리는 조직의 한 가운데에 놓여있게 된다.</p>
<p>필자를 비롯한 이 글을 읽는 독자들도 당돌하고 일 좀 하는 <strong>비즈니스 파트너</strong> 로써 상급자의 도움이 필요없는 믿을만한 파트너로 거듭나 훌륭한 사회의 조직원으로 거듭난다면 더할나위 없이 좋은 일일 것이다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/14/go-language-시작하기/" itemprop="url">
                go language 시작하기
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-14T04:45:04.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                7 minutes read (About 1111 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h2><span id="설치하기">설치하기</span></h2><p>Go 는 패키지 매니저가 없으며 VCS에서 직접 받아와서 라이브러리를 사용합니다.</p>
<p>먼저, 다음 페이지에서 window 용 Go 를 설치해줍니다.</p>
<p><a href="https://golang.org/dl/" target="_blank" rel="noopener">공식 다운로드 사이트</a></p>
<p>설치가 완료 되었다면. 아래와 같은 구조로 디렉터리를 만들어 줍니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Go/</span><br><span class="line">  bin/</span><br><span class="line">  pkg/</span><br><span class="line">  src/</span><br></pre></td></tr></table></figure></p>
<h2><span id="maingo-만들기">main.go 만들기</span></h2><p><strong>main.go</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main //namespace declaration 하는 부분으로 기능과 논리들을 그룹화시켜준다.</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot; // format의 약자로 standard lib에 있다.</span><br><span class="line"></span><br><span class="line">// 여기서 main 은 keyword 로써 해당 함수가 라이브러리가 아닌 어플리케이션으로 동작함을 나타낸다.</span><br><span class="line">// go 어플리케이션이 여기서 시작된다.</span><br><span class="line">// func는 function을 선언하는 keyword 이다.</span><br><span class="line">func main() &#123;</span><br><span class="line">  fmt.Println(&quot;Hello, World&quot;) //여기서 println의 앞의 P가 대문자 인데, 이는 외부 라이브러리에서 가져왔음을 의미한다.</span><br><span class="line">                              // 같은 원리로 함수를 선언할때 대문자로 시작하면 외부에서 접근이 가능한 것이다.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>실행하기</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure></p>
<p><strong>빌드하기</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go build # 실행가능한 binary 파일을 만들어 준다.</span><br><span class="line">이 경우 파일명이 아니라 폴더 명으로 파일이 생성된다.</span><br><span class="line">./go-study</span><br><span class="line"></span><br><span class="line">윈도우용 빌드</span><br><span class="line">GOOS=windows go build -o main.exe main.go</span><br></pre></td></tr></table></figure></p>
<h1><span id="슬라이스">슬라이스</span></h1><p>슬라이스는 배열의 값을 가리킵니다(point). 그리고 배열의 길이를 가지고 있습니다.</p>
<p>[]T 는 타입 T 를 가지는 요소의 슬라이스(slice) 입니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    p := []int&#123;2, 3, 5, 7, 11, 13&#125;</span><br><span class="line">    fmt.Println(&quot;p ==&quot;, p)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; len(p); i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;p[%d] == %d\n&quot;,</span><br><span class="line">            i, p[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="레인지">레인지</span></h1><p>for 반복문에서 range 를 사용하면 슬라이스나 맵을 순회(iterates)할 수 있습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i, v := range pow &#123;</span><br><span class="line">        fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>_ 를 이용해서 인덱스(index)나 값(value)를 무시할 수 있습니다.</p>
<p>만약 인덱스만 필요하다면 “ <code>, value</code> ” 부분을 다 제거하면 됩니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    pow := make([]int, 10)</span><br><span class="line">    for i := range pow &#123;</span><br><span class="line">        pow[i] = 1 &lt;&lt; uint(i)</span><br><span class="line">    &#125;</span><br><span class="line">    for _, value := range pow &#123;</span><br><span class="line">        fmt.Printf(&quot;%d\n&quot;, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="맵">맵</span></h2><p>맵은 값에 키를 지정합니다.</p>
<p>맵은 반드시 사용하기 전에 make 를 명시해야합니다. (주의: new 가 아닙니다)</p>
<p>make 를 수행하지 않은 nil 에는 값을 할당할 수 없습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">    Lat, Long float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m map[string]Vertex</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    m = make(map[string]Vertex)</span><br><span class="line">    m[&quot;Bell Labs&quot;] = Vertex&#123;</span><br><span class="line">        40.68433, -74.39967,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m[&quot;Bell Labs&quot;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>맵 리터럴 (Map literals)</strong><br>맵 리터럴은 구조체 리터럴과 비슷하지만 key 를 반드시 지정해야 합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">    Lat, Long float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m = map[string]Vertex&#123;</span><br><span class="line">    &quot;Bell Labs&quot;: Vertex&#123;</span><br><span class="line">        40.68433, -74.39967,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;Google&quot;: Vertex&#123;</span><br><span class="line">        37.42202, -122.08408,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>다양한 함수<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    m := make(map[string]int)</span><br><span class="line"></span><br><span class="line">    m[&quot;Answer&quot;] = 42</span><br><span class="line">    fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])</span><br><span class="line"></span><br><span class="line">    m[&quot;Answer&quot;] = 48</span><br><span class="line">    fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])</span><br><span class="line"></span><br><span class="line">    delete(m, &quot;Answer&quot;)</span><br><span class="line">    fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])</span><br><span class="line"></span><br><span class="line">    v, ok := m[&quot;Answer&quot;]</span><br><span class="line">    fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="switch">switch</span></h2><p>다른 일반적인 언어를 아는 분이라면 switch 에 대해서 잘 알 것입니다.</p>
<p>다른 언어와 다른점은 case의 코드 실행을 마치면 알아서 break를 한다는 점입니다.</p>
<p>( fallthrough 로 끝나는 case는 스스로 break를 하지 않습니다 )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Print(&quot;Go runs on &quot;)</span><br><span class="line">    switch os := runtime.GOOS; os &#123;</span><br><span class="line">    case &quot;darwin&quot;:</span><br><span class="line">        fmt.Println(&quot;OS X.&quot;)</span><br><span class="line">    case &quot;linux&quot;:</span><br><span class="line">        fmt.Println(&quot;Linux.&quot;)</span><br><span class="line">    default:</span><br><span class="line">        // freebsd, openbsd,</span><br><span class="line">        // plan9, windows...</span><br><span class="line">        fmt.Printf(&quot;%s.&quot;, os)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="메소드">메소드</span></h2><p>고에는 클래스가 없습니다. 하지만 메소드를 구조체(struct)에 붙일 수 있습니다.</p>
<p>메소드 리시버(method receiver) 는 func 키워드와 메소드의 이름 사이에 인자로 들어갑니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">    X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Abs() float64 &#123;</span><br><span class="line">    return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    v := &amp;Vertex&#123;3, 4&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="인터페이스">인터페이스</span></h2><p>인터페이스는 메소드의 집합으로 정의됩니다.</p>
<p>그 메소드들의 구현되어 있는 타입의 값은 모두 인터페이스 타입의 값이 될 수 있습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Abser interface &#123;</span><br><span class="line">    Abs() float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var a Abser</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    v := Vertex&#123;3, 4&#125;</span><br><span class="line"></span><br><span class="line">    a = f  // a MyFloat implements Abser</span><br><span class="line">    a = &amp;v // a *Vertex implements Abser</span><br><span class="line">    a = v  // a Vertex, does NOT</span><br><span class="line">    // implement Abser</span><br><span class="line"></span><br><span class="line">    fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MyFloat float64</span><br><span class="line"></span><br><span class="line">func (f MyFloat) Abs() float64 &#123;</span><br><span class="line">    if f &lt; 0 &#123;</span><br><span class="line">        return float64(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    return float64(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Vertex struct &#123;</span><br><span class="line">    X, Y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *Vertex) Abs() float64 &#123;</span><br><span class="line">    return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br></pre></td></tr></table></figure></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/05/13/영화-인썸니아-insomnia/" itemprop="url">
                영화 인썸니아(Insomnia)
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-05-13T01:04:07.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                7 minutes read (About 991 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>살면서 누구나 한번쯤은 돌이킬 수 없는 잘못된 결정으로 인한 실수를 진실을 왜곡함으로써 해결하고 싶은 강한 욕망에 휩싸이는 순간이 있다.<br>가장 사소한 예로, 학창시절 선생님이 교실에서 어떤 잘못을 저지른 사람에게 자백을 요구하는 훈계를 듣는 경우는 사실 누구나 한번쯤은 있었던 경험일 것이다. 나는 항상 그 상황에서 진짜 잘못을 저지른 사람은 어떤 마음일까 하는 생각을 하고 했다. 그 상황이 나에게는 그저 귀찮은 일인 반면 그 당사자에게는 얼마나 큰 마음의 짐이 될까를 생각해보면 생각만으로도 암담한 일이 아닐 수 없었다.</p>
<p>인간은 누구나 실수를 하기에 많은 사람들이 이런 욕망에 휩싸일 수 있고, 두가지 선택지만을 가진다. 진실을 밝히는가 혹은 진실을 숨기는가.</p>
<p>많은 경우에 전자의 선택지는 너무도 큰 희생이 필요할 수 있다. 내가 일생동안 살아온 나의 신념을 배반하는 감당할 수 없는 실수로 내 인생을 송두리 째 바꾸어 놓을 것만 같고, 다시는 회생할 수 없을 것 같은 암담한 미래가 그려진다. 반면, 두번째 선택지는 너무도 달콤하다. 나의 실수를 없던 것으로 하는것. 그것은 마치 시간을 되돌리는 것처럼 단 한번만 진실을 감추면 모든 문제가 해결 될 것만 같다.</p>
<p>사실 이런 이야기는 영화나 책속에나 나올법 한 일이라고 생각할 수 있지만, 사실 사회의 많은 곳들에서 흔히 일어나는 일중 하나이다. 대부분의 부패한 정치인 혹은 기업가, 범죄자들도 많은 경우 선량하고 옳바른 선택을 할 수 있었던 시절이 있었을 것이라 생각하고 또 누군가는 과거의 단 한번의 잘못된 처신을 평생을 후회하며 열심히 살아가고 있을지도 모른다.</p>
<p>이 영화는 그런 감당할수 없을 것 같은 실수에 대처하는 한 잘나가던 경찰의 이야기를 다룬다.<br>평생을 신념에 입각해서 살았고, 훌륭한 경찰로 살았지만, 단 한번의 선택으로 최악의 상황으로 치닫게 되며, 그러한 심적 부담과 ‘백야’ 라는 극중 설정으로 인해 불면증을 않아 점점 더 판단력을 잃어간다.<br>이러한 설정은 현실의 상황을 너무도 잘 반영한다. 진실을 은닉한 것에 대한 엄청난 마음의 부담은 그 사람에게 제대로된 판단을 할 힘을 앗아가고 결국 거짓의 구렁텅이로 빠져버리게 되는 것이다.</p>
<p>결국 영화는 우리가 살면서 겪을 이런 상황들에 대한 가장 쉽고 유일한 선택지를 제시하고 있다.</p>
<p>그것은 바로 “모든 진실을 밝히고 실수를 감내하는 것” 그리고 “최악의 상황에서도 옳바르게 행동할 판단력을 잃지 않는것”이다.</p>
<p>그 어떤 순간에서도 한치앞의 달콤한 유혹을 뿌리치고 진실로 삶을대하는 것이 남은 인생을 위한 최고의 선택지이며, 실수를 할 수 밖에 없는 인간으로써 모든 결정적인 실수에 대한 책임을 감내하고 살아야 하는 것은 인간의 숙명이기에 최악의 상황에서도 판단력을 잃지않고 올바른 선택을 할 수 있는 용기와 힘을 가지도록 노력해야 할 것이다.</p>

                        
    </div>
    
            
</article>



        
    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/page/8/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/page/10/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/">1</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/8/">8</a></li>
        
        <li><a class="pagination-link is-current" href="/page/9/">9</a></li>
        
        <li><a class="pagination-link" href="/page/10/">10</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/23/">23</a></li>
        
    </ul>
</nav>
    
    </div>
</section>

            <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 Jake.Lee 이남훈&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" href="https://github.com/frontalnh">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
                <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        //plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110077250-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-110077250-2');
</script>


    


<script src="/js/script.js"></script>

                    
                        <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
                            
</body>

</html>