<!DOCTYPE html>
<html class="has-navbar-fixed-top">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Jake.Lee&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="google-site-verification" content="PgpnJMuvO-IqYWyFljnyr-tusLhJUz1VRMmECenJyHE">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">






<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="/css/style.css">
<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>

</head>

<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">Categories</a>
            
            <a class="navbar-item " href="/tags">Tags</a>
            
            <a class="navbar-item " href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" href="https://github.com/frontalnh">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

        <section class="section">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6354931397950820",
    enable_page_level_ads: true
  });
</script>

    <div class="container">
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/11/22/direnv-시작하기/" itemprop="url">
                direnv 시작하기
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-11-22T14:47:05.000Z" itemprop="datePublished">
                8 months ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/direnv/">direnv</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                3 minutes read (About 417 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h2><span id="direnvdirectory-environment-란">direnv(Directory Environment) 란?</span></h2><p>direnv는 이름 그대로 폴더별로 환경을 관리해주는 도구이다. </p>
<p>direnv로 설정을 해 놓으면 폴더 이동을 할 때마다 자동으로 설정해놓은 환경변수나 원하는 런타임 버전 지정 등을 알아서 할 수 있다. 그래서 한번 설정해 놓으면 해당 프로젝트에서 다른 설정에 대해서는 잊어버리고 쉽게 작업을 할 수 있고 어떤 환경 설정을 해놨는지가 궁금해지면 설정 파일을 열어보면 그만이다.</p>
<p><a href="https://direnv.net/" target="_blank" rel="noopener">direnv</a>는 <a href="https://golang.org/" target="_blank" rel="noopener">Go</a>로 작성되었는데 <a href="https://direnv.net/" target="_blank" rel="noopener">홈페이지</a>에 나온대로 각 OS의 패키지 매니저를 이용해서 설치하거나(macOS라면 <code>brew install direnv</code>) <a href="https://github.com/direnv/direnv/releases" target="_blank" rel="noopener">릴리스 페이지</a>에서 OS에 맞는 바이너리를 받아서 설치해서 사용하면 된다.</p>
<p><strong>direnv 를 cli 에 적용하기</strong></p>
<p>설치 후에는 쉘에서 direnv가 실행되도록 해야 하므로 <code>bash</code>를 쓰고 있다면 <code>~/.bashrc</code>파일에 <code>eval &quot;$(direnv hook bash)&quot;</code>를 추가하면 폴더 이동을 할 때마다 자동으로 실행되게 된다. <code>bash</code> 외에 다른 쉘을 쓰고 있다면 zsh, fish, tcsh를 다 지원하므로 <a href="https://direnv.net/" target="_blank" rel="noopener">홈페이지</a>를 참고해서 설정하면 된다.</p>
<p>위 명령어를 통해 cli 에서 디렉토리를 이동하는 경우에 훅을 걸어 특정 설정을 적용시킬 수 있다.</p>
<p><strong>.direnv 파일의 예</strong></p>
<p><a href="https://www.notion.so/frontalnh/Direnv-69a55f7ccc71438e896c8fb37b54819a#cf184a4d4bb346119a569c683eb7cd97" target="_blank" rel="noopener">direnv 참고 블로그</a></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/11/11/경제학-강의-01/" itemprop="url">
                경제학 강의 01. 경제학이란 무엇인가?
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-11-11T05:18:07.000Z" itemprop="datePublished">
                8 months ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/economics/">economics</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                20 minutes read (About 3024 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h2><span id="경제학은-무엇이며-왜-필요한가">경제학은 무엇이며 왜 필요한가?</span></h2><p>필자는 현대 사회의 큰 축을 이루는 정치, 경제, 사회 모두의 측면에서 가장 근본이 되는 것은 바로 경제라고 생각한다.</p>
<p>현대 사회의 대부분의 문제들 가령, 전세난, 노조의 파업, 가계 부채, 글로벌 금융 위기와 취업난, FTA 문제들은 각 개인들 혹은 국가간 경제력을 거머쥐기 위한 치열한 전쟁의 현장이며, 이를 해결하는 것이 각국 정부의 주요 관심사가 되어가고 있다.</p>
<p>이토록 많은 사회적 문제를 해결하기 위한 학문이 바로 <strong>경제학</strong> 이며, 이는 그 이름이 주는 낯선 느낌과는 달리 삶의 모든 순간순간 우리가 고민하는 문제들의 집합체이기도 하다.</p>
<p>이러한 경제학을 간단히 정의하자면, <strong>희소성 안에서 선택을 탐구하는 학문</strong> 이라고 할 수 있겠다.</p>
<p>인간의 욕망은 무한하고 인간이 가진 자원은 유한하기에 모든 개인과 국가는 더 많은 자원을 소유하기 위해 경쟁하고, 또 주어진 자원을 효율적으로 사용하기 위해 노력하며, 그 모든 행위를 위한 학문적 토대를 경제학이 제공한다.</p>
<p>먼저, <strong>자원</strong> 에 대한 정의부터 생각해보자. 우리는 앞서 자원을 가지기 위해 경쟁한다고 했기 때문에, 자원이란 반드시 가치가 있어야 하고 또 그 양이 무한해야 할 것이다. 마치 공기처럼 수없이 많이 있기 때문에 다른 사람들과 경쟁할 필요가 없다면 그것은 더 이상 경쟁의 대상이 되지 못한다. 이러한 자원은 <strong>재화</strong> 와 <strong>서비스</strong> 로 분류될 수 있는데, 여기서 <strong>재화</strong> 란 쌀, 가전제품 처럼 형태가 존재하는 유형의 상품을 말하며, <strong>서비스</strong> 란 트레이너의 PT 처럼 무형의 상품을 말한다.</p>
<p>또 <strong>재화</strong> 는 <strong>자유재</strong> 와 <strong>경제재</strong> 로 구분될 수 있는데, <strong>자유재</strong> 란 앞에서 말한 것처럼 무한히 존재하여 다른 사람과 경쟁이 필요없는 재화를 말하며, <strong>경제재</strong> 란 그 양이 한정적이기 때문에 모든 사람이 원하는 만큼 소유할 수 없기에 <strong>경쟁의 대상</strong> 이 될 수 있는 재화를 말한다.</p>
<p>이처럼 경제학이란 전체 사회원 혹은 국가의 입장에서는 무한하지 못한 재화를 효과적으로 사용하기 위한 학문이며, <strong>효율성</strong> 과 <strong>형평성</strong> 을 추구하는데 즉, 최소의 비용으로 최대의 효과를 얻고, 사회 구성원간에 보다 공평하게 재화를 나눌 수 있도록 하는 것을 목적으로 한다. 이처럼 <strong>효율성과 형평성을 극대화</strong> 하기 위해서는 <strong>비용과 수익의 분석을 통해 어느 선택이 다른 대안에 비해서 효율적인가를 판단하고 각 대안에 소요되는 비용과 수익을 정확하게 계산할 수 있어야 한다.</strong></p>
<h3><span id="비용이란-무엇이며-어떻게-산출되는가">비용이란 무엇이며 어떻게 산출되는가?</span></h3><p>경제학의 목적인 효율성과 형평성을 추구하기 위해서는 비용과 수익의 분석을 통해 어느 선택이 다른 대안에 비해서 효율적인가를 판단하고 각 대안에 소요되는 비용과 수익을 정확하게 계산할 수 있어야 한다고 하였다. 그렇다면 여기서 비용이란 무엇인가?</p>
<p>비용은 <strong>기회 비용(경제적 비용)</strong> 과 <strong>명시적 비용</strong> 으로 나누어 생각할 수 있는데, 먼저 <strong>기회 비용</strong> 이란 내가 얻고자 하는 것을 얻기위해 내가 지불해야하는 경제적 가치로 내가 가진 모든 선택지를 고려하여 하나의 선택지를 선택하였을때 지불해야 할 비용 뿐 아니라 다른 선택지를 선택함으로써 얻을 수 있는 이익까지 포기하는 것이 되므로 그 두 가치를 합산한 것으로, 흔히 생각하는 시장의 가격과는 차이가 있다. 반면, <strong>명시적 비용</strong> 이란, 단순히 장부상에 기록되는 비용으로 흔히 우리가 인식하는 비용이라 생각할 수 있다.</p>
<p>한 예를 들면 만약 필자가 10년 할부로 페라리를 구입한다고 하면, 매달 내가 지불하는 할부금액의 합이 <strong>명시적 비용</strong> 이라고 볼 수 있다. 하지만 필자가 경제적으로 지불하는 만약 필자가 저축이라는 다른 선택을 선택하였다면 얻을 수 있는 복리에 대한 이자율 또한 포기한 셈이 되므로 10년 동안 은행에 할부금을 저축한 금액에 대한 10년간의 복리 이자액을 <strong>묵시적 비용</strong> 이라 부르고 이 둘을 합한 것이 필자가 지불한 <strong>경제적 비용 </strong> 즉, <strong>기회 비용</strong> 이 되는 것이다.</p>
<blockquote>
<p><strong>경제적 비용 = 명시적 비용 + 묵시적 비용</strong></p>
</blockquote>
<p>이처럼 매 결정에서 내가 지불하는 <strong>기회 비용</strong> 을 정확히 따져보고 선택을 내리는 것은 매우 힘든 일이다. 내가 처한 경제적 상황과 선택지를 면밀히 따져보고 경제 현상을 이해해야만 옳은 경제적 선택을 내릴 수 있으며, 이때 필요한 것이 <strong>경제적 사고</strong> 이다.</p>
<h2><span id="무엇을-선택할-것인가">무엇을 선택할 것인가?</span></h2><p>우리는 경제학의 주요 요소인 <strong>재화 와 비용</strong> 에 대해 알아보았다.</p>
<p>경제학은 이러한 한정된 재화를 효율적으로 사용하기 위한 여러가지 선택을 내리는 것이라 배웠고, 각 선택을 함에 있어 정확한 경제적 비용을 측량하는 방법 또한 배웠다.</p>
<p><strong>그렇다면 우리는 무엇에 관한 선택을 할 것인가?</strong></p>
<p>경제학에서 우리는 크게 3가지에 관한 경제적 선택에 대해 알아볼 것인데, 그것은 바로 <strong>무엇을, 어떻게, 누구를 위하여 생산할 것인가에 대한 문제</strong> 이다.</p>
<p>먼저, <strong>무엇을 생산할 것인가의 선택</strong> 은 제한된 자원을 사용하여 사회 안에서 어떠한 상품들이 생산되느냐를 선택하는 문제인데, 가령 한 국가에서 전쟁을 위한 무기를 생산하여 국력을 증강시킬 지 혹은 식량을 생산하여 국민들의 삶의 질을 높일 것인지를 선택하는 문제는 매우 중요하다.</p>
<p>두번째 선택은 <strong>어떻게 생산할 것인가</strong> 에 대한 문제이다.</p>
<p>무엇을 생산할지가 결정되었다면 그 재화를 가장 효율적으로 생산하기위한 다양한 프로세스를 고민해야 한다. <strong>어떠한 생산 방식을 채택</strong> 하여 효율을 높일지, <strong>노동을 주로 사용하여 생산할 것인지 혹은 자본투자를 통하여 생산을 극대화 할 것인지</strong> 등을 고민한다.</p>
<p>두번째 선택지에 관한 문제는 현대 과학과 공학의 주요한 발전의 목적이 되는데, 독보적인 기술의 진보를 통해 생산성 증진을 혁신적으로 끌어올릴 수 있기에 많은 국가는 막대한 자본을 투자하여 생산 기술의 진보에 열을 올리곤 한다.</p>
<p>선번째 경제적 선택은 바로 <strong>누구를 위해 생산할 것인가</strong> 에 대한 것이다.</p>
<p>이것은 분배에 관한 문제이며, 효율적으로 축적한 경제적 이윤을 어떤방식으로 형평성을 맞추어 분배할지에 대한 문제이다.</p>
<p>이러한 문제에 대한 다양한 선택지가 존재하는데, 극단적으로는 자본주의와 공산주의의 대립처럼 부의 효율적이고 공정한 분배에 관한 문제를 고려한다.</p>
<h2><span id="경제학의-종류">경제학의 종류</span></h2><h3><span id="주류-경제학과-정치-경제학">주류 경제학과 정치 경제학</span></h3><p>경제이론에 대한 의견은 경제학사에서도 첨예하게 대립하고 있으며 흔히 <strong>아담 스미스</strong> 이후의 고전학파와 이를 이어받은 신고전학파 경제학과 1930년대 세계 대공황 이후 정부의 역할을 강조하는 <strong>케인즈 학파</strong> 로 이루어 지는 <strong>주류 경제학</strong> 과 <strong>정치 경제학</strong> 이라 부르는 <strong>마르크스 주의 경제학</strong> 이 있다.</p>
<p>여기서 <strong>주류 경제학</strong> 은 자유방임의 시장경제가 자원배분을 가장 효율적으로 이룰 수 있다고 믿는 경제학파 이며, 흔히 우리가 아는 <strong>보이지 않는 손</strong> 을 신봉하는 경제학파라고 볼 수 있다. 반면 <strong>정치 경제학</strong> 이란 생산 수단의 공동 소유를 기초로 하는 사회주의적 경제체제를 추구하여 국가의 이상적인 통치와 질서를 통해 경제의 효율성과 형평성을 이룩할 수 있다고 주장하는 학파이다.</p>
<h3><span id="규범적-경제학과-실증적-경제학">규범적 경제학과 실증적 경제학</span></h3><p><strong>규범적</strong> 이란 주관적 가치관이 개입된 경우를 말하며, <strong>실증적</strong> 이란 가치관이 들어가지 않고 현상을 있는 그대로 묘사하는 것을 말한다. 즉, <strong>실증적 경제학</strong> 이란 주관적 가치관의 개입 없이 경제현상을 있는 그대로 설명하는 것을 의미하며, <strong>규범적 경제학</strong> 이란 가치관이 개입되는 경제학을 말한다.</p>
<p>가령 <strong>수요의 법칙</strong> 을 생각해 보자. <strong>수요의 법칙</strong> 이란 가격이 오르면 소비가 줄고 가격이 내리면 소비가 늘어난다는 경제 법칙으로 이는 실험과 경험을 통해 측정된 사실을 바탕으로 얻어낸 <strong>실증적 경제학</strong>의 예를 보여준다.</p>
<p>반면, 농산물을 수입하는 정책을 세운다고 해 보자. 값싼 농산물을 수입하면, 국내의 가난한 농민들에게는 큰 타격이 되겠지만, 많은 사람들이 보다 저렴하게 식품을 구매할 수 있고, 수입하지 않으면, 국민들이 비교적 비싼 가격으로 식품을 구매해야 하지만 가난한 농민들에게는 큰 보탬이 된다. 즉, 이와 같은 경정을 할 때에는 어떤 집단의 이익을 우선시 하는가에 따라 서로 다른 선택을 해야하며 여기에는 반드시 주관적인 가치판단이 들어가야 한다. 이를 기반으로 하는 경제학을 <strong>규범적 경제학</strong> 이라 일컷는다.</p>
<h3><span id="미시-경제학과-거시-경제학">미시 경제학과 거시 경제학</span></h3><p><strong>미시 경제학</strong> 이란 개별 시장의 관점에서 경제를 보는 것이고, <strong>거시 경제학</strong> 이란 경제 전체의 관점에서 경제를 바라보는 경제학으로, 가령 특정 개인이나 집단 혹은 기업의 입장에서 시장을 바라보는 것을 <strong>미시 경제학</strong> 에서 다루며 국가 경제 전체를 대상으로 하는 <strong>환율, 물가, 이자율</strong> 등에 대한 고민을 하는 것이 <strong>거시 경제학</strong> 이다.</p>
<p>즉, <strong>미시 경제학</strong> 이란 가계와 기업의 의사결정과정을 분석하고 이들이 시장에서 어떻게 상호작용하는가를 연구하는 분야이고, <strong>거시 경제학</strong> 은 경제 전체에 미치는 변수와 추세에 관하여 연구하는 분야이다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/11/10/두나무의-블록체인-개발-플랫폼-루니버스/" itemprop="url">
                두나무의 블록체인 개발 플랫폼, 루니버스
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-11-10T07:18:39.000Z" itemprop="datePublished">
                8 months ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/blockchain/">blockchain</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                18 minutes read (About 2724 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="두나무의-블록체인-개발-플랫폼-루니버스">두나무의 블록체인 개발 플랫폼, 루니버스</span></h1><p>이번 포스트에서는 두나무의 블록체인 개발 플랫폼 루니버스에 대해 알아보고자 합니다.</p>
<h2><span id="루니버스란">루니버스란?</span></h2><p>블록체인 기술에 대한 관심은 계속해서 증가하고 있지만, 블록체인의 특성상 메인넷을 구성하고 자체 코인을 발행하는 것은 상당한 기술력을 필요로 하고, 네트워크를 구축했다 하더라도 다른 블록체인 네트워크와 접점을 만들고 블록체인 플랫폼의 참여자를 만들어 나가는 것 또한 매우 어려운 일이기에, 국내에서 성공적으로 운영되고 있는 블록체인 서비스는 사실상 전무하다고 볼 수 있습니다.</p>
<p>두나무의 루니버스란 이처럼 개발의 진입장벽이 높은 블록체인 기술의 장벽을 낮추고 개발자라면 누구나 쉽게 Decentralized Application을 만들 수 있도록 하겠다는 목표로 블록체인 서비스 개발 플랫폼인 ‘루니버스’ 의 출시를 준비하고 있습니다.</p>
<p>루니버스는 마치 아마존의 클라우드 서버처럼 클릭 몇번으로 네트워크 상에 자체적인 블록체인 네트워크를 구축하도록 도와주며, 해당 블록체인 네트워크에 토큰을 발행하고 Dapp 을 올리는 등의 일련의 작업을 매우 쉽게 만들어주어 개발자들에게 인종의 블록체인 네트워크에 대한 쉽고 간편한 인터페이스를 제공해 줍니다.</p>
<p>루니버스 플랫폼을 통해서 개발자는 간편한 REST API를 통해 블록체인 상의 대부분의 기능을 수행할 수 있게 되기에 오직 비즈니스 로직에만 집중하여 블록체인 서비스를 만들 수 있는 환경을 제공받습니다. 즉, 루니버스를 이용하면 블록체인 개발에 대한 전문 지식이 없어도 쉽게 컨소시엄 블록체인 네트워크를 구축하고 토큰을 발행, 운영할 수 있습니다.</p>
<h2><span id="루니버스-체인">루니버스 체인</span></h2><p>루니버스 체인은 파트너들 모여 분산화된 네트워크 구성합니다. 각 개발사들은 루니버스를 통해 간편하게 자신의 체인을 만들고 루니버스 체인 내의 다른 체인들에 쉽게 deploy 및 transaction 발행할 수 있습니다.</p>
<p>루니버스 체인을 이해하기 전에 3가지 종류의 체인에 대해 이해할 필요가 있으며, 루니버스 체인, 컨소시엄 블록체인, 프로턱트 체인이 바로 그것입니다.</p>
<p>먼저, 루니버스 체인은 전체 블록체인 네트워크를 포함하는 개념이며, 루니버스의 블록체인 위에서 여러 개발사들의 블록체인 네트워크가 운영되며, 여러 블록체인 사이의 인터페이스를 만들어 주어 여러 블록체인 네트워크 사이에서 통신이 가능하게 해줍니다.</p>
<p>다음은 컨소시엄 블록체인인데, 루니버스를 통해 블록체인을 개발하는 개발사들은 루니버스 체인 위에 자신만의 별도의 컨소시엄 블록체인을 구축할 수 있습니다. 루니버스 체인은 이러한 여러개의 컨소시엄 블록체인들을 이어주는 역할을 수행합니다.</p>
<p>마지막으로 <strong>프로덕트 체인</strong> 이 있는데, 이러한 프로덕트 체인 위에서 실제적인 Dapp 과 Token이 운영되게 됩니다. 각 개발사들은 자신들의 컨소시엄 블록체인 위에 다수의 프로덕트 체인을 구축하여 운영하거나 혹은 루니버스 체인 위에 바로 자신만의 프로덕트 체인을 구축하는 방식으로 서비스를 운영할 수 있습니다.</p>
<p>루니버스에서 프로덕트 체인은 아이콘과 협력하여 만들어지고 있으며, 12월에 정식으로 루니버스 체인의 메인넷이 가동될 예정입니다.</p>
<p>뿐만 아니라 루니버스 네트워크는 <strong>이더리움, 이오스 등 다른 대형 블록체인 네트워크</strong> 와의 인터페이스를 구축할 예정으로 루니버스 내의 블록체인을 다른 거대 메인넷과 손쉽게 연동할 수 있는 다리 역할을 해줄 것으로 기대됩니다.</p>
<p>종합하자면, 루니버스는 일종의 sass 로 볼 수 있으며, 블록체인 기술을 추상화 시켜 개발자들이 비즈니스 로직에만 집중하여 블록체인 서비스를 만들수 있게 해줍니다.</p>
<h2><span id="블록체인과-루니버스의-활용">블록체인과 루니버스의 활용</span></h2><p>현시점에서 블록체인 기술은 블록체인 인프라에 그 관심이 집중되었습니다. 이더리움, 이오스 등 계속해서 새로운 블록체인 메인넷들이 출시되었으며, 해당 메인넷 위에서 다양한 서비스가 운영되기 보다는 우수한 메인넷 자체를 개발하는 것에 전 세계의 관심이 집중되었습니다.</p>
<p>즉, 이제까지의 블록체인산업은 블록체인 인프라에 집중되었다고 볼 수 있습니다.</p>
<p>하지만, 과거 산업의 발전 행태를 볼 때 현 시점에서 가장 중요한 것은 바로 블록체인을 활용한 킬러앱의 출시가 블록체인 인프라의 발전방향을 결정짓는 다고 볼 수 있습니다. 가령 인터넷이 처음 나왔을때 인터넷 상의 전자 상거래 서비스 혹은 각종 게임의 발전이 인터넷 산업과 인프라의 발전을 가속화한 것처럼 블록체인 기술을 활용한 상용적인 서비스가 계속 생겨나야 블록체인 인프라도 그에 발맞추어 발전할 전망입니다.</p>
<h2><span id="블록체인에서의-게임-산업">블록체인에서의 게임 산업</span></h2><p>루니버스는 블록체인의 여러 산업방면에서도 <strong>게임 산업</strong> 에 상당한 관심을 가지고 있습니다. 현재 블록체인 기반의 게임산업의 규모는 빠르게 성장하고 있으며, 크게 다음과 같은 3가지 활용처가 존재합니다.</p>
<p><strong>게임의 블록체인화</strong></p>
<ol>
<li>인게임 재화 ⇒ fungible token</li>
<li>아이템 경재 ⇒ non fungible token</li>
<li>게임의 규칙 ⇒ smart contract</li>
</ol>
<p>이미 블록체인 기반의 다양한 게임들을 성공리에 운영되고 있는데, 게임회사 뿐 아니라 게임 스트리밍, 게임 마켓 등 다양한 게임 관련 산업분야가 성장하고 있습니다.</p>
<p><strong>블록체인 게임 사례</strong></p>
<ul>
<li>eos 기반의 한 방치형 rpg 게임<br>인게임 상에서 재화를 획들할 수 있고 이를 게임 내에서 다시 소비하는 방식으로 토큰 이코노미가 만들어짐</li>
<li>이더몬<br>각 사이트를 10명의 유저가 호스트가 되어 공동 소유할 수 있고 일반 유저는 입장료를 내고 탐험하는 방식의 새로운 비즈니스 모델을 선보였으며, 입장료 중 90%는 호스트에게 돌아가고 나머지는 개발자에게 돌아가는 방식으로 운영</li>
<li>게임 스킨<br>사용자와 디자이너가 각종 게임 스킨을 만들고 이를 여러 게임에서 사용 가능 =&gt; 게임 스킨은 조단위 시장을 형성</li>
<li>토너먼트 형 게임<br>좋은 아이템을 구매해서 경기에서 승리하여 상금을 얻는다 =&gt; 게임을 통한 수익창출을 위한 기회 비용으로 아이템을 구매한다.</li>
</ul>
<p><strong>루니버스는 무엇을 해결하는가?</strong></p>
<p>크립토 키티의 경우 메타마스크를 통해 로그인하면서 이탈되는 유저가 전체의 99%에 달할만큼 편리한 유저 인터페이스의 필요성이 대두되고 있습니다. 루니버스는 간편한 사용자 경험을 제공하여 손쉽게 블록체인 서비스를 이용할 수 있도록 할 것입니다.</p>
<p>또한, 기존의 메인넷에서 게임을 하기 위해 필요한 막대한 거래 비용을 게임산업 발전을 저해하고 있으며, 루니버스는 0에 가까운 트랜잭션 fee를 지향하여 서비스를 만들고 있으며, 거래 비용을 줄여 게임에 진입장벽을 낮추어 줍니다.</p>
<h2><span id="또-무엇을-제공하나요">또 무엇을 제공하나요?</span></h2><p><strong>기업 운영</strong></p>
<ol>
<li>투자자 네트워크 연계</li>
<li>올비트 상장 패스트 트랙</li>
<li>글로벌 마케팅</li>
<li>공동 PR 진행 및 지원</li>
</ol>
<p><strong>편리한 개발 프로세스</strong></p>
<p>루니버스 이전의 개발 프로세스에서는 프라이빗 체인 구축 및 디앱개발 및 웹3 작성 및 배포등 일련의 과정에 몇달의 기간이 소요되지만 루니버스를 통한 개발 프로세스에서는 30분 내에 체인을 만들고 토큰을 발행할 수 있습니다. 체인 생성 및 토큰을 버튼 몇번으로 생성하고, 이를 rest api 를 호출함으로써 편리하게 개발이 가능합니다.</p>
<p><strong>개발 프로세스</strong></p>
<ol>
<li>메인 체인 만들고 메인 토큰 발행</li>
<li>프로덕 체인 구축</li>
<li>메인 토큰과 매칭 되는 프로덕 토큰 발행</li>
<li>트랜잭션 정의</li>
<li>REST api 를 call 함으로써 서비스 구현</li>
</ol>
<p><strong>가상화폐 지갑</strong></p>
<p>비트베리와 협업하여 안전하고 편리한 가상화폐 지갑을 제공합니다.</p>
<p><strong>편리한 암호화폐 상장</strong></p>
<p>Allbit Alliance Program ⇒ 루니버스를 이용하기 전의 플로우</p>
<ol>
<li>토큰 경제 설계, 백서 검토</li>
<li>파운데이션 컨설팅</li>
<li>리갈 펀드 매칭</li>
</ol>
<p>현재 암호화폐 거래소의 문제였던 <strong>과도한 리스팅 비용, 복잡한 절차, 리스팅 네트워킹, 리스팅 사후 관리(가격 방어, 거래량 확보)</strong> 를 해결해주고, 루니버스 이용하여 서비스를 개발하여 탈중앙화 거래소인 올비트와 협력하여 간편하게 리스팅이 가능합니다.</p>
<p>또한 올비트가 제공하는 머미넷, 비트 고수, cmt group, Dr. Node&amp;mainblock 등을 통해 리스팅 후의 마케팅 까지 지원합니다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/10/30/kubernetes-시작하기/" itemprop="url">
                kubernetes 시작하기
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-10-30T00:45:15.000Z" itemprop="datePublished">
                8 months ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/kubernetes/">kubernetes</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                15 minutes read (About 2281 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="쿠버네티스-시작하기">쿠버네티스 시작하기</span></h1><p>최근에는 컨테이너 기술인 도커 등을 이용하여 어플리케이션을 컨테이너 형태로 배포하는 추세이다.</p>
<p>kubernetes는 이렇게 많은 컨테이너들의 배포 프로세스를 관리하고 컨테이너 들을 클러스터링 하여 체계적이로 관리, 배포할 수 있게 해주는 툴이다.</p>
<p>클러스터를 생성하고 각 어플리케이션을 노드 단위가 아니라 클러스터 단위로 배포함으로써 특정 컨테이너에 문제가 생기면 kubernetes가 컨테이너를 재시작 하는 등 다양한 기능을 제공하여 보다 안정적으로 서비스를 운영할 수 있게 해준다.</p>
<p>또한 여러 컨테이너들 사이에서 Load Balancing 등을 활용한 라우팅 기능을 사용하여 분산처리도 가능하게 해주는 장점이 있다.</p>
<h2><span id="kind-of-objects-in-kubernetes">Kind of Objects in kubernetes</span></h2><p>Kubernetes에는 다음과 같이 크게 4가지 종류의 Object 가 존재한다.</p>
<ol>
<li>Cluster</li>
<li>Service</li>
<li>Pod</li>
</ol>
<h2><span id="create-kubernetes-cluster">Create kubernetes cluster</span></h2><p>먼저 쿠버네티스를 시작하기 위해서는 클러스터를 생성하여 그 위에 컨테이너화된 어플리케이션을 배포할 수 있다.</p>
<p>쿠버네티스 디플로이먼트 설정을 만들어야 한다. <strong>디플로이먼트는 쿠버네티스가 애플리케이션의 인스턴스를 어떻게 생성하고 업데이트해야 하는지를 지시한다</strong>. 디플로이먼트가 만들어지면, 쿠버네티스 마스터가 해당 애플리케이션 인스턴스를 클러스터의 개별 노드에 스케줄한다.</p>
<p>디플로이먼트는 애플리케이션 인스턴스를 생성하고 업데이트하는 역할을 담당한다.</p>
<p>미니쿠베를 통해 로컬에서 간단하게 쿠버네티스를 실행시킬 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minikube start</span><br><span class="line">minikube stop</span><br></pre></td></tr></table></figure>
<p>새로운 deployment를 실행한다.</p>
<p>아래 명령어에서 deployment의 이름과 app의 이미지 주소를 입력해 준다.</p>
<p>We want to run the app on a specific port so we add the –port parameter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl run kubernetes-bootcamp --image=[gcr.io/google-samples/kubernetes-bootcamp:v1](&lt;http://gcr.io/google-samples/kubernetes-bootcamp:v1&gt;) --port=8080</span><br><span class="line"></span><br><span class="line">kubectl get deployments</span><br></pre></td></tr></table></figure>
<p>기본적으로 쿠버네티스의 팟들은 해당 클러스터 내에서 서로 ip를 알고 있지만 클러스터 밖은 클러스터 내의 팟의 아이피를 알지 못한다.</p>
<p>The kubectl command can create a proxy that will forward communications into the cluster-wide, private network.</p>
<p>이러한 클러스터에 접근하기 위해 proxy 서버를 돌릴 수 있는데, 다음과 같다.</p>


undefined


<p>위처럼 환경변수를 설정하면 다음과 같이 접근이 가능하다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [&lt;http://localhost:8001/api/v1/namespaces/default/pods/<span class="variable">$POD_NAME</span>/proxy/&gt;](&lt;http://localhost:8001/api/v1/namespaces/default/pods/<span class="variable">$POD_NAME</span>/proxy/&gt;)</span><br></pre></td></tr></table></figure>
<p>파드는 쿠버네티스 플랫폼 상에서 최소 단위가 된다. 우리가 쿠버네티스에서 배포를 생성할 때, 그 배포는 컨테이너 내부에서 컨테이너와 함께 파드를 생성한다</p>
<p><strong>파드는 하나 또는 그 이상의 애플리케이션 컨테이너 (도커 또는 rkt와 같은)들의 그룹이고 공유 스토리지 (볼륨), IP 주소 그리고 그것을 동작시키는 방식에 대한 정보를 포함하고 있다.</strong></p>
<ul>
<li><strong>kubectl get</strong> - 자원을 나열한다</li>
<li><strong>kubectl describe</strong> - 자원에 대해 상세한 정보를 보여준다.</li>
<li><strong>kubectl logs</strong> - 파드 내 컨테이너의 로그들을 출력한다</li>
<li><strong>kubectl exec</strong> - 파드 내 컨테이너에 대한 명령을 실행한다.</li>
</ul>
<p>노드는 쿠버네티스에 있어서 워커 머신이며 클러스터에 따라 VM 또는 물리 머신이 될 수 있다. 여러개의 파드는 하나의 노드 위에서 동작할 수 있다.</p>
<p>We can execute commands directly on the container once the Pod is up and running. For this, we use the exec command and use the name of the Pod as a parameter. Let’s list the environment variables:</p>
<p>특정 팟에서 명령어를 실행할 수 있따.</p>
<p>가령 kubectl exec -it \$POD_NAME bash</p>
<p>cat server.js</p>
<h2><span id="service">Service</span></h2><p><strong>쿠버네티스에서 서비스는 하나의 논리적인 파드 셋과 그 파드들에 접근할 수 있는 정책을 정의하는 추상적 개념이다</strong></p>
<p>서비스는 종속적인 파드들 사이를 느슨하게 결합되도록 해준다. 서비스는 모든 쿠버네티스 오브젝트들과 같이 YAML 또는 JSON을 이용하여 정의된다.</p>
<p>쿠버네티스 클러스터 내 각 파드는 유일한 IP 주소를 가지며, 여러분의 애플리케이션들이 지속적으로 기능할 수 있도록 파드들 속에서 발생하는 변화에 대해 자동으로 조정해 줄 방법이 있어야 한다.</p>
<p>비록 각 파드들이 고유의 IP를 갖고 있기는 하지만, 그 IP들은 서비스의 도움없이 클러스터 외부로 노출되어질 수 없다. 서비스들은 여러분의 애플리케이션들에게 트래픽이 실릴 수 있도록 허용해준다. 서비스들은 ServiceSpec에서 type을 지정함으로써 다양한 방식들로 노출시킬 수 있다:</p>
<p>서비스는 쿠버네티스의 객체들에 대해 논리 연산을 허용해주는 기본 그룹핑 단위인, <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels" target="_blank" rel="noopener">레이블과 셀렉터</a>를 이용하여 파드 셋과 매치시킨다. 레이블은 오브젝트들에 붙여진 키/밸류 쌍으로 다양한 방식으로 이용 가능하다:</p>
<ul>
<li>개발, 테스트, 그리고 상용환경에 대한 객체들의 지정</li>
<li>임베디드된 버전 태그들</li>
<li>태그들을 이용하는 객체들에 대한 분류</li>
</ul>
<p>여러분은 kubectl 명령에<strong><code>--expose</code></strong> 옵션을 사용함으로써 디플로이먼트 생성과 동일 시점에 서비스를 생성할 수 있다.</p>
<p>how to expose Kubernetes applications outside the cluster using the kubectl expose command</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">노드 포트 타입으로 클러스터를 외부로 노출시킴</span><br><span class="line">kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080</span><br></pre></td></tr></table></figure>
<p>열린 포트를 확인하기 위해 다음 명령어를 실행시킴</p>
<p>kubectl describe services/kubernetes-bootcamp</p>
<p>curl $(minikube ip):$NODE_PORT</p>
<p>라벨 사용하기</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">아래 커맨드의 -l 은 라벨을 의미한다.</span><br><span class="line">kubectl get pods -l run=kubernetes-bootcamp</span><br></pre></td></tr></table></figure>
<p>다음과 같이 라벨링을 한다.</p>
<p>kubectl label pod \$POD_NAME app=v1</p>
<p>kubectl describe pods \$POD_NAME</p>
<p>를 실행시켜 보면 라벨링이 바뀐 것을 볼 수 있다.</p>
<p>다음과 같이 새로운 라벨로 쿼링을 할 수 있다</p>
<p>kubectl get pods -l app=v1</p>
<p>다음과 같이 서비스를 삭제하면 요청이 오지 않는데 그것은 외부로 열려있지 않기 때문이다.</p>
<p>kubectl delete service -l run=kubernetes-bootcamp</p>
<p>드플로이먼트의 복제수를 변경하면 스케일링이 수행된다.</p>
<p>스케일링 명령어</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployments/kubernetes-bootcamp --replicas=4</span><br></pre></td></tr></table></figure>
<p>다음 명령어로 확인하면 서로 다른 ip를 가진 여러 개의 팟이 생긴것을 볼 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe deployments/kubernetes-bootcamp</span><br></pre></td></tr></table></figure>
<p>앱 업데이트 하기</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</span><br></pre></td></tr></table></figure>
<p>위 명령어는 특정 deployment의 팟의 이미지를 교체해준다.</p>
<p>kubectl get pods</p>
<p>를 통해 확인해 본다.</p>
<p>롤아웃</p>
<p>kubectl rollout status deployments/kubernetes-bootcamp</p>
<p>롤백</p>
<p>kubectl rollout undo deployments/kubernetes-bootcamp</p>
<p>클러스터 밖에서 팟을 바라보기</p>
<p>The hostNetwork setting applies to the Kubernetes pods. When a pod is configured with hostNetwork: true, <strong>the applications running in such a pod can directly see the network interfaces of the host machine where the pod was started.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: influxdb</span><br><span class="line">spec:</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  containers:</span><br><span class="line">    - name: influxdb</span><br><span class="line">      image: influxdb</span><br></pre></td></tr></table></figure>
<p>컨테이너에 hostPort 옵션</p>
<p>The hostPort feature allows to expose a single container port on the host IP.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: influxdb</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: influxdb</span><br><span class="line">      image: influxdb</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: 8086</span><br><span class="line">          hostPort: 8086</span><br></pre></td></tr></table></figure>
<p>To make the service accessible from outside of the cluster a user can create a service of type NodePort.</p>
<p>each Kubernetes node will proxy that port to the pods selected by the service.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: influxdb</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 8086</span><br><span class="line">      nodePort: 30000</span><br><span class="line">  selector:</span><br><span class="line">    name: influxdb</span><br></pre></td></tr></table></figure>
<h1><span id="kubernetes-dns">kubernetes DNS</span></h1><h2><span id="httpskubernetesiodocsconceptsservices-networkingdns-pod-service"></span></h2><h2><span id="services">Services</span></h2><h3><span id="a-records">A records</span></h3><p>“Normal” (not headless) Services are assigned a DNS A record for a name of the form <code>my-svc.my-namespace.svc.cluster.local</code>. This resolves to the cluster IP of the Service.</p>
<p>“Headless” (without a cluster IP) Services are also assigned a DNS A record for a name of the form <code>my-svc.my-namespace.svc.cluster.local</code>. Unlike normal Services, this resolves to the set of IPs of the pods selected by the Service. Clients are expected to consume the set or else use standard round-robin selection from the set.</p>
<h3><span id="srv-records">SRV records</span></h3><p>SRV Records are created for named ports that are part of normal or <a href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" target="_blank" rel="noopener">Headless Services</a>. For each named port, the SRV record would have the form <code>_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster.local</code>. For a regular service, this resolves to the port number and the domain name: <code>my-svc.my-namespace.svc.cluster.local</code>. For a headless service, this resolves to multiple answers, one for each pod that is backing the service, and contains the port number and the domain name of the pod of the form <code>auto-generated-name.my-svc.my-namespace.svc.cluster.local</code>.</p>
<p>Kube dns</p>
<p><a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/</a></p>
<p>minikube start</p>
<p>kubectl cluster-info</p>
<p>kubectl get nodes</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/09/30/it-chain04/" itemprop="url">
                it-chain 04
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-09-30T09:20:30.000Z" itemprop="datePublished">
                9 months ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/blockchain/">blockchain</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                2 minutes read (About 317 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="opensource-blockchain-engine-it-chain-04-authentication">[ Opensource Blockchain Engine, IT-CHAIN] 04. Authentication</span></h1><p>Open Source Blockchain Engine인 It-chain 의 네번째 포스트입니다.</p>
<p>이번 포스트에서는 IT-CHAIN에서 블록의 인증과정에 대해 알아보겠습니다.</p>
<h2><span id="어떻게-노드들의-신분을-인증하는가">어떻게 노드들의 신분을 인증하는가?</span></h2><p>모든 노드는 각자 고유의 private key와 public key를 발행하며 이는 it-chain의 자체 라이브러리인 heimdal을 통해 이루어 집니다. heimdal를 통해 키를 생성하면 private key 와 public key 두 쌍의 키가 생기게 되는데, 여기서 public key를 활용하여 각 노드들의 id를 만들어 노드들의 신분을 보장하며, 각 노드는 트랜잭션을 발행하는 시점에 해당 트랜잭션을 자신의 private key로 sign한 signature를 함께 동봉합니다.</p>
<h2><span id="트랜잭션의-signing">트랜잭션의 Signing</span></h2><p>트랜잭션을 발행할 때 TX와 함께 signatature를 동봉하게 되는데 이는 보내는 사람의 private key로 sign한 정보이다.</p>
<p>It-chain:  <a href="https://github.com/it-chain/engine" target="_blank" rel="noopener">https://github.com/it-chain/engine</a></p>
<p><strong>Opensource Blockchain Engine It-chain 시리즈</strong></p>
<ul>
<li><a href="https://steemit.com/blockchain/@keepit/keep-t-column-opensource-blockchain-engine-it-chain-01-peer-to-peer-network" target="_blank" rel="noopener">01. P2P 네트워크와 합의 알고리즘</a></li>
<li><a href="https://steemit.com/blockchain/@keepit/keep-t-column-opensource-blockchain-engine-it-chain-02-blockchain-component" target="_blank" rel="noopener">02. 블록의 생성과 동기화</a></li>
</ul>
<p><strong>LNH</strong></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/08/30/it-chain03/" itemprop="url">
                it-chain 03
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-08-30T09:20:30.000Z" itemprop="datePublished">
                10 months ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/blockchain/">blockchain</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                9 minutes read (About 1371 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="opensource-blockchain-engine-it-chain-03-ivm-component">[ Opensource Blockchain Engine, IT-CHAIN] 03. IVM Component</span></h1><p>Open Source Blockchain Engine인 It-chain 의 세번째 포스트입니다.</p>
<p>이번 포스트에서는 IT-CHAIN에서 Smart Contract 의 배포와 실행을 담당하는 IVM COMPONENT에 대해 알아보겠습니다.</p>
<h2><span id="it-chain의-ivm-component">It-chain의 IVM Component</span></h2><p>It-chain 에서는 icode라 불리는 smart contract을 배포할 수 있으며, It-chain 위에서 일어나는 Transaction 이 내포하는 의미는 바로 어떤 노드에서 어떤 smart contract의 어떤 함수를 실행시켰는가에 관한 정보이며 그 구조 중 일부는 다음과 같습니다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	icodeId: _icodeid,</span><br><span class="line">	type: invoke | query</span><br><span class="line">	function: _functionName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>여기서 트랜잭션을 실행시킨다는 것은 해당하는 icode 에게 특정 요청을 전달하는 것입니다.</p>
<p>transaction의 종류에는  invoke와 query가 있는데, 여기서 invoke는 데이터를 쓰는 작업이고 query는 데이터를 읽는 작업이라고 볼 수 있습니다. 각 아이코드는 특정 함수에 대한 handler를 가지고 있으며 특정 함수를 실행하면 그에 매칭되는 핸들러가 동작하여 아이코드 내에서 일련의 작업이 일어나게 됩니다.</p>
<h2><span id="icode-들은-어디에-저장되나요">Icode 들은 어디에 저장되나요?</span></h2><p>각 노드에서 배포된 Smart contract인 icode 들은 자신의 고유값을 기준으로 한 git repository에 자장되며, 어떤 노드에서 특정 icode를 실행하기 위해서는 git repository에서 해당 icode 를 받아와서 자신의 노드에 docker container를 구축하여 그 내부에서 icode를 실행시킵니다.</p>
<p>즉, 새로운 스마트 컨트랙이 생성되면 이는 특정 git repository 로 업로드되고 사용되기 전까지 해당 git repository에 저장되어 있습니다.</p>
<h2><span id="docker-container-관리를-위한-tesseract-library">Docker Container 관리를 위한 Tesseract Library</span></h2><p>블록체인 노드에서 여러개의 icode 가 하나의 노드에서 실행되어야 하며, 각 icode는 서로에게 독립적으로 작동하기 위해서 각 icode가 실행되는 환경을 가상화하여 독립시킬 필요성이 생기게 되었으며, 이를 해결하기 위해 it-chain 에서는 리눅스 컨테이너 기술인 <strong>Docker</strong> 를 사용하게 됩니다.</p>
<p><strong>Docker</strong> 란 하나의 노드에서 여러개의 독립 실행 환경을 구성해 줄 수 있으며, 각 실행환경을 Container라는 단위로 부릅니다.</p>
<p>IVM에서 각 icode는 각각 저마다의 독립된 실행공간인 <strong>Container</strong> 를 가지며 it-chain에서는 각 컨테이너를 생성하고 관리하는 별도의 라이브러리인 <strong>Tesseract</strong> 라는 독자적인 라이브러리를 사용하고 있으며, <strong>Tesseract</strong> 라이브러리는 각 컨테이너의 DB에 데이터를 저장하고 출력하는 작업을 수행합니다.</p>
<h2><span id="smart-contract-작성을-위한-sdk-library">Smart Contract 작성을 위한 SDK Library</span></h2><p>Smart Contract 이란 사용자가 특정 함수나 요청을 전달하였을 때 항상 동일한 결과를 내놓는 일종의 블랙박스라고 볼 수 있습니다. icode는 docker위에서 동작하며 위의 invoke 등을 처리함에 있어 sdk의 함수들을 사용하는데 여기서 sdk는 ivm의 tesseract에게 grpc 통신을 통해 데이터를 쓰고 읽는 작업을 처리합니다.</p>
<h2><span id="icode-는-언제-실행되나요">Icode 는 언제 실행되나요?</span></h2><p>먼저, icode 의 각 함수는 transaction을 만들어내고 이 tx는 리더에게 전달됩니다.</p>
<p>리더는 tx를 받아 블록을 만들고 해당 블록을 받아 내부에 있는 tx를 실행시킴으로서 실제 icode 가 실행이 됩니다.</p>
<p>현재 잇체인 팀은 계속해서 icode의 실행의 유효성을 보장하기 위한 다양한 시도들을 하고 있습니다.</p>
<p>가령, 현재 it-chain은 transaction 내의 임의 함수로 인해 각 노드에서 다른 결과가 나오는 등 노드 별로 같은 결과값을 가지고 공유하기 위한 연구와 시도등이 있으며, it-chain 팀은 이를 해결하기 위해 각 노드에서 생성된 블록의 transaction 들을 바로 실행시키고 반영하기 전에 미리 한번 각 transaction을 실행시킨 뒤 상대방이 실행시킨 결과값과 나의 결과값이 일치할 때에만 icode 를 실행시키는 등의 장치를 구현중에 있습니다.</p>
<h2><span id="스마트-컨트랙의-실행과-world-state-database">스마트 컨트랙의 실행과 World State Database</span></h2><p>실행된 스마트 컨트랙트는 각 노드의 상태를 변경시키고 변경된 상태들에 각 컨테이너가 접근할 수 있어야 하기에 공용으로 사용할 상태값 저장 공간이 필요하게 되었으며 이를 World State Database 라고 부릅니다.</p>
<p>it-chain에서 world state database 는 키밸류 DB 인 Level DB를 사용하여 구현되었습니다.</p>
<p>이번 포스트에서는 It-chain 내에서 Smart Contract을 배포 및 실행, 관리하는 IVM Component에 대해 알아보았습니다.</p>
<p>다음 포스트에서는 it-chain에서 노드의 인증을 담당하는 Authentication에 대해 알아보겠습니다.</p>
<p>It-chain:  <a href="https://github.com/it-chain/engine" target="_blank" rel="noopener">https://github.com/it-chain/engine</a></p>
<p><strong>Opensource Blockchain Engine It-chain 시리즈</strong></p>
<ul>
<li><a href="https://steemit.com/blockchain/@keepit/keep-t-column-opensource-blockchain-engine-it-chain-01-peer-to-peer-network" target="_blank" rel="noopener">01. P2P 네트워크와 합의 알고리즘</a></li>
<li><a href="https://steemit.com/blockchain/@keepit/keep-t-column-opensource-blockchain-engine-it-chain-02-blockchain-component" target="_blank" rel="noopener">02. 블록의 생성과 동기화</a></li>
</ul>
<p><strong>LNH</strong></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/08/28/golang-cookbook/" itemprop="url">
                Golang cookbook
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-08-28T05:09:11.000Z" itemprop="datePublished">
                10 months ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/go/">go</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                a few seconds read (About 67 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!--toc-->
<h2><span id="setup">Setup</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line">export GOPATH = /Users/_username/Desktop/git/_projectName</span><br><span class="line">echo $GOPATH # 고패스 확인</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<h2><span id="type">Type</span></h2><p><strong>type assertion</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable.(<span class="keyword">type</span>)</span><br></pre></td></tr></table></figure>
<h2><span id="goland">Goland</span></h2><p>Gland 자동 copy right</p>
<p><code>Preferences</code> - <code>Editor</code> - <code>File and Code Templates</code> - <code>Files</code> 탭에서 <code>Go File</code> 클릭 - <code>package ${GO_PACKAGE_NAME}</code> 앞에 copyright 주석을 추가하시면 됩니다!</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/08/12/what is the blockchain technology/" itemprop="url">
                What is the blockchain technology
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-08-12T03:02:01.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                30 minutes read (About 4546 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="블록체인-기술은-무엇인가요">블록체인 ‘기술’은 무엇인가요</span></h1><p>가상화폐에 대한 관심이 높아지면서 많은 사람들이 블록체인 기술에 대해 이야기합니다. 누군가는 새로운 화폐경제의 도래에서 블록체인의 의미에 대해 열변을 토하며 진정한 의미의 경제의 민주화를 이야기하고, 누군가는 단순한 투기의 대상으로써 일확천금을 기대하며 인생역전의 기회에 대해 이야기 합니다.</p>
<p>하지만, 가상화폐는 블록체인 기술의 막대한 활용처 중 일부에 불과하며, 진정한 의미에서 블록체인 기술이 가지는 사회 경제적 의미를 알기 위해서는 블록체인의 ‘기술’ 그 자체로서의 의미와 역사에 대한 이해가 반드시 수반되어야 할 것입니다. </p>
<p>이번 글에서는 ‘가상화폐’를 넘어 블록체인 ‘’기술’ 자체에 주목하여, 기본적인 기술 철학과 개념에 대해 이야기해 보고자 합니다.</p>
<h2><span id="블록체인-기술은-무엇을-해결하고자-하는가">블록체인 기술은 무엇을 해결하고자 하는가</span></h2><p>현대 사회에서 일어나는 모든 일들은 사실 개인과 개인 사이의 약속과 합의에 관한 문제를 다룬다고 보아도 무방할 것입니다.</p>
<p>인간은 사회적 동물로써 최대 다수의 최대 행복을 추구하기 위한 수많은 사회적 계약을 체결하였고, 현대 사회의 윤리와 법 비즈니스는 이런 사소한 약속들의 집합체에 불과한 것입니다.</p>
<p>이렇게 인간 사회에서 약속과 계약, 거래라는 것이 중요해 짐에 따라 이를 보다 효율적으로 수행하기 위한 수많은 방법들이 도입되었는데, 과거 조개 껍데기가 화폐로 쓰이던 시절부터 오늘날의 주주 명세서에 이르기까지 개인과 개인부터 국가 단체 사이의 거래까지 모든 계약의 신뢰를 보장하고 많은 사람들이 합의를 이루기 위한 각종 형태의 매개물이 생겨나게 되었습니다.</p>
<p>블록체인 기술이 본질적으로 해결하고자 하는 문제도 이와 같은 사회적 의미를 가지며, 그 본질적인 원리는 고대 그리스에서 사회적 합의를 도자기 조각에 적어서 투표를 하던 것 그 이상도 이하도 아닙니다. 다만 물리적인 한계로 과거에는 소수의 사람들만이 도자기에 의사를 적어 선별된 소수끼리만 합의를 이룰 수 있었던 반면, 현대에는 분산 컴퓨팅과 네트워크 속도의 향상 등의 기술적 진보를 통해 이 과정이 과거에 비교할 수 없이 빨라졌으며, 이를 통해 일부의 선별된 집단의 구성원만이 아니라 모든 사람들의 의사를 효과적으로 반영할 수 있는 합의 시스템이 만들어 지게되었는데, 그것이 바로 블록체인 기술이 주는 핵심적인 의미입니다.</p>
<p><strong>즉, 기술의 발전으로 수천 수만의 사람들이 서로간에 완벽하게 투명하게 의사를 교환하고 수렴에 이를 수 있게 된 것입니다.</strong></p>
<p>하지만, 막대한 컴퓨팅 기반으로 수많은 거래와 계약을 모두가 인정하는 합의를 이루는 데에는 과거에는 없던 새로운 문제가 발생하게 되었는데 그것은 바로 모든 거래와 계약의 순서를 올바르게 지키는 것입니다. 수억대의 컴퓨터가 각각의 계약과 거래를 체결하고 이를 모든 컴퓨터와 공유함에 따라 어떤 계약이 먼저 일어났는지를 올바르게 유지하는 것은 매우 어려운 일이며 이를 해결하기 위한 다양한 시도들이 진행되었습니다.</p>
<p>이처럼 블록체인 에서는 위에서 수많은 <strong>거래, 계약</strong>들이 발생하게 되고, 그 모든 활동을 <strong>트랜잭션(transaction)</strong> 이라고 부르며, 그 순서와 신뢰도를 보장하여 수많은 컴퓨터들이 합의에 이르도록 해 주는 <strong>합의 알고리즘</strong>을 필요로 합니다.</p>
<h2><span id="합의-알고리즘">합의 알고리즘</span></h2><p>블록체인 내에서 일어나는 트랜잭션의 진실여부와 올바른 순서로 일어났는지에 대한 합의를 이루는 방법을 <strong>합의 알고리즘</strong> 이라고 합니다. 사실 블록체인이 생겨나기 전에는 이러한 모든 합의를 거대한 중앙기관(가령 은행이라는 통화 거래의 중심점) 에게 위임하고 그들이 판단하는 것을 진실로 약속하여 문제를 해결해 왔지만, 블록체인은 이러한 거대 기관이 아닌 진정한 의미에서의 민주주의라는 철학적 관점으로 모든 사람들의 합의를 진실로 규정하고자 하기에 이를 수행하기 위한 합의 알고리즘의 중요성이 강조됩니다.</p>
<h2><span id="블록체인의-성능">블록체인의 성능</span></h2><p>그렇다면 어떤 블록체인이 우수한 블록체인이라고 불릴 수 있을까요?</p>
<p>블록체인의 성능을 이야기 함에 있어 우리는 <strong>TPS(초당 트랜잭션 처리량)</strong> 에 대해 이야기 하며, 구체적으로 보자면 블록체인에서 하나의 블록에 속하는 트랜잭션의 수를 그 블록이 생성되는데 걸리는 시간으로 나눈 값으로 이해하면 됩니다. 하지만 이것은 불확실한 정의이며, 가령 특정 블럭이 생성된 이후에 블록이 폐기된다면 해당 트랜잭션은 무효처리 되는데 이 빈도가 많고 적음에 따라 실질적인 TPS를 따지는 데 영향을 미치게 됩니다.</p>
<p>얼핏 생각하면 블록은 어차피 컴퓨터가 만드는 것이고 단순히 임의로 블록을 빠르게 만들어 내도록 하면 더 빠르게 거래가 이루어 질 수 있다고 생각될 수 있습니다.</p>
<p>하지만, 여기서 생각해보아야 할 문제가 있는데 그것은 바로 컴퓨터 사이의 통신 속도입니다.</p>
<p>가령 1억대의 컴퓨터가 있고, 어떤 컴퓨터에서 거래가 일어나 그 거래가 가장 멀리 떨어진 노드에 전파되는 속도가 블록이 생성되는 속도에 비해 너무 길다고 생각해 봅시다. 그렇다면 어떤 거래에 대한 내용을 모든 네트워크 구성원이 인지하기도 전에 거래가 승인되고 그런 거래는 그 신뢰도에 문제가 생기게 될 것입니다. 때문에 <strong>전체 네트워크를 구성하는 노드들 사이에서 신뢰를 획득할 수 있을만큼 트랜잭션의 전달(propagation)하는 시간이 주어져야 하며 그 시간보다 블럭이 생성되는데 걸리는 시간이 길어야 신뢰할 수 있는 블럭을 생성할 수 있습니다.</strong></p>
<h2><span id="어떻게-블록체인의-성능을-향상시킬-것인가">어떻게 블록체인의 성능을 향상시킬 것인가?</span></h2><p>그렇다면 어떻게 블록체인의 성능을 향상시킬 수 있을까요?</p>
<p>블록체인의 성능을 향상시키는 방법에는 다음과 같이 크게 3가지 방법이 있습니다.</p>
<ol>
<li>샤딩</li>
<li>사이드 체인</li>
<li>스테이트 채널</li>
</ol>
<p><strong>먼저 전체 네트워크에서 특정 거래가 전파되는 속도를 향상시키기 위해서 네트워크를 작게 나누는 방법을 생각할 수 있습니다.</strong> 가령 어떤 학교에서 합의를 이루어야 하는 내용을 각 반별로 합의를 이루는 것으로 축약하고, 각 반의 구성원을 특정 숫자 이상으로 유지한다면 어느정도 믿을만한 합의가 이루어질 것인데, 이것을 블록체인에서는 <strong>샤딩</strong> 이라고 합니다.</p>
<p>현재 이더리움 재단에서 이러한 샤딩을 추진하고 있으며, 누구나 합의 과정에 참여 가능하도록 하자라는 철학을 가지고, stateless client(full state를 들고 있지 않고, state root 및 트랜잭션 정보만을 가진 노드) 도 검증을 수행할 수 있게 하였으며, 트랜잭션에 witness라는 값을 두어서 어떤 노드가 변경이 일어나는지를 추가합니다.</p>
<p><strong>즉, 샤딩은 블록체인 네트워크를 쪼게어 각각 순서를 정하여 합의를 이루고 나중에 합치는 방식으로 네트워크 속도를 향상시킵니다.</strong></p>
<p>다른 방법으로는 어떤 대규모 블록체인 안에서 소규모의 체인을 독자적으로 형성하고 그들사이의 합의 내용을 대규모 블록체인에 전달하는 방식이 있는데 이것을 <strong>사이드 체인</strong> 이라과 합니다. 이는 마치 중앙 정부와 시민 자치단체의 예로써 설명될 수 있는데, 시민 자치단체의 일정 수 이상의 구성원들이 완벽하게 합의를 이룬 사항에 대해 중앙 정부에 전달하고 이에대한 합의를 진행한다면, 전체 사회 내에서 시민단체에 속한 사람들 사이의 완벽한 합의를 도출하고 그 결과를 중앙정부에 합리적이고 투명하게 전달할 수 있게 될 것입니다.</p>
<p><strong>세번째 방식인 스테이트 채널</strong>은 거래 당사자들끼리 합의를 이루고 그 정보를 전체 체인에 올리는 방식입니다.</p>
<p>이처럼 위 방법들은 네트워크를 쪼개어 순서 문제를 해결하고 propagation 속도를 높여 성능을 증가시키고자 하지만, 이 경우 전체 네트워크를 구성하는 노드가 적어지기 때문에 거대 네트워크일 때보다 그 신뢰도가 내려가고 여러가지 문제가 발생할 수 있는 단점이 있습니다.</p>
<h2><span id="블록체인에서-거래는-언제-확정되는가">블록체인에서 거래는 언제 확정되는가</span></h2><p>흔히 사람들이 블록체인은 안전하지만 아직 너무 느리다는 이야기를 듣고는 하는데, 일반적으로 거래는 일어나는 즉시 블록체인에 기록하고 합의를 진행하는데 그것이 그렇게 오래 걸리나 하는 의문이 드는 것은 매우 당연한 일입니다.</p>
<p>과거 은행들이 개인의 거래를 누군가와의 합의 없이 자신들의 내부 DB의 정보만을 바꾸는 것으로 거래를 수행하던 것과는 달리 블록체인은 모든 사람의 거래 내역을 하나의 거대한 줄기인 블록들의 체인에 기록하는 것으로 합의가 올바르게 이루어 지지 않는 경우 하나의 줄기가 계속해서 여러 갈래로 나뉘고 다시 합쳐지는 것을 반복합니다. 즉, 이미 일어난 거래라도 블록이 나뉘고 합쳐지는 과정에서 소실될 수 있는 확률이 생기는데, 이는 화폐의 거래에는 매우 큰 이슈입니다. 때문에 블록체인을 통해 화폐를 거래하는 현대의 많은 체인들의 경우 여러 특정 거래가 나뉘지 않고 큰 하나의 줄기로 이어질 확률인 <strong>finality</strong> 라는 개념을 사용하며 finality 가 낮을 수록 거래가 확정될 확률이 높다고 보며, 비트코인에서는 이러한 finality를 위해 블록이 현재 거래가 발생한 시점부터 6개 이상이 생겨나게 되면 finality가 0.02 이하이기 때문에 확정된 거래로 보고 있습니다.</p>
<p>잘 생각해 보면 이러한 finality는 TPS 속도에 무관함을 알 수 있는데, 거래가 아무리 빨리 일어난다고 하더라도 그만큼 믿을만한 블록들이 생겨나는것은 다른 문제이기 때문입니다. 가령 TPS가 아주 높은 블록체인에서 거래를 하더라도 거래가 빠른 만큼 블록들이 많이 생겨야 finality가 특정 수치 이상으로 낮아질 것이고, TPS가 낮은 블록체인에 비해 더 많은 블록들이 생겨나야 거래가 확정될 수 있습니다.</p>
<p>이러한 <strong>finality 를 빨리 단축시키는 방법, 즉 이상적으로 즉시 결제가 일어나기 위해서 많은 방법들이 시도되고 있으며 그 활용 현황은 다음과 같습니다.</strong></p>
<ol>
<li>finality를 확보하지 않고 거래를 승인</li>
<li>DAG 알고리즘<br>블록이 아닌 트랜잭션의 유효성과 순서를 승인 받음</li>
<li>갈라진 두개의 블록을 병합하는 방식 -&gt; 연구중</li>
</ol>
<p><strong>첫번째 방식을 사용하는 대표적인 사례는 비트코인 캐시가 있습니다</strong>. 비트코인 캐시는 트랜잭션을 받자마자 바로 순서를 인정하며 사용자의 지갑의 값을 변경하는 것으로 즉, finality가 확보되지 않은 상태에서 거래가 진행이 되며 추후 이것이 바뀌면 지갑에서 값이 바뀔 수 있는 문제가 있습니다.</p>
<p><strong>두번째 방식은 DAG 알고리즘을 활용하는 것입니다.</strong> DAG 알고리즘에서는 블록단위로 거래를 기록하는 것이 아닌 트랜잭션 단위로 거래를 기록하기 때문에 사실상 실시간으로 거래가 일어날 수 있습니다. 블록체인이 하나의 큰 줄기를 만들어 역사를 기록하는 반면 DAG는 복잡한 거래를 DAG 그래프의 확장으로 보고 모든 노드는 자신에게 관련이 있는 거래만을 가지고 거래를 직접 검증하며, 이경우 블록의 합의 라던가 하는 부분이 이루어 지지 않기 때문에 사실 블록체인으로 보기는 힘든 측면이 있습니다.</p>
<p>세번째 방식은 갈라진 두개의 블록을 병합하여 하나의 블록의 만드는 방식으로 국내 decipher라는 블록체인 학회에서 연구가 진행중에 있습니다.</p>
<h2><span id="블록체인의-트랜잭션이-다루는-정보">블록체인의 트랜잭션이 다루는 정보</span></h2><p>블록체인이란 기본적으로 transaction으로 인해 변경되는 state를 기록하는 state machine입니다.</p>
<p>여기서 state의 종류에 따라 다양한 state model이 있는데, 다음과 같이 3가지 종류로 구분이 가능합니다.</p>
<ol>
<li>UTXO(Unspent Transaction Output)</li>
<li>Account</li>
<li>Memory</li>
</ol>
<p>먼저 <strong>UTXO state model</strong>은 비트코인이 쓰고 있는 모델로 트랜잭션의 아웃풋 자체가 토큰이고 토큰을 사용하였는가 안하였는가를 현재의 상태로 보고, 이것이 다른 트랜잭션의 인풋으로 들어가면 소비가 된 것으로 봅니다.</p>
<p><strong>Account 모델</strong>에서 모든 state는 account에 종속되어 있습니다. 각 account는 자신만의 고유의 nonce 를 가지며, 해당 account의 public key가 키값으로 사용된다. 즉 트랜잭션의 내용은 어떤 account가 가진 잔고에 대한 정보가 되며 이러한 수많은 계정 내역으로 블록체인이 이루어 진다. 이 경우 누가 얼마를 가졌는지를 바로 알 수 있기 때문에 편리한 점이 있지만, 프라이버시 부분에서 좋지 못한 부분이 있습니다.</p>
<p>마지막 모델은 memory 모델인데, 이 경우 트랜잭션은 256비트 짜리 address를 다루며, 각 컨트랙트는 특정 주소값을 할당받고, 여기서 트랜잭션이란 해당 주소값을 변경하는 내용을 기록합니다. 여기서의 키는 각 컨트랙트의 주소가 되며 현재 이더리움 재단에서 이러한 memory 모델과 account 모델을 차용하여 사용하고 있습니다.</p>
<h2><span id="블록체인은-어떻게-정보를-저장하는가">블록체인은 어떻게 정보를 저장하는가</span></h2><p>블록체인은 사실 블록들의 연결에 불과하고 모든 블록은 컴퓨터에 저장됩니다.</p>
<p>그렇다면 블록체인은 우리 컴퓨터에 어떤 정보들을 어떻게 저장하고 있을까요?</p>
<p>블록체인은 크게 다음과 같은 3가지 정보를 저장하고 있습니다.</p>
<ol>
<li>state</li>
<li>transaction</li>
<li>result of transaction</li>
</ol>
<p>위에서 알아본 바와 같이 블록체인은 상태값을 기본으로 저장합니다. 비트코인의 경우 트랜잭션만 저장하고 읽기 작업은 알아서 수행하는 반면 이더리움의 경우는 트랜잭션이 완료된 후의 현재 상태도 저장을 하여 보다 빠르게 데이터를 읽어 올 수 있게 합니다.</p>
<p>위와같은 정보는 대부분의 블록체인에서 키와 밸류 쌍으로 저장되며, 복잡한 쿼리문을 통해 정보를 읽는 등의 기능이 필요하지 않고 <strong>단순히 정보를 저장하고 꺼내오는 역할만 수행하므로 가벼운 데이터베이스인 키밸류 db를 사용하며, 흔히 leveldb 를 사용하고 있습니다</strong></p>
<p>LNH</p>
<p><strong>이 저작물은 <a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">크리에이티브 커먼즈 저작자표시-비영리-변경금지 4.0 국제 라이선스</a>에 따라 이용할 수 있습니다.</strong></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/08/12/c-언어-포인터/" itemprop="url">
                c 언어 포인터
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-08-11T15:04:14.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/c/">c</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                6 minutes read (About 863 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="c-언어-포인터">C 언어 포인터</span></h1><p>c 에서 포인터를 통해 직접 데이터의 주소에 접근할 수 있으며, 이러한 특성 때문에 C 언어가 low 하다고 불린다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num =<span class="number">5</span>; <span class="comment">// 정수형 변수 num을 생성한다.</span></span><br><span class="line">    <span class="keyword">int</span> * pnum = &amp;num; <span class="comment">// 정수형 변수 num을 가리키는 포인터 변수 pnum을 선언한다.</span></span><br><span class="line">    *pnum = <span class="number">10</span>; <span class="comment">// pnum이 가리키는 변수에 10을 저장하라</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이처럼 특정 자료를 가리키는 자료형을 정의 할 수 있고, 이를 포인터라 한다. </p>
<p>포인터는 특정 자료형을 가리키고 있다.</p>
<p>여기서 포인터는 어떤 변수를 가리키는 그 자체이므로 메모리의 특정 주소값을 가진다.</p>
<p>때문에 포인터를 선언할 때에는 매우 신중해야 하는데 선언 후 아무 값도 할당 하지 않는다면 포인터는 쓰레기 값으로 초기화 되기 때문이다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pnum = <span class="number">399</span>;</span><br></pre></td></tr></table></figure>
<p>가령 위와 같은 코드는 매우 위험한데 이는 pnum이라는 포인터에 399를 할당하고 있고, 우리는 399 의 주소값이 얼마나 중요한 주소인지 전혀 이해하고 있지 못하기 때문이다. 이를 해결하기 위해 반드시 우리는 해당 포인터 값이 이상한 값을 가리키지 않도록 해야 하는데 주로 다음과 같이 널 포인터를 지정해 준다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr2 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>위와 같이 NULL 혹은 0 으로 초기화 하면 시스템은 이것을 0 번째 주소값으로 인식하지 않고 아무것도 가리키지 않는 포인터를 만들어 낸다.</p>
<h2><span id="포인터와-배열의-관계">포인터와 배열의 관계</span></h2><p>c 언어에서 배열의 이름은 그 자체로 포인터 이며, 정확히 말하면 배열의 첫번째 요소의 주소값이다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>, arr); <span class="comment">// 주소값이 나온다.</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>, arr[<span class="number">0</span>]); <span class="comment">// 위와 같은 주소값이 나온다. 즉, 배열의 주소는 첫번째 값의 주소를 의미한다.</span></span><br></pre></td></tr></table></figure>
<p> 변수 형태의 문자열 vs 상수형태의 문자열</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"my string"</span>;</span><br><span class="line"><span class="keyword">char</span> * str2 = <span class="string">"your string"</span>;</span><br><span class="line"></span><br><span class="line">str1[<span class="number">0</span>] = <span class="string">"x"</span>;<span class="comment">// 문자열 변경 성공</span></span><br><span class="line">str2[<span class="number">0</span>] = <span class="string">"x"</span>; <span class="comment">// 문자열 변경 실패</span></span><br></pre></td></tr></table></figure>
<p>위처럼 모든 문자열 혹은 배열을 선언하면 그 자체는 그 문자열 혹은 배열의 첫번째 요소의 주소값이 된다.</p>
<p>하지만 위에서 처럼 문자열 혹은 배열 자체를 선언하는 경우와 그것의 주소값을 선언하는 경우에 따라 그 값의 변경 가능 유무가 결정이 된다.</p>
<p>위의 예처럼 str1의 경우 문자열 자체를 저장한 변수형 문자열이며, str2의 경우 문자열에 대한 주소값을 저장하는 상수 형태의 문자열이기 때문에 가리키는 값의 내용이 변경될 수 없다.</p>
<h2><span id="포인터-변수로-이루어진-배열">포인터 변수로 이루어진 배열</span></h2><p>다음과 같이 포인터 변수로 이루어진 배열을 선언할 수 있다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * strArr[<span class="number">3</span>] = &#123;<span class="string">"Simple"</span>, <span class="string">"String"</span>, <span class="string">"Array"</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s \n"</span>,strArr[<span class="number">0</span>]) <span class="comment">// Simple</span></span><br></pre></td></tr></table></figure>
<p>위처럼 “” 로 감싸진 문자열은 그 자체로 주소값을 나타내기 때문에 위와 같은 결과가 나오게 된다.</p>
<p>큰 따옴표로 묶여서 표현되는 문자열은 그 형태에 상관없이 메모리 공간에 저장된 후 그 주소값이 반환된다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/08/06/ejs-를-통해-express-에서-server-rendering-하기/" itemprop="url">
                ejs 를 통해 express 에서 server rendering 하기
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-08-06T03:06:41.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/ejs/">ejs</a><span>></span><a class="article-category-link" href="/categories/ejs/express/">express</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                a few seconds read (About 41 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="ejs-를-통해-express-에서-server-rendering-하기">ejs 를 통해 express 에서 server rendering 하기</span></h1><h2><span id="설치하기">설치하기</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save ejs</span><br></pre></td></tr></table></figure>
<h2><span id="server-code-작성">server code 작성</span></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.set(<span class="string">'views'</span>, __dirname + <span class="string">'/views'</span>);</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</span><br><span class="line">app.engine(<span class="string">'html'</span>, <span class="built_in">require</span>(<span class="string">'ejs'</span>).renderFile);</span><br></pre></td></tr></table></figure>
                        
    </div>
    
            
</article>



        
    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/page/5/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/page/7/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/">1</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/5/">5</a></li>
        
        <li><a class="pagination-link is-current" href="/page/6/">6</a></li>
        
        <li><a class="pagination-link" href="/page/7/">7</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/23/">23</a></li>
        
    </ul>
</nav>
    
    </div>
</section>

            <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 Jake.Lee 이남훈&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" href="https://github.com/frontalnh">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
                <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        //plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110077250-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-110077250-2');
</script>


    


<script src="/js/script.js"></script>

                    
                        <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
                            
</body>

</html>