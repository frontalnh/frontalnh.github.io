<!DOCTYPE html>
<html class="has-navbar-fixed-top">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Jake.Lee&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="google-site-verification" content="PgpnJMuvO-IqYWyFljnyr-tusLhJUz1VRMmECenJyHE">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">






<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="/css/style.css">
<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>

</head>

<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">Categories</a>
            
            <a class="navbar-item " href="/tags">Tags</a>
            
            <a class="navbar-item " href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" href="https://github.com/frontalnh">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

        <section class="section">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6354931397950820",
    enable_page_level_ads: true
  });
</script>

    <div class="container">
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/01/14/심리학-개론/" itemprop="url">
                심리학 개론
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-01-14T05:43:39.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                2 hours read (About 22065 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="심리학의-본질과-이해">심리학의 본질과 이해</span></h1><h2><span id="심리학이란-무엇인가">심리학이란 무엇인가</span></h2><p>심리학이란 인간의 행동이나 정신 과정에 대한 과학적 연구를 하는 학문이다.<br>Psyche(영혼) + Logos(연구) ‘영혼에 대한 연구’</p>
<p>인간의 정신 과정과 행동에 관한 과학적 연구<br>인간행동의 포괄적인 설명을 목표로 하였고 즉, “인간들은 왜 그렇게 행동하는가?”에 대한 질문을 한다.</p>
<h3><span id="심리학의-역사">심리학의 역사</span></h3><p>심리학의 역사는 철학과 과학에서 시작되었으며, 19세기 후반 마음의 연구에 과학적 방법을 사용하면서 하나의 독립적인 학문으로 성장하였다.<br>‘사유’로서 진리, 진실에 대한 답을 얻었다.(철학적이었다.) - 무검증</p>
<p>1920년대 초<br>직접 관찰이 불가능한 마음에 대한 연구보다 관찰 가능한 행동에 대한 연구를 시작하였다.<br>갈등이나 분노와 같은 정신적 경험에 대해 연구하기 보다 음주나 공격적 행동과 같은 관찰 가능한 명백한 행동에 대해 연구하기 시작하였다.<br>즉, 1920년대의 심리학은 행동의 과학적 연구로 정의할 수 있다.</p>
<p>다음과 같은 두가지 측면을 고려하여 심리학을 정의할 수 있다.</p>
<ol>
<li>심리학은 인간행동의 포괄적인 설명을 그 목표로 하고 있다.</li>
<li>심리학이 과학이 되기 위해서는 엄격한 정의, 부정하게 규정된 절차, 그리고 결과의 항상성을 강조하는 일반화된 과학적 방법론을 따라야 한다.</li>
</ol>
<ol>
<li>심리학의 근원<br>심리학의 역사적 근원은 철학과 과학에 있다.19세기 후반 학자들이 마음의 연구에 과학적인 방법을 사용하면서 심리학은 비로소 하나의 독립적인 과학적 학문으로 자리를 잡았다.</li>
</ol>
<p>심리학의 철학적 근원<br>심리학의 역사는 소크라테스를 전후로 나뉜다.<br>소크라테스는 질문법으로 상대의 무지를 깨닫게 하였으며, 이성의 힘을 강조하였다.</p>
<p>플라톤은 지식의 원천 면에서 감각을 의심하였다.<br>물 속에서 굽어보이는 막대기를 예를 들어 왜곡된 지각을 설명하였다.<br>인간은 원래 지식을 가지고 태어난다고 믿었으며, 추론이 이러한 지식에 접근할 수 있게 한다고 믿었다. - 합리주의<br>꿈, 지각, 정신질환 등을 연구하기 위해 이성을 사용하였다. - 이성주의</p>
<p>아리스토텔레스는 경험주의 철학을 강조하여 감각 경험을 플라톤보다 중요하게 받아들였다.<br>아리스토텔레스는 뇌보다 심장이 더 민감하게 반응한다는 논리로 인간이 정서적인 경험을 더 강하게 받아들인다고 하였다.<br>또한, 심리학적 주제에 대해 최초로 형식을 갖추어 깊이 생각하였다.</p>
<p>성 어거스틴은 고백에서 자기분석을 통해 기억과 정서 동기에 대해 기술하였으며, 이성과 동물적 열정, 성욕 사이의 지속적 갈등에 대한 통찰을 제시하였다.<br>이성을 심리적 연구에 사용했으나 과학적 방법은 사용하지 않았다.</p>
<p>베이컨은 오감을 통해서 지식획득을 강조한 아랍 과학자의 영향을 받았다.<br>권위에 대항한 경험주의를 철학자들에게 강조하였다.<br>증명, 체계적 관찰 등을 장려하여 현대 과학적 태도를 취했다.<br>경험주의를 강조함으로써 신학자들과 충돌하였다.</p>
<p>데카르트는 최초의 현대적 이성주의자이자 수학자, 철학자, 과학자 였다.<br>분명하게 증명되지 않은 모든 것을 의심하였다.<br>방법서설 : “나는 생각한다. 고로 나는 존재한다.”<br>종교지도자의 주장을 맹목적으로 받아들이는 것에 반대하였다.</p>
<p>로크는 베이컨의 경험주의적 사상을 추종하였다.<br>그는 백지설을 내세우며 감각을 통해 얻은 인생 경험으로 지식을 채운다고 설명하였으며, 지식이란 인생 경험을 통해 얻어지는 것이라 하였다.<br>경험주의(nuture) - 이성주의(nature, 본성)</p>
<p>칸트는 합리주의와 경험주의의 절충을 이루어 낸다.<br>“지식이란 물리적 환경의 감각적 조직화와 이해의 생득적 정신기제에 의한 결과물”이라고 보았다.<br>예를 들어 인간은 태어난 곳의 언어 경험에 의해 특정한 말을 하게 되는데, 말하는 능력과 언어는 타고난 두뇌기제에 의존하므로 경험하지 못한 다른 언어를 구사할 수 없다. 그런데 인간은 생득적 언어기제를 통해 다른 환경에서 다른 언어의 학습과 이해도 가능하다는 것이다.<br>하지만, 심리학이 과학이라는 것을 부정하였으며, 정신은 직접 관찰, 측정, 조작할 수 없다는 주장을 펼쳤다.</p>
<ol start="2">
<li>심리학의 과학적 근원<br>헬름홀츠는 허벅지와 발에 자극을 가해 반응한 속도를 측정하여 신경자극이 순간적인 것이 아니라는 것을 보여주었다.</li>
</ol>
<p>플루랑스는 특정 뇌 부위의 손상이 운동기능에 부조화를 일으킨다는 것을 발견하였고, 브로카는 인간의 뇌손상이 언어 능력을 상실한는 사례를 통해 뇌와 심리적 과정의 본질에 대한 과학적 탐구를 하였다.</p>
<p>페히너는 물질적 자극과 정신적 경험 간의 관계를 측정함으로써 (예를 들어 밝기, 소음의 역치 등) 심리학이 과학적으로 연구될 수 없다고 믿었던 당대 통념을 깨놓게 된다.</p>
<p>개인차 심리학<br>사람들 간의 지능, 성격 신체적 특성의 다양성<br>커텔 - 시각, 청각, 신체적 기술 등 다양한 검사를 기술하였다.<br>정신검사라는 단어를 사용하였고, 최초의 심리학 교수이다.</p>
<h2><span id="초기-심리학">초기 심리학</span></h2><h3><span id="구조주의-심리학">구조주의 심리학</span></h3><p>최초의 심리학 학판인 구조주의는 19세기에 생겨났다.<br>구조주의자들은 마음을 구성 요소로 분석하고, 그 구성 요소가 어떻게 상호작용하는가를 발견하려고 하였다.<br>즉, 정신을 구성하는 요소와 내용을 밝히려고 시도하였다.</p>
<p>구조주의는 최초로 등장한 심리학파이면서 동시에 가장 빨리 그 자취를 감춘 학파인데, 이는 구조주의 학파의 연구가 연구실에 제한되었기 때문이다.</p>
<p>분석적 내성법<br>정신을 구성하는 심상, 느낌, 감각을 분석하는 방법이다.</p>
<h3><span id="기능주의-심리학">기능주의 심리학</span></h3><p>어떤 자극이 사람들에게 어떻게 영향을 미치는가<br>분석적 내성법이 불가능한 대상 즉, 어린아이, 정신장애인, 동물에 대해서는 구조주의 심리학을 적용할 수 없다.<br>구조주의 심리학자들이 맛에대한 정신적 구성 요소를 알고자 했다면, 기능주의 심리학자들은 맛을 구별하는 능력이 행동에 미치는 영향을 탐구하였다.<br>기능주의 심리학자들은 인간이 갖고 있는 의식의 내용이 아니라 인간이 보고 느끼고 생각하는 것의 심리적 기능을 연구 대상으로 삼아야 한다고 주장하였다.<br>ex) 듀이는 이러한 이론을 교육현장에 적용하였다.</p>
<h3><span id="행동주의-심리학">행동주의 심리학</span></h3><p>행동주의 심리학의 창시자로 볼 수 있는 왓슨은 정신이 심리학을 연구하기 위한 적절한 대상이라는 생각에 반대하였다.<br>직접 실험이나 관찰이 불가능한 정신 경험을 연구하는 데 반대하였다.</p>
<p>행동주의 심리학자들은 모든 행동을 조건 형성의 결과로 보고 인간 이해의 기본 공식을 자극과 반응의 관계로 규정하였다.<br>또한 왓슨은 행동에 미치는 환경의 영향력을 주용시하였다.</p>
<p>특히, 아동들의 행동에 미치는 환경의 영향력을 믿었는데, 다음과 같은 말에 그런 내용이 잘 녹아난다.<br>“나에게 건강한 유아와 그들을 잘 자라게 할 수 있는 환경만 제공해 준다면, 나는 무작위로 그들 중 한 명을<br>택하여 내가 원하는 어떤 방면의 전문가도 될게 할 수 있다.”</p>
<p>유전보다 환경을 가조한다. / 관찰 및 추정 가능한 사건 또는 행동만을 연구 대상으로 삼았다.</p>
<h3><span id="행태주의-심리학">행태주의 심리학</span></h3><p>행태주의 심리학은 ‘게슈탈트’ 즉, “전체는 부분의 합이 아니다”를 강조한다.<br>이것은 마음을 그 구성요소로 분석하려는 구조주의 심리학자들을 반박하는 것으로<br>인간은 어떤 대상을 부분의 조합이 아닌 전체로 인식한다고 주장하였으며, 어떤 내용을 요소로 다시 나누면 원래의 내용은 존재하지 않으며 이 요소를 다시 재결합 하여도 원래대로 돌릴 수 없다고 말한다.<br>즉, 의식의 내용을 구성 요소로 분석하면 원래의 내용은 사라지고, 이 요소를 다시 결합한다 해도 원래대로 돌릴 수 없다는 것이다.</p>
<p>행태주의 심리학자들은 인지는 일련의 개별적인 감각 이상의 것이라고 말하며 학습, 기억 문제해결 등의 지적 활동에서 지각 중심적인 해석을 강조한다.<br>이는 인지심리학의 발달에 많은 영향을 끼치게 된다.</p>
<h3><span id="정신분석">정신분석</span></h3><p>프로이트의 정신분석은 무의식을 심리학에 포함시킨 최초의 연구이다.<br>프로이트의 사례연구는 대개 성, 공격성과 관련된 무의식적 충동들이 인간행동의 가장 강력한 동인이라고 얘기한다.<br>성과 같은 무의식에 의하여 동기화 된다고 주장하여 대중에게 충격을 주었다.<br>또한, 아동 초기의 경험들이 성격발달에 가장 중요한 요인이라는 주장을 한다.</p>
<p>정신결정론 - 사람의 행동은 정상이든 비정상이든 간에 의식하지 못하는 심리적 동기(무의식)에 영향을 받게 됨.<br>프로이트의 정신분석은 무의식이 명확한 원인이 없는 행동들을 설명하는 데 너무 쉽게 사용된다는 점과 실험을 통한 측정과정이 없다는 비판을 받는다.<br>뿐만 아니라 환자들의 면담과정 기록 자료를 근거로 사용하여 심리적 장애상태의 소수 사례를 일반화 시킨다는 지적이 있다.</p>
<h2><span id="현대-심리학의-관점">현대 심리학의 관점</span></h2><h3><span id="행동주의적-관점">행동주의적 관점</span></h3><p>왓슨의 방법론적 행돈주의를 계승하여 급진적 행동주의가 나타나게 된다.<br>인간의 심리 상태를 관찰 가능한 행동을 통해 객관적으로 연구함<br>정서, 느낌, 사고 등과 같이 직접 관찰하기 어려운 현상에 대해서도 심리학적 연구 필요성 주장하였다.<br>스키너 “바람직한 행동에 대해 긍정적 강화를 제공함으로써 시민을 조절하는 행동주의자들이 이상적인 사회를 만든다.”</p>
<h3><span id="정신분석적-관점">정신분석적 관점</span></h3><p>프로이트로 대표되는 정신분석적 관점은 인간의 행동이나 정신 과정을 본능과 무의식으로 설명하려 한다.<br>대표적인 학자로 아들러와 융이 있다.<br>인간의 행동을 본능과 무의식으로 설명하였으며, 무의식의 과정을 설명하기 위해 노력하였다.</p>
<p>사고, 공포, 갈등 등의 본질은 파악할 수 없으며, 무의식적 과정은 존재하여 인간행동에 영향을 미친다고 주장한다.<br>생리적 추동의 중요성을 무시하였으며, 유아기 경험 및 무의식을 강조하였다.</p>
<h3><span id="인본주의적-관점">인본주의적 관점</span></h3><p>매슬로와 로저스는 인간은 자유의지를 가지고 있으며 무의식적인 동기와 환경적 자극에 의해 움직이는 존재가 아니다.<br>인간의 자유의지와 자아실현에 대한 욕구에 집중하였으며, “모든 사람의 잠재력 실현”<br>현재의 느낌과 사고와 같은 개인의 주관적 경험을 강조하였다.<br>현대 심리학 연구에 가장 크게 영향을 미쳤으며, 인간은 스스로 자신을 통제할 능력을 가지고 있는 자유로운 행위자로 간주한다.</p>
<h3><span id="인지적-관점인지-심리학">인지적 관점(인지 심리학)</span></h3><p>인간은 수동적으로 자극을 지각하는 것이 아니라, 능동적으로 지각한다고 주장한다.<br>그것ㅇ르 다시 새로운 형태나 항목으로 변경한다고 한다.<br>외부에서 받아들이는 정보를 사람들이 어떻게 받아들이고 처리하는가를 연구하였다.<br>인간의 정보처리과정에 관심</p>
<h3><span id="생리심리학적-관점">생리심리학적 관점</span></h3><p>생물학적 견지에서 인간을 이해</p>
<h2><span id="심리학의-분야">심리학의 분야</span></h2><h3><span id="이론심리학">이론심리학</span></h3><p>학습심리학<br>세상 배우는 원리를 학습심리학</p>
<p>발달심리학<br>전생에 발달을 연구하는 발달 심리학</p>
<p>인지심리학</p>
<h3><span id="응용심리학">응용심리학</span></h3><h3><span id="새로운-분야">새로운 분야</span></h3><p>법정 심리학<br>법 제도와 관련된 분야</p>
<p>스포츠 심리학<br>선수들의 수행을 향상시키는데 적용</p>
<p>신경심리학<br>기능적으로 문제가 있는 뇌의 영역을 파악</p>
<h1><span id="심리학의-연구-방법">심리학의 연구 방법</span></h1><h2><span id="심리학-연구의-단계">심리학 연구의 단계</span></h2><p>연구 환경<br>개인의 실제 환경, 통제된 연구실</p>
<p>한계<br>행동은 직접 관찰할 수 있지만, 개인의 정신과정은 관찰할 수 없다.<br>인간의 많은 활동은 매우 개인적이다.<br>내적인 사건(추론, 창조, 꿈 등)을 포함한다.<br>-&gt; 정신과정을 직접 관찰할 수는 없지만, 정신과정의 연구는 매우 중요한 주제이고, 심리학 연구기술의 발전을 가져왔다.</p>
<p>심리학의 과학 연구는 문제 선정, 연구 방법 설계, 데이터 수집 및 분석, 결론 도출, 결과 발표의 과정을거친다.<br>연구 문제의 선정<br>연구 주제는 어떤 현상에 대한 의문으로 선택하며 이러한 질문들은 과학적으로 가능한 것이어야 한다.</p>
<p>가설 설정과 조작적 정의<br>가설은 둘 또는 그 이상의 변인 간의 관계성에 대한 추측이다.<br>어떤 개념을 측정 가능하게 정의하는 것을 조작정 정의라고 한다.</p>
<p>연구 방법 결정과 데이터 수집<br>연구방법은 크게 기술적 연구와 실험연구로 나뉘게 된다.<br>기술적 연구는 사례연구, 자연적 관찰, 조사법과 같은 방법으로 실험을 수행하기가 불가능한 경우에 사용한다.<br>실험연구는 변인 간 인과관계를 설명하는 데 사용된다.</p>
<p>데이터 수집 방법<br>실험연구에서는 표본의 반응을 측정함으로써 수집하고, 기술적 연구에서는 설문조사나 질문지를 통해 데이터를 수집한다.<br>데이터 분석과 결론 도출</p>
<p>연구 결과 보고</p>
<p>연구 단계<br>가설<br>변인<br>조작적 정의<br>어떤 개념을 측정가능하게 정의하는 것<br>‘공부 시간’은 ‘일정 시간’동안 실제 공부한 양</p>
<h2><span id="횡단적-연구와-종단적-연구">횡단적 연구와 종단적 연구</span></h2><p>횡단적 연구 VS 종단적 연구<br>횡단적 연구 / 단일 시점에서 수행하는 연구<br>종단적 연구 / 동일한 대상으로 일정 기간 수행하는 연구</p>
<p>실험 관찰</p>
<h3><span id="인과관계와-상관관계">인과관계와 상관관계</span></h3><p>인과관계란 어떤 변인이 다른 변인의 변화를 이야기하는 것이며, 상관관계는 어떤 한 변인이 변화할 때 다른 변인도 함께 변화하는 것을 말한다.</p>
<p>상관관계<br>정적상관 / 한 변인이 증가함에 따라 다른 변인도 증가하는 관계이다.<br>부적상관 / 한 변인이 증가함에 따라 다른 변인이 감소하는 관계이다.</p>
<p>심리학을 비롯한 사회과학에서 상관관계와 인과관계를 명확하게 구분하는 것은 매우 중료하다.<br>그렇지 않으면 두 변인관의 관계가 잘못 해석될 수 있기 때문이다.<br>심리학에서는 독립변수에 처치를 가한 유무에 따른 결과를 비교하는 경우가 많다.</p>
<h3><span id="연구-설계">연구 설계</span></h3><p>실험 연구<br>실험법은 변인 간 인과관계를 규명하기 위하여 사용한다.<br>표본의 반응을 측정함으로써 수집한다.</p>
<p>기술적 연구<br>조작적 정의<br>연구자의 추론이나 조작 없이, 어떤 행동이 일어나고 있으며 어떤 양과 빈도로 발생하고 있는지를 수량화하는 것이다.<br>설문조사나 질문지를 통해 데이터를 수집한다.</p>
<ol>
<li>자연적 관찰<br>자연적 관찰이란 자연적 환경에서 관심 있는 변인을 관찰하고 기록하는 방법이다.</li>
</ol>
<p>-이점-<br>실험상황이 아닌 자연 상황<br>추후 연구에 대한 아이디어를 얻을 수 있다<br>실험 연구가 불가능한 상황에서 실험 연구의 대안이 될 수 있다.<br>ex) 유아의 불안행동</p>
<p>-문제점-<br>시간과 비용이 많이 발생한다.<br>인과관계의 어려움이 있다.<br>가외변인을 통제할 수 없다.<br>대상자의 편향이 나타난다.<br>관찰 대상자가 관찰자의 존재를 알아차리고 평소와 다르게 행동할 가능성이 있다.<br>신뢰도문제가 생긴다 -&gt; 관찰자가 행동을 정확하게 관찰햇다는 것을 보장하기 위해 두명 이상의 관찰자가 동시에 관찰한 후 비교해 보는 관찰자간 비교가 필요하다</p>
<ol start="2">
<li>조사법(Survey Method)<br>심리학 연구에서 가장 흔하게 사용되는 방법이다.<br>연구자는 모집단에서 표본을 추출하여 조사하고 그 결과로 전집의 특성을 추론하는 방식이다.<br>조사를 통해 행동, 의견 및 태도, 인구통계학적 변인을 광범위하게 수집할 수 있다.</li>
</ol>
<p>접집을 모두 조사하는 경우와 표본을 추출하여 조사하는 경우가 있는데<br>전집을 모두 조사하는 <b>센서스</b>의 경우 시행하기 어렵고 <b>무선표집(random sampling)</b>을 통한 모집단에서 표본 추출을 통해 조사를 하는 경우가 많다.</p>
<p>-정보를 얻는 방식-<br>면접법, 전화조사법, 질문지법</p>
<p>-장점-<br>1)다량의 데이터<br>2)적은 비용<br>3)빠른 시간</p>
<p>-단점-<br>1)대표성이 없는 표본 또는 잘못 작성된 질문 문항에 의해 조사 결과가 영향을 받을 수 있다.<br>2)조사 대상자의 태도가 결과에 영향을 주 수 있다<br>3)대상자가 연구자의 의도에 순응하여 반응하거나, 자기 자신을 좀 더 좋게 보이도록 거짓 반응을 하거나, 잘못된 기억에 의하여 반응할 수 있다.</p>
<ol start="3">
<li><p>상관연구</p>
</li>
<li><p>사례연구(Case Study)<br>사례연구란 한 개인이나 집단 또는 조직을 대상으로 어떤 문제나 특성을 심층적으로 조사, 분석하는 연구이다.<br>대표적으로 프로이트의 정신분석이론의 사례들이 이에 해당되며, 임상심리학에서 유용하게 사용된다.(개인의 행동 특징에 관심을 두기 때문)</p>
</li>
</ol>
<p>사례연구는 한 개인이나 집단을 심도 있게 관찰한다는 측면에서 자연적 관찰의 한 유형으로 볼 수 있다.</p>
<ol start="5">
<li>문헌 연구(Archival Research)<br>문헌연구란 다른 연구자가 수행한 연구를 분석하거나 역사적 기록을 살펴보는 방식이다.</li>
</ol>
<p>-이점-<br>1) 다량의 데이터가 존재하기 때문에 추세, 관계성 및 결과에 대해 더 잘 알 수 있다.<br>2) 비용이 적게 든다.</p>
<p>-단점-<br>1) 필요한 데이터를 마음대로 수집하기 어렵다.<br>2) 일정 시기의 데이터가 누락되어 있는 경우가 있다.<br>3) 선행 연구를 신뢰할 수 없는 경우가 있다.</p>
<h2><span id="연구의-타당도와-신뢰도">연구의 타당도와 신뢰도</span></h2><p>타당도<br>측정하고자 의도한 것을 실제로 측정해 낸 정도를 의미한다.<br>내적 타당도<br>관찰한 결과에 대해서 인과관계를 확신할 수 있는가를 말한다.</p>
<p>외적 타당도<br>연구 결과를 다른 사람, 다른 환경에 일반화 시킬 수 있느냐의 문제이다.<br>외적 타당도는 전집 타당도와 생태학적 타당도의 측면에서 검토하여야 한다.<br>전집 타당도 / 연구 결과를 다른 피험자에게 일반화할 수 있느냐<br>생태학적 타당도 / 실험 상황이나 조건과 유사한 다른 상황 및 환경에 대하여 일반화할 수 있느냐</p>
<p>-내적 타당도를 향상시키는 방법-<br>가외변인의 통제와 무선할당을 통해 내적 타당도를 향상시킬 수 있다.</p>
<p>-외적 타당도를 향상시키는 방법-<br>전집 타당도의 경우 전집의 특성을 충분히 반영하고 있는 표본을 표집함으로써 어느 정도 극복할 수 있다.<br>주로, 무선표집을 통하여 전집 타당도를 확보한다.</p>
<p>-내적 타당도를 위협하는 요인-<br>피험자 특성, 외적 사건, 피험자 성숙, 피험자 학습효과, 측정도구의 변화, 평균으로의 회귀, 피험자 상실, 선택-성숙 상호작용, 실험자 편파</p>
<p>-외적 타당도를 위협하는 요인-<br>1)표본의 대표성 : 표본이 전집을 대표하지 못하는 경우<br>2)피험자의 반응성 : 피험자들이 평소와 다른 행동과 반응을 보이는 경우</p>
<p>신뢰도<br>우리가 조사한 값이 얼마나 믿을만 한가에 대한 것이다.<br>신뢰도는 행동 측정의 인관성을 의미한다.<br>즉, 동일한 대상을 반복 측정하면 동일한 값을 얻어야 한다는 것이다.</p>
<p>-검사-재검사 신뢰도-<br>짧은 시간 간격 동안 연속해서 같은 검사를 두 번 실시한다.</p>
<p>-동형검사 신뢰도-<br>문항내용은 다르지만 측정 내용, 문항 수, 문항 형식, 난이도 등이 같은 두 개의 동형 검사를 제작하여 동일한 대상에게 연속적으로 실시하는 것이다.</p>
<p>-반분 신뢰도-<br>피험자에게 한 번의 검사를 실시한 후 적절하게 평가도구를 반분하여 분할된 각 부분을 독립된 검사라고 여기고 실시한다.</p>
<h2><span id="연구의-윤리">연구의 윤리</span></h2><p>연구 수행 과정에서의 윤리<br>1) 연구 참여에 대한 동의가 이루어져야 한다.<br>2) 피험자를 속여야 한느 경우 연구의 과학적 가치 측면에서 정당해야 하며, 다른 대안이 있을 수 없을 때에만 제한적으로 사용해야 한다.<br>3) 동물의 인도적인 보호와 사용<br>심리학 실험에서 동물의 사용은 동물 실험 이외의 대안이 없을 때에만 가능하다.<br>연구 결과 출판에서의 윤리<br>1) 자료의 조작 및 표절을 하면 안 된다.<br>2) 연구 자료를 중복으로 출판하면 안된다.</p>
<h1><span id="감각과-지각">감각과 지각</span></h1><p>감각이란 시각, 청각, 후각, 미각, 촉각 과정으로 즉각적이고, 원초적이고 직접적인 반면, 지각이란 사람이 느낀 감각을 어떻게 받아들이느냐에 대한 것으로 선택적이고 조직적이고 해석적이다.</p>
<p>외부 세계의 물리적 자극을 내면화 하는 과정의 가장 초기 단계에는 외부로부터 유입되는 자극의 물리적 특성을 신경전달 신호로 변환하는 감각수용기가 존재한다.</p>
<p>인간이 지각하는 다양한 자극의 물리적 특성은 반드시 그 특성이 일대일로 지각되지는 않는다.</p>
<h2><span id="감각과-지각의-측정방법과-원리">감각과 지각의 측정방법과 원리</span></h2><p>베버의 법칙과 최소 식별 차이<br>자극 변화를 탐지하기 위한 자극 강도 변화의 최소값은 그 자극의 원래 강도와 비례한다.<br>최소식별 차이: 자극 강도의 탐지는 물리적 자극 간의 절대적 차이가 아닌 기준 자극의 변화량에 의존하는 데 이와 같은 자극 변별을 위한 상대적인 변화량을 최소식별차이라고 정의한다.<br>감각역치와 신호탐지이론<br>감각역치: 탐지를 의식적으로 보고 할 수 있는 물리적 자극의 강도이다.<br>감각역치는 측정의 대상이 되는 각 개인마다 개인차가 있으며, 자극에 대한 탐지 보고의 유무와 실제 자극의 존재 유무를 고려해 개인의 민감도를 측정하는 방법이 신호탐지이론이다.<br>점화 현상과 역하지각<br>역하지각(subliminal perception): 물리적 자극은 존재하지만 그 강도가 역치 이하인 자극<br>점화 효과는 의식적으로 그 존재를 보고하지 못하는 자극들이라도 일정 수준의 지각적 처리가 일어나는 현상이다.</p>
<p>상향식 처리<br>물리적 속성의 단서가 가장 낮은 수준으로부터 높은 수준으로 이동하는 처리단계로 감각 정보가 수용기세포를 통해 입력되어 뇌로 전달되어 해석되는 일방향적인 과정이다.<br>ex) 책상을 지각하는 경우</p>
<h2><span id="시각-과정의-기능적-이해">시각 과정의 기능적 이해</span></h2><p>시각 정보의 조직화와 게슈탈트 원리<br>시각 체계가 시각정보를 조직화하여 사물의 모양을 파악하는 과정을 관찰함으로써 이해할 수 있다.</p>
<h2><span id="지각의-이해">지각의 이해</span></h2><p>외부 세계에 존재하는 압도적인 감각 정보의 양을 고려할 때 경우에 따라서는 정보의 선별적 처리가 불가피하다는 것에 동의하지만 이러한 관점은 인간의 정보 처리 능력에는 한계가 있으며, 따라서 매 순간 가장 중요한 정보들만 선택적으로 처리함으로써 효율적 정보 처리를 달성할 수 있다는 맥락에서 이해될 수 있다.<br>지각의 기능</p>
<ol>
<li>주의 과정을 통해 어느 입력 정보가 처리되어야 하고 어느 입력 정보가 버려져야 하는지에 관한 결정을 내린다.</li>
<li>대상이 어디에 위치하는가를 결정할 수 있다.</li>
<li>지각 체계는 내가 지각하고 있는 대상이 정확하게 무엇인지 결정할 수 있어야 한다.</li>
<li>재인된 대상의 결정적 특성을 추상적으로 도식할 수 있어야 한다.</li>
<li>지각적 항등성<br>지각 체계는 대상의 본질적 특징을 개념적으로 파악하여야 한다.</li>
</ol>
<h1><span id="학습">학습</span></h1><h2><span id="학습의-정의">학습의 정의</span></h2><p>학습이란 경험을 통해 얻는 행동과 지식에서의 비교적 영속적인 변화이다.<br>행동주의 에서는 고전적 조건화, 조작적 조건화, 조형 등의 원리를 활용하여 학습을 시키고,<br>인지주의 에서는 관찰학습, 모방학습, 통찰학습, 잠재학습 등을 이용한다.</p>
<h2><span id="고전적-조건화">고전적 조건화</span></h2><p>고전적 조건화는 흔히 반응 조건화 혹은 파블로프 조건화로 불린다.<br>고전적 조건화에서는 처음에 어떠한 기능도 하지 않던 자극이 특정 반응을 유출할 수 있는 능력을 가지게 된다.</p>
<h3><span id="고전적-반응의-형성">고전적 반응의 형성</span></h3><p>고전적 조건화를 시도하기 위해서는 먼저 반사반응을 유발시키는 자극을 찾아야 하는데 이를 무조건 자극(UnConditioned Stimulus)이라고 한다.<br>무조건 자극에 의해 자동적으로 유발되는 반응을 무조건 반응(UnConditioned Response)이라고 한다.</p>
<p>고전적 조건화를 형성하기 위한 다음 단계는 무조건 자극과 중립 자극을 서로 조건화 시키는 과정이다.<br>이 같은 연합과정을 여러 차례반복하게 되면 중립 자극은 결구구 무조건 자극이 없어도 반응을 유발시킬 수 있게 되는데 이 중립 자극을 조건 자극이라고 하며, 이 자극에 의해 유발되는 반응을 조건 반응이라고 한다.</p>
<p>시간을 어떻게 배치하는 가에 따라 다음과 같은 다섯 가지 유형의 조건화 과정이 있다.<br>지연 조건화<br>두가지 종류가 있는데 하나는 중립 자극을 먼저 제시하여 일정 시간을 유지한 후 제거함과 동시에 무조건 자극을 제시하는 방법이며, 하나는 중립 자극을 제시하고 있는 중에 무조건 자극을 제시함으로써 두 자극을 동시에 제시하여 일정 시간이 지난 후 동시에 제거하는 방법이다.</p>
<p>흔적 조건화<br>중립 자극의 철회와 무조건 자극의 제시 사이에 어느 정도의 시간 간격이 있는 것을 말한다.<br>이 방법은 시간 간격이 짧은 경우에만 효과적이라고 할 수 있다.</p>
<p>동시 조건화<br>중립 자극과 무조건 자극을 동시에 제시하였다가 동시에 제거하는 것인데, 이 방법은 일반적으로 효과적이지 못한 것으로 알려져 있다.</p>
<p>후진 조건화<br>무조건 자극을 먼저 제시하고 조건 자극을 나중에 제시하는 것으로, 앞의 방법들에 비해 조건화가 가장 형성되기 어렵다.<br>고차적 조건화<br>어떤 중립 자극이 고전적 조건화 과정을 통해 조건 자극이 되었을 때, 이 조건 자극을 또 다른 중립 자극과 반복적으로 연합하면 그 중립 자극도 조건 반응을 일으킬 수 있는 또 하나의 조건 자극이 될 수 있다. 이러한 현상을 이차적 조건화라고 한다.</p>
<p>소거와 자발적 회복<br>소거: 무조건 자극이 조건 자극과 연합되지 않음으로써 조건 자극이 반응을 일으키지 못하는 현상이다.<br>소거 과정을 통하여 일단 조건 자극이 능력을 상실한 것으로 보이더라도 어느 정도 시간이 지난 후 조건 자극을 제시하면 다시 조건 반응이 일어난다.<br>소거 후에 아전의 조건 자극을 다시 제시하면 이러한 현상이 일반적으로 나타나는데 이것을 자발적 회복이라고 한다.<br>자극 일반화와 변별<br>자극 일반화란 어떤 자극이 일단 조건 자극으로서 형성되고 나면, 이 자극과 유사한 다른 자극들도 무조건 자극과 연합된 적이 없음에도 조건 반응을 알 수 있다.<br>ex) 자라보고 놀란 가슴 솥뚜껑 보고 놀란다.</p>
<h2><span id="조작적-조건화">조작적 조건화</span></h2><p>조작적 조건화의 원리<br>행동이 그 결과에 의해 증가되거나 약화되는 절차를 의미한다.<br>사람들이 바람직한 결과를 이끌어 내기 위해 단지 어떤 자극에 수동적으로 반응하는 것이 아니라 환경에 능동적인 ‘조작’을 가한다는 의미에서 나왔다.</p>
<ol>
<li>정적강화와 부적강화<br>정적 강화<br>어떤 특정한 행동 뒤에 즉각적으로 주어지는 자극으로 인해 이후 그 행동의 빈도가 증가하는 과정이다.<br>여기서 행동의 빈도를 증가시킨 자극을 강화인이라고 한다.<br>ex) 어머니의 심부름을 한 어린이에게 과자를 선물로 줌으로써 계속 심부름을 잘 하게 됨.</li>
</ol>
<p>부적 강화<br>행동의 결과로 어떤 자극이 없어짐으로써 이후 그행동의 빈도가 증가하는 과정을 말한다.<br>ex) 더울때 문을 여는 행동<br>도피 행동 / 어떤 혐오 자극이 이미 존재하고 있을 때 특정 행동을 함으로써 그 혐오 자극을 제거하는 경우를 말한다.<br>회피행동 / 혐오 자극이 현재 존재하고 있지는 않지만 미리 어떤 행동을 함으로써 혐오적인 상황이 닥치지 않게 하는 경우를 말한다.</p>
<ol start="2">
<li>강화인의 종류<br>미래의 반응이 증가할 수만 있다면 무엇이라도 강화인이 될 수 있다.<br>정적 강화 및 부적 강화에서 행동의 빈도를 증가시키는 역할을 하는 강화인에는 여러가지가 있다.</li>
</ol>
<p>무조건 강화인(일차적 강화인)<br>특별한 경험 없이도 유기체의 행동을 증가시키는 강화인이다.<br>ex) 음식, 물, 공기 등</p>
<p>조건화된 강화인(이차적 강화인)<br>일차적 강화인과 연합됨으로써 생긴다.<br>ex) 돈 등</p>
<ol start="3">
<li>강화 스케줄<br>강화인이 어떤 행동을 형성하고 유지하는 데 중요한 역할을 하는 것은 사실이지만 강화 스케줄에 따라 행동의 학습 속도, 패턴, 지속성 등은 달라진다.<br>즉, 어떤 행동 후에 나오는 강화인이 어떤 방식으로 제공되느냐에 관한 것이다.</li>
</ol>
<p>계속적 강화<br>그 행동이 나올 때마다 매번 강화인을 제공하는 것.</p>
<p>간헐적 강화<br>행동이 일어날 때마다 매번 강화가 주어지지 않는 경우를 말한다. 비율 스케줄과 간격 스케줄로 나뉜다.</p>
<p>비율 스케줄은 특정 반응의 횟수를 기반으로 강화가 주어지는 것으로 고정 비율과 변동 비율 스케줄이 있다.<br>고정 비율 스케줄/n 번째의 반응마다 강화인이 주어지는 스케줄<br>변동 비율 스케줄/정확하게 몇번째인지는 모르지만 평균적으로 n번째에 강화인이 주어지는 스케줄.</p>
<p>간격 스케줄은 특정 시간이 지난 후에 나오는 반응에 대해서만 강화인이 주어지는 경우로 고정간격 스케줄과 변동간격스케줄로 나뉜다.<br>고정 간격 스케줄 / n초가 지난 후에 나오는 첫번째 반응에 대해서만 강화인이 주어진다.<br>ex) 30초 스케줄에서는 30초가 경과하기 전에 나온 반응은 아무런 강화를 받지 못하고 30초가 지난 후 천 번째 반응에 강화가 주어지면 그 시점에서 다시 30초가 지난 후의 첫 번째 반응에 강화가 주어지는 식으로 진행된다.<br>변동 간격 스케줄 / 정확히 n초는 아니지만 평균적으로 n초가 지난 이후에 나온 첫번째 반응에 강화인이 주어진다.</p>
<p>-&gt; 고정비율과 고정 간격 스케줄에서는 강화를 받은 후 일시적으로 반응이 중단되는 특성이 있다. 그 이유는 강화인에 대한 예측이 어느 정도 가능하기 때문이다. 이에 비해 변동비율과 변동간격스케줄에서는 반응이 중단되지 않고 지속적으로 나오는 특성이 있는데, 이는 강화인의 제공에 대한 예측이 불가능하기 때문이다.<br>그리고 일반적으로 비율 스케줄이 간격 스케줄보다 더 높은 방응률을 가져온다.</p>
<ol start="4">
<li><p>소거<br>강화인의 제공이 감소함에 따라 그 행동의 빈도도 감소하여 소거가 이루어진다.<br>일반적으로 간헐적 강환느 계속적 강화보다 소거가 잘 되지 않는 특징을 가지고 있다.</p>
</li>
<li><p>처벌<br>처벌이란 특정 행동 뒤에 즉각적으로 따라오는 자극의 변화 때문에 이후의 행동 빈도가 감소하는 과정을 말한다.<br>여기서 행동의 빈도를 감소시키는 자극의 변화를 처벌인이라고 한다.<br>처벌인은 무조건 처벌인과 조건화된 처벌인이 있다.</p>
</li>
</ol>
<p>무조건 처벌인<br>무조건 처벌인은 특정 경험이 없는 유기체에게도 처벌인으로서 효과를 지닌 것들을 말한다.<br>조건화된 처벌인<br>무조건 처벌인과 반복적으로 연합되어 처벌인으로서의 역할을 하게 되는 것이다.</p>
<p>처벌은 정적 처벌과 부적 처벌로 나누어 진다.<br>정적 처벌이란 어떤 자극이 주어짐으로써 행동이 감소하게 되는 경우이고<br>부적 처벌은 어떤 자극이 없어짐으로써 행동이 감소하게 되는 것을 말한다.</p>
<p>효과적인 처벌<br>-반응이 일어난 후 즉각적으로 처벌이 주어져야 한다.<br>-반응이 나올 때마다 매번 처벌을 하는 것이 효과적이다.<br>-처벌의 강도는 처음부터 아주 강한 것이 좋다.<br>-처벌받는 행동에 대해 대안적 행동이 있을 때 처벌의 효과는 커진다.<br>-처벌 받는 행동보다 대안행동을 제시해야 한다.</p>
<h1><span id="동기와-정서">동기와 정서</span></h1><h2><span id="동기의-개념">동기의 개념</span></h2><p>인간은 항상 무엇인가를 하고 이쏙, 또 하고자 한다. 이러한 행동은 대부분 그 이유가 있게 마련인데 이를 동기라고 한다.<br>동기는 동기의 소재에 따라 내적 동기와 외적 동기로 나뉘게 된다.<br>-왜 그런 행동을 하는 것일까?<br>-그 사람은 왜 그런 선택을 했을까?<br>-그는 왜 그렇게 공부를 열심히 할까?</p>
<p>왜 행동의 원인에 대해 알고자 하는가?<br>1) 행동의 원인이 무엇이냐에 따라 그 행동에 대해 적절히 대처할 수 있다.<br>2) 사물이나 현상에 대해 이해하고자 하는 것은 인간의 본질적 욕구이다.</p>
<p>동기의 개념을 사용하는 이유는 다음과 같다.</p>
<ol>
<li>다양한 행동을 설명하기 위해서</li>
<li>행동을 생물학적으로 설명하기 위해서</li>
<li>행동으로 개인의 상태를 설명하기 위해서</li>
<li>행동에 대한 책임 소재를 밝히기 위해서</li>
<li>역경에 대한 도전을 설명하기 위해서</li>
</ol>
<h2><span id="생리적-동기">생리적 동기</span></h2><p>욕구<br>헐의 추동이론에 따르면 생리적 박탈과 결핍이 생물학적 욕구를 생성하는 데 그 욕구가 계속 충족되지 않으면 생리적 추동이 생성된다.<br>그러므로 욕구란 유기체가 생명을 유지하고 성장하며 안녕을 도모하는 데 필수불가결한 조건이라고 할 수 있다.<br>욕구가 좌절되면 생물학적, 심리적 안녕이 방해를 받게 된다.</p>
<p>Hull의 추동이론<br>1) 생물학적 박탈과 결핍으로 인한 생물학적 욕구 생성<br>2) 추동이란, 생물학적 결핍에 기인하는 심리적 불편함(긴장감이나 불안감)<br>3) 추동 에너지는 유기체가 생리적 욕구를 해결하는 행동을 하도록 촉구.</p>
<ol>
<li><p>동기화 상태<br>동기화 상태는 이러한 방해를 받기 전에 유기체가 행동하도록 만드는 것이며,<br>동기화 상태는 음식 박탈이나, 수면, 공기 온도 등 기본적인 생리적 욕구에서 나올 수 있다.<br>은것은 생물학적 체계와 동기화된 행동 간의 직접적인 고리를 만들어 주었으며, 동질정체와 부적 피드백이라는 두 가지 개념을 도출하는 기반이 된다.</p>
</li>
<li><p>동질 정체<br>유기체는 내외 환경에 직면하여 안정적인 내적 상태를 유지하려는 신체적 경향성을 가지고 있다.<br>이러한 생리적 안정 상태의 유지기제를 동질정체라고 한다.</p>
</li>
<li><p>부적 피드백<br>추동에 의해 활성화된 행동을 부적 피드백이 정지시킨다.<br>생리적 욕구가 필요 이상으로 채워지기 전에 부적 피드백이 신호를 보낸다.<br>투입에 의한 산출이 그 투입을 제어하는 시스템을 의미한다.</p>
</li>
</ol>
<p>갈증</p>
<p>배고픔</p>
<p>성 행동</p>
<p>공격성</p>
<h2><span id="심리적-동기">심리적 동기</span></h2><p>앞서 살펴본 생리적 동기는 인간이나 동물 모두 가지고 있다. 생리적 동기에 의존하여 삶을 보다 원활하게 영위해 가는 것이다.<br>그러나 인간은 더 고차원적인 형태의 심리적 동기를 추구한다.</p>
<p>자율성 추구<br>자율성은 인간이 행동을 시작하고 통제할 때 자기 스스로 선택하고 결정하는 경험을 원하는 심리적 욕구를 말한다.</p>
<p>자율성 상태를 판단하기 위한 세 가지 기준</p>
<ol>
<li>행동의 원인이 자신에게 있는지 혹은 외부에 있는지의 여부</li>
<li>행동이 자신의 의지에 따라 이루어졌는지의 여부</li>
<li>선택 가능한 대안이 얼마나 있었는가의 여부</li>
</ol>
<p>타율성이란?<br>외부의 힘이 특정한 사고나 감정 혹은 행동 방식을 강요하는 경우</p>
<p>자신의 역량 확인<br>역량이란 자신에게 가장 알맞은 도전을 추구하고 완성하여 능력을 확인하고자 하는 심리적 욕구이다.</p>
<p>관계 추구<br>관계에 대한 욕구는 다른 사람과 정서적 유대감을 가지고 애착을 형성하고자 하는 심리적 욕구를 말한다.<br>이러한 관계는 이익과 손해를 초월하여 서로를 염려하고 배려하는 관계다.</p>
<p>이렇나 관계욕구의 해소는 가족 내에서 가장 먼저 이루어진다.</p>
<p>관계의 양보다는 질이 중요하다는 것이다.<br>우리가 바람직한 삶을 누리기 위해서는 우선 생리적 욕구를 해결하는 것이 중요하다.<br>인간은 자율성을 추구하고, 자신의 역량을 확인하면서, 다른 사람과 바람직한 관계를 형성할 때 능동적인 삶을 산다고 할 수 있다.</p>
<h2><span id="정서">정서</span></h2><p>인간이 경험하는 가장 기본적인 느낌에는 강증과 배고픔뿐만 아니라 즐거움이나 분노와 같은 정서도 포함된다.</p>
<p>동기와 정서를 구별해 주는 차이점은 다음과 같다.</p>
<ul>
<li>정서는 주로 외부 요인에 의해 유발되는 반면, 동기는 주로 내부 요인에 의해 유발된다.</li>
<li>동기는 주로 특정 욕구에 의해 유발되는 반면, 정서는 광범위한 종류의 자극에 의해 유발된다.</li>
</ul>
<h3><span id="정서의-기능">정서의 기능</span></h3><p>정서적 행동과 표현에는 적어도 다음과 같은 일곱 가지의 기능이 있다.<br>이렇나 특성은 유기체로 하여금 복잡하게 변화하는 환경에 적응할 수 있도록 돕는 역할을 한다.</p>
<ol>
<li>위기에 대처하기 위하여 자율신경 반응을 이끌어 낸다.</li>
<li>특별한 지역 조건에 알맞은 반응을 하도록 한다.</li>
<li>목표를 이루기 위해 행동하도록 동기화시킨다.</li>
<li>타인에게 자신의 의도를 전달한다.</li>
<li>사회적 유대를 증가시킨다.</li>
<li>사건에 대한 기억과 평가에 영향을 미친다.</li>
<li>특정 기억의 저장을 향상시킨다.</li>
</ol>
<h3><span id="정서의-표현">정서의 표현</span></h3><ol>
<li><p>정서 표현은 생득적이다?<br>시각 장애를 가진 아기가 성숙함에 따라 정서와 관련된 표현이 자연스레 나타남으로 보아 누군가에게 배운것이 아니라 생득적으로 표현법을 알고 있다는 주장.</p>
</li>
<li><p>정서 표현은 학습되었다?<br>정서적 표현의 일부는 학습된 것이다.<br>ex) 솔직한 감정을 표현하는 것에 대한 문화적 민감성 차이, 정서표현 중 의사소통 수단으로 사용되는 것은 대다수가 학습된 것.</p>
</li>
<li><p>진화론적 의미<br>하등 동물과 인간의 정서 표현에는 유사점이 많다.<br>성인과 유아의 정서 표현이 비슷하다.<br>선천적 시각 장애 아동과 정상인의 정상표현이 유사하다.<br>서로 다른 문화간의 정서 표현에 공통점이 많다.</p>
</li>
</ol>
<h3><span id="정서-이론">정서 이론</span></h3><ol>
<li><p>제임스-랑게 이론<br>어떤 상황에서 신체적 변화가 먼저 오고 그 변화를 지각하게 될 때 특정한 정서를 느낀다고 주장.<br>즉, 정서는 어떤 행동의 원인이 아니라 어떤 상황에서 일어난 신체반응에 대한 지각이라고 주장.<br>ex) 슬프기 때문에 눈물을 흘리는 것이 아니라 눈물을 흘리기 때문에 슬프다는 이론</p>
</li>
<li><p>캐넌-바드 이론.<br>정서에서 중심적인 역할을 하는 것은 뇌의 시상이라고 주장하며 제임스-랑게 이론을 반박하였다.<br>자극이 시상에 전달되면, 정서적 경험과 신체적 변화를 동시에 유발한다고 주장한다.</p>
</li>
</ol>
<p>이와 같은 주장은 뇌와 신체를 연결하는 신경 절단 후에도 정서를 경험함을 보이는 실험을 통해 증명된다.<br>또한 제임스-랑게 처럼 신체 변화가 먼저 오고 그 변화를 지각하는 것은 신체 반응의 속도 문제가 있다고 주장한다.<br>예를 들어 위협적인 상황잉나 분노를 느끼게 하는 상황에서 경험하는 정서를 설명하기에 너무 느리다고 주장한다.</p>
<ol start="3">
<li>인지평가이론(샥터-싱어 이론)<br>그 정서를 경험하게 된 상황에 대한 평가가 정서적 경험에 상당한 영향을 미친다고 주장.<br>신체의 생리적 반응에 대한 인지적 해성을 중요시 한다.<br>정서적 각성의 효과<br>적절한 수준의 정서적 각성은 생활 속에서 많은 경우 어떤 일을 수행하는 데 도움이 된다.<br>그러나 정서적 각성의 정도가 너무 높을 때에는 반대되는 현상을 초래할 수 있다.</li>
</ol>
<h1><span id="기억과-사고">기억과 사고</span></h1><h2><span id="기억-이론">기억 이론</span></h2><p>기억이란?<br>과거의 경험으로 부터 얻은 정보와 지식을 유지하고 현재에 되살려 주어진 과제에 맞춰 사용 할 수 있도록 하는 수단<br>부호화, 저장, 인출의 세 가지 과정으로 이루어진다.<br>부호화(excoding)<br>감각 정보가 표상(representation)으로 전환되는 과정이다. 감각을 받아들이고 머리에 남기는 과정<br>인지과정 혹은 정보 처리 과정의 한 형태로, 청각, 시각, 촉각 등 감각을 통해 들어오는 정보를 처리하고 저장하기 위해 그 정보를 유의미하게 만들고, 장기기억에 저장되어 있는 기존의 정보와 연결하고 결합하는 과정<br>이러한 과정을 통해 정본느 작업기억에서 장기기억으로 전환<br>저장<br>해당 내용을 저장함<br>인출<br>머리 속의 정보를 과제 수행을 위해 이끌어내는 과정<br>작업 기억<br>어떤 내용을 받아들였을 때 이를 일시적으로 저장하는 기억<br>회상 과제<br>기존에 가지고 있었던 정보를 특별한 단서 없이도 자유롭게 꺼내 쓸 수 있는 과제<br>재인 과제<br>단서를 제시하고 기억된 정보와 일치하는 가를 판단하는 요구<br>외현적 기억<br>머리 속에 있는 것을 의식적으로 머리 속에서 찾아보고 끄집어냄.<br>암묵적 기억<br>의식적 의도적으로 기억하려 한 적이 없음에도 불구하고 과거 경험을 통해 기억이 살아나는 기억</p>
<p>전통적 기억 모형<br>애트스킨과 쉬프린은 기억을 세 단계로 구분한 기억 모형을 제시하였다.</p>
<ol>
<li>감각 저장소<br>감각기관을 통해 들어온 정보가 극도로 짧은 시간만 머무는 기억 저장소</li>
<li>단기 저장소<br>감각 기억에 비해 정보가 머무르는 시간은 상대적으로 길지만 기억 가능한 정보의 양이 매우 적은 것</li>
<li>장기 저장소<br>무한대에 가까운 양의 정보를 오랜 시간 영구적으로 저장하는 기억 저아소</li>
</ol>
<p>대안적 기억 모형<br>크레이크와 로크하트는 기억이 용량 및 파지 시간 등에 따라 단계별로 분리되어 있기보다는 부호화와 인출의 단계에서 정보가 얼마나 깊이 있게 처리되는지에 따라 그용량과 지속 시간 등이 결정된다고 하였다.</p>
<p>한편 배들리는 저장소적 기능을 강조한 과거의 관점과는 달리 기억 정보의 흘므을 제어하는 중앙 집행기를 포함시켜 저장소의 정보를 능동적으로 활성화하고 유지하는 과정을 중요하게 부각시켰다.<br>기억 현상을 명확하게 설명함으로써 가장 합리적인 모형으로 각광 받고 있다.</p>
<h2><span id="처리-과정으로서의-기억">처리 과정으로서의 기억</span></h2><p>기억 공고화가설<br>공고화 과정은 암송과 정보의 조직화에 의한 기존 정보와 새로운 정보의 합을 의미한다.<br>단기기억장치 속의 새로운 정보가 암송과 조직화에 의해 안정된 상태로 장기기억 장치에 저장되는 현상을 의미한다.<br>예를들어 스콰이어는 전기충격치료를 받은 환자들이 경험하는 일시적인 기억상실증을 조사하였는데, 전기충격 치료가 행해진 시기 전후에 환자가 보고한 정보들이 비교적 부정확함을 보여주어, 전기충격으로 인한 정보 연합 과정의 방해가 기억상실의 직접적인 원인임을 밝혀내었다.<br>암송<br>에빙하우스는 반복적인 암송이 기억을 공고화 시키는 데 큰 효과가 있음을 발견하였다.<br>규칙적인 시간간격을 두고 여러 번 행해지는 분산학습에서 기억 증진 효과가 큰 것이 밝혀졌다.<br>조직화<br>정보의 조직화는 암송과 더불어 학습 효과를 극대화하는데 도움이 된다.<br>또한 좀 더 깊은 수준의 공고화로 이어진다.</p>
<ol>
<li>유사한 것들끼리 범주로 묶는 범주화 과정</li>
<li>기억 항목들이 가지는 특성들을 서로 연결시켜 임의의 상호작용 관계를 부여한다.</li>
<li>이미 익히 알고 있던 지식 항목들과 암기해야 할 완전히 새로운 항목들을 서로 연합시켜 이미 알고 있던 항목을 인출 단서로 사용하는 방식.</li>
<li>친숙한 지형 지물에 기억해야 할 항목을 연관시킨다.</li>
<li>머리글자를 이용하기.</li>
</ol>
<p>인출<br>스턴버그는 단기기억에서의 인출 특징을 조사하여 다음과 같은 사실을 얻었다.<br>기억 항목의 수가 증가할수록 반응 시간이 점차 증가하였는데, 이는 단기기억 내 저장된 정보를 인출하는 과정은 기억 항목 전체를 한꺼번에 인출하는 것이 아니라 하나하나식 인출하는 순차적 처리방식을 따름을 시사한다.<br>여기서 유의할 점은 기억 항목 내에서 속한 위치는 반응 시간에 영향을 미치지 않는 것으로 보아 기억된 항목의 인출은 순차적이되 일단 인출 과정이 시작되면 기억 항목 전체를 인출하기 전까지는 종료되지 않는 전체적 순차처리 과정임을 의미한다.</p>
<p>망각 과정과 기억 왜곡<br>간섭 모형</p>
<p>쇠잔 모형</p>
<p>지식 표상</p>
<h2><span id="인지와-사고">인지와 사고</span></h2><p>일반적인 문제 해결 과정<br>문제란 목표와 현실 사이의 갭.</p>
<ol>
<li>문제의 인식</li>
<li>문제의 정의</li>
<li>문제 해결을 위한 전략 구성.</li>
<li>문제에 대한 정보 조직화</li>
<li>자원 할당</li>
<li>해결 여부 점검</li>
<li>문제 해결의 평가 단계</li>
</ol>
<p>알고리즘과 어림법<br>알고리즘<br>어림법</p>
<p>통찰과 갖춤새<br>통찰<br>문제 해결 과정 중 해결에 결정적인 역할을 하는 방법을 갑작스럽게 발견하거나 이해하는 현상.<br>의사결정</p>
<h1><span id="태도와-태도변화">태도와 태도변화</span></h1><p>태도란?<br>마음의 경향성을 의미한다.<br>태도가 중요한 이유<br>행동에 영향을 미치는 중요한 심리변수이며 행동을 예측하거나, 변화시키려고 할때 가장 많이 거론되는 요인이다.<br>태도의 3요소<br><mark>인지적 요소</mark> / 내가 아는 것을 통해 태도가 변할 수 있다. 상대적으로 쉽게 변할 수 있다.<br><mark>정서적 요소</mark> / 대상에 대해서 좋아하는가 그렇지 않은가이다. 인지적 요소에 비해 훨씬 더 오래 남고 잘 바뀌지 않는다.</p>
<p>ex) 마케팅 에서도 인지적 요소보다 정소적 요소에 집중하는 것이 그래서 중요하다.<br><mark>행동적 요소</mark> / 나의 태도와 내 행동을 일치시키는가에 대한 것이다. 내 태도와 행동이 항상 일치하지는 않는다.<br>태도의 생성 요인<br>유전적 요인<br>학습에 의한 태도 형성</p>
<ul>
<li>연합에 의한 획득</li>
<li>강화에 의한 획득</li>
<li>모방에 의한 획득(관찰 학습)</li>
</ul>
<p>일관성 동학에 의한 태도 형성<br>사람들은 자신의 태도와 행동이 다르다면 둘 중하나를 포기하게 된다.</p>
<p>손익계산에 의한 태도 형성</p>
<p>태도의 강도<br>많은 정보를 가질 수록 태도가 강화 된다.<br>대상에 대한 태도는 잘 변하지 않는다.</p>
<p>사회적 규범</p>
<p>태도변화의 두 이론<br>인지 부조화 이론<br>나의 행동이 태도와 다르면 태도가 달라진다.<br>과거에 했던 노력이나 고생을 미화시켜 지금 보상받으려는 심리가 있다.<br>ex) 누군가를 채용할때 힘들게 해야 그 사람이 회사에 들어왔을때 뿌듯해 한다.</p>
<p>정교화가능성 모델<br>권위가 있는 사람이거나 중요한 사람이 말을 하면 그 태도를 주입할 수 있다.<br>지식이 있는 사람이 설명 or 그 사람과 관련성을 높여서 설명(집단에 대한 정보가 아니라 나에 대한 정보를 받을 때 달라진다.)</p>
<h1><span id="발달심리학">발달심리학</span></h1><h2><span id="발달심리학의-핵심-질문들">발달심리학의 핵심 질문들</span></h2><h3><span id="발달의-연속성">발달의 연속성</span></h3><p>발달이라는 것이 점진적으로 진행이 되는 것인지 혹은 급격하게 변화하는 것인가에 대한 논의이다<br>인간이 작은 양적인 변화들을 통해 점진적으로 천천히 바뀌어 나간다고 주장하는 설이 있는가 하면, 발달의 특정 시기 즉 발달 단계별로 새로운 패턴이 출현한다고 보는 견해가 있다.<br>또한, 환경이 발달에 끼치는 영향이 연속적인지 혹은 특정 시기의 경험이 발달에 결정적인가에 하는 문제인데 즉, <strong>결정적 혹은 민감한 시기가 있는가</strong> 에 관한 문제이다.</p>
<p>예를 들면 한 개인이 사춘기에 들어가 기존과 상반된 행동 패턴을 보이는 경우<br>또, 청소년기의 특정 시기(민감하고 결정적인 시기)에 특이한 경험을 겪어 그것이 발달에 큰 영향을 미치는 경우 등이 논쟁의 주제가 된다.</p>
<h3><span id="발달의-원인">발달의 원인</span></h3><p>발달이 유전에 의한 것인가 아니면 환경에 의한 것인가?<br>오늘날 심리하자들은 이 둘을 따로 구분해서 논의하는 것이 적절치 않다고 판단을 내렸다.</p>
<h3><span id="개인차의-문제">개인차의 문제</span></h3><p>개인차의 원인은 무엇이고 개인적 특성은 어느정도 안정적인가?</p>
<h2><span id="유아-아동-청소년기의-발달">유아, 아동 청소년기의 발달</span></h2><p>이 시기에 이루어지는 신체, 감각 및 운동 발달을 살펴본 다음, 인지 발달, 사회성 발달을 살펴본다.</p>
<h3><span id="신체-감각-및-운동-발달">신체, 감각 및 운동 발달</span></h3><p><strong>영유아기</strong> 의 신체의 발달은 미약한 시력과 청력을 가지고 맛 또한 구분할 수 있다.<br>이런 신생아는 몇몇 <strong>반사</strong> 를 가지는데, 예를들면 알굴에 닿는 사물 쪽으로 머리와 입이 향한다던가 입 안에 있는 물체를 빠는 등의 반사이다.<br>이 시기의 운동 능력의 발달은 그 유무에 따라 자극을 능동적으로 취사선택을 할 수 있는지가 정해지기 때문에 매우 중요하다.<br>운동 능력이 없는 시기의 신생아는 시청각을 통해서만 대상을 이해하게 된다.</p>
<p><strong>전학령기</strong> 에 들어선 2세 경의 아동은 지각능력이 크게 향상된다.<br>이때 몸을 좀 더 잘 통제할 수 있게된다.</p>
<p><strong>학령기</strong> 에 접어들면 아동의 감각 능력은 성인 수준만큼 가능하다.<br>또한 움직임을 더 잘 통제할 수 있게 되고, <strong>청소년기의 시작</strong> 과 함께 급진적인 변화를 경험하게 된다.<br><strong>이차 성징</strong> 으로 인해 자신을 초기 성인으로 보기 시작하고 발달 속도에 따라 인기와 자신감을 가지느냐 혹은 불안을 경험할 수도 있다.</p>
<h3><span id="인지-발달">인지 발달</span></h3><h4><span id="피아제의-인지-발달-이론">피아제의 인지 발달 이론</span></h4><p>아동의 자연적인 성숙 능력과 환경과의 상호작용을 강조한다.<br>아동이 생물학적 요잉닝나 환경적 자극에 대해 수동적으로 반응하는 존재가 아니라 <strong>발달에 능동적으로 참여하는 존재</strong> 로 보았다.<br>경험을 통해 아동은 자신이 경험하는 세계를 조직화해서 물리적 및 사회적 세상이 어떻게 작동하는지에 대한 이론을 구성한다. =&gt; <strong>도식화</strong></p>
<p>동화<br>: 새로운 사건을 기존의 도식에 동화시키는 과정<br>즉, 새로운 사건이나 대상을 접할 때 아동은 그것을 기존의 도식을 통해서 이해하고자 한다.</p>
<p>아동이 성숙해 감에 따라 그들의 사고 및 추론 능력이 질적으로 다른 일련의 단계를 거쳐 진행된다.</p>
<p><strong>/피아제의 인지 발달 단계/</strong><br><strong>감각운동기</strong> 에는 자아를 행위의 주체로 인식하고 의도적으로 행동하기 시작한다.<br>또한 대상의 영속성 개념을 획득하여, 눈에 보이지 않아도 대상은 계속해서 존재한다는 것을 깨닫는다.</p>
<p><strong>전조작기</strong> 에서는 언어사용을 학습한다.<br>하지만 사고는 여전히 자기중심적이기 때문에 다른 사람의 관점을 취하는 데 어려움을 겪는다.</p>
<p><strong>구체적 조작기</strong> 에는 사물과 사건에 대해 논리적으로 사고할 수 있다.<br>또한 수, 양, 무게에 대한 보존 개념을 획득한다.<br>여러개의 사물을 특징에 따라 분류하고 크기와 같은 하나의 차원에서 그들을 나열할 수 있다.</p>
<p><strong>형식적 조작기</strong> 에는 추상적인 명제에 대해 논리적으로 사고하고 가설을 체계적으로 검증할 수 있다.<br>또한, 가상적인 것 미래 그리고 이념적인 문제에 대해 관심을 가지기 시작한다.</p>
<h4><span id="비고츠키의-사회문화적-이론">비고츠키의 사회문화적 이론</span></h4><p>아동의 사고가 좀 더 <strong>능력있는 사람들과의 대화를 통해 발달</strong> 한다고 주장.</p>
<p>근접발달영역<br>: 발달 영역은 아이가 외부의 도움 없이 혼자서 문제를 해결할 수 있는 영역이고, 발달은 미발달 영역이 근접발달영영기 되고 그 다음 최종적으로 발달 영여이 되는 과정을 거친다.</p>
<p>발달과 관련하여 교육과 같은 환경적인 요인이 가장 중요한 부분은 근접발달영역이다.</p>
<h2><span id="전생애-발달-관점과-성인기-발달-이론">전생애 발달 관점과 성인기 발달 이론</span></h2><h3><span id="전-생애-발달심리학적-관점">전 생애 발달심리학적 관점</span></h3><p>인간의 발달이 그 전 생애를 통해 영위된다.</p>
<h3><span id="에릭슨과-레빈슨의-이론">에릭슨과 레빈슨의 이론</span></h3><h4><span id="에릭슨">에릭슨</span></h4><p>신체 나이에 따라 발달해야 할 발달 과제들이 있고 이것이 순차적으로 이루어지지 못하면 다음 발달과제에 영향을 받는다.<br>인간 발달이 전 생에에 걸쳐 지속되고 개인뿐만 아니라 사회역사적 맥락 역시 인간 발달에서 매우 중요하다.<br><strong>점성적 원칙</strong></p>
<ol>
<li>기본적 특질들의 각각의 조합은 육체적, 인지적, 정서적, 그리고 사회적 발달로 인해 위기를 넘기게 될 때 보다 우위의 단계로 넘어간다.<br>이 우위의 단계들은 대각선을 구성한다.</li>
<li>각각의 우위 단계들은 그 단계 나름의 성숙의 위기에까지 수직적으로 전진해야만 하는 선행 단계가 있다.</li>
<li>각각의 위기는 계속되는 위기가 출현할 때마다 그 당시의 우세한 갈등의 새로운 수준가지 전진해야만 한다.</li>
</ol>
<p><strong>에릭슨의 심리사회적 발달 이론</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">단계 및 연령</th>
<th style="text-align:left">심리사회적 위기</th>
<th>발달 과업</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1단계 : 0~1.5세</td>
<td style="text-align:left">신뢰 대 불신</td>
<td>어머니에 대한 애착으로 타인에 대한 신뢰의 기초가 됨</td>
</tr>
<tr>
<td style="text-align:left">2단계 : 1.5~3세</td>
<td style="text-align:left">자율성 대 수치심과 의심</td>
<td>자기와 환경에 대한 기본적인 통제력을 획득</td>
</tr>
<tr>
<td style="text-align:left">3단계 : 3~6세</td>
<td style="text-align:left">주도성 대 죄책감</td>
<td>목적 지향적이고 방향성을 획득하는 것</td>
</tr>
<tr>
<td style="text-align:left">4단계 : 6세~사춘기</td>
<td style="text-align:left">근면성 대 열등감</td>
<td>사회적, 신체적, 학업적 기술을 발달시키는 것</td>
</tr>
<tr>
<td style="text-align:left">5단계 : 청소년기</td>
<td style="text-align:left">정체성 대 역할 혼돈</td>
<td>아동에서 성인으로 이행하는 것으로, 정체감을 발달시키는 것</td>
</tr>
<tr>
<td style="text-align:left">6단계 : 성인초기</td>
<td style="text-align:left">친밀감 대 고립감</td>
<td>사랑 및 우정같은 친밀한 유대를 형성하는 것</td>
</tr>
<tr>
<td style="text-align:left">7단계 : 중년기</td>
<td style="text-align:left">생산성 대 침체성</td>
<td>가족, 직업 및 사회와 관련된 인생의 목표를 수행하는 것으로 미래의 세대와 관련된 관심사 발달</td>
</tr>
<tr>
<td style="text-align:left">8단계 : 노년기</td>
<td style="text-align:left">자아통합 대 절망</td>
<td>자신의 인생을 되돌아보며 그 의미를 수용하는 것</td>
</tr>
</tbody>
</table>
<h4><span id="레빈슨">레빈슨</span></h4><p>성인기의 발달에 관한 종합적인 이론을 제시하였다.<br>인생을 계절의 개념으로 접근한다.<br>질적으로 다른 네 개의 계절이 20년 정도 지속된다고 보았다.</p>
<p>인생은 <strong>아동 청소년기</strong>, <strong>성인 초기</strong>, <strong>성인 중기</strong>, <strong>성인 후기</strong> 라는 질적으로 다른 네 개의 계절이 존재한다.</p>
<p>인생 구조는 다음과 같은 세 변수로 구성되어 있다.</p>
<ol>
<li>개인에게 심리적으로 중요한 사회문화적 세계</li>
<li>숨겨져 있거나 현재 가장 부각된 자아의 구성 요소들</li>
<li>개인이 현재 참여하고 있는 활동들</li>
</ol>
<p><strong>성인 초기 전환기</strong> 에는 중요한 두개의 과제가 있는데 바로 <em>청소년기의 인생 구조를 마무리 짓고 성인 이전기를 떠나는 것</em> 과 <em>성인 세계로 예비적인 발걸음을 내디든 것</em> 이다.<br>성인 세계의 가능성을 탐색하고 그 안에서 참여자로서 자신을 상상해보고 시험해본다.</p>
<p><strong>성인 입문기</strong> 는 보통 22세에 시작해서 6년 정도 지속되며<br>젊은이들은 자아와 성인 세계를 연결해 줄 수 있는 최초의 인생구조를 형성하고 그것을 시험해 보아야 한다.<br>자신의 삶의 중심을 태어날 때부터 속한 가족의 어린이 위치에서 자신이 새롭게 구성한 가정에 기반한 풋내기 성인의 위치로 전환해야 한다.<br>이때는 성인으로서의 자신을 구체적으로 정의하며 <strong>직업, 사랑 관계, 삶의 양식, 가치들에 관한 최초의 선택</strong> 을 하고, 더불어 살기 위한 노력을 하는 것이다.<br>이때 필요한 자세는 느긋하고 대안들에 개방적이고 깊은 개입을 피하는 것이다.</p>
<p><strong>30대 전환기</strong> 에는 과거를 재평가하고 미래를 생각해 볼 수 있는 5~6년의 시간을 가질 수 있다.<br><em>내 인생에서 내가 한 것은 무엇이고, 내가 하고자 원했던 것은 무엇인가</em> 를 생각하고 고민한다.<br>이때는 20대의 탐색적인 자질은 사라지고 더욱 긴박감을 가지게 된다.<br>30대 전환기는 성인 초기 내에서 좀 더 만족스러운 인생 구조를 만들어 내기 위한 두 번재 기회다.</p>
<blockquote>
<p>위의 두 단계를 합쳐 <strong>초심자 단계</strong> 라고 하며 다음과 같은 중요한 발달과제 들이 있다.</p>
<ol>
<li>꿈을 형성하고 인생구조 안에 그 꿈을 배치하기</li>
<li>멘토 관계를 맺기(5~6년 선배)</li>
<li>직업을 선택해서 이력을 쌓아 나가기</li>
<li>사랑 관계를 맺어 결혼하고 가족을 이루기</li>
</ol>
</blockquote>
<p><strong>레빈슨 이론의 확인사항 및 한계</strong></p>
<ol>
<li>각 시기가 시작하고 끝나는 연령이 비교적 안정되어 있다.</li>
<li>인생구조의 발달 과정상 현재의 인생 구조가 아무리 적응적이라고 하더라도 그 유효기간은 최대 7년을 넘지 못한다.</li>
<li>이론의 보편성에 문제가 있다.<br>이 이론은 여성과 소수민족이 배제되었다는 한계가 있다.</li>
<li>남성중심적인 관점에서 이루어 졌다.</li>
</ol>
<h1><span id="성격과-개인차">성격과 개인차</span></h1><h2><span id="성격의-이해">성격의 이해</span></h2><h3><span id="성격의-정의-시험-출제">성격의 정의 - 시험 출제</span></h3><ol>
<li>독특성<br>성격은 한 개인을 특징짓는 독특한 면이 그 핵심이다.</li>
<li>일관성<br>성격은 여러 상황에서 비교적 일관성 있게 나타나는 행동 및 사고방식이다.</li>
<li>환경과 상호작용<br>성격은 개인이 환경에 적응해 나가는 과정에서 나타나는 행동양식이다.</li>
</ol>
<h3><span id="성격의-요소">성격의 요소</span></h3><p>성격은 내면적인 특성만 있는 것이 아니라 다른 사람이나 환경과 상호작용을 하는 과정에서 타인에게 보이는 측면을 포함한다.<br>내가 생각하는 나의 모습이 아니라 다른 사람이 보는 나의 모습이 나를 설명한다.<br>페르소나(남이 보는 나)<br>성격이 문제가 되는 것은 내가 생각하는 나와 다른사람이 보는 내가 다를 때 발생한다.</p>
<h3><span id="성격심리학의-목표">성격심리학의 목표</span></h3><ol>
<li>개인차를 파악한다<br>의미있고 안정된 사람들 간의 개인차를 파악한다.</li>
<li>미래의 사람의 행동을 예측한다<br>한 개인의 행동바익을 있는 기대로 기술하고 지금까지 축적된 행동 방식을 토대로 미래에 그 사람의 행동을 예측하는 것이다<br>$$B(Behaviour)=P(Personality) * E(Environment)$$</li>
<li>특정한 사고, 행동, 정서가 나타나는 기저를 알아내어 설명하고 이해한다.<br>사람들의 차이를 유발하는 요인을 파악하여 특정한 사고, 행동, 정서가 나타나는 기저를 알아내어 설명하고 이해한다.</li>
</ol>
<h2><span id="성격이론">성격이론</span></h2><h3><span id="특성이론">특성이론</span></h3><h4><span id="유형론">유형론</span></h4><p>체액론<br>: 히포크라테스가 주창하였으며, 피에따라 사람의 성격을 나눈다.</p>
<p>체격론<br>: 크래츠머는 체형에 따라 쇠약형, 비만형, 근육형, 이상신체형으로 나누고 이 체형에 따라 성격이 결정된다고 보았다.</p>
<p>체질론<br>: 셀돈은 신체 유형에 따른 체질론을 제안하였다.<br>내배엽형, 중배엽형, 외배엽형</p>
<h4><span id="특질론">특질론</span></h4><p>특질<br>: 특질이란 한 사람을 다른 사람과 비교적 영속적으로 구분해주는 일관된 <strong>심리적 경향성</strong> 이다.</p>
<p><strong>올포트</strong><br>특질을 다양한 종류의 자극에 같거나 유사한 방식으로 반응하는 경향 또는 성향으로 정의하였다.</p>
<p><strong>커텔</strong><br>: 특질을 행동의 객관적 관찰에서 추론되는 가설적 또는 상상적 구성 개념으로 보았다.<br>또한 특질은 성격의 기본 요소이며 행동을 예언하는 데 매우 중요한 요인이라고 간주하였다.</p>
<p>표면 특질 - 인간의 행동 중에서 겉으로 보기에 한데 붂을 수 잇는 특성들을 말한다.<br>예를들어 타인을 비방하기, 욕하기, 타인에 대한 공격성 등이 있다.</p>
<p>원천 특질 - 표면적인 행동의 결정원인이 되는 기저변인을 가리킨다.<br>원천 특질은 훨씬 안정적이며 영속적인 단일 성격요인이고 하나의 원천 특질이 여러 표면 특질들과 관련된다.<br>16가지 근원 특질을 성격요인(Personal Factor)이라고 하였는데, 이들을 측정하는 검사인 16PF가 그것이다.</p>
<p><strong>아이젱크</strong><br>3가지 축으로 사람의 성격을 설명<br>외향성, 신경증 성향, 정신병 성향</p>
<p>외향성<br>: 외향성<br>사교적이고 충동적, 친구많고 모험적<br>내향성<br>조용하고 내성적이고 말수가 적고 신중</p>
<p>신경증 성향<br>: 정서적으로 불안정하고 변덕스러우며 걱정, 불안, 우울, 낮은 자존감, 긴장, 수줍음 등의 특징</p>
<p>정신병 성향<br>: 공격적, 차가움, 자기중심적 등</p>
<p>아이젱크는 왜 이러한 성격 차원들이 나타난ㄴ지에 관심을 가지고 연구를 수행하였다.<br>주로 성격 차원의 생물학적 기초를 밝히는 데 관심을 가지고 잇었다.</p>
<h1><span id="사회속의-개인">사회속의 개인</span></h1><h2><span id="사회적-지각">사회적 지각</span></h2><p>내가 생각하는 나, 타인이 생각하는 나, 나를 이렇게 생각할것이다라고 생각하는 나 사이의 상관관계는 0에 가깝다.<br>사람들은 내가 생각하는 대로 다른사람이 생각할 것이라고 생각한다.</p>
<h3><span id="자기">자기</span></h3><p>자기에 대한 지식이나 신념=&gt; 자기 개념</p>
<p>William James의 자기론<br>주체적인 자기 - 내가 생각하는 나<br>객체적인 자기 - 다른 사람이 생각하는 자기</p>
<p>Higgins 의 자기불일치이론<br>현실적 자기와 이상적 자기 사이의 차이가 생기게 된다.<br>의무적 자기 - 내가 가진 속성에 의해서 생기는 자기</p>
<p>즉, 내가 생각하는 나와 타인이 보는 나 사이에는 차이가 생기기 마련이나, 이 간격이 작으면 작을 수록 더 행복한 삶을 영위할 확률이 높아진다.</p>
<h4><span id="자기고양-관련-동기">자기고양 관련 동기</span></h4><p>자아존중감, 자기고양편향, 자기 불구화전략, 인상관리이론</p>
<p>자기 불구화 전략<br>: 실패할 수 밖에 없는 이유를 찾아 합리화 시키려고 한다.</p>
<p>인상관리이론<br>: 타인에게 늘 좋은 이미지를 심어주고 싶다.</p>
<h4><span id="자기-유지-동기">자기 유지 동기</span></h4><p>자기가치 확인 이론<br>: 내가 인정받을 존재란 것을 타인을 통해서 확인받고싶어 한다.</p>
<p>자기확증이론<br>: 내가 어떤 사람인가를 확인받고 싶어하는 동기, 성과물을 통해 확증받고 싶어함</p>
<h4><span id="자기개념의-근원">자기개념의 근원</span></h4><p>쿨리 - 거울속에 비친 자기<br>: 중요한 타인이 자신에게 하는 행동을 통해서 자기개념을 형성한다<br>다른 사람들의 지각에 따라 자기에 대한 인식이 달라지고 그럼으로써 자기개념도 변하게 된다.</p>
<p>사회비교이론<br>: 사람들은 자신의 능력 수준과 태도의 정당성을 정확히 평가하려는 동기를 가지고 있다.<br>비교를 통해서 나온 결과에 따라 자신에 대한 자기개념을 형성하게 된다.</p>
<h4><span id="자기의-기능">자기의 기능</span></h4><p>자기는 자신과 관련된 정보를 처리하고 세상을 이해하는 데 기초가 된다.</p>
<p>자기참조효과<br>: 타인들의 특징이 자기와 관련될 때 그러한 특징들을 더 잘 기억하게 된다.<br>ex) 시끄러운 교실에서도 선생님이 부르는 자기 이름을 다른 사람의 이름보다 더 잘 알아듣는다.</p>
<p>자기중심적 사고<br>: 자기와 관련된 정보를 중시하고 다른 사람들도 자기처럼 생각할 것이라고 믿는다.<br>또한 자신을 가능한 한 긍정적으로 보려는 강한 경향성을 가지고 있다.<br>사람들은 다양한 상황에 따라 서로 다른 행동을 보일 수 있지만, 그것은 상황에 따른 것이지 내면적으로는 일관적인 특성을 가지고 있다고 생각한다.</p>
<h4><span id="자기의-문화-차이">자기의 문화 차이</span></h4><p>자기 관련 개념은 특정 개인이 속한 사회문화적 맥락 속에서 만들어지는 산물이다.</p>
<p>동양 - 상호의존적 자기<br>서양 - 독립적 자기</p>
<p>사람들은 나의 행동만을 보고 판단을 한다.<br>나의 의도는 나만이 알고있다.</p>
<h4><span id="홉스테드의-문화구분의-4차원">홉스테드의 문화구분의 4차원</span></h4><p>동양사회<br>: 집단주의적 문화권<br>집단에 속한 사람들이 서로서로를 돌봄으로써 그집단에 대한 충성심을 함양하는 문화로, 개인의 욕구나 독립성 보다는 집단의 목표와 구성훤들 간의 조화와 화합을 강조하는 특징이 있다.</p>
<p>서양사회<br>: 개인주의적 문화권<br>자기 자신뿐만 아니라 직접적으로 관련된 가족을 돌보는 것을 촉진시키는 문화로 개인의 독립성과 자율성을 가조하는 특징을 가지고 있다.</p>
<h4><span id="마커스와-키타야마">마커스와 키타야마</span></h4><p>문화를 독립적 자기와 상호의존적 자기를 추구하는 문화로 구분</p>
<p>독립적 자기를 추구하는 문화<br>: 북미와 서유럽 등이 있다.<br>자기 실현을 삶의 최대 목표로 생각하며 독립적이고 안정된 자기를 확립하기 위해 노력한다.<br>이처럼 안정된 자기로부터 자신의 삶을 일관적으로 영위하는 것이 곧 성숙한 사람의 모습으로 간주한다.</p>
<p>상호의존적 자기를 추구하는 문화<br>: 중국, 한국 일본과 같이 유교적 특성이 강한 문화권의 사람들<br>같은 집단이나 지역에 속하는 사람들과 원만한 관계를 유지하고자 한다.<br>개인적 욕망을 추구하기보다는 그렇나 욕망의 절제 속에서 자신에게 주어진 사회적 역할과 책임을 다하는 데서 삶의 의미를 찾고자 한다.</p>
<h3><span id="귀인">귀인</span></h3><p>귀인이란 행동의 원인을 설명하기 위해서 거치는 과정이다.</p>
<h4><span id="귀인의-일반적-특성">귀인의 일반적 특성</span></h4><p>사람들은 모든 일에 대해서 원인을 찾지 않고 기대에 미치지 못했거나 특이한 일이 일어났을 때 혹은 고통스럽거나 불쾌한 사건이 발생했을 때 원인을 찾게 된다.</p>
<h4><span id="귀인의-차원">귀인의 차원</span></h4><p>내재적 요인vs외적인 요인<br>: 행위의 원인을 행위자의 내적인 요소에서 찾을 것이냐 외적인 요소에서 찾을 것이냐</p>
<p>안정성 차원<br>: 행위의 원인이 ㅣ시간적 측면에서 안정적인가 불안정한가</p>
<p>통제 가능성 차원<br>: 어던 원인을 개인이 통제할 수 있는가 혹은 없는가</p>
<h4><span id="귀인에서의-편향들">귀인에서의 편향들</span></h4><p>기본적 귀인 오류<br>: 상황적 혹은 외적인 요인을 과소평가하고 성향적 혹은 내적 요인을 과대평가하는 경향성</p>
<p>행위자-관찰자 편향(조망의 차이)<br>: 다른 사람의 행동을 성향적인 요인에 귀인하려는 반면, 자신의 행동은 상황적인 요인에 귀인하는 경향<br>행위자는 자신의 행동을 보지 못하고 상황을 보기 때문에 자신의 행동을 이러한 외적인 요소에 귀인하게 된다.</p>
<p>이기적 편향<br>: 성공은 자기의 공적이고 실패는 다른 사람이나 상황의 탓이라고 보는 경향<br>이렇나 이기적 편향은 집단적인 수준에서 발생하는데 우리는 자신이 속한 집단을 보호하는 식으로 귀인을 한다.</p>
<h4><span id="귀인에서의-문화-차이">귀인에서의 문화 차이</span></h4><p>기본적 귀인 오류의 경우 미국인들은 오류를 범하는 경향을 보이는 반면 동아시아 인들은 그렇지 않았다. 왜나하면 맥락과 상황에 좀 더 민감하게 반응하기 때문이다.</p>
<h3><span id="태도">태도</span></h3><p>한 개인이 어떤 대상에게 가지고 있는 체계적인 느낌이나 신념<br>어떤 대상에 대해 판단하는 기준이 되기 때문에 매우 중요햐다.<br>기업의 경우도 고객의 제품에 대한 태도가 매출에 직접적인 영향을 미친다.<br>때문, 사람들의 태도를 컨트롤 할 수 있다면, 이를 바꿀 수 있다.</p>
<h4><span id="태도의-3요소">태도의 3요소</span></h4><p>인지적요소<br>: 태도 대상에 대한 생각과 신념이다. 내가 대상에 대해 많이 알면 알 수록 그에 대한 평가가 바뀌지 않는다.<br>하지만 정서적인 평가보다는 인지적인 평가가 훨씬 바뀌기 쉽다.</p>
<p>정서적 요소<br>: 태도 대상에 대한 느낌이나 호불호를 포함하는 평가적 반응, 정서적 측면은 인지적 요소가 사라진 후에도 지속적으로 영향을 미침.</p>
<p>행동적 요소<br>: 태도 대상에 대해 가지고 있는 평가와 같은 방향으로 행동하기를 원한다.</p>
<h4><span id="태도의-형성">태도의 형성</span></h4><p>유전적 요인, 학습, 인관성 동인, 손익계산</p>
<p>유전적 요인<br>: 특정 대상에 대한 두려움, 사형 제도, 이혼, 사회주의에 대한 태도도 유전적 요인에 기인하는 것이 많다.</p>
<p>학습에의한 태도 형성<br>: 모든 학습의 원리가 태도를 형성하는 데 기여한다.<br>고전적 조건형성을 통해 사람들은 어떤 대상을 특정 인지와 정서와 연합한다.연합, 강화, 모방<br>ex) 연합에 의한 획득 - 광고/모델에 대한 긍정적인 이미지를 다른 상품과 연계시켜 긍정적 이미지를 연상시킴.</p>
<p>모방에 의한 획득<br>: 나와 많은 시간을 함께 하는 시간이 많은 사람들을 보고 배움</p>
<p>매스컴이나 책에의 단순 노출 효과<br>: 하나의 형태가 특정 대상에 반복적으로 노출되어 친숙성이 높아지면 그 대상에 긍정적인 태도를 가지게 된다.</p>
<p>Heider의 균형이론<br>: 사람들은 특정 태도 대상에 대해서 자신이 좋아하는 사람과 같은 태도를 갖고 싫어하는 사람과는 다른 태도를 갖고자 하는 경향이 있다.</p>
<p>합리화 이론 - 불균형 상태를 합리화를 통해 정당화한다.</p>
<h4><span id="태도의-변화">태도의 변화</span></h4><p>인지부조화이론<br>: 사람들은 자신의 태도와 행동 간의 일관성을 유지하고자 하기 때문에 일치하는 행동을 함으로써 인지적으로 조화로운 상태를 유지하고자 한다.<br> 불충분한 정당화, 노력의 정당화, 위선 유도 전략, 의사결정후의 부조화</p>
<p>자기지각이론<br>: 사람들은 자신의 태도를 확신할 수 없는 상황에서 자신의 행동을 되돌아보고 상황을 고려하여 태도를 추론한다.</p>
<p>합리적 설득 요청<br>: 의사전달자, 메시지(메시지의 형태에따라), 청중요인에 달려있음</p>
<p>행동을 통한 태도 변화<br>: <em>문간에 발 들여놓기 기법</em><br>사소한 요구 들어준 사람은 이후 더 큰 요구 들어줄 가능성이 높다.<br><em>면전에 문 기법</em><br>처음에 매우 큰 요구를 해서 거절하면 좀 더 작은 요구를 했을 때 들어줄 가능성 높음</p>
<h2><span id="대인-관계">대인 관계</span></h2><h3><span id="대인간-매력">대인간 매력</span></h3><p>근접성<br>: 내 가까이 있는 사람들일수록 매력이 더 높아 보인다.<br>신체적 매력<br>: 신체적인 매력을 가지고 있는 경우가 더 좋은 성과를 낸다. 이는 단순히 이성간에만 작동하는 것이 아니라 동성간에도 작동을 한다.</p>
<p>유사성<br>: 나이, 사회 경제적 수준, 학력, 취미 등이 유사할수록 관계를 시작하고 오래 지속할 확률이 높아진다.</p>
<p>보상성<br>: 자신에게 없는 것을 가진 사람에게 느껴지는 매력</p>
<p>상호성<br>: 내가 좋아하는 사람을 만나는 것이 행복한가, 자신을 좋아하는 사람을 만나는 것이 행복한가</p>
<h2><span id="사회적-영향">사회적 영향</span></h2><p>다른 사람들의 행위에 의해 유발된 행동의 변화</p>
<h3><span id="동조">동조</span></h3><p>대세를 따른다.<br>다른 사람들의 행동이나 의견을 자발적으로 받아들이는 현상.</p>
<h3><span id="소수자-효과">소수자 효과</span></h3><p>소수의 주장이 일관적이고 강력해야 함.</p>
<p>복종/특정 권위를 가진 사람을 만나는 순간 그에 복종하려는 경향이 나타난다.</p>
<h3><span id="방관자-효과">방관자 효과</span></h3><p>주변의 사람들이 많을 수록 도움 행동이 감소한다.<br>공동책임 무책임, 내 주변의 많은 사람들이 있기 때문에 그에 대한 책임을 회피하는 현상이다.</p>
<h2><span id="집단-역학">집단 역학</span></h2><h3><span id="집단-수행">집단 수행</span></h3><p>사회적 촉진<br>: 다른 사람이 있을 때 수행 수준이 높은 현상</p>
<p>사회적 태만<br>: 개인이 어느 정도 노력했는지 확인할 수 없는 경우에 사람들은 개인적인 상황에서보다 덜 노력하는 경향이 있다.<br>특정 과업을 수행하기 위해 팀 전체의 노력이 필요한 경우</p>
<h3><span id="집단의사결정">집단의사결정</span></h3><p>: 집단 극화<br>집단 전체의 의사결정은 개인적 의사결정의 평균보다 더 극단적으로 일어나는 현상</p>
<p>집단 사고<br>: 응집성 강한 집단에 몰입함으로써 대안적 사고에 대한 충분한 검토 없이 성급하게 만장일치에 도달하려는 사고방식을 일컷는다.</p>
<p>몰개성화<br>: 군중이 개인을 완전히 변형시켜, 그 개인은 자신의 개성을 상실하고 몰개성화되어 완전히 비이성적으로 된다는 것이다.<br>군중이 개인에게 미치는 가장 극적인 영향, 평소와 달리 매우 폭력적인 성향을 보임<br>높은 수준의 흥분과 익명성이 존재할 때 이러한 상태가 발생할 가능성이 높으며,<br>평상시에 억제 상태에 놓여 있는 충동적인 행동들을 풀어놓는다.</p>
<h1><span id="심리측정과-평가">심리측정과 평가</span></h1><h2><span id="심리평가의-이해">심리평가의 이해</span></h2><p>심리 검사<br>짧은 시간안에 타인을 이해하고 비교해 볼 수 있다.<br>심리 평가<br>진단지 이외의 관찰이라던지 면담등을 통해 개인을 이해한다.</p>
<h3><span id="심리검사법">심리검사법</span></h3><p>심리 검사<br>한 개인을 포괄적으로 이해하기는 어렵다.<br>면담법</p>
<h3><span id="행동평가법">행동평가법</span></h3><p>실제 관찰가능한 행동을 통해 그 사람을 추론하는 것<br>자연관찰, 자기관찰, 유사관찰, 참여관찰법 등<br>내가 추론한 내용을 적는 것이 아니라 철저히 객관적인 관찰만을 적고 추후 추론을 한다.</p>
<h2><span id="심리검사가-갖춰야-할-사항">심리검사가 갖춰야 할 사항</span></h2><h3><span id="신뢰도">신뢰도</span></h3><p>반복측정 했을 때 같은 결과가 나옴</p>
<h3><span id="타당도">타당도</span></h3><p>내가 실제 알고 싶은 것을 제대로 측정하고 알 수 있도록 측정하였는가?<br>ex) 내용 타당도, 준개 타당도, 구성 타당도</p>
<h2><span id="지능검사">지능검사</span></h2>
                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/01/14/컴퓨터-네트워크/" itemprop="url">
                컴퓨터 네트워크
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-01-14T05:41:45.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                2 hours read (About 17507 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#1-computer-network-and-the-internet">1. Computer Network And The Internet</a><ul>
<li><a href="#인터넷이란">인터넷이란?</a><ul>
<li><a href="#인터넷의-하드웨어-소프트웨어적인-기초">인터넷의 하드웨어, 소프트웨어적인 기초</a><ul>
<li><a href="#isp">ISP</a></li>
<li><a href="#protocol">protocol</a></li>
<li><a href="#rfcsrequest-for-comments">RFCs(Request For Comments)</a></li>
</ul>
</li>
<li><a href="#서비스를-제공하는-주체로서의-인터넷의-기본-지식">서비스를 제공하는 주체로서의 인터넷의 기본 지식</a><ul>
<li><a href="#socket-interface">Socket Interface</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#the-network-edge">The Network EDGE</a><ul>
<li><a href="#엔드-시스템hosts의-종류">엔드 시스템(hosts)의 종류</a><ul>
<li><a href="#access-networks">Access Networks</a></li>
</ul>
</li>
<li><a href="#home-access">Home Access</a></li>
</ul>
</li>
<li><a href="#the-network-core">THE NETWORK CORE</a><ul>
<li><a href="#패킷-스위칭">패킷 스위칭</a><ul>
<li><a href="#store-and-forward-transmission">store and forward transmission</a></li>
<li><a href="#queing-delays-and-packet-loss">Queing Delays and Packet Loss</a></li>
<li><a href="#forwarding-tables-and-routing-protocol">Forwarding tables and Routing Protocol</a></li>
</ul>
</li>
<li><a href="#circuit-switching">Circuit Switching</a><ul>
<li><a href="#multiplexing-in-circuit-switched-networks">Multiplexing in Circuit-Switched Networks</a></li>
<li><a href="#packet-switching-vs-circuit-switching">Packet Switching VS Circuit Switching</a></li>
</ul>
</li>
<li><a href="#a-network-of-networks">A Network of Networks</a></li>
</ul>
</li>
<li><a href="#delay-loss-and-throughput-in-packet-switched-networks">Delay, Loss, and Throughput in Packet-Switched Networks</a><ul>
<li><a href="#overview-of-delay">Overview of Delay</a><ul>
<li><a href="#processing-delay">processing delay</a></li>
<li><a href="#queing-delay">queing delay</a></li>
<li><a href="#transmission-delay">transmission delay</a></li>
<li><a href="#propagation-delay">propagation delay</a></li>
<li><a href="#total-delay">total delay</a></li>
<li><a href="#end-to-end-delay">End to End delay</a></li>
</ul>
</li>
<li><a href="#throughput-in-computer-networks">Throughput in Computer Networks</a></li>
</ul>
</li>
<li><a href="#protocol-layers-and-their-service-models">Protocol layers and their Service Models</a><ul>
<li><a href="#layered-architecture">Layered Architecture</a></li>
<li><a href="#protocol-layering">Protocol Layering</a></li>
<li><a href="#application-layer">Application Layer</a></li>
<li><a href="#transport-layer">Transport Layer</a></li>
<li><a href="#network-layer">Network Layer</a></li>
<li><a href="#link-layer">Link Layer</a></li>
<li><a href="#physical-layer">Physical Layer</a><ul>
<li><a href="#encapsulation">Encapsulation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#network-under-attack">Network Under Attack</a><ul>
<li><a href="#사용자를-공격하는-형태">사용자를 공격하는 형태</a></li>
<li><a href="#서버-혹은-네트워크-인프라를-공격하는-형태">서버 혹은 네트워크 인프라를 공격하는 형태</a></li>
<li><a href="#패킷을-가로채는-형태">패킷을 가로채는 형태</a></li>
<li><a href="#신뢰하는-다른-사람으로-위장하는-형태의-공격">신뢰하는 다른 사람으로 위장하는 형태의 공격</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-application-layer">2. Application Layer</a><ul>
<li><a href="#principles-of-network-application">Principles of Network Application</a><ul>
<li><a href="#network-application-architecture">Network Application Architecture</a><ul>
<li><a href="#client-server-architecture">client-server architecture</a></li>
<li><a href="#p2p-application">P2P application</a></li>
</ul>
</li>
<li><a href="#process-communicating">Process Communicating</a><ul>
<li><a href="#the-interface-between-the-process-and-the-computer-network">The Interface Between the Process and the Computer Network</a></li>
<li><a href="#addressing-process">Addressing Process</a></li>
</ul>
</li>
<li><a href="#transport-services-available-to-applications">Transport Services Available to Applications</a><ul>
<li><a href="#reliable-data-transfer">reliable data transfer</a></li>
<li><a href="#throughput">Throughput</a></li>
<li><a href="#timing">Timing</a></li>
<li><a href="#security">Security</a></li>
</ul>
</li>
<li><a href="#transport-services-provided-by-the-internet">Transport Services Provided by the Internet</a><ul>
<li><a href="#tcp-services">TCP Services</a></li>
<li><a href="#udp-services">UDP Services</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#the-web-and-http">The web and HTTP</a><ul>
<li><a href="#user-server-ineraction-cookies">User-Server Ineraction: Cookies</a></li>
<li><a href="#web-caching">Web Caching</a><ul>
<li><a href="#web-cache의-작동-순서">web cache의 작동 순서</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#electronic-mail-in-the-internet">Electronic Mail in the Internet</a></li>
<li><a href="#dns-the-internets-directory-service">DNS - The Internet’s directory Service</a><ul>
<li><a href="#services-provided-by-dns">Services Provided by DNS</a></li>
<li><a href="#overview-of-how-dns-works">Overview of How DNS Works</a><ul>
<li><a href="#a-distributed-hierarchical-database">A Distributed, Hierarchical Database</a></li>
<li><a href="#dns-caching">DNS Caching</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#peer-to-peer-file-distribution">Peer to Peer File Distribution</a><ul>
<li><a href="#scalability-of-p2p-architectures">Scalability of P2P Architectures</a><ul>
<li><a href="#server-to-client-architecture">Server to Client Architecture</a></li>
<li><a href="#p2p-architecture">P2P Architecture</a></li>
</ul>
</li>
<li><a href="#bit-torrent">bit torrent</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-transport-layer">3. Transport Layer</a><ul>
<li><a href="#introduction-and-transport-layer-services">Introduction and Transport-Layer Services</a></li>
<li><a href="#multiplexing-and-demultiplexing">Multiplexing and Demultiplexing</a></li>
<li><a href="#connectionless-transport-udp">Connectionless Transport: UDP</a></li>
<li><a href="#principles-of-reliable-data-transfer">PRINCIPLES OF RELIABLE DATA TRANSFER</a><ul>
<li><a href="#building-a-reliable-data-transfer-protocol">Building a Reliable Data Transfer protocol</a><ul>
<li><a href="#reliable-data-transfer-over-a-perfectly-reliable-channel-rdt10">Reliable Data Transfer over a perfectly Reliable Channel: rdt1.0</a></li>
<li><a href="#reliable-data-transfer-over-a-channel-with-bit-errors-rdt20">Reliable Data Transfer over a Channel with Bit Errors: rdt2.0</a></li>
<li><a href="#rdt21">rdt2.1</a></li>
<li><a href="#rdt22">rdt2.2</a></li>
<li><a href="#reliable-data-transfer-over-a-lossy-channel-with-bit-errorsrdt30">Reliable Data Transfer over a lossy Channel with Bit Errors:rdt3.0</a></li>
</ul>
</li>
<li><a href="#go-back-ngbn">Go-Back-N(GBN)</a></li>
<li><a href="#selective-repeatsr">Selective Repeat(SR)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-the-network-layer-data-plane">4. The Network Layer: Data Plane</a><ul>
<li><a href="#overview-of-network-layer">Overview of Network Layer</a><ul>
<li><a href="#forwarding-and-routing-the-data-and-control-planes">Forwarding and Routing: The Data and Control Planes</a><ul>
<li><a href="#control-plane-the-traditional-approach">Control Plane: The Traditional Approach</a></li>
<li><a href="#control-plane-the-sdn-approach">Control Plane: The SDN Approach</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-the-network-layer-control-plane">5. The Network Layer: Control Plane</a><ul>
<li><a href="#routing-algorithms">Routing Algorithms</a><ul>
<li><a href="#the-link-statels-routing-algorithm">The Link State(LS) Routing Algorithm</a></li>
<li><a href="#the-distance-vector-routing-algorithms">The Distance-Vector Routing Algorithms</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-wireless-and-mobile-networks">7. Wireless and Mobile Networks</a><ul>
<li><a href="#wifi-80211-wireless-lans">WIFI : 802.11 WIRELESS LANS</a><ul>
<li><a href="#the-80211-mac-protocol">The 802.11 MAC Protocol</a><ul>
<li><a href="#dealing-with-hidden-terminals-rts-and-cts">Dealing with Hidden Terminals: RTS and CTS</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-security-in-computer-networks">8. Security in Computer Networks</a><ul>
<li><a href="#what-is-network-security">What is Network security?</a><ul>
<li><a href="#confidentiality">Confidentiality</a></li>
<li><a href="#message-integrity">Message integrity</a></li>
<li><a href="#end-point-authentication">End point authentication</a></li>
<li><a href="#operational-security">Operational security</a></li>
<li><a href="#중간-침입자는-다음과-같은-기능을-할-수-있다">중간 침입자는 다음과 같은 기능을 할 수 있다.</a></li>
</ul>
</li>
<li><a href="#principles-of-cryptography">Principles of Cryptography</a><ul>
<li><a href="#symmatrcic-key-cryptography">Symmatrcic Key Cryptography</a></li>
<li><a href="#public-key-encryption">Public Key Encryption</a></li>
</ul>
</li>
<li><a href="#message-integrity-and-digital-signature">Message Integrity and Digital Signature</a><ul>
<li><a href="#cryptographic-hash-functions">Cryptographic Hash Functions</a><ul>
<li><a href="#비트코인">비트코인</a></li>
</ul>
</li>
<li><a href="#비트코인이란">비트코인이란?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#industry-40">Industry 4.0</a><ul>
<li><a href="#ubiquitous">Ubiquitous</a></li>
<li><a href="#layering-architecture">Layering Architecture</a></li>
</ul>
</li>
<li><a href="#history-of-computer-network">History Of Computer Network</a><ul>
<li><a href="#80년대">80년대</a></li>
<li><a href="#90년대">90년대</a></li>
<li><a href="#2000년대">2000년대</a></li>
<li><a href="#유비쿼터스-컴퓨팅-vs-모바일-컴퓨팅">유비쿼터스 컴퓨팅 VS 모바일 컴퓨팅</a></li>
<li><a href="#mobile-computing">Mobile Computing</a></li>
<li><a href="#유비쿼터스-컴퓨팅">유비쿼터스 컴퓨팅</a></li>
<li><a href="#home-network">Home Network</a></li>
<li><a href="#security-vs-privacy">Security VS privacy</a></li>
<li><a href="#energy">Energy</a></li>
</ul>
</li>
<li><a href="#introduction-of-data-analytics">Introduction Of Data Analytics</a><ul>
<li><a href="#data-analytics-rd-environment">Data Analytics R/D Environment</a></li>
<li><a href="#three-types-of-communication">Three Types of Communication</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="1-computer-network-and-the-internet">1. Computer Network And The Internet</span></h1><h2><span id="인터넷이란">인터넷이란?</span></h2><p>인터넷이란 컴퓨터 네트워크의 한 형태이다.<br>인터넷은 전 세계에 있는 수십억개의 컴퓨팅 디바이스들을 연결하는 컴퓨터 네트워크 이다.<br>이를 구성하는 요소들에는 컴퓨터 뿐만이 아니라 다양한 기기들이 있으며, 이 모든 기기를 <strong>hosts</strong> 또는 <strong>end systems</strong> 라고 부른다.</p>
<p>end systems들은 communication link와 packet switches들의 네트워크에 의해 연결되어 있다.</p>
<p>packet switch는 여러 가지 형태로 있는데, 가장 많이 사용되는 형태는 router와 linke-layer switches이다.<br>link layer switch는 네트워크에 접속하는 데 많이 쓰이고, 라우터는 네트워크 코어에 쓰인다.</p>
<h3><span id="인터넷의-하드웨어-소프트웨어적인-기초">인터넷의 하드웨어, 소프트웨어적인 기초</span></h3><h4><span id="isp">ISP</span></h4><p>end systems들은 ISP(Internet Service Provider)를 통해 인터넷에 접속한다.<br>이 종류에는 local cable, telephone companies같은 지역 ISP와, Wifi Access를 제공하는 ISP 등을 포함한다.</p>
<h4><span id="protocol">protocol</span></h4><p>End System, Packet Switch 그리고 다른 인터넷의 구성요서들은 인터넷을 통해 정보를 전송하고 수신하는 것을 컨트롤 하기 위해 프로토콜을 실행한다.<br>TCP(Transmission Control Protocol)<br>IP(Internet Protocol)<br>가 인터넷에서 가장 중요한 두개의 프로토콜이다.<br>프로토콜이란 두개 혹은 여러개의 communicating entities들이 메세지를 교환할 때 사용하는 포맷이나 규칙을 정의한다.</p>
<p>예를 들어 사람사이의 커뮤니케이션에서의 프로토콜이라 하면 특정 사람이 어떤 메세지를 받았을 때, 답으로 전달할 구체적인 메세지와 특정한 행동 양식이 있다는 것이다.<br>만약 두 사람 사이의 커뮤니케이션에 있어 한 사람은 매너가 좋은데 한 사람은 매너가 없다면 대화가 이루어 지지 않고, 한 명은 아예 다른 문화권(혹은 외계인)일 경우에도 대화가 이루어 지지 않는다.<br>즉, 프로토콜이란 이러한 커뮤니케이션이 가능한 환경을 말한다.</p>
<p>네트워크 프로토콜의 경우도 사람사이의 프로토콜과 마찬가지로 많이 존재한다.<br>예를 들어 두 개의 컴퓨터가 비트를 주고받기 위한 물리적인 프로토콜이 있고, 또 다른 예로는 엔드 시스템에서 전송자와 수신자 사이의 패킷 전송률을 관장하는 congestion control protocol이 있다.<br>위에서 보듯이 프로토콜을 정의하는 핵심 요소는 특정 메세지를 보내거나 받을 때 취해지는 메세지나 행동의 교환이다.</p>
<blockquote>
<p>프로토콜은 두개 혹은 여러개의 커뮤니케이팅 대상들의 메세지 교환의 형식과 순서를 정의한다.<br>또한, 메세지의 전송 혹은 수신이나 또 다른 이벤트가 발생하였을 때의 행동을 정의한다.</p>
</blockquote>
<p><strong>컴퓨터 네트워크를 마스터한다는 것은 네트워크 프로토콜들이 왜, 어떻게 동작하는지를 아는 것과 동일하다</strong></p>
<h4><span id="rfcsrequest-for-comments">RFCs(Request For Comments)</span></h4><p>모두가 프로토콜들이 하는 역할을 동의하기 위해서 IETF(Internet Engineering Task Force)에서 internet Standards를 도입했다.<br>IETF의 공식 문서를 RFCs라고 하는데, 여기서는 다양한 종류의 프로토콜을 정의한다.<br>대표적으로 IP, TCP, HTTP(웹을 위한 프로토콜), SMTP(이메일을 위한 프로토콜) 등이 있다.</p>
<h3><span id="서비스를-제공하는-주체로서의-인터넷의-기본-지식">서비스를 제공하는 주체로서의 인터넷의 기본 지식</span></h3><h4><span id="socket-interface">Socket Interface</span></h4><p>하나의 end system에서 동작하는 프로그램이 다른 end system에서 동작하는 특정 대상 프로그램에게 데이터를 전송하기 위해 Internet Infrastucture에게 요청하는 양식 혹은 환경을 말한다.<br>마치 편지를 보낼 때 우체국을 이용하려면 그들이 갖추어 놓은 체계에 따라 편지 봉투에 우편번호를 작성하는 것 처럼.<br>인터넷을 통해 무언가 정보를 보내기 위해서는 이러한 internet socket interface환경에 맞추어야 한다.</p>
<h2><span id="the-network-edge">The Network EDGE</span></h2><p>컴퓨터, 스마트폰 등 네트워크에서 우리가 가장 흔하게 접해본 내용들을 학습한다.<br>즉, 네트워크의 엔드시스템들을 다룬다.<br>그리고 다음 장에서는 실제 컴퓨터 네트워크에서 스위칭과 라우팅이 어떻게 동작하는 지를 다루는 network core를 학습한다.</p>
<h4><span id="엔드-시스템hosts의-종류">엔드 시스템(hosts)의 종류</span></h4><p>여기서 host는 client와 server로 나뉜다.<br>데스크탑 컴퓨터, 서버, 모바일 기기, iot devices</p>
<h3><span id="access-networks">Access Networks</span></h3><p>엔드 시스템에서 네트워크의 edge로 접속하는 것을 다룬다.<br>엔드 시스템과 최초의 라우터(edge router) 사이의 네트워크 이다.</p>
<h4><span id="home-access">Home Access</span></h4><p>DSL 방식<br>: 전화선을 공유하여 인터넷을 연결한다.<br>전화선에 각각 다른 주파수를 통해 통신을 하기 때문에 전화 통신이랑 같은 선을 쓸 수 있다.</p>
<h2><span id="the-network-core">THE NETWORK CORE</span></h2><h3><span id="패킷-스위칭">패킷 스위칭</span></h3><p>인터넷의 end system들을 연결하는 packet switch와 links의 동작 흐름을 알아본다.<br>source가 되는 end system 하서 destination이 되는 end system으로 정보를 전송할 때 source는 긴 메세지를 작은 정보의 뭉터기로 쪼게는데 이를 패킷이라고 한다.<br>소스에서 destination으로 가기 위해서 각 패킷은 커뮤니케이션 링크와 패킷 스위치들을 통과하게 되는데 이 패킷 스위치에는 가장 잘 알려진 라우터와 링크 레이어 스위치가 있다.<br>각 커뮤니케이션 링크의 패킷들을 그 링크의 전송률을 최대로 활용하므로<br>전송률 R로 L bit의 패킷을 보내는 데 걸리는 시간  $T=L/R$이다.</p>
<h4><span id="store-and-forward-transmission">store and forward transmission</span></h4><p>대부분의 packet switch들은 link의 input단에서 store and forward transmission을 하는데 이는 packet switch가 다른 outbound link로 최초의 packit 의 bit를 보내기 전에 전체 packet을 받아야 함을 의미한다.</p>
<p>라우터는 받은 패킷을 어떤 링크로 전송하는 지를 결정하는 역할을 수행하는데, packet의 bit를 buffer하여 다 받고 나서 outbound link로 패킷을 전송하기 시작한다.</p>
<p>propagation delay<br>: 피트가 와이어를 타고 빛의 속도로 이동하는 데 걸리는 시간으로 지금은 무시하기로 한다.</p>
<p>queing delay<br>: 전송하기 전에 output buffer에서 packet bit들이 쌓이게 되는데 이 때문에 queing delay가 발생한다.</p>
<p>transmissioin delay<br>: 패킷의 모든 비트를 링크로 밀어넣는데 걸리는 시간이다.<br>router의 output link단에서의 buffer 때문에 발생한다.</p>
<p>실제 전송에 걸리는 시간<br>: source에서 $L/R$의 시간동안 데이터를 전송하면 propagation delay를 무시하므로 데이터를 전송하는 동안 라우터의 buffer에 이 패킷의 비트들이 쌓이게 된다.<br>전송이 끝나면 이 라우터는 목적지로 데이터를 전송하기 시작하는 데, 이때도 또한 $L/R$의 시간이 걸리게 되므로 <strong>총 걸리는 시간은 $2L/R$의 시간이 걸리게 된다.</strong></p>
<p>하나의 소스에서 여러개의 라우터를 통해 패킷을 전송하는 경우<br>: 소스부터 라우터 사이에 N-1개의 링크가 있고, 라우터에서 destination사이에 하나의 경로가 있어 전송률이 R인 총 N개의 링크를 통해 데이터를 보내는 데 걸리는 시간은<br>$$d_{end-to-end} = NL/R$$</p>
<h4><span id="queing-delays-and-packet-loss">Queing Delays and Packet Loss</span></h4><p>queing Delays<br>: 라우터는 각각의 링크들과의 연결에서 보낼 패킷을 저장해두는 outer buffer가 있다.<br>만약 각 링크들에 이미 패킷을 보내고 있다면 라우터는 이런 패킷들의 전송이 끝나기 까지 기다려야 하는데 이것이 바로 queing delay이다. 이러한 queing delay는 네트워크의 혼잡도에의해 결정된다.</p>
<p>pakcet loss<br>: outer buffer가 전송을 기다리는 다른 패킷들로 꽉 차있어서 패킷을 받지 못하는 경우 패킷이 유실된다.</p>
<h4><span id="forwarding-tables-and-routing-protocol">Forwarding tables and Routing Protocol</span></h4><p>우리는 라우터가 패킷을 받아 다른 링크로 전송해 준다고 배웠다. 하지만 이 라우터는 어떻게 보내야할 링크를 선택하는 것일까?<br>이것은 마치 사람이 길을 찾아갈 때 전체 지도를 가지고 있지 않더라도 분기점 마다 방향에 대한 정보만을 받아 목적지에 도착할 수 있는 것과 같은 원리이다.<br>모든 end system은 IP주소를 가지고 있다.<br>source end system 이 destination end system 으로 패킷을 전송하고자 할 때에는 packet의 header에 destination end system의 IP주소를 포함해야 한다.<br>각 router는 destination address를 해당 router의 outbout link에 매칭시키는 forwarding table을 통해 목적지로 가는 다음 라우터의 주소를 가르쳐주고, 이런 forwarding table은 routing protocol을 통해 만들어 진다.</p>
<h3><span id="circuit-switching">Circuit Switching</span></h3><p>서킷 스위칭 네트워크에서, 각 엔드시스템 사이에서 통신을 하기 위한 자원들(버퍼, 링크 전송률 등)이 커뮤니케이션 세션이 유지되는 동안에만 제공된다.<br>전화 네트워크가 서킷 스위칭의 예이다. 전화 통신에서의 이런 연결은 circuit(회선)이라고 부른다. 전화가 한번 연결이 되면, 네트워크에서의 전송률을 보장을 한다.<br>각 연결은 총 4개의 링크가 유지되어야 하기 때문에 전체 전송률이 1Mbps라면  각각의 circuit switch 연결은 250Kbps의 속도밖에 얻지 못한다.</p>
<h4><span id="multiplexing-in-circuit-switched-networks">Multiplexing in Circuit-Switched Networks</span></h4><p>FDM(Frequency Division Multiplexing)<br>: 주파수를 다르게 하여 송신한다, 이러한 주파수의 범위를 bandwidth라고 한다.</p>
<p>TDM(Time Division Multiplexing)<br>: 시간간격을 쪼개어 데이터를 전송한다.<br>시간은 프레임으로 쪼개지고 각 프레임의 slop이 하나의 통신 데이터를 담고 있다.<br>만약 초당 8000프레임의 속도로 링크를 통한 전송을 할 때 각 slot이 8bit로 구성되어 있다면<br>이 circuit의 전송률은 8000*8bps 즉 64Kbps이다.</p>
<p>packet switching을 옹호하는 많은 사람들은 서킷 스위칭은 쉬는 시간에도 자원을 소모한다는 점을 단점으로 꼽는다.</p>
<h4><span id="packet-switching-vs-circuit-switching">Packet Switching VS Circuit Switching</span></h4><p>현 트렌드는 패킷스위칭을 주로 한다.</p>
<h3><span id="a-network-of-networks">A Network of Networks</span></h3><p>엔드시스템들이 ISP를 통해 인터넷에 연결되는 만큼 이런 ISP들 사이의 네트워크 또한 필요하다.</p>
<p>Network Structure 1<br>: 각각의 access ISP들을 묶어 하나의 global transit ISP를 만든다.</p>
<p>Network Structure 2<br>: 여러개의 global transit ISP들이 생겨나고 이 transit ISP들이 연결된다.</p>
<p>Network Structure 3<br>: 기존의 global transit ISP들을 tier-1 ISP라 명명하고 이를 통합하는 regional ISP들이 생겨나게 된다.<br>여기서 global transit ISP들에는 많은 통신사들이 포함된다.</p>
<p>Network Structure 4<br>: access ISP를 제외한 모든 ISP 들은 provider ISP에 접속하기 위한 PoP이 있다.<br>그리고 가가운 ISP들이 모여 Internet Exchange Point를 형성한다.</p>
<p>Network Structure 5<br>: google과 같은 큰 대기업들은 content provider networks를 구성한다.<br>구글은 수십개의 데이터센터를 보유하고 있으며 독자적인 TCP/IP를 통해 연결되어 있으며 이는 전 세계를 연결하는 동시에 public 망과는 독자성을 띄고 있다.<br>구글의 독자적인 네트워크는 internet의 upper tiers를 건너뛰고 바로 access ISP에 접근하고 자하며, 이를 통해 가격을 절감한다.</p>
<h2><span id="delay-loss-and-throughput-in-packet-switched-networks">Delay, Loss, and Throughput in Packet-Switched Networks</span></h2><p>가장 중요한 delay들은 nodal processing delay, queing delay, transmission delay, propagation dalay가 있다.<br>위의 모든 delay를 합산하면 total nodal delay가 된다.</p>
<h3><span id="overview-of-delay">Overview of Delay</span></h3><h4><span id="processing-delay">processing delay</span></h4><p>패킷의 헤더를 통해 목적지가 어디인지 파악하는데 걸리는 시간이다.</p>
<h4><span id="queing-delay">queing delay</span></h4><p>outbound link 에서 전송되기를 기다리는 데 걸리는 delay이다.<br>이는 전체 delay에서 매우 중요한 역할을 하며 이를 다루는 논문들이 매우 많다.<br>이는 다른 delay와 다르게 패킷마다 그 정도가 다르다.<br>예를 들어 10개의 패킷이 도착하면 첫 패킷은 처음왔으므로 queing delay가 zero이나 뒤의 패킷들은 앞에 남은 패킷에 따라 그 정도가 제각각이다.<br>때문에 queing delay를 말할 때는 통계학적 수치를 가지고 말한다.<br>가령 평균 queing delay라고너, variance of queing delay, 그리고 queing delay가 특정 수치 이상일 확률 등으로 표현한다.</p>
<p>a를 queue에 도착하는 패킷 개수의 초당 비율이라 하고, R을 transmission rate라 하고, 각 패킷의 비트수가 모두 L이라고 하면 도착하는 비트의 속도는 La/sec가 된다.<br>여기서 $La/R$을 <strong>traffic intensity</strong> 라고 부른다.<br>이 수치가 1을 넘게 되면, queing delay는 무한으로 본다.<br>이 수치가 1에 가까워 지면 가까워 질수록 Average Queing Delay는 급격하게 증가한다.<br>또한 packet lose가 발생한다.</p>
<h4><span id="transmission-delay">transmission delay</span></h4><p>패킷의 모든 피트를 링크 안에 밀어넣는데 걸리는 시간이다.<br>$L/R$이다</p>
<h4><span id="propagation-delay">propagation delay</span></h4><p>비트가 전선을 타고 전달되는 속도이다.<br>흔히 빛의 속도를 일컬어 지며 무시해도 될만큼 작다.</p>
<h4><span id="total-delay">total delay</span></h4><p>$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$<br>여기서 propagation delay는 거의 무시 가능하나, 위성 통신 등에서는 상당한 값을 가진다.<br>또한, processing delay의 경우도 거의 무시 가능하나, 하나의 라우터의 최대 throughput을 결정하는 데 큰 영향을 준다.</p>
<p>throughput in computer Networks<br>파일을 전송받는 데 걸리는 시간이다.</p>
<h4><span id="end-to-end-delay">End to End delay</span></h4><p>source 와 host 사이에 N-1개의 router가 있는 경우<br>$d_{end-end}=N(d_{proc}+d_{trans}+d_{prop})$<br>여기서 $d_{trans}=L/R$ 이다.</p>
<h3><span id="throughput-in-computer-networks">Throughput in Computer Networks</span></h3><p>F bit의 파일을 보내는 데 T 초가 걸린다면<br>average throughput은 $F/T$이다.<br>하지만 만약 서버가 라우터에 보내는 속도($R_s$)보다 라우터가 클라이언트에 보내는 속도($R_s$)가 더 느리다면 이 때 전송 속도는 라우터가 클라이언트에 보내는 속도와 같을 것이다.<br>그러므로 throughput은 $min(R_c, R_s)$ 이다.</p>
<h2><span id="protocol-layers-and-their-service-models">Protocol layers and their Service Models</span></h2><h4><span id="layered-architecture">Layered Architecture</span></h4><p>비행기를 타고 내리는 것과 마찬가지로 인터넷도 패킷을 보내고 받는 일련의 과정으로 나눌 수 있다.<br>티켓을 끈고 수화물을 찾는 등 여러가지 절차들로 나누어 비행서비스를 설명할 수 있듯이 네트워크도 이러한 일련의 작업들의 집합으로 설명한다. 이런 구조화를 layering Architecture라고 한다.<br>이러한 layered architecture를 통해 우리는 각 부분들을 더욱 잘 이해할 수 있으며, 크고 복잡한 시스템의 각 부분을 더 잘 이해하게 된다.</p>
<p>이러한 간소화작업은 모듈화를 해주며, 각 레이어들이 제공하는 서비스들을 알 수 있게 해준다.</p>
<p>각 레이어들은 상위 레이어에게 같은 서비스를 제공하고, 하위 레이어와 같은 서비스를 이용하기 때문에 특정 레이어의 기능이 바뀌어도 전체 시스템은 변하지 않고 유지 될 수 있도록 해 준다.<br>예를들어, 공항에서 승객들을 실어나르는 방식이 바뀌어도 역시 승객을 실어나른다는 같은 기능을 수행하기 때문에 전체 시스템은 변하지 않고 유지될 수 있다.</p>
<p>layering을 통해서 크고 복잡한 시스템의 각 부분의 동작방식을 바꾸어도 다른 요소들에 영향을 주지 않을 수 있는 점은 아주 중요하다.</p>
<h4><span id="protocol-layering">Protocol Layering</span></h4><p>각 프로토콜은 하나의 레이어에 속하게 된다.<br>우리는 하위 레이어가 상위 레이어에게 어떤 서비스를 제공하는가를 관심있게 살펴볼 것이며, 이것을 <strong>service model</strong> 이라고 한다.</p>
<p>각기 다른 레이어들의 프로토콜들을 protocol stack이라고 부른다.<br>인터넷 프로토콜 스택은 5개의 레이어로 나뉜다.</p>
<p>physical, link, network, transport, application 이 그것이다.<br>이책은 application-layer를 시작으로 하위 위에서 아래로 학습해 나가는 top-down 접근을 사용했다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">프로토콜 레이어</th>
<th style="text-align:left">사용하는 패킷 단위</th>
<th>대표적인 프로토콜</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">application-layer</td>
<td style="text-align:left">message</td>
<td>HTTP, SMTP, FTP</td>
</tr>
<tr>
<td style="text-align:left">transport-layer</td>
<td style="text-align:left">segment</td>
<td>TCP, UDP</td>
</tr>
<tr>
<td style="text-align:left">network-layer</td>
<td style="text-align:left">datagram</td>
<td>IP</td>
</tr>
<tr>
<td style="text-align:left">Link-Layer</td>
<td style="text-align:left">frame</td>
<td>Ethernet, Wifi</td>
</tr>
<tr>
<td style="text-align:left">physical-layer</td>
<td style="text-align:left">bit</td>
<td>protocol for copper wire etc</td>
</tr>
</tbody>
</table>
<h4><span id="application-layer">Application Layer</span></h4><p>네트워크 어플리케이션과 어플리케이션 레이어의 프로토콜들이 있다.<br>어플리케이션 레이어 프로토콜은 여러개의 엔드 시스템에서 동작하며 각 각의 엔드 시스템에서 프로토콜을 사용하여 다른 엔드시스템의 어플리케이션과 메세지 형태로 패킷을 주고 받을 수 있다.<br>어플리케이션 레이어 프로토콜의 종류</p>
<table>
<thead>
<tr>
<th style="text-align:left">프로토콜 이름</th>
<th style="text-align:left">기능</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HTTP</td>
<td style="text-align:left">웹 문서를 전송하고 받는 프로토콜</td>
</tr>
<tr>
<td style="text-align:left">SMTP</td>
<td style="text-align:left">이메일 메세지를 주고 받는 프로토콜</td>
</tr>
<tr>
<td style="text-align:left">FTP</td>
<td style="text-align:left">두 엔드시스템 사이에서 파일을 주고받는 프로토콜</td>
</tr>
</tbody>
</table>
<h4><span id="transport-layer">Transport Layer</span></h4><p>application-layer의 message들을 전송한다.<br>TCP와 UDP 두 종류가 있는데, 둘 다 어플리케이션 레이어의 메세지들을 전송할 수 있다.</p>
<p>TCP<br>: connection 기반의 서비스를 제공하여, 어플리케이션 레이어의 메세지 전송을 보장하고 flow control을 제공한다.<br>또한 큰 메세지들을 작은 segment로 나누고, congestion control mechanism을 제공한다.</p>
<p>UDP<br>: 무선 서비스를 제공한다.<br>이는 안정성도 보장하지 못하고 흐름제어 또한 하지못하며, 혼잡 컨트롤이 안된다.</p>
<p>transport layer의 패킷을 <strong>segment</strong> 라고 부를 것이다.</p>
<h4><span id="network-layer">Network Layer</span></h4><p>datagrams라 불리는 네트워크 레이어 패킷들을 호스트들 사이에서 전송하는 역할을 한다.<br>트랜스포트 레이어의 프로토콜은 네트워크 레이어에게 segment와 목적지 정보를 전달하면, 목적지의 호스트의 트랜스포트 레이어에 세그먼트를 전달한다.<br>일반적으로 IP 프로토콜을 포함하는 개념이며, 네트워크 레이어를 구성하는 모든 구성요소들이 IP프로토콜을 실행하여야 한다.</p>
<h4><span id="link-layer">Link Layer</span></h4><p>라우터의 한 노드에서 다른 노드로 패킷을 옮기기 위해 네트워크 레이어는 링크 레이어의 서비스에 의존한다.<br>링크 레이어에 의해 제공되는 서비스는 링크에 적용된 링크레이어 프로토콜에 의존한다.<br>예를 들어, 어떤 링크 레이어 프로토콜은 송신 노드에서 링크를 거쳐 수신 노드로 reliable delivery를 제공한다.<br>여기서 말하는 reliable delivery service는 한 엔드 시스템에서 달느 엔드시스템으로 reliable delivery를 하는 TCP의 reliable delivery service와는 다르다.<br>네트워크 레이어는 각각 다른 링크 레이어 프로토콜에게 다른 서비스를 받는다. 이 책에서 링크 레이어 패킷을 frames라고 부른다.</p>
<h4><span id="physical-layer">Physical Layer</span></h4><p>한 네트워크 요소에서 전체 프레임을 다른 인접한 네트워크 요소로 옮기는 역할을 link layer가 수행한다.</p>
<h3><span id="encapsulation">Encapsulation</span></h3><blockquote>
<p>전체 네트워크 프로세스는 한 엔드 시스템에서 어플리케이션의 메세지가 그 엔드 시스템의 transport layer와 network layer, link layer, physical layer를 거쳐 라우터의 link layer로 들어가 physical layer를 거쳐 네트워크의 physical layer로 가서 link layer, network layer 를 거쳐 다른 엔드 시스템의 physical layer로 들어가고 여기서 다시 link layer, network layer, transport layer, application layer를 거쳐 전달된다.</p>
<p>우체국을 예를 들자면 편지(메세지)를 봉투(segment)에 담는것이 트랜스포트 레이어에서의 작업이다. 여기에 우편번호를 쓰고 다른 봉투에 담는 행위를 네트워크 레이어에서 처리하고 이를 가까운 우편 사무국에 전달 함으로써 (링크레이어로 보냄) 우편을 보낸다.<br>여기서 부터 decapulation이 시작되는데, 여기서 정보를 읽어들여 실제 배송을 준비하고 밥에게 메세지를 전달한다.</p>
</blockquote>
<h2><span id="network-under-attack">Network Under Attack</span></h2><h4><span id="사용자를-공격하는-형태">사용자를 공격하는 형태</span></h4><p>인터넷을 통해 악한 것들을 보낼 수 있는데 이런 악한 것들의 모음을 malware라고 칭한다.<br>이런 malware들은 온갖 종류의 나쁜 짓을 할 수 있고, 현대의 많은 malware는 자가 복재를 하여 주변의 인터넷을 사용하는 많은 호스트들을 감염시킨다.<br>Virus는 사용자가 특정 행동을 취할때 사용자의 디바이스를 감염시키는 것이다.<br>Worm은 유저의 상호작용없이도 사용자의 디바이스에 침임할 수 있는 형태이다.</p>
<h4><span id="서버-혹은-네트워크-인프라를-공격하는-형태">서버 혹은 네트워크 인프라를 공격하는 형태</span></h4><p>Denial Of Service(Dos) Attacks<br>: 네트워크, 호스트, 다른 인프라환경을 변형하여 기능을 못하도록 하는 것.</p>
<p>대표적인 Dost 공격은 다음과 같다.</p>
<ol>
<li><p>Vulnerability Attacks<br>특정하게 조작된 메세지를 취약한 어플리케이션이나 운영 시스템에 보내는 것<br>적합한 형태의 패킷이 전달되면 서비스가 중지될 수 있다.</p>
</li>
<li><p>Bandwidth flooding<br>막대한 양의 패킷을 보내 공격 대상의 access link가 마비되게 하는 것</p>
</li>
<li><p>Connection flooding<br>많은 양의 TCP 연결을 걸어 다른 연결을 못하도록 하는 것.</p>
</li>
</ol>
<h4><span id="패킷을-가로채는-형태">패킷을 가로채는 형태</span></h4><h4><span id="신뢰하는-다른-사람으로-위장하는-형태의-공격">신뢰하는 다른 사람으로 위장하는 형태의 공격</span></h4><h1><span id="2-application-layer">2. Application Layer</span></h1><h2><span id="principles-of-network-application">Principles of Network Application</span></h2><h3><span id="network-application-architecture">Network Application Architecture</span></h3><p>네트워크 아키텍쳐는 이미 그 체계가 잡혀있고, 어플리케이션에게 정해진 서비스를 제공한다.<br>어플리케이션 아키텍쳐란 어플리케이션 개발자들에 의해 디자인되며, 여러가지 시스템들에서 어떻게 동작하는 지를 명시한다.<br>어플리케이션 아키텍쳐를 디자인 할 때, 두 가지 종류의 큰 아키텍쳐 디자인 패러다임이 있는데 그것은 바로 <strong>client-server Architecture</strong> 와 <strong>peer-to-peer architecture</strong> 이다.</p>
<h4><span id="client-server-architecture">client-server architecture</span></h4><p>클라이언트 서버 구조에서는 서버라 불리는 호스트가 항상 존재한다.<br>서버는 클라이언트라 불리는 많은 호스트들이 계속해서 요청을 하고 그에 맞는 서비스를 제공한다.</p>
<h4><span id="p2p-application">P2P application</span></h4><p>p2p 구조에서는 피어라고 불리는 호스트들 사이에 직접 통신이 이루어 진다.<br>현대의 매우 유명하고 트래픽이 많은 어플리케이션들이 p2p에 기반한다.</p>
<h3><span id="process-communicating">Process Communicating</span></h3><p>end system 내에서 서로 소통을 하는 것은 program이 아니라 process이다.</p>
<h4><span id="the-interface-between-the-process-and-the-computer-network">The Interface Between the Process and the Computer Network</span></h4><p>process는 소켓이라는 소프트웨어 인터페이스를 통해 네트워크에 메세지를 전송하고 수신할 수 있다.<br>socket은 <strong>application layer와 transport layer의 경계</strong> 이다.<br>또한 소켓은 network application이 구성되어 있는 환경에서의 programming interface이기 때문에 API(Application Programming Interface)라고 불린다.</p>
<h4><span id="addressing-process">Addressing Process</span></h4><p>프로세스의 주소를 찾아가기 위해서는 두가지를 알아야 한다.</p>
<ol>
<li>목적 디바이스의 IP 주소</li>
<li>해당 프로세스가 작동하고 있는 디바이스의 포트번호</li>
</ol>
<h3><span id="transport-services-available-to-applications">Transport Services Available to Applications</span></h3><p>트랜스포트 레이어의 프로토콜이 제공하는 서비스는 어떤 것들이 있는가?</p>
<h4><span id="reliable-data-transfer">reliable data transfer</span></h4><p>프로토콜이 데이터 전송 서비스를 보장하면 안정적인 데이터 전송을 한다고 말한다.<br>트랜스포트 레이어 프로토콜이 제공하는 것 중 하나는 프로세스에서 프로세스로의 안정적인 데이터 전송을 가능하게 한다는 것이다.</p>
<h4><span id="throughput">Throughput</span></h4><p>트랜스포트 레이어 프로토콜은 일정한 수준의 throughput을 보장한다.<br>특정 수준의 throughput을 필요로 하는 어플리케이션을 bandwidth-sensitive application이라고 한다.</p>
<h4><span id="timing">Timing</span></h4><h4><span id="security">Security</span></h4><h3><span id="transport-services-provided-by-the-internet">Transport Services Provided by the Internet</span></h3><p>인터넷이 제공하는 구체적인 트랜스포트 레이어 프로토콜의 서비스를 알아본다.</p>
<h4><span id="tcp-services">TCP Services</span></h4><ol>
<li>연결 기반의 서비스 이다.</li>
<li>안정적인 데이터 전송 서비스를 제공한다.</li>
</ol>
<h4><span id="udp-services">UDP Services</span></h4><p>UDP는 Connectionless하기 때문에 handshaking 이 필요없다.</p>
<h2><span id="the-web-and-http">The web and HTTP</span></h2><p>Overview of HTTP<br>Http란 Hypertext Transfer Protocol의 약자로, 웹의 application-layer protocol이다.</p>
<h3><span id="user-server-ineraction-cookies">User-Server Ineraction: Cookies</span></h3><p>쿠키는 웹 사이트가 유저를 트래킹 하기 위해서 존재한다.</p>
<h3><span id="web-caching">Web Caching</span></h3><p>proxy server라고도 불리는 web cache는 원래 서버를 대신하여 HTTP 요청을 만족하는 네트워크 요소이다.<br>web cache는 자체적인 디스크 저장소가 있어서 최근에 요청된 객체들의 카피를 저장하고 있는다.</p>
<p>브라우저가 무언가를 요청하면 가장 먼저 web cache로 요청이 간다.</p>
<h4><span id="web-cache의-작동-순서">web cache의 작동 순서</span></h4><ol>
<li>브라우저가 Web Cache와 TCP Connection을 형성하고, HTTP 요청을 보낸다.</li>
<li>Web Cache는 요청한 내용의 가피본을 자체적으로 저장하고 있는지를 체크하고 만약 있으면 해당 객체를 돌려준다.</li>
<li>만약 Web Cache가 요청받는 객체를 가지고 있지 않으면 Web Cache는 origin server와 TCP Connection을 열고 요청받은 객체를 가져온다.</li>
<li>Web Cache가 요청한 객체를 받으면 이 것을 자체 저장소에 저장하고 카피본을 보내준다.</li>
</ol>
<blockquote>
<p>웹 캐시를 통해 클라이언트의 요청을 보다 빠르고 저렴하게 처리할 수 있다.<br>또한 인터넷으로의 접근량을 줄여 획사 혹은 대학에서 대역폭을 업그레이드 하지 않아도 된다.<br>또한, 웹 캐시는 전체 인터넷의 웹 트래픽을 현저하게 줄여준다.</p>
</blockquote>
<h2><span id="electronic-mail-in-the-internet">Electronic Mail in the Internet</span></h2><h2><span id="dns-the-internets-directory-service">DNS - The Internet’s directory Service</span></h2><h3><span id="services-provided-by-dns">Services Provided by DNS</span></h3><p>Donmain Name System은 hostname을 IP주소로 번역해주는 시스템이다.</p>
<h3><span id="overview-of-how-dns-works">Overview of How DNS Works</span></h3><h4><span id="a-distributed-hierarchical-database">A Distributed, Hierarchical Database</span></h4><ol>
<li>host가 인근 local dns server에 domain name을 요청한다.</li>
<li>local dns server는 root DNS Server에 요청을 보낸다.</li>
<li>Root DNS Server는 .com 등 domain을 분석하여 해당 도메인을 관리하는 TLD DNS Server를 가르쳐 준다.</li>
<li>Local DNS Server는 위의 TLD DNS Server로 요청을 보낸다.</li>
<li>TLD DNS Server는 해당 Authoritative DNS Server를 가르쳐 준다.</li>
<li>위의 Authoritative DNS Server로 요청을 보낸다.</li>
<li>Authoritative DNS Server는 Local DNS Server 에게 도메인을 보낸다.</li>
<li>도메인을 받아 host에게 돌려준다.</li>
</ol>
<h4><span id="dns-caching">DNS Caching</span></h4><p>위의 DNS 구조는 DNS Caching을 무시한 것이다.<br>이 구조는 매우 간단한데 바로 한번 요청한 url에 대해서 이를 캐싱해 놓는 것이다.</p>
<h2><span id="peer-to-peer-file-distribution">Peer to Peer File Distribution</span></h2><h3><span id="scalability-of-p2p-architectures">Scalability of P2P Architectures</span></h3><h4><span id="server-to-client-architecture">Server to Client Architecture</span></h4><p>서버에서 클라이언트로 데이터를 주고 받는 방식에서는 Distribution time은 클라이언트가 서버로 부터 다운받는 속도가 가장 느린 경우보다 커야하며, 또한 클라이언트가 서버에 자료를 올리는 시간보다도 커야한다.<br>최소 배포 속도(Minimum Distribution Time)를 결정할때 다음을 고려한다.</p>
<ol>
<li>최초에는 서버만 원본 파일을 가지고 있기 때문에 최소 이 전송시간 보다는 minimum distribution time이 길어야 한다.</li>
<li>제일 느린 피어가 다 받아야 하므로 이 시간보다도 길어야 한다.</li>
<li>전체 전송 가용량(upload capacitance)는 서버와 다른 피어들의 전송률의 합과 같다.<br>전체 피어들의 개수와 전체 파일 크기를 곱한 만큼을 전송해야 한다.<br>즉, 최소 $NF/u_s$보다 커야한다.<br>$D_{cs} = max(NF/u_{s}, F/d_{min})$<br>$while,$ $d_{min} = min(d_1, d_p, …, d_N)$</li>
</ol>
<h4><span id="p2p-architecture">P2P Architecture</span></h4><p>각 피어들이 파일을 배포할 때 서버를 도울 수 있다.</p>
<ol>
<li>배포의 시작점에서 파일은 오직 서버만이 들고있다.<br>이 파일을 피어들의 집합으로 전송하기위해 하나의 파일을 온전히 다 전송해야 한다.<br>즉, minimum distribution time은 적어도 $F/u_s$ 이상이다.</li>
<li>가장 느린 피어가 다 받는데 걸리는 시간인 $F/d_min$보다도 커야한다.</li>
<li>전체 시스템의 업로드 역량은 서버 뿐 아니라 각 피어들의 업로드 전송률을 다 합한 것이다.<br>즉, $u_{total}=u_s+u_1+u_2+…+u_N$ 이다.<br>따라서 전체 업로드에 걸리는 시간은 $NF/u_{total}$ 이다.<blockquote>
<p>$D_{P2P}=max(F/u_s, F/d_{min}, NF/(u_s+u_1+u_2+…+u_N))$</p>
</blockquote>
</li>
</ol>
<h3><span id="bit-torrent">bit torrent</span></h3><p>비트 토렌트는 매우 유명한 P2P Protocol이다.<br>하나의 피어가 다운로드를 받는 동안 이 피어는 동시에 자체적인 업로딩 성능을 가지고 서버를 도와 다른 피어에게 데이터를 전송한다.(TCP Connection)<br>특정 파일을 배포하는데 참여하는 모든 피어들의 집합을 토렌트라고 부른다.<br>각 토렌트는  tracker라고 불리는 infrastructure node를 가지는데, 한 피어가 토렌트에 조인하면 그 자신을 트래커에 등록시키고 주기적으로 자신이 아직 토렌트에 있음을 알려준다. 이런식으로 트래커는 토렌트에 참여하는 피어들을 추적하게 된다.</p>
<p>예를들어 엘리스라는 사람이 토렌트에 참여했다고 보자.</p>
<ol>
<li>엘리스가 토렌트에 참여하는 순간 무작위로 토렌트에 참여한 다른 피어들의 IP주소를 받아와 엘리스에게 전달한다.<br>이 피어들을 가짐으로써 엘리스는 이 IP리스트의 피어들과 모두 TCP Connection을 연결한다. 이 피어들을 neighboring peers라고 부른다.</li>
<li>모든 시간대에서 각 피어들은 파일의 뭉텅이들 중 일부를 가지고 있을 것이다. 엘리스는 자신의 neighboring peers에게 뭉텅이들의 리스트를 요구할 것이고, 만약 엘리스가 L명의 각기 다른 이웃을 가진다면 그녀는 L개의 뭉텅이들을 가질 것이다.</li>
<li>모든 시간대동안 엘리스는 자신의 이웃들이 어떤 chunks를 가지고 있는지 알고 있다.</li>
<li>엘리스는 자신의 이웃들중 누구에게 어떤 chunks를 요청할지 결정해야 하는데 이는 rarest first원칙에 따라 가장 희소한 chunks를 먼저 받아오게 된다.<br>이를 통해 희소한 chunk들은 더 빨리 redistribute 될 수 있게 된다.</li>
<li>어떤 요청에 대해 응답할지를 결정해야 하는데 여기서 BitTorrent는 아주 똑똑한 알고리즘을 사용한다.<br>이는 바로 그녀에게 가장 빨리 전송해 주고 있는 4명의 peer에게 chunk를 보내는 것이다.<br>10초 마다 그녀는 이 4명의 peer를 갱신하고, 이 4 개의 피어는 unchoked라고 말한다.<br>30초 마다 그녀는 또한 한명의 추가적인 이웃을 무작위로 골라 chunk를 전송한다.</li>
<li>위에서 임의로 선택되 피어를 bob이라고 하자.<br>여기서 bob은 optimistically unchoked되었다고 하는데 이를 통해 엘리스는 bob의 최고 4명의 uploader중 한명이 되었기 때문이다.</li>
</ol>
<p>만약 엘리스가 최초로 토렌트에 입장하였다면 다른 사람들보다 optimistically unchoked 될 확률이 3배가량 더 높게 책정되어 최대한 빨리 완전한 chunk를 가지게 되어 다운로드에 참여할 수 있게 한다.</p>
<p><a href="https://wiki.theory.org/BitTorrentSpecification#Choking_and_Optimistic_Unchoking" target="_blank" rel="noopener">출처 바로가기</a></p>
<h1><span id="3-transport-layer">3. Transport Layer</span></h1><h2><span id="introduction-and-transport-layer-services">Introduction and Transport-Layer Services</span></h2><hr>
<p>내용없음</p>
<hr>
<h2><span id="multiplexing-and-demultiplexing">Multiplexing and Demultiplexing</span></h2><hr>
<p>내용없음</p>
<hr>
<h2><span id="connectionless-transport-udp">Connectionless Transport: UDP</span></h2><p>UDP는 Transport Protocol이 할 수 있는 최소한의 기능만을 수행한다.<br>UDP를 사용하면 segment를 전달할 때 handshaking이 필요없다.<br>TCP가 보다 안정적이고 믿을만한 데이터 전송 서비스를 수행하지만 다음과 같은 이유로 인해 UDP가 많이 쓰이는 경우가 있다.</p>
<ol>
<li><p>Finer application-level control over what data is sent, and when.<br>UDP를 사용하면 데이터를 받는 즉시 세그먼트에 담아 네트워크 레이어로 보내기대문에 속도가 매우 빠르다.<br>실시간 방송 등 어느정도의 데이터 유실이 발생하더라도 실시간으로 빠르게 정보를 주어야 하는 어플리케이션의 경우 UDP를 사용한다.</p>
</li>
<li><p>No Connection establishment<br>TCP의 경우 다양한 방식으로 핸드쉐이킹을 하기 때문에 속도가 느리다.<br>UDP는 핸드쉐이킹 없이 즉시 연결한다.<br>구글의 크롬 브라우저는 UDP를 메인 프로토콜로 이용하고 어플리케이션 레이어의 프로토콜을 통해 안정성 문제를 보완하고 있다.</p>
</li>
<li><p>No Connection State<br>TCP는 엔드 시스템과의 연결을 계속 유지한다.<br>UDP는 연결을 유지하지 않는다.</p>
</li>
<li><p>Small Packet header overhead<br>TCP segment는 20 bytes 가량의 헤더를 포함하는데 반해 UDP는 단지 8bytes 가량만 포함한다.</p>
</li>
</ol>
<blockquote>
<p>미래에는 TCP를 사용하지 않을 것이다.<br>네트워크 환경이 완벽하게 reliable 해 질 것이기 때문이다.</p>
</blockquote>
<h2><span id="principles-of-reliable-data-transfer">PRINCIPLES OF RELIABLE DATA TRANSFER</span></h2><p>내가 보낸 데이터가 상대방에게 100% 잘 전달되었는지는 네트워킹에서 가장 중요한 논점이다.</p>
<p>만약 신뢰적이지 못한, 비신뢰적인 채널(unreliable channel)에서 데이터를 전송한다면 어떤 문제가 발생할 수 있을까요? 메세지 에러(message error) 그리고 메세지 분실(message loss) 등의 문제점이 발생할 수 있음을 예상할 수 있습니다. 그렇기 때문에 신뢰적인 데이터 전송 프로토콜(reliable data transfer protocol)이 필요한 것입니다.</p>
<p>그러나 생각보다 이 topic이 어렵고 중요한데요. 이유는 위 그림을 보면 알 수 있듯이 TCP가 Reliable Channel로 데이터를 잘 전송하는 것 같지만, 사실 그 서비스 구현을 위해 Network Layer의 Unreliable Channel 위에 구현되어 있기 때문입니다.</p>
<p>그러니깐 다시 말해서, 우리 눈(초록색)에는 TCP는 Reliable하게 데이터를 잘 전송하는게 맞지만, 실제로(빨간색) 구현 측면에서 보자면 TCP는 Unreliable Channel이 존재하는 Network Layer 위에 존재하므로 구현하기가 복잡하다라는 의미입니다.</p>
<h3><span id="building-a-reliable-data-transfer-protocol">Building a Reliable Data Transfer protocol</span></h3><p>신뢰적인 데이터 전송 프로토콜을 구축하기 위해서 가장 간단한 상황부터 시작해서 조금씩 더 복잡해지는 상황으로 이어지는 다음의 4가지 경우에 대해 알아봅시다.<br>좀 더 복잡하고 무결하고 안정적인 데이터 전송 프로토콜을 생각해 본다.<br>일단 송신자로부터 수신자로의 데이터 전송은 단방향의 경우만 고려합니다. 그리고 송신자와 수신자를 정의하기 위해 유한 상태 머신 FSM(Finite State Machine)을 사용합니다.</p>
<h4><span id="reliable-data-transfer-over-a-perfectly-reliable-channel-rdt10">Reliable Data Transfer over a perfectly Reliable Channel: rdt1.0</span></h4><p>완벽하게 신뢰적인 채널 상에서의 신뢰적인 데이터 전송에 쓰이는 프로토콜 rdt1.0을 살펴본다.</p>
<p>송신측<br>: rdt_send(data) 이벤트에 의해 상위 계층으로부터 데이터를 받는다.<br>paket=make_pkt(data) 이벤트에 의해 데이터를 포함하는 패킷을 생성한다.<br>udt_send(packet) 이벤트에 의해 패킷을 채널로 내려보내며 송신한다.</p>
<p>수신측<br>: rdt_rcv(packet) 이벤트에 의해 하위 채널로부터 패킷을 수신한다.<br>extract(packet,data) 이벤트에 의해 패킷으로부터 데이터를 추출한다.<br>deliver_data(data) 이벤트에 의해 데이터를 상위 계층으로 전달한다.</p>
<blockquote>
<p>rdt1.0의 경우에는 하위 채널이 완전히 신뢰할 수 있는 경우이므로 중간에 데이터 변형이 없고(비트에러가 없음), 패킷의 손실도 없기 때문에, 오류가 생길 수 없으므로 수신 측이 송신 측에게 송신을 늦추어 달라는 어떠한 피드백도 제공할 필요가 없다.</p>
</blockquote>
<h4><span id="reliable-data-transfer-over-a-channel-with-bit-errors-rdt20">Reliable Data Transfer over a Channel with Bit Errors: rdt2.0</span></h4><p>비트 오류가 있는 채널 상에서의 신뢰적인 데이터 전송 : rdt2.0<br>패킷 안의 비트들이 하위 채널에서 손상되는 경우이다. 비트의 손상은 패킷이 전송되고, 버퍼되는 등 네트워크의 물리적인 부분에서 발생한다.<br>rdt1.0보다 조금 복잡한 rdt2.0이라고 부르며, 모든 패킷들이 순서대로 수신되고 패킷손실은 없다고 가정한다.<br>여러분은 전화통화를 할 때, 상대방의 말이 잘 들리면 계속 대화를 이어가지만 상대방의 말이 잘 안들리거나 하면 “뭐라고? 잘 안들려”라고 상대방에게 피드백을 줄 것입니다. 통신에서도 마찬가지입니다. 상대방의 말이 잘 들리면(데이터가 잘 도착하면) ACKs(acknowledgements)라는 긍정확인응답을 보내고, 상대방의 말이 잘 안들리면(데이터가 잘 도착하지 못하면) NAKs(negative acknowledgements)라는 부정 확인응답을 보내서 재전송을 요청합니다. 이렇게 재전송을 기반으로 하는 신뢰적인 프로토콜을 자동재전송요구 프로토콜인 ARQ(Automatic Repeat reQuest) 프로토콜이라고 합니다.</p>
<p>ARQ의 기능은 크게 3가지 입니다.</p>
<ol>
<li>오류검출 : 체크섬 필드를 사용하여 비트오류 발생 시 수신자가 검출할 수 있게 합니다.</li>
<li>수신자 피드백 : 패킷이 정확하게 수신되었는지 아닌지를 수신자가 송신자에게 ACK 또는 NAK로 피드백 합니다.</li>
<li>재전송 : NAK의 피드백일 경우 송신자는 재전송합니다.</li>
</ol>
<p><strong>송신 측(2가지의 상태를 가집니다)</strong></p>
<ol>
<li><p>송신 측은 상위 계층으로부터 데이터가 전달되기를 기다립니다.</p>
</li>
<li><p>rdt_send(data) 이벤트에 의해 상위 계층으로부터 데이터를 받으면, sndpkt=make_pkt(data,checksum) 이벤트에 의해 데이터와 체크섬을 포함하는 패킷을 생성하고, udt_send(sandpit) 이벤트에 의해 패킷을 채널로 내려보내며 송신합니다.</p>
</li>
<li>송신 후에는 오른쪽 상태로 넘어와 ACK 또는 NAK로 피드백 받기를 기다립니다.</li>
<li>만약, 수신 측이 잘 받고(receive) ACK의 피드백이 돌아온다면 왼쪽의 상태로 넘어가 상위계층으로부터 데이터가 전달되기를 기다리며 위의 과정을 반복합니다.</li>
<li>그러나, 수신 측이 잘 받았지만 NAK의 피드백이 돌아온다면 ACK의 피드백이 돌아올 때까지 udt_send(sandpit)의 과정을 반복합니다.</li>
</ol>
<blockquote>
<p>이 때 송신 측이 ACK 또는 NAK를 기다리는 오른쪽 상태에 있는 중에는 상위 계층으로부터 더 이상의 데이터를 전달받을 수 없습니다. rdt2.0은 전송-후-대기(Stop-and-Wait) 프로토콜이라고도 합니다.</p>
</blockquote>
<p><strong>수신 측</strong></p>
<ol>
<li>rdt_rcv(rcvpkt) 이벤트에 의해 하위 채널로부터 패킷을 수신합니다.</li>
<li>corrupt(rcvpkt) 이벤트에 의해 수신한 패킷에 오류가 있는 경우 udt_send(NAK)로 NAK 피드백을 합니다.</li>
<li>수신한 패킷에 오류가 없는 경우 extract(rcvpkt, data) 이벤트에 의해 패킷으로부터 데이터를 추출합니다.</li>
<li>deliver_data(data) 이벤트에 의해 데이터를 상위 계층으로 전달합니다.</li>
<li>udt_send(ACK) 이벤트에 의해 ACK 피드백을 합니다.</li>
</ol>
<blockquote>
<p>rdt2.0은 위와 같이 잘 동작되는 것처럼 보이지만 실제로는 치명적인 결합이 있는데 바로 ACK/NAK 패킷의 손상 가능성을 무시했다는 것입니다.</p>
</blockquote>
<p>송신 측으로부터 수신 측으로 data가 잘 왔고, ACK 피드백을 보냈는데 중간에 ACK 패킷이 손상되어서 송신 측이 ACK를 못 알아듣는다면 어떻게 해야할까요? 가장 간단하면서 단순한 방법으로 송신 측은 그저 data를 수신 측으로 다시 한 번 보냅니다. 그러면 ACK/NAK가 다시 올테니깐요.</p>
<p>그런데 수신 측은 혼란스러울 겁니다. 자신은 아까 받은 data에 대해 ACK를 보내주었는데, 동일한 data가 한 번 더 왔으니… 이게 다음 data인지 똑같은 data를 두번 중복(duplicate)으로 보낸건지…. 헷갈립니다.</p>
<p>이러한 중복 패킷에 대한 문제에 대한 간단한 해결책은 패킷에 순서번호(sequence number)를 붙이는 것입니다. 그래서 수신 측은 수신된 패킷이 재전송으로 인한 중복패킷인지 새로운 패킷인지를 결정할 때 sequence number만 확인하면 됩니다. 동일한 sequence number의 패킷이 수신된다면 이는 중복패킷으로 인식하는 것입니다.</p>
<h4><span id="rdt21">rdt2.1</span></h4><p>세번째로, 바로 위에서 언급한 sequence number를 추가한 모델이 rdt2.1입니다. 송신 측은 0과 1을 sequence number로 사용합니다. 그리고 수신측은 0과 1로 중복패킷인지 여부를 결정합니다. 아래의 FSM을 봅시다</p>
<p>왼쪽 송신 측이 sequence number 0의 패킷을 보내면 0번에 대한 ACK/NAK를 기다립니다.<br>오른쪽 수신 측은 문제없이 잘 수신한 경우 ACK를 보내며 sequence number 1의 패킷이 수신되기를 기다립니다.<br>왼쪽 송신 측은 ACK를 받으면 sequence number 1의 패킷을 보내고, NAK를 받거나 피드백 패킷에 오류가 있을 경우에 sequence number 0의 패킷을 재전송합니다.<br>오른쪽 수신 측은 sequence number 1의 패킷을 기다리고 있는데, sequence number 1의 패킷이 수신되면 순조롭게 ACK를 보내면 되고, sequence number 0의 패킷이 도착한다면 sequence number 0의 패킷이 중복도착했으므로 무언가 중간에 문제가 생겼음을 알고 sequence number 0에 대한 ACK를 보냅니다.</p>
<h4><span id="rdt22">rdt2.2</span></h4><p>기능은 rdt2.1과 동일하지만 NAK를 사용하지 않고(NAK-free) ACK만 사용하는 모델이 rdt2.2입니다.</p>
<p>NAK를 보내는 대신에, 가장 최근에 잘 받은 패킷에 대한 ACK를 보냄으로써 NAK를 보내는 것과 동일한 효과를 얻을 수 있습니다. 다음 그림을 보면 쉽게 이해할 수 있습니다.</p>
<p>송신 측이 pkt1을 보냈지만 수신측이 ACK1이 아닌 ACK0만 계속 보낸다면 송신 측은 pkt1의 전송에 문제가 생겼음을 인식하고 재전송할 수 있다라는 의미입니다.</p>
<h4><span id="reliable-data-transfer-over-a-lossy-channel-with-bit-errorsrdt30">Reliable Data Transfer over a lossy Channel with Bit Errors:rdt3.0</span></h4><p>마지막으로, 비트 손상과 함께 패킷을 손실하는 모델을 고려봅시다. 이를 rdt3.0이라고 부르며, 어떻게 패킷 손실을 검출하며 패킷손실이 발생했을 때 어떤 행동을 해야하는지가 중요한 사항이 됩니다. 다행히 패킷손실이 발생했을 경우 rdt2.2까지 설명하면서 사용되어 왔던 체크섬,sequence number, ACK, 재전송 등은 패킷손실이 발생했을 때 해야하는 행동에 대한 답이 될 수 있습니다. 패킷 손실의 검출은 바로 Timer로 할 수 있습니다.</p>
<p>타이머는 패킷 손실이 일어났다는 100% 보장은 아니지만, 손실이 일어났을 만한 그런시간을 현명하게 선택하는 방식입니다. 만일 ACK가 이 시간안에 수신되지 않는다면 패킷은 재전송될 것(그림 b,c)입니다. 심지어 패킷이 유별나게 큰 delay를 가져서 타이머 시간보다 늦게 도착하는 경우 비록 ACK가 손실되지 않았다 하더라도 패킷은 재전송할 수 있습니다. 이는 중복 데이터 패킷(duplicate data packet)의 가능성을 포함한다는 이야기입니다.(그림d) 다행히 rdt2.2는 이미 패킷이 중복되었을 경우를 처리하기 위한 sequence number의 기능을 가지고 있습니다.</p>
<p>재밌는 점은 프로토콜 rdt3.0은 기능적으로 매우 정확한 프로토콜임에도 불구하고 오늘날의 고속 네트워크에서 만족스러운 성능을 보여주지 못한다는 점입니다. 이유는 ‘전송-후-대기(Stop-and-Wait)’방식이기 때문입니다. 이를 위해서 pipelining이 도입되었고 이는 다음과 같은 성질을 가진다.</p>
<ol>
<li>sequence number의 범위가 증가한다. 왜냐하면 각각의 패킷이 서로 다른 시퀀스 넘버를 가져야하기 때문이다.</li>
<li>리시버 사이드는 하나 이상의 패킷을 버퍼해야 한다. 제대로 받은 패킷들에 대한 버퍼링이 필요하다.</li>
<li>시퀀스 넘버의 범위는 유실되고 손상되고 지연된 패킷들에 따라 결정된다. 이를 위해 Go-Back-N, selective repeat이라는 두가지 파이프라인 에러 리커버리 접근이 있다.</li>
</ol>
<h3><span id="go-back-ngbn">Go-Back-N(GBN)</span></h3><p>누적 ACK, 단일 타이머<br>GBN 방식은 단일한 타이머를 사용한다.<br>만약 1번 패킷까지만 도착을 했고 2번 패킷이 도착을 하지 않았으면, 리시버는 2번부터 계속해서 날아오는 패킷들을 죄다 버리고 전체 타이머가 다 되어 2번이 날아오기를 기다린다.<br>그리고 2번 이후로 날아오는 패킷마다 ACK1만 보내 내가 1까지 밖에 못받았음을 알린다.</p>
<h3><span id="selective-repeatsr">Selective Repeat(SR)</span></h3><p>개별 ACK, 개별 타이머<br>SR 방식은 패킷마다 신경을 쓴다.<br>만약 2번 패킷이 전달되지 않았다면 3번부터 오는 패킷들을 전부 버퍼해 두고 2번 패킷에 대한 타이머가 타임아웃되어 다시 전송을 해 주면 버퍼해두었던 모든 패킷을 한꺼번에 어플리케이션 레이어로 보내주고 2번 패킷에 대한 ACK를 보낸다.</p>
<h1><span id="4-the-network-layer-data-plane">4. The Network Layer: Data Plane</span></h1><h2><span id="overview-of-network-layer">Overview of Network Layer</span></h2><h3><span id="forwarding-and-routing-the-data-and-control-planes">Forwarding and Routing: The Data and Control Planes</span></h3><p>네트워크 레이어가 하는 일은 간단히 말하면 아주 쉽다.<br>바로 보내는 host로 부터 받는 host로 패킷을 이동시키는 것이다.<br>이를 위해서는 다음과 같은 두가지 중요한 네트워크 레이어의 기능을 알아야 한다.</p>
<p>Forwarding<br>: 패킷이 라우터의 인풋링크에 도착하면, 라우터는 패킷을 적합한 output link에 옮겨야 한다. 즉, 패킷이 다음 라우터로 가는 링크를 가르키게 해야한다. 또한 다른 호스트로 패킷이 이동하지 못하도록 막아야 한다. 이는 네트워크 레이어의 <strong>data plane</strong> 에서 이루어진다.</p>
<p>Routing<br>: 네트워크 레이어의 <strong>control plane</strong> 에서 이루어지는 것으로 routing algorithm을 통해 다음에 어떤 라우터로 갈지를 결정한다.</p>
<blockquote>
<p>운전자를 예로 들면 운전자가 각각의 갈림길에서 어느 길로 갈지를 순간순간 결정하는 것이 forwarding 이고 routing은 목적지로의 여행을 계획하는 프로세스로 볼 수 있다.</p>
</blockquote>
<h4><span id="control-plane-the-traditional-approach">Control Plane: The Traditional Approach</span></h4><p>네트워크 레이어의 기존의 Control Plane에서는 routing algorithm이 모든 라우터에서 실행되어 포워딩과 라우팅 기능이 모두 라우터 안에 내장되어 있었다.<br>때문에 모든 포워딩 테이블들을 관리하기 위해서 물리적인 라우터에 관여해야 했다.</p>
<h4><span id="control-plane-the-sdn-approach">Control Plane: The SDN Approach</span></h4><p>현대의 네트워크 레이어의 컨트롤 플레인의 경우 원격의 컨트롤러가 포워딩 테이블을 계산하고 각 라우터에 배포하는 식이다.<br>이를 통해 컨트롤 플레인의 라우팅 기능이 라우터의 물리적인 부분에서 독립되어 라우팅 디바이스는 단순히 포워딩 기능만을 담당하게 되었다.<br>이러한 SDN의 개념은 포워딩 테이블을 계산하는 컨트롤러가 소프트웨어로 구축이되어 네트워크의 개선 가능성을 높였다.<br>이러한 SDN 기술은 오픈소스로 배포되어 많은 사람들이 효과적인 네트워킹 방식에 대해 논의를 지속적으로 하여 기술 향상성이 기대된다.</p>
<h1><span id="5-the-network-layer-control-plane">5. The Network Layer: Control Plane</span></h1><h2><span id="routing-algorithms">Routing Algorithms</span></h2><p>송신자에서 수신자까지 좋은 길을 찾아내는 routing 알고리즘을 배운다.<br>여기서 좋은 path란 말은 least coast를 말한다.</p>
<p>라우팅 알고리즘의 구분</p>
<ol>
<li>centralized routing인가 decentralized routing인가?</li>
</ol>
<p>centralized routing algorithm<br>완벽하고 네트워크 전체의 이해를 기반으로 least coast를 결정한다.</p>
<p>decentralized routing algorithm<br>least coast path에 대한 계산이 라우터들마다 저만의 방식으로 반복적으로 수행되는 알고리즘이다.</p>
<ol start="2">
<li>static routing algorithms인가 dynamic routing algorithms인가?<br>static routing algorithm은 라우팅이 매우 천천히 진행된다.<br>가끔은 인간의 간섭으로 진행되기도 한다.</li>
</ol>
<p>dynamic routing algoritms은 현재 연결상태에 따라 매우 다이나믹하게 routing path가 바뀐다.</p>
<ol start="3">
<li>load-sensitive인가 load-insensitive인가?<br>load-sensitive에서는 현재 연결의 혼잡도에 따라 cost가 매우 다이내믹 하게 바뀐다.</li>
</ol>
<h3><span id="the-link-statels-routing-algorithm">The Link State(LS) Routing Algorithm</span></h3><p>Link State Algorithms에서는 네트워크 위상과 코스트가 모두 알려져 있다.<br>때문에 link state broadcast algorithm이라고도 불린다.<br>즉, 때문에 이 모든 값들은 LS알고리즘의 input으로 들어갈 수 있다.</p>
<p>WorkFlow<br>모든 노드가 최적의 길을 알고있다고 한다.<br>하나의 노드에서 각각의 모든 노드에 이르는 least coast path를 구하는 식으로 테이블을 그려나가며<br>각 반복마다 전 노드 추가에 대한 반복을 기준으로 가장 least cost가 작은 노드를 추가하여 다시 반복을 실행한다.<br>모든 테이블을 완성하였다면 이를 기반으로 Least cost Path를 그리고 forwarding table을 완성한다.</p>
<h3><span id="the-distance-vector-routing-algorithms">The Distance-Vector Routing Algorithms</span></h3><p>LS 알고리즘이 전체 네트워크에 대한 정보를 사용하는 반면, distance-vector(DV) algorithms은 반복적이고, 비동기적이고, 분산적이다.<br>이것은 각 노드가 주변의 하나 혹은 여러개의 직접 붙어있는 노드에서 정보를 받아온다는 점에서 분산적이다.<br>또한 이렇게 계산된 정보를 다시 이웃의 노드로 전달하는 것을 더 이상 노드 사이에 정보 교환이 필요없는 시점까지 반복한다는 점에서 반복적이다.<br>또한 각 계산과정에서 모든 노드가 필요하지 않다는 점에서 비동기적이다.</p>
<p>이는 centralized algorithm 보다 훨씬 흥미롭다.</p>
<p>기본적인 작동 원리는<br>예를 들어 x노드에서 y노드 까지의 least cost는 x에서 v로 갈때의 코스트와 v에서 y로 갈때의 least cost의 합중 가장 작은 값이라는 bellman-ford의 방정식에 입각한다.</p>
<h1><span id="7-wireless-and-mobile-networks">7. Wireless and Mobile Networks</span></h1><h2><span id="wifi-80211-wireless-lans">WIFI : 802.11 WIRELESS LANS</span></h2><h3><span id="the-80211-mac-protocol">The 802.11 MAC Protocol</span></h3><p>AP 혹은 디바이스를 다중접속 채널을 나누는 무선 스테이션이라고 칭한다.<br>무선 연결시 충돌된 연결을 피하기 위해서 다양한 기술들을 사용하는데<br>802.11 Wireless LAN에서는 CSMA/AC 기술을 이용한다.<br>CSMA/CA란 Carrier Sense Multiple Access / Avoiding Collision의 약어로<br>각 스테이션이 데이터 전송 전에 채널을 센싱하고 채널이 바쁘면 데이터를 전송하지 않아 충돌을 막는 방법을 일컷는다.</p>
<h4><span id="dealing-with-hidden-terminals-rts-and-cts">Dealing with Hidden Terminals: RTS and CTS</span></h4><p>RTS와 CTS를 통해 네트워크 사이의 충돌을 막는다.</p>
<ol>
<li>한 호스트가 AP에게 데이터를 받기 위해 RTS Frame을 보낸다<br>이 RTS Frame에는 데이터 프레임을 보낼때 소요되는 총 시간과 ACK 프레임을 받기 위해 필요한 총 시간을 명시한다.</li>
<li>AP가 RTS 프레임을 받으면 CTS 프레임을 broadcasting 해 줌으로써 응답한다.<br>이러한 CTS 프레임은 전송자에게 데이터 프레임 전송을 시작하도록 허락하고 그 동안 다른 호스트들이 그 시간동안 데이터를 전송하지 못하도록 한다.</li>
<li>AP가 원하는 데이터를 다 받으면 <strong>ACK 프레임</strong> 을 <strong>broadcasting</strong> 하여 전송이 완료되었음을 알린다.</li>
<li>다른 호스트는 ACK프레임을 전송받음과 동시에 AP로의 접근 제한이 풀리게 된다.</li>
</ol>
<p>RTS<br>: Request to Send</p>
<p>CTS<br>: Clear To Send</p>
<blockquote>
<p>RTS와 CTS 프레임을 사용하면 다음과 같은 두가지 중요한 성과를 얻을 수 있다.<br>첫째로, 채널이 확보되고 난 다음에 데이터 프레임을 전송하므로 hidden station problem을 해결한다.<br>둘째로, RTS와 CTS 프레임은 매우 짧으므로 이 두 프레임을 전송하면서 발생하는 충돌은 아주 짧은 시간동안만 발생 가능하다. RTS와 CTS 프레임을 전송하고 난 뒤에는 뒤따라 데이터와 ACK 프레임들이 충돌없이 전송되어야 한다.</p>
</blockquote>
<h1><span id="8-security-in-computer-networks">8. Security in Computer Networks</span></h1><p>인터넷에서 secure communication을 원하는 경우는 수없이 많다.<br>전쟁 서신부터 연애편지, 사업 거래 등 많은 요소에서 보안을 필요로 하고, 이를 할 수 있는 방법을 배운다.<br>먼저 기초적인 암호기술을 배우고 4개의 layer에 대해서 먼저 application layer에서 부터의 안전한 protocol에 대해 배운다.</p>
<h2><span id="what-is-network-security">What is Network security?</span></h2><p>다음과 같은 조건이 만족되어야 한다.</p>
<h4><span id="confidentiality">Confidentiality</span></h4><p>오직 송신자와 수신자만이 전송된 메세지의 내용을 알 수 있어야 한다.<br>중간에 도청자가 메세지를 가로체더라도 이것이 암호화되어있어 도청자에 의해 해독되지 못해야 한다.<br>이를 위해 우리는 간단한 암호화 기술을 배운다.</p>
<h4><span id="message-integrity">Message integrity</span></h4><p>전송된 메세지의 내용이 중간에 변형되지 않아야 한다.<br>이건은 data link protocol에 의해 제공될 수 있다.</p>
<h4><span id="end-point-authentication">End point authentication</span></h4><p>전송자와 수신자가 서로 상대방이 누구인지 알아야 한다.</p>
<h4><span id="operational-security">Operational security</span></h4><p>대부분의 기관들의 네트워크가 공용 인터넷에 연결되어 있는 만큼 이러한 네트워크가 공격받을 수 있다.<br>이러한 네트워크의 보안이 잘 지켜져야 한다.<br>firewall이 기관의 네트워크와 공용 네트워크 사이에 있어서 접근하고 나가는 패킷들을 관리해야 한다.</p>
<h4><span id="중간-침입자는-다음과-같은-기능을-할-수-있다">중간 침입자는 다음과 같은 기능을 할 수 있다.</span></h4><p>eavesdropping / 조작 메세지 및 데이터 메세지를 가로체거나 복제할 수 있다.<br>modification, insertion, or deletion of messages or message content</p>
<h2><span id="principles-of-cryptography">Principles of Cryptography</span></h2><p>암호화 되기 전 메세지를 plaintext 혹은 cleartext라고 한다.<br>함호화를 위해 사용한 알고리즘을 encryption algorithm이라 하며, 암호화된 메세지를 ciphertext라 한다.<br>요즘의 경우 암호화 기술은 그 자체로 누구에게나 잘 알려져 있는데 이를 해독하기 위해서는 비밀스런 정보인 키값이 필요하다.<br>암호화 기술에 키값을 넣으면 plaintext가 나오게 된다.</p>
<h3><span id="symmatrcic-key-cryptography">Symmatrcic Key Cryptography</span></h3><p>엘리스가 자신의 private key로 암호화해서 보내면 밥은 자신의 private key로 해독하여 메세지를 읽는다.<br>두 key는 symmetric하다.</p>
<h3><span id="public-key-encryption">Public Key Encryption</span></h3><p>엘리스가 밥에게 메세지를 보낼 때 밥의 공개키로 암호화를 해서 보내고 밥은 이를 열때 밥의 private key로 해독한다.</p>
<h2><span id="message-integrity-and-digital-signature">Message Integrity and Digital Signature</span></h2><h4><span id="cryptographic-hash-functions">Cryptographic Hash Functions</span></h4><p>Hash function이 입력 메세지를 받으면, 고정된 사이즈의 스트링 H(m)을 계산해 낸다.(Hash)<br>Cryptographic Hash Function은 다음과 같은 성질을 가진다.<br>다른 메세지를 Hash Function에 넣고 같은 Hash값을 가지는 경우가 반드시 있다.<br>이러한 성질은 intruder가 한 메세지를 다른것으로 만드는 것을 불가능하게 만든다.</p>
<p>어떤 메세지가 있을때 단순히 checksum 방식을 이용하여 메세지를 변형하였을때 같은 hash를 가지는 메세지를 쉽게 찾을 수 있기 때문에 메세지를 변형하기 쉽다. 하지만 Hash Function을 이용하면 intruder가 같은 Hash를 가지는 메세지를 찾는 것이 거의 불가능해 진다.<br>즉, hash를 이용할 경우가 더 좋은 message integrity를 가진다.</p>
<h3><span id="비트코인">비트코인</span></h3><h4><span id="비트코인이란">비트코인이란?</span></h4><p>데이터 마이닝을 통해 새로운 블록들이 마만들어고 이것은 25개의 비트코인을 만들어 낸다.<br>디지털 화폐로 매우 신뢰도 있고, 합법적으로 되고 있다.</p>
<p>비트코인을 어떻게 트래킹 하는가?<br>여기서 블록체인의 개념이 나온다.<br>비트코인이 생성되면 비트코인을 가진 모든 사용자들에게 알려지게 된다.<br>모든 사람들이 다 이 정보를 볼 수 있다.<br>영속적이고 신뢰할 수 있는 정보인지 어떻게 하는가</p>
<p>해쉬를 만들어 데이터 마이닝을 한다.<br>해쉬는 만들기 어려운 것이 아니다.<br>한번 이걸 만들면 즉각적으로 블록과 연결이 된다.<br>해쉬는 일종의 판별자이다<br>-secure, permanent</p>
<p>마이닝을 통해 데이터는 안전하게 되고 영속적으로 된다.</p>
<p>블록체인의 핵심은 중앙집권화된 단체를 없애는 것이다.<br>모든 참여자들이 모든 거래에 대해 ㄱ알게하고 각 모든 거래는 그 정보를 구성하는 판별자를 가지고 있다.</p>
<p>퍼블릭 블록체인<br>퍼블릭 키를 사용한다.<br>너무 많은 에너지를 사용한다.</p>
<p>private 블록체인<br>개인 키를 사용한다.</p>
<p>블록체인을 사용하면 매우 보안이 높고 효율적인 데이터 교환을 할 수 있지만 블록체인 자체를 통제하는 데 어려움이 있게 때문에 이를 통제하기 위해 노력한다.<br>주로 금융 기관에서 블록체인을 적용하려고 노력하고 있다.</p>
<p>블록체인에 각종 정보를 담아 널리 퍼뜨릴 수 있느 가능성이 있다.<br>의료사업에 있어서도 현재는 나의 모든 의료정보를 병원이나 다른 의료 기관에서 들고 있지만 이는 그다지 합리적이지 못하다.<br>블록체인을 통해서 이러한 보든 정보들을 사용자가 직접 가질 수 있다.</p>
<p>블록체인 1<br>시초<br>블록체인 2.0<br>스마트카 등등<br>블록체인 3.0<br>인텔리전스 기반</p>
<p>Blockchain Application<br>현재 기관들이 block chain을 도입하면 많은 부분들이 급변하게 된다.</p>
<p>왜 블록체인이 좋은가?<br>p2p<br>scalable<br>block 없이는 아무것도 바꾸지 못한다.</p>
<p>private하다면 접속하는데 private key가 필요하기 때문에</p>
<p>Buisiness Model<br>initiate -&gt; design -&gt; strengthen -&gt; implement</p>
<p>여기서 디자이닝 모델에 집중한다.<br>현재 금융 시장에서 돌아가는 방식을 토대로 앞으로 이러한 시장에 블록체인 기술을 통해 어떤 방식의 통화흐름을 만들어낼 것인가?</p>
<p>블록체인의 정보들이 FTA 과정을 통해 분석될 수 있고, 이 내용을 통해 각 국의 경제정보를 얻을 수 있어 이를 통해 새로운 비즈니스가 가능해 진다.<br>블록체인을 통해 모든 정보가 투명해 질 수 있다.</p>
<p>의료정보에 쉽게 접근가능 - 정보가 투명해 졌기 때문<br>예를 들어 의료 정보들은 각 의료센터마다 분산되어 있기 때문에 누구나 접근할 수 있는 정보가 아니다.<br>하지만 블록체인 기술을 통해 분산된 지역에서의 모든 정보들이 누구든지 접근할 수 있는 형태가 되기 때문에 가능하다.</p>
<p>프로슈머들이 훌륭하게 활동할 수 있다.</p>
<p>ad-hoc<br>기기가 라우터의 역할 까지 하는 등 센서 네트워크가 이런 것이 많다.<br>독립 단말끼리 외부의 도움없이 자기들 만으로 자율적인 임시적 망을 구성함을 뜻함<br>ㅇ 동적 토폴로지</p>
<ul>
<li>이동이 자유롭기 때문에 네트워크 토폴로지가 동적으로 변함<br>ㅇ 유연한 망 구성</li>
<li>임시 망의 구성은 각 이동단말이 서로 가까이 있을 때에 만 통신망을 구성<br>ㅇ 중앙 제어 없음 (자율 망 구성 능력)</li>
<li>어떠한 중앙 제어나 표준 지원 서비스의 도움 없이 임시로 망을 구성.<br>ㅇ 정보 전달 방식</li>
<li>일대일 다중 홉 라우팅(Multihop Routing) 방식으로 전달<br>ㅇ 각 노드 역할 다양성</li>
<li>Mesh network에서는 각 노드가 메시지를 보내거나 받을 수 있으며 라우터 역할도 가능<br>ㅇ Self-healing (자율 고장 치유 능력)</li>
<li>하나의 연결이 끊어져도 network는 자동적으로 다른 연결로 메세지를 전송할 수 있음<br>ㅇ 신호 강도</li>
<li>각 노드가 가까워 질수록 신호가 매우 좋아짐<br> . 예를들면,  거리가 반으로 줄어들면 신호는 4배로 좋아짐<br>ㅇ 노드 추가/탈퇴 유연성</li>
<li>간단하게 노드들이 추가,탈퇴할 수가 있음</li>
</ul>
<h1><span id="industry-40">Industry 4.0</span></h1><p>4차 산업은 생산공정에서의 자동화와 데이터 교환의 흐름을 일컷는다.<br>이 용어는 cyber-physical system와 IoT 그리고 클라우드 컴퓨팅을 포함하는 개념이다.<br>4차 산업혁명을 통해 이른바 스마트 팩토리라는 개념이 생겨나고 모듈화 되고 구조화된 스마트 팩토리를 통해 Cyber Physical System은 물리적 공정을 감독하고, 실제 세계의 모형을 본떠 decentralized된 의사결정을 내릴 수 있게 되었다.</p>
<p>Over the Internet of Things, cyber-physical systems communicate and cooperate with each other and with humans in real time, and via the Internet of Services, both internal and cross-organizational services are offered and used by participants of the value chain.[1]<br>block chain기술 - p2p big data를 포괄한다.<br>IoT<br>smart machine<br>한정된 컴퓨팅 자원만을 이용한다.<br>clustering of things using cloud computing</p>
<h3><span id="ubiquitous">Ubiquitous</span></h3><p>make smart space</p>
<h3><span id="layering-architecture">Layering Architecture</span></h3><p>새로운 platform을 만들기 위한 구조를 설계하는 법을 배울 것이다.<br>모든 플랫폼은 이러한 layer를 기반으로 설계된다.</p>
<p>Five Layer<br>Application Layer<br>Transport Layer - TCP<br>Network Layer - IP<br>Data Link Layer - WLAN<br>Physical Layer</p>
<p>여기서 Application, Transport, Network, DataLink는 Software의 범주에 속한다.<br>Network, Data Link 를 middleware에 속한다.<br>Physical Layer는 Hardware를 의미한다.</p>
<h1><span id="history-of-computer-network">History Of Computer Network</span></h1><h3><span id="80년대">80년대</span></h3><p>distributed computing을 사용하였다<br>이 경우에는 매우 한정적인 computing resources를 가지고 일을 하였다.</p>
<h3><span id="90년대">90년대</span></h3><p>mobile computing 에 대한 관심이 높아졌다.<br>모바일 컴퓨팅의 경우는 단지 nomadic한 네트워크 통신을 하였다면<br>유비쿼터스 시대에는 상당히 스마트한 환경을 기반으로 한다.</p>
<h3><span id="2000년대">2000년대</span></h3><p>IoT + big data analytics</p>
<h3><span id="유비쿼터스-컴퓨팅-vs-모바일-컴퓨팅">유비쿼터스 컴퓨팅 VS 모바일 컴퓨팅</span></h3><h3><span id="mobile-computing">Mobile Computing</span></h3><p>모바일 컴퓨팅<br>모바일 컴퓨팅은 단순히 서버에서 클라이언트로의 네트워크를 의미한다.<br>base station에서 다른 스마트 기기로 정보를 전송한다.</p>
<h3><span id="유비쿼터스-컴퓨팅">유비쿼터스 컴퓨팅</span></h3><p>Two Entities</p>
<ol>
<li>sensors</li>
<li>actuators<br>유비쿼터스 에서의 네트워크는 peer to peer를 의미한다. 또는 센서 네트워크<br>p2p ad-hoc network, mesh network</li>
</ol>
<p>Context<br>formal data 와 informal data를 모두 포함한다.<br>이러한 기술을 통해 유비쿼터스 컴퓨팅은 reasoning과 inferencing, learning이 가능해 진다.<br>센세들이 단순한 컴퓨터 데이터가 아닌 context를 수집하기 때문이다.<br>-&gt; context awareness<br>peer는 바로 인터넷에 적합하지 못함 반드시 gateway를 거쳐야.</p>
<p>IoT<br>단순 sensor와 actuator만 가지고는 reasoning inferencing, learning 등을 할 수 없다.<br>여기에는 반드시 gateway가 들어가야 한다.<br>Ex) 스마트카 등이 gateway의 일종이다.<br>유비쿼터스 컴퓨팅의 기초는 localized service라는 것이다.<br>이 기술을 통해 우리는 당면한 문제를 중앙집중된 처리를 하는 것이 아니라 주변 네트워크 자원을 이용하여 해결한다.<br>이를 통해 통신 네트워크 자원을 아낄 수 있게 된다.<br>더 적은 센서와 actuator를 사용하기 위해 더 똑똑한 IoT가 필요하게 되었다.<br>IoT란 센서와 actuator 네트워크를 모두 사용한 일종의 기기를 의미한다.<br>사용하는 통신의 기술에는 WLAN, ZGBEE,ZWAVE,LTE등이 있다.<br>SK의 경우 여기에 LTE를 이용하고, KT 는 WLAN, LTE,를 이용한다. LG의 경우는 ZGBEE,ZIWAVE</p>
<p>lte의 경우impossible to make clustering entities for smart space<br>스마트폰이 지역적 통신망에 접근하는 유일한 방법은 wifi를 이용하는 것이다.<br>즉 lte는 유비쿼터스 컴퓨팅에 적합하지 않은 통신 방법이다.</p>
<p>vertical handoff<br>lte to wifi or wifi to bluetooth</p>
<p>회사들은 zgbee와 zwave방식을 더 선호한다. - 왜 그런지는 다음에</p>
<p>security<br>p.726 - wep</p>
<h3><span id="home-network">Home Network</span></h3><h3><span id="security-vs-privacy">Security VS privacy</span></h3><p>Authentication이 매우 중요해 졌다.<br>이를 위해 PKI같은 기술들을 사용하게 된다.</p>
<h3><span id="energy">Energy</span></h3><p>ZEB(Zero Energy Building)을 만들기 위해서 다음과 같은 기술이 필요하다.<br>a. renewable energy<br>b. Energy IoT<br>ex) Smart switch의 경우 센서와 액츄에이터의 역할을 같이 한다.<br>c. HEMS - Home Energy Management System<br>d. ESS - Energy Storage System.</p>
<p>Service<br>Cost<br>Performance<br>Reliability<br>Safety<br>Security<br>Reliability<br>Scabiability</p>
<h1><span id="introduction-of-data-analytics">Introduction Of Data Analytics</span></h1><p>Big Data Analytics<br>traditionally / SPSS, R<br>Future oriented / python, php, 하둡</p>
<p>Crawling<br>필요한 데이터를 긁어오는 것<br>Supervised Learning<br>learning with labeled examples<br>x값과, y값이 이 정해져 있다.<br>어떤 데이터가 들어가서 어떤 데이터가 나오는지 안다</p>
<p>Unsupervised Learning<br>google news grouping<br>word clustering<br>어떤 값인지 모르고 데이터의 특성에 따라 분류한다.</p>
<p>Data Visulalization Tools<br>python library<br>matplotlib<br>flask</p>
<p>process<br>data gathering<br>preprocessing<br>modeling<br>testing<br>visualization</p>
<p>Start Data Analytics<br>“프로그램인 Tableau<br>phthon+TensorFlow(구글 라이브러리)”</p>
<h3><span id="data-analytics-rd-environment">Data Analytics R/D Environment</span></h3><p>Main Tool<br>Tableau<br>Phython with Pycharm<br>Tensorflow</p>
<h3><span id="three-types-of-communication">Three Types of Communication</span></h3><ol>
<li>Unicast<br>one to one communication</li>
<li>Multicast<br>만약 UDP방식을 채택하게 되면 만약 하나의 패킷이 다른 유저에게 전달되지 않았을 경우<br>재 요청을 하면 다른 모든 사용자에게 요청을 날리게 된다.</li>
</ol>
<p>QOS(Quality Of Service)<br>사용자의 품질이 좋지 않으면 환불하는 등의 정책을 편다.<br>link layer protocol<br>to resolve</p>
<p>wired network - ethernet (CSMA(Multiple Access)/CD(Collision Detection) )<br>다 연결되어 잇기 때문에 colision을 다 detect할 수 있다.<br>collistion detection</p>
<p>wireless network - wifi(CSMA/CA(Collision Avoidance))<br>hidden node problem이 발생한다.<br>연결되지 않은 부분이 있기 때문이. detect colision할 수 없다.<br>collision avoidance</p>
<p>Zigbee</p>
<p>bluetooth</p>
<p>Zigwave</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/01/14/안드로이드-시작하기/" itemprop="url">
                안드로이드 시작하기
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-01-14T05:40:31.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                23 minutes read (About 3515 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#개발-세팅-및-환경-설정">개발 세팅 및 환경 설정</a><ul>
<li><a href="#가상화-기기-설정">가상화 기기 설정</a></li>
<li><a href="#기본-환경-설정">기본 환경 설정</a></li>
</ul>
</li>
<li><a href="#android-프로젝트-세팅">Android 프로젝트 세팅</a><ul>
<li><a href="#ide란">IDE란?</a></li>
<li><a href="#xml이란">XML이란?</a></li>
</ul>
</li>
<li><a href="#advanced-layout">Advanced Layout</a><ul>
<li><a href="#drawable의-활용">Drawable의 활용</a></li>
<li><a href="#listview">ListView</a></li>
</ul>
</li>
<li><a href="#network">Network</a><ul>
<li><a href="#url이란-uniform-resource-locator">URL이란? Uniform Resource Locator</a></li>
<li><a href="#api">API</a><ul>
<li><a href="#parsing">Parsing</a></li>
<li><a href="#permission-in-android">Permission in Android</a></li>
<li><a href="#readfromstream">readFromStream()</a></li>
<li><a href="#inputstream">InputStream</a></li>
<li><a href="#mainthread">MainThread</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#레이아웃">레이아웃</a><ul>
<li><a href="#fragment">Fragment</a><ul>
<li><a href="#workflow">WorkFlow</a></li>
</ul>
</li>
<li><a href="#tablayout">TabLayout</a><ul>
<li><a href="#workflow-1">WorkFlow</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#라이브러리">라이브러리</a><ul>
<li><a href="#butterknife">ButterKnife</a><ul>
<li><a href="#개요">개요</a></li>
<li><a href="#workflow-2">WorkFlow</a></li>
</ul>
</li>
<li><a href="#recyclerview">RecyclerView</a><ul>
<li><a href="#workflow-3">WorkFlow</a></li>
</ul>
</li>
<li><a href="#retrofit">Retrofit</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="개발-세팅-및-환경-설정">개발 세팅 및 환경 설정</span></h1><h2><span id="가상화-기기-설정">가상화 기기 설정</span></h2><p>안드로이드 가상화 기기 설정을 위해 VT-X 켜기<br>컴퓨터의 BIOS세팅에 진입(레노버의 경우F1 혹은 Enter)에 진입하여<br>Intel 가상화 세팅을 Enable로 바꾼다.</p>
<h2><span id="기본-환경-설정">기본 환경 설정</span></h2><ol>
<li><p>자바 JDK(Java Development Kit)를 설치한다.<br>JDK는 앱을 만드는 일종의 작업장과 같은 역할을 한다.<br>JDK는 컴퓨터가 JAVA 프로그래밍 언어를 읽고 쓸수 있게 해 주는 소프트 웨어 이다.<br>결론적으로 JDK Standard Edition을 설치한다.</p>
</li>
<li><p>안드로이드 스튜디오를 설치한다.<br>안드로이드 스튜디오는 우리가 앱을 만드는 일종의 작업장과 같은 개념이다.</p>
</li>
<li><p>Android Setting의 plugin에서 lombok plugin 다운로드</p>
</li>
</ol>
<p>도메인 이름 설정</p>
<p>흔히 알고 있는 패키지 명은 .com 형식을 취하며 이것은 특정 도메인을 일컷는다.<br>패키지 명은 이를 단순히 뒤집은 꼴이며 제일 뒤에 Application name이 붙게 된다.<br>이는 어플리케이션을 배포 할때 각각 고유한 패키지를 가지게 한다.</p>
<p>만약 company domain 이 tangentx.com이고 어플리케이션 이름이 expirit이라면 패키지 명은<br>com.tangentx.expirit이 된다.</p>
<p>모바일 설정</p>
<p>핸드폰에게 내가 개발자라는 사실을 알리기 위해 개발자 모드를 적용한다.<br>핸드폰 제작사 별로 알맞은 드라이버를 설치한다.<br>핸드폰을 연결하여 에뮬레이팅 할 수 있다.<br>가상 장치를 이용하여 에뮬레이팅 할 수 있다.<br>컴퓨터의 프로그램 및 기능에 들어가서 vt-x를 활성화 한다.</p>
<p>한글 설정</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//plugins/android/lib/layoutlib/data/fonts/fonts.xml 에서</span><br><span class="line">&lt;family lang=&quot;&quot;ko&quot;&quot;&gt;</span><br><span class="line">&lt;font weight=&quot;&quot;400&quot;&quot; style=&quot;&quot;normal&quot;&quot; index=&quot;&quot;1&quot;&quot;&gt;NanumGothic.ttf&lt;/font&gt;</span><br><span class="line">&lt;/family&gt;</span><br></pre></td></tr></table></figure>
<p>를 추가해준다.</p>
<p>바로 수정이 되지 않는 경우가 있으므로 파일을 바탕화면에 저장하여 바꾼뒤 복사해주는 식으로 한다.</p>
<h1><span id="android-프로젝트-세팅">Android 프로젝트 세팅</span></h1><p>AndroidManifest 세팅<br>AndroidManifest에서 처음 어플리케이션을 시작한다.</p>
<h3><span id="ide란">IDE란?</span></h3><p>IDE란 Integrated Developing Envionment의 약자로써 코드를 작성하는 공간을 의미한다.<br>안드로이드 에서는 흔히 Android Studio를 일컷는다.</p>
<h3><span id="xml이란">XML이란?</span></h3><p>XML이란 Extensible Markup Language의 약자로써 기본적인 표현 언어이다.<br>이 언어의 문법을 XML Syntax라고 한다.</p>
<h1><span id="advanced-layout">Advanced Layout</span></h1><h2><span id="drawable의-활용">Drawable의 활용</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:shape=&quot;oval&quot;&gt;</span><br><span class="line">&lt;solid android:color=&quot;@color/magnitude1&quot; /&gt;</span><br><span class="line">&lt;size</span><br><span class="line">android:width=&quot;36dp&quot;</span><br><span class="line">android:height=&quot;36dp&quot; /&gt;</span><br><span class="line">&lt;corners android:radius=&quot;18dp&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>
<p>Drawable에 새로운 Shape을 정의<br>하고 이를 background로 사용</p>
<h2><span id="listview">ListView</span></h2><h1><span id="network">Network</span></h1><h2><span id="url이란-uniform-resource-locator">URL이란? Uniform Resource Locator</span></h2><p>http: 는 protocol, scheme을 의미한다.<br>example.com은 host/domain/authority<br>를 의미한다.<br>/animal/mammal/primate/tarsier는<br>resource path를 의미한다.<br>?diet=carnivore&amp;active=night은 query<br>부분이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2><span id="api">API</span></h2><p>Application Programming Interface<br>다른 소프트웨어에서 해당 어플리케이션이 편하게 사용되도록 하는 장치<br>모든 사람람들은 API를 사용하게 된다.<br>API의 url 에 특정한 request를 보내면 일정한 데이터 형식을 같추어 response를 보내준다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="parsing">Parsing</span></h3><p>긴 스트링을 컴퓨터가 이해하기 쉬운 다른 형태로 변형하는 과정 즉 JSON과 같은 형태로 변형<br>JSON = JavaScript Object Notation</p>
<h3><span id="permission-in-android">Permission in Android</span></h3><p>인턴넷에 접속하거나 혹은 메시지를 보내고 카메라를 작동 시키는 등 다양한 동작을 하기 위해서는<br>permission을 얻어야 한다.</p>
<h3><span id="readfromstream">readFromStream()</span></h3><p>클라이언트가 서버에 요청을 보내면 서버는 이진수 형태의 raw data를 보내주는데 이를 사람이 이해 할 수 있<br>는 형태의 데이터로 읽어들이기 위해서 readFromStream을 사용한다.</p>
<h3><span id="inputstream">InputStream</span></h3><p>input Stream은 이미지나 텍스트 등 다양한 resource들이 입력되는 입력 형태이다.<br>이 input Stream을 읽어들여 이미지, 텍스트 등 다양한 요소들을 적합한 형태로 받아온다.</p>
<h3><span id="mainthread">MainThread</span></h3><p>Android가 작업들을 처리할때는 처음부터 순차적으로 처리하게 되는데 이러한 주 작업목록을<br>MainThread 라고 한다. 이는 사용자가 쓰는 측면에서 UIThread 라고도 하는데 이 작업목록에 긴 시간동안의<br>작업이 포함되면 사용자가 다음 입력을 지시하여도 화면이 얼어있게 된다.<br>그래서 절대 UIThread를 막으면 안된다.<br>즉, UIThread에서는 사용자가 실제 사용하는 것들만 처리하고 그 동안 다른 근 작업들은 backgroundthread<br>에서 처리하도록 한다. - AsyncTask&lt;Params, Progress, Result&gt;</p>
<h1><span id="레이아웃">레이아웃</span></h1><h2><span id="fragment">Fragment</span></h2><h3><span id="workflow">WorkFlow</span></h3><ol>
<li><p>Activity에 Fragment 추가<br>activity_main에 fragment를 추가해 준다.</p>
</li>
<li><p>Fragment를 위한 Layout Resource XML 작성</p>
</li>
<li><p>각 Fragment Class 구현</p>
</li>
<li><p>Activity의 onCreate()에서 Fragment초기화.</p>
</li>
<li><p>FragementTransaction을 사용한 Fragment 제어<br>FracmentTansaction의 replace()함수를 통해 제어.</p>
</li>
</ol>
<h2><span id="tablayout">TabLayout</span></h2><h3><span id="workflow">WorkFlow</span></h3><ol>
<li><p>gradle에 dependencies를 추가해 준다.</p>
</li>
<li><p>style.xml에서 액션바를 제거한 다음, 탭으로 사용할 Fragment를 생성한다.</p>
</li>
<li><p>프래그먼트를 구현할 xml를 생성한다.</p>
</li>
<li><p>MainActivity에서 Toolbar, TabLayout, ViewPager를 생성하고 설정한다.<br><a href="http://swalloow.tistory.com/80" target="_blank" rel="noopener">출처 바로가기</a></p>
</li>
</ol>
<h1><span id="라이브러리">라이브러리</span></h1><h2><span id="butterknife">ButterKnife</span></h2><h3><span id="개요">개요</span></h3><p>일반적으로 레이아웃을 생성하고 난뒤, 제일 먼저 View를 선언하고 할당하는 작업이다.</p>
<h3><span id="workflow">WorkFlow</span></h3><ol>
<li><p>Gradle에 추가<br>그레이들 -&gt; compile ‘com.jakewharton:butterknife:7.0.1’</p>
</li>
<li><p>Activity에서 버터나이프로 바인드 해주기</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//액티비티의 경우</span><br><span class="line">super.setContentView(layoutResID);</span><br><span class="line">ButterKnife.bind(this);</span><br><span class="line"></span><br><span class="line">//Fragment의 경우</span><br><span class="line">View  view = LayoutInflater.from(getActivity()).inflate(resId, null);</span><br><span class="line">ButterKnife.inject(this, view);</span><br></pre></td></tr></table></figure>
</li>
<li><p>레이아웃에서 View 객체 선언</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bind(R.id.view_action_sms)</span><br><span class="line">View view_action_sms;</span><br><span class="line">@Bind(R.id.view_action_comment)</span><br><span class="line">View view_action_comment;</span><br><span class="line">@Bind(R.id.view_input_comment)</span><br><span class="line">View view_input_comment;</span><br></pre></td></tr></table></figure>
<p>기타 기능<br>onClickListener달기<br>ClickListener가 필요한경우 setOnClickListener를 선언해줄필요 없이 바로 실행될 함수를 만들고 <code>@OnClick</code> 을 사용하면 됩니다.<br>만약 View가 button처럼 클릭 이벤트만을 받고싶은 경우라면 2번에서 처럼 View객체를 선언할 필요조차 없이 그냥 바로 <code>@OnClick</code>함수만 사용해도 됩니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@OnClick(R.id.view_action_call)</span><br><span class="line">void onCallClick() &#123;</span><br><span class="line">.... </span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 여러 뷰에 대해서 하나의 함수만을 실행시키고 싶다면 아래와 같이 선언해주면 됩니다. --&gt;</span><br><span class="line"></span><br><span class="line">@OnClick(&#123;R.id.pager, R.id.indicator, R.id.cell_picture, R.id.cell_product, R.id.cell_price, R.id.cell_description,R.id.cell_location&#125;)</span><br><span class="line">public void onSomeThingClick(View view) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="recyclerview">RecyclerView</span></h2><h3><span id="workflow">WorkFlow</span></h3><ol>
<li><p>레이아웃에 RecyclerView를 추가한다.</p>
</li>
<li><p>액티비티에 레이아웃을 연결한다.</p>
</li>
<li><p>RecyclerView.Adapter 클래스를 생성한다. // 굳이 만들지 않고 다음단계로 진행해도 된다.<br>RecyclerView.Adapter를 extends하여 클래스를 생성하고, 내부에서 ViewHoler를 생성한다.</p>
</li>
</ol>
<p>onCreateViewHolder(ViewGroup parent, int viewType)<br>뷰와 뷰홀더를 만들고 레이아웃의 사이즈 마진 패딩 등을 조절한다.<br>뷰홀더에 뷰를 넣어 뷰홀더 인스턴스를 만들어 리턴한다.</p>
<p>onBindViewHolder(ViewHolder holder, int position)<br>데이터베이스에서 데이터들을 받아와 뷰홀더 내의 요소들에 입혀준다.</p>
<ol start="4">
<li>액티비티에 LayoutManager와 Adapter를 생성한다.<br>어댑터는 데이터 집합의 항목에 액세스할 수 있게 해주며, 항목 뷰를 생성하고, 원래의 항목이 더 이상 보이지 않을 경우 일부 뷰의 콘텐츠를 새 데이터 항목으로 교체합니다</li>
</ol>
<p></p><p class="strongfont" href="https://developer.android.com/training/material/lists-cards.html">Google Developer 참조</p>
<h2><span id="retrofit">Retrofit</span></h2><p>개요<br>Rest API통신을 위한 Android/Java 라이프러리<br>WorkFlow</p>
<ol>
<li>build.gradle에 의존성 설정</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos; // Retrofit</span><br><span class="line">compile &apos;com.squareup.retrofit2:converter-gson:2.0.0-beta3&apos; // Gson 변환을 위한 converter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>퍼미션 추가<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">인터넷 통신을 하기 위한 퍼미션을 추가해 준다.</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br><span class="line">&lt;!-- Resource URI</span><br><span class="line"></span><br><span class="line">http://apis.skplanetx.com/weather/current/hourly?version=&#123;version&#125;&amp;lat=&#123;lat&#125;&amp;lon=&#123;lon&#125;&amp;city=&#123;city&#125;&amp;county=&#123;county&#125;&amp;village=&#123;village&#125;</span><br><span class="line"></span><br><span class="line">Protocol - REST</span><br><span class="line"></span><br><span class="line">HTTP Method - GET --&gt;</span><br><span class="line"></span><br><span class="line">public interface WeatherApiInterface &#123;</span><br><span class="line">@Headers(&#123;&quot;Accept: application/json&quot;&#125;)</span><br><span class="line">@GET(&quot;weather/current/hourly&quot;)</span><br><span class="line">Call&lt;WeatherRepo&gt; get_Weather_retrofit(@Query(&quot;version&quot;) int version, @Query(&quot;lat&quot;) String lat, @Query(&quot;lon&quot;) String lon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- @Headers 에는 필요한 헤더 부분을 (&#123; ~~ . ~~ &#125;) 형식으로 넣어줄 수 있습니다.</span><br><span class="line"></span><br><span class="line">@GET 부분에는 현재날씨(시간별)에 해당하는 URL 을 넣어줍니다.</span><br><span class="line"></span><br><span class="line">다음으로 Call입니다.</span><br><span class="line"></span><br><span class="line">Call &lt;&apos;주고받을 객체&apos;&gt; &apos;함수명&apos; (@Query (&apos;변수 이름&apos;) &apos;자료형&apos; &apos;변수 이름&apos;)  형태로 나타나 있는데요</span><br><span class="line"></span><br><span class="line">@Query 를 통해 위치가 바뀌어도 동적으로 값을 받아올 수 있습니다! --&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>GSON<br>JSON의 파싱을 쉽게 하기 위해 구글에서 만든 라이브러리이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class WeatherRepo &#123;</span><br><span class="line">@SerializedName(&quot;result&quot;)</span><br><span class="line">Result result;</span><br><span class="line">@SerializedName(&quot;weather&quot;)</span><br><span class="line">weather weather;</span><br><span class="line"></span><br><span class="line">public class Result &#123;</span><br><span class="line">@SerializedName(&quot;message&quot;) String message;</span><br><span class="line">@SerializedName(&quot;code&quot;) String code;</span><br><span class="line"></span><br><span class="line">public String getMessage() &#123;return message;&#125;</span><br><span class="line">public String getCode() &#123;return code;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class weather &#123;</span><br><span class="line"></span><br><span class="line">public List&lt;hourly&gt; hourly = new ArrayList&lt;&gt;();</span><br><span class="line">public List&lt;hourly&gt; getHourly() &#123;return hourly;&#125;</span><br><span class="line"></span><br><span class="line">public class hourly &#123;</span><br><span class="line">@SerializedName(&quot;sky&quot;) Sky sky;</span><br><span class="line">@SerializedName(&quot;precipitation&quot;) precipitation precipitation;</span><br><span class="line">@SerializedName(&quot;temperature&quot;) temperature temperature;</span><br><span class="line">@SerializedName(&quot;wind&quot;) wind wind;</span><br><span class="line"></span><br><span class="line">public class Sky&#123;</span><br><span class="line">@SerializedName(&quot;name&quot;) String name;</span><br><span class="line">@SerializedName(&quot;code&quot;) String code;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;return name;&#125;</span><br><span class="line">public String getCode() &#123;return code;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class precipitation&#123; // 강수 정보</span><br><span class="line">@SerializedName(&quot;sinceOntime&quot;) String sinceOntime; // 강우</span><br><span class="line">@SerializedName(&quot;type&quot;) String type; //0 :없음 1:비 2: 비/눈 3: 눈</span><br><span class="line"></span><br><span class="line">public String getSinceOntime() &#123;return sinceOntime;&#125;</span><br><span class="line">public String getType() &#123;return type;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class temperature&#123;</span><br><span class="line">@SerializedName(&quot;tc&quot;) String tc; // 현재 기온</span><br><span class="line"></span><br><span class="line">public String getTc() &#123;return tc;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class wind&#123; // 바람</span><br><span class="line">@SerializedName(&quot;wdir&quot;) String wdir;</span><br><span class="line">@SerializedName(&quot;wspd&quot;) String wspd;</span><br><span class="line"></span><br><span class="line">public String getWdir() &#123;return wdir;&#125;</span><br><span class="line">public String getWspd() &#123;return wspd;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public Sky getSky() &#123;return sky;&#125;</span><br><span class="line">public hourly.precipitation getPrecipitation() &#123;return precipitation;&#125;</span><br><span class="line">public hourly.temperature getTemperature() &#123;return temperature;&#125;</span><br><span class="line">public hourly.wind getWind() &#123;return wind;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public Result getResult() &#123;return result;&#125;</span><br><span class="line">public weather getWeather() &#123;return weather;&#125;</span><br><span class="line"></span><br><span class="line">public interface WeatherApiInterface &#123;</span><br><span class="line">@Headers(&#123;&quot;Accept: application/json&quot;&#125;)</span><br><span class="line">@GET(&quot;weather/current/hourly&quot;)</span><br><span class="line">Call&lt;WeatherRepo&gt; get_Weather_retrofit(@Query(&quot;version&quot;) int version, @Query(&quot;lat&quot;) String lat, @Query(&quot;lon&quot;) String lon);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- GSON이 쉽고 편하고 아름답게 파싱해 주는 것을 볼 수 있습니다!</span><br><span class="line"></span><br><span class="line">여기서 @SerializedName 어노테이션이 포인트인데요</span><br><span class="line"></span><br><span class="line">이 어노테이션을 이용하면 wspd(풍속) 을 </span><br><span class="line"></span><br><span class="line">@SerializedName(&quot;wspd&quot;) String windSpeed; 처럼 변수 이름을 바꿔 넣을 수도 있습니다.</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<p>장점 / 용도<br>다음과 같은 귀찮은 작업들을 매우 편리하게 바꾸어 준다.</p>
<ol>
<li>네트워크 통신 연결/해제</li>
<li>가져온 데이터 파싱</li>
<li>Json통신의 경우, Json데이터를 Class로 변환</li>
<li>각종 에러 처리</li>
</ol>
<p><a href="http://gun0912.tistory.com/30" target="_blank" rel="noopener">출처 - 박상권의 삽질 블로그</a><br><a href="&quot;http://square.github.io/retrofit/">출처 - Retrofit 공식 홈페이지</a></p>
<p>EventBus<br>Workflow</p>
<ol>
<li>Otto를 관리해주는 Singleton 개념의 BusProvider 클래스를 생성</li>
<li>Event를 감지하고자 하는 ACtivity 혹은 Fragment에서 register를 수행한다.</li>
<li>Event가 발생하는 위치에서 Event가 발생했음을 알린다.</li>
<li>이벤트가 발생했을때 수행할 함수를 FinishLoad 메소드에 만들어 준다.</li>
<li>해당 이벤트에서 원하는 변수, 리스트 등을 받아서 작업을 처리한다.<br><p class="strongfont" href="http://gun0912.tistory.com/4">출처 바로가기</p></li>
</ol>
<p>Dagger<br>개요<br>Android/Java에서 Dependency Injection을 위한 편리한 도구이다.<br>주요 Annotation<br> @Module, @Provides, @Component, @Inject<br>@Inject: 이 어노테이션은 의존성을 요청합니다. 의존성 주입을 통해서 해당 어노테이션이 달린 클래스나 필드에게 값을 주입해 달라고 Dagger 에게 요청합니다. Dagger 는 어노테이션이 달린 클래스의 인스턴스를 생성하고 그것들의 의존성을 만족시킵니다.</p>
<p>@Module: 모듈들은 의존성을 제공하는 메서드들을 가진 클래스입니다. 의존성을 제공하는 클래스를 정의하고 @Module 어노테이션을 답니다. 그러면 Dagger 는 클래스 인스턴스를 만들 때 의존성을 만족시키기 위한 정보를 찾을 수 있습니다.</p>
<p>@Provide: 모듈 안에서 해당 어노테이션이 달린 메서드를 정의합니다. 해당 어노테이션이 달린 메서드가 Dagger 가 어떻게 의존성에 맞게 객체를 만들고 제공하는지 알려줍니다.</p>
<p>@Component: 컴포넌트는 @Inject 와 @Module 사이 다리이며 의존성을 주입하는 역할을 합니다. 컴포넌트는 미리 정의한 모든 타입의 인스턴스를 줍니다. @Component 어노테이션은 인터페이스에다만 달아야합니다 그리고 컴포넌트를 구성하는 모든 @Module 이 달린 클래스 목록을 적어야합니다. 컴포넌트에서 사용하는 모듈들중 하나라도 없다면 컴파일 타임에 에러를 만듭니다. 모든 컴포넌트들은 컴포넌트에 포함된 모듈들을 통해 의존성의 범위를 알 수 있습니다.</p>
<p>@Scope: 스코프는 매우 유용하고 Dagger 2 에서 사용자 정의 어노테이션을 통해 범위를 나누는 명확한 방법입니다. 나중에 예제에서 보겠지만 이것은 매우 강력한 기능입니다. 앞에서 언급한바와 같이 하기 때문에, 모든 객체는 자기 자신의 인스턴스를 관리하는 방법에 대해 알필요가 없습니다. 예를들어 사용자가 지정한 @PerActivity 어노테이션이 달려있는 클래스는 액티비티가 살아있는 동안 존재합니다. 다시말하자면 객체 범위의 단위를 정의할 수 있습니다.</p>
<p>@Qualifier: 클래스의 유형이 종속성을 식별하기 불충분할 때 사용하는 어노테이션입니다. 예를 들어 안드로이드의 경우, 많은 경우 컨텍스트의 다양한 타입이 필요합니다, 그래서 “@ForApplication”, “@ForActivity” 같은 식별자 어노테이션을 정의합니다. 컨텍스트를 주입할 때 이 식별자 어노테이션을 이용해서 Dagger 가 어떤 타입을 제공할지 정해줍니다.</p>
<p>WorkFlow</p>
<ol>
<li>buil.gradle에 dependencies를 추가하여 준다.<br><p class="strongfont" href="https://medium.com/@jason_kim/tasting-dagger-2-on-android-%EB%B2%88%EC%97%AD-632e727a7998">출처 바로가기</p></li>
</ol>
<p>Plugins<br>Lombok<br>주요 요소</p>
<p></p><p clas="mainfont"></p>
<ol>
<li><p>@Getter / @Setter<br>기본적으로 멤버필드들에 대한 getter/setter메소드들을 만들어 줍니다.</p>
</li>
<li><p>@AllArgsConstructor / @NoArgsConstructor<br>멤버필드들이 모두 파라미터로 지정된 생성자와 빈 생성자를 만들어 줍니다.</p>
</li>
<li><p>@Builder<br>모델을 빌더 패턴으로 만들어 줍니다.</p>
</li>
<li><p>@ToString<br>toString의 override된 메소드를 만들어 줍니다.</p>
</li>
</ol>
<p>WorkFlow</p>
<p></p><p clas="mainfont">1. Lombok Plugin 설치</p>
<ol start="2">
<li>gradle에 Lombokk 적용하기.</li>
<li>gradle에 annotaion을 provide 해주기</li>
</ol>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/01/14/퍼스트-클래스-승객은-펜을-빌리지-않는다/" itemprop="url">
                퍼스트 클래스 승객은 펜을 빌리지 않는다
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-01-14T05:39:43.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                2 minutes read (About 278 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>실천적 행동에 매우 도움이 되는 책이다.</p>
<ol>
<li><p>역사책을 읽어라 / 전기와 역사소설은 진정한 멘토를 찾아준다.<br>신문읽기는 모든 독서에 앞서 필수이다.</p>
</li>
<li><p>펜과 메모는 언제 어디라도 함께한다.</p>
</li>
<li><p>아침은 생산적인 일에 쓰라</p>
</li>
<li><p>경계를 풀지않고 대화에 거리를 두는 스타일이 아닌 지나가는 사람에게도 스스럼 없이 말을 건네는 붙임성을 가지라.<br>말을 할 때에는 중저음의 차분한 목소리로 침착하게 말하라.<br>“따라하기 대화법” 항상 질문조의 어투를 유지하라 / 칭찬을 하라<br>완충어구의 사용 “죄송하지만” “미안하지만” “고마워요”</p>
</li>
<li><p>인사의 힘! / 퍼스트 클래스는 승무원에게도 먼저 적극적으로 인사를 건넨다.</p>
</li>
<li><p>성공한 사람들은 자세가 다르다.<br>당당하게 정면을 그리고 바로 앞이 아니라 먼 곳까지 내다보는 시선</p>
</li>
</ol>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/01/14/행복의-철학/" itemprop="url">
                행복의 철학
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-01-14T05:31:06.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                an hour read (About 8202 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#사랑과-행복">사랑과 행복</a><ul>
<li><a href="#사랑의-종류">사랑의 종류</a><ul>
<li><a href="#agape">Agape</a></li>
<li><a href="#philia-친애-우정">philia (친애, 우정)</a></li>
<li><a href="#eros">Eros</a></li>
</ul>
</li>
<li><a href="#에로스를-통한-사랑의-정의">에로스를 통한 사랑의 정의</a><ul>
<li><a href="#에로스의-정의">에로스의 정의</a></li>
<li><a href="#두-가지-종류의-에로스-천상의-에로스-vs-범속적-에로스">두 가지 종류의 에로스 : 천상의 에로스 VS 범속적 에로스</a></li>
<li><a href="#여성-남성의-신화적-기원-인간의-성의-탄생-신화aristophanes">여성, 남성의 신화적 기원 - 인간의 성의 탄생 신화(Aristophanes)</a></li>
<li><a href="#에로스는-아름다운-존재인가">에로스는 아름다운 존재인가?</a></li>
</ul>
</li>
<li><a href="#사랑의-기능과-원인-ergon">사랑의 기능과 원인 (ergon)</a></li>
<li><a href="#사랑의-본성">사랑의 본성</a></li>
<li><a href="#사랑의-확장된-의미-에로스의-사다리">사랑의 확장된 의미 - 에로스의 사다리</a><ul>
<li><a href="#첫째-에로스는-젊을-때-아름다운-몸들을-사랑하는-것으로-시작한다">첫째, 에로스는 젊을 때 아름다운 몸들을 사랑하는 것으로 시작한다</a></li>
<li><a href="#둘째-에로스의-두번째-단계는-몸에-있는-아름다움보다-영혼에-있는-아름다운이-더-귀중하다고-여기는-것이다">둘째, 에로스의 두번째 단계는 몸에 있는 아름다움보다 영혼에 있는 아름다운이 더 귀중하다고 여기는 것이다.\</a></li>
<li><a href="#셋째-그를-앎으로-이끌어-앎의-아름다움을-보게-하면-그는-아름다움-일반을-보게-될-것">셋째, 그를 앎으로 이끌어 ‘앎의 아름다움’을 보게 하면 그는 ‘아름다움 일반’을 보게 될 것</a></li>
<li><a href="#넷째-이러한-에로스의-사다리를-차근차근-밟아-올라가다-보면-사랑하는-자는-최종적으로-놀라울-정도로-본성상-아름다운-것을-직관하게-된다">넷째, 이러한 에로스의 사다리를 차근차근 밟아 올라가다 보면 사랑하는 자는 최종적으로 “놀라울 정도로 본성상 아름다운 것”을 직관하게 된다</a></li>
</ul>
</li>
<li><a href="#사랑과-행복-1">사랑과 행복</a></li>
</ul>
</li>
<li><a href="#우정과-행복">우정과 행복</a><ul>
<li><a href="#친애란">친애란?</a></li>
<li><a href="#친애의-종류">친애의 종류</a><ul>
<li><a href="#부수적인-것에-따르는-친애">부수적인 것에 따르는 친애</a></li>
<li><a href="#즐거움을-추구하는-친애">즐거움을 추구하는 친애</a></li>
<li><a href="#덕탁월성에-따르는-친애">덕(탁월성)에 따르는 친애</a></li>
</ul>
</li>
<li><a href="#친애의-특징">친애의 특징</a></li>
<li><a href="#행복과-친애">행복과 친애</a><ul>
<li><a href="#에피쿠로스의-우정론">에피쿠로스의 우정론</a></li>
<li><a href="#우정에-대한-우리의-태도">우정에 대한 우리의 태도</a></li>
</ul>
</li>
<li><a href="#친애의-조건">친애의 조건</a></li>
</ul>
</li>
<li><a href="#신과-행복">신과 행복</a><ul>
<li><a href="#종교란">종교란?</a></li>
<li><a href="#종교의-공통적인-내용">종교의 공통적인 내용</a><ul>
<li><a href="#영원의-추구">영원의 추구</a></li>
<li><a href="#지복-사상">지복 사상</a></li>
</ul>
</li>
<li><a href="#아우구스티누스의-행복론">아우구스티누스의 행복론</a></li>
<li><a href="#신과-행복-1">신과 행복</a></li>
<li><a href="#종교의-의의">종교의 의의</a></li>
</ul>
</li>
<li><a href="#정의">정의</a><ul>
<li><a href="#정의란">정의란?</a></li>
<li><a href="#플라톤-국가의-정의">플라톤 [국가]의 정의</a></li>
<li><a href="#아리스토텔레스의-니코마코스윤리학의-정의-이론">아리스토텔레스의 니코마코스윤리학의 정의 이론</a></li>
<li><a href="#에피쿠로스의-정의-개념">에피쿠로스의 정의 개념</a></li>
<li><a href="#역사적으로-규정되고-있는-정의의-개념">역사적으로 규정되고 있는 정의의 개념</a></li>
<li><a href="#공통된-정의-개념">공통된 정의 개념</a></li>
<li><a href="#정의와-행복">정의와 행복</a><ul>
<li><a href="#j-rawls">J. Rawls</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#도덕과-행복">도덕과 행복</a><ul>
<li><a href="#도덕이란">도덕이란</a></li>
<li><a href="#도덕에-관한-학문적-탐구로서의-윤리학">도덕에 관한 학문적 탐구로서의 윤리학</a><ul>
<li><a href="#윤리학의-두-가지-원리">윤리학의 두 가지 원리</a></li>
<li><a href="#공리주의적-입장">공리주의적 입장</a></li>
<li><a href="#의무론적-입장">의무론적 입장</a></li>
</ul>
</li>
<li><a href="#도덕과-행복-1">도덕과 행복</a></li>
</ul>
</li>
<li><a href="#노동과-행복">노동과 행복</a><ul>
<li><a href="#노동이란">노동이란?</a></li>
<li><a href="#일-노동의-어원적-의미">일, 노동의 어원적 의미</a></li>
<li><a href="#노동의-역사">노동의 역사</a><ul>
<li><a href="#고대-그리스의-노동-개념">고대 그리스의 노동 개념</a></li>
<li><a href="#기독교의-노동-개념">기독교의 ‘노동’ 개념</a></li>
<li><a href="#르네상스의-노동-개념">르네상스의 노동 개념</a></li>
<li><a href="#근대의-노동-개념">근대의 노동 개념</a></li>
<li><a href="#현대의-노동">현대의 ‘노동’</a></li>
</ul>
</li>
<li><a href="#노동과-행복-1">노동과 행복</a><ul>
<li><a href="#소외를-지양하는-생활">소외를 지양하는 생활</a></li>
<li><a href="#노동에-관한-비판적-접근">노동에 관한 비판적 접근</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#지식과-행복">지식과 행복</a><ul>
<li><a href="#지식이란">지식이란?</a><ul>
<li><a href="#플라톤이-말하는-지식의-종류">플라톤이 말하는 지식의 종류</a></li>
<li><a href="#참된-지식이란진리">참된 지식이란?=진리?</a></li>
<li><a href="#지식의-기원">지식의 기원</a></li>
<li><a href="#fbacon의-우상이론">F.Bacon의 우상이론</a></li>
</ul>
</li>
<li><a href="#지식과-지혜">지식과 지혜</a></li>
<li><a href="#지식과-행복-1">지식과 행복</a></li>
</ul>
</li>
<li><a href="#자연과-행복">자연과 행복</a><ul>
<li><a href="#자연이란">자연이란?</a><ul>
<li><a href="#스토아학파의-자연-개념">스토아학파의 자연 개념</a></li>
</ul>
</li>
<li><a href="#인간과-자연세계">인간과 자연(세계)</a></li>
<li><a href="#환경">환경</a><ul>
<li><a href="#환경윤리이론의-주요-방향">환경윤리이론의 주요 방향</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#행복의-방법">행복의 방법</a><ul>
<li><a href="#자아-성찰">자아 성찰</a><ul>
<li><a href="#독서와-사색을-통한-정적인-자기-탐구">독서와 사색을 통한 정적인 자기 탐구</a></li>
<li><a href="#거울-만들기">거울 만들기</a></li>
<li><a href="#자아-능력-개발">자아 능력 개발</a></li>
<li><a href="#실천적-습관과-태도">실천적 습관과 태도</a></li>
<li><a href="#개인적인-방법">개인적인 방법</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="사랑과-행복">사랑과 행복</span></h1><h2><span id="사랑의-종류">사랑의 종류</span></h2><h3><span id="agape">Agape</span></h3><p>신의 사랑 또는 인간의 신에 대한 사랑<br>부모의 사랑도 이 범주에 들어간다.</p>
<h3><span id="philia-친애-우정">philia (친애, 우정)</span></h3><p>우정, 아는 사람간의 정</p>
<h3><span id="eros">Eros</span></h3><p>남녀간의 사랑, 열정적인 사랑<br>사랑은 눈으로 보지 않고 마음을 봅니다.<br>그래서 큐피트는 장님으로 그려졌나 봅니다.</p>
<h2><span id="에로스를-통한-사랑의-정의">에로스를 통한 사랑의 정의</span></h2><p>플라톤의 향연(Symposion / 같이 술을 마심)<br>아가톤의 비극경연대회 우승을 기념하여 모인 소크라테스와 그의 추종자들이 에로스에 대해 나누는 대화</p>
<h3><span id="에로스의-정의">에로스의 정의</span></h3><p>사람들은 아름다운 것을 사랑한다.<br>아름다운 것을 사랑하는 자는 무엇을(무엇 때문에) 사랑하는가(욕망하는가)?</p>
<p>자기 것이 되기를 사랑한다.(욕망한다)</p>
<p>아름다운 것이 자기 것이 될때 그에게 무엇이 있게 되는가?<br>좋은 것이 자기 것이 될 때 그에게 무엇이 있게 되는가?<br>사람은 누구나 좋은 것들이 자신에게 있기를 바란다.<br>사람은 누구나 ‘공통적으로’ 사랑이 자신에게 있기를 바란다.</p>
<h3><span id="두-가지-종류의-에로스-천상의-에로스-vs-범속적-에로스">두 가지 종류의 에로스 : 천상의 에로스 VS 범속적 에로스</span></h3><p><strong>천상의 에로스(아프로디테)</strong><br>천상의 에로스는 상대의 영혼을 사랑하는 에로스이며 상대가 아름답고 훌륭하고 지혜롭게 되기를 바라고 실천하는 에로스이다.<br>천상의 아프로디테는 더 나이가 많고 어머니가 없다 - 우라노스의 딸이다.</p>
<p><strong>범속적 에로스(아프로디테)</strong><br>범속적 아프로디테는 더 젊고 제우스와 디오네의 딸이다.<br>범속적 에로스는 육체를 탐하는 에로스이며 상대를 아름답게(kalos) 하는 일에는 관심이 없다.</p>
<blockquote>
<p>천상의 에로스만이 칭송될 만하다.</p>
</blockquote>
<h3><span id="여성-남성의-신화적-기원-인간의-성의-탄생-신화aristophanes">여성, 남성의 신화적 기원 - 인간의 성의 탄생 신화(Aristophanes)</span></h3><p>본래 인간의 성은 남성, 여성, 남-여성(남녀추니)으로 세가지 였는데, 여기서 남녀추니의 힘이 세지자 신들이 이를 질투하여 둘을 갈라놓았다.<br>즉, 사람은 오만으로 인해 떨어지게 되었고, 겸손함을 통해 원래의 삶을 유지할 수 있다.<br>이처럼 반쪽으로 나뉜 각 짝들이 자신의 다른 짝을 그리워하고 욕구하는 것이 에로스(사랑)이기에 자신의 짝을 만나면 친애와 친근함 사랑에 압도되어 서로<br>떨어져 있으려 하지 않는다. 이것은 성적인 함께함 이상이며 서로가 하나가 되려는 영혼의 열망이다.<br>이러한 온전한 하나됨에 대한 욕망과 추구가 곧 에로스이며, 사랑은 헤어진 짝과의 이별의 고통을 치유하는 활동이다.</p>
<blockquote>
<p>에로스는 원래 함께였던 인간이 오만하여 떨어지게 되었기 때문에 항상 자신의 본래모습으로 돌아가려고 하는 성질이다.<br>즉, 사랑의 고통은 서로가 떨어져 있음에서 오고, 에로스는 인간이 본래의 자신의 모습으로 돌아가다록 하여 행복하게 해 주는 존재이다.</p>
</blockquote>
<h3><span id="에로스는-아름다운-존재인가">에로스는 아름다운 존재인가?</span></h3><p>에로스는 ‘어떤 것’에 대한 에로스이다.<br>에로스는 아름다운 것을 사랑(욕망)하는 것이며, 그 대상은 아름다운 것이 된다.<br>무언가를 욕망한다는 것은 자신에게 결여된 것을 욕망한다는 뜻이며 즉, 에로스 자체는 자신이 가지지 못한 아름다움을 추구하는 행위이기 때문에 그 자체로 아름답지 못하다.<br>에로스는 사랑하는 자 자체를 의미한다.</p>
<p>따라서 에로스는 아름다움을 결여하고 있다.</p>
<h2><span id="사랑의-기능과-원인-ergon">사랑의 기능과 원인 (ergon)</span></h2><p>사랑의 근본적인 원인은 아름다운 것 안에서 출산하는 것이고, 이는 좋은 것과 더불어 불사를 욕망하는 것이다.<br>이렇게 출산을 욕망할 때면, 자신을 목숨을 불사하고 어떤 어려움이나 고초도 이겨내고 출산을 하고자 한다.<br>즉, 사랑은 출산을 통한 불사적 존재에 대한 갈구 때문에 발생하며 이를 통해 동물이건 사람이건 평생에 걸쳐 항상 새롭게 생겨나고 있다.<br>이것은 몸뿐만이 아니라 영혼에서도 그러하다. 성격, 성품, 의견, 욕망, 쾌락, 고통 , 두려움 등 모든 것이 새롭게 생겨나고 소멸한다.</p>
<blockquote>
<p>사랑은 근본적으로 출산을 통해 불사를 추구하는 기능을 수행하며, 그것이 사랑 자체의 발생 원인이다.<br>즉, 에로스는 불사를 위해 계속해서 사랑하는 것이고 때문에 사랑 자체가 ‘실현’되지는 않는 유비적 의미를 지닌다.</p>
</blockquote>
<h2><span id="사랑의-본성">사랑의 본성</span></h2><ol>
<li>사랑 받는 자는 어떤 추한 일에 연루되었다가 들키게 되었을 때 자신을 사랑하는 사람에 의해 발각되는 경우 더욱 수치심을 느낀다.</li>
<li>자신의 목숨도 기꺼이 바칠 정도로 상대를 사랑하는 사람은 신조차도 감동시킨다.</li>
</ol>
<p>알케스티스와 아킬레우스의 경우.</p>
<h2><span id="사랑의-확장된-의미-에로스의-사다리">사랑의 확장된 의미 - 에로스의 사다리</span></h2><h3><span id="첫째-에로스는-젊을-때-아름다운-몸들을-사랑하는-것으로-시작한다">첫째, 에로스는 젊을 때 아름다운 몸들을 사랑하는 것으로 시작한다</span></h3><p>한 몸을 사랑하고 거기에 아름다운 이야기를 낳음<br>어느 한 몸에 속한 아름다움이 다른 한 몸에 속한 아름다움과 형제지간임을 깨달아야 함<br>하나의 몸을 향한 열정을 느슨하게 만듬</p>
<h3><span id="둘째-에로스의-두번째-단계는-몸에-있는-아름다움보다-영혼에-있는-아름다운이-더-귀중하다고-여기는-것이다">둘째, 에로스의 두번째 단계는 몸에 있는 아름다움보다 영혼에 있는 아름다운이 더 귀중하다고 여기는 것이다.\</span></h3><p>사람이 행실과 법을 아름다움을 보면, 그는 몸과 관련된 아름다움이 사소한 것이라고 여기게 될 것이다.</p>
<h3><span id="셋째-그를-앎으로-이끌어-앎의-아름다움을-보게-하면-그는-아름다움-일반을-보게-될-것">셋째, 그를 앎으로 이끌어 ‘앎의 아름다움’을 보게 하면 그는 ‘아름다움 일반’을 보게 될 것</span></h3><p>그것을 관조하고 지혜를 사랑하면서 많은 아름답고 웅장한 이야기들과 사유들을 산출하게 될 것<br>아름다움에 관한 앎에의 직관</p>
<h3><span id="넷째-이러한-에로스의-사다리를-차근차근-밟아-올라가다-보면-사랑하는-자는-최종적으로-놀라울-정도로-본성상-아름다운-것을-직관하게-된다">넷째, 이러한 에로스의 사다리를 차근차근 밟아 올라가다 보면 사랑하는 자는 최종적으로 “놀라울 정도로 본성상 아름다운 것”을 직관하게 된다</span></h3><p>-&gt; 아름다움 자체의 순수한 형상<br>아름다움 자체의 순수한 형상</p>
<ol>
<li>생성하거나 소멸하지 않는 영원한 것</li>
<li>관계적인 것이나 상관적인 것이 아닌 그 자체로 아름다운 것</li>
<li>시공간을 초월하여 아름다운 것</li>
<li>증가하거나 감소하지 않는 불변의 것</li>
</ol>
<blockquote>
<p>에로스의 사다리는 하나의 몸을 사랑하는 것에서 시작하여, 여러 몸들을 사랑하게 되고, 이를 넘어서는 몸보다 안에있는 영혼을 사랑하게 된다.<br>그 사람과의 많은 아름다운 경험과 이야기들을 통해 아름다운 것에 대해 알고 보편적인 아름다움에 관해 알게 된다.<br>아름다움에 대한 보편적인 아름다움을 알게 되면 최종적으로는 아름다움 자체의 순수한 형상을 보게 된다.<br>이러한 아름다움이란, 생성, 소멸하지 않고, 관계적이고 상관적이지 않으며 시공관을 초월하고 불변하는 아름다움 그 자체이다.<br>이는 아름다움의 이데아 라고 일컬어 진다.</p>
</blockquote>
<h2><span id="사랑과-행복">사랑과 행복</span></h2><p>행복이란?</p>
<ol>
<li>아리스토텔레스 - <mark><b>Eudaimonia</b></mark><br>eu(좋은) daimonia(신과 같은 사람) - (좋은 신과 같은 특성)<br>비교 : eutychia (행운)은 내가 조절할 수 없고 지속적이지 못하기 때문에 절대 행복이 될 수 없다.</li>
<li>에피쿠로스 학파 - Hedone의 지속적인 소유</li>
<li>[향연] 좋은 것을 갖는 것</li>
</ol>
<h1><span id="우정과-행복">우정과 행복</span></h1><h2><span id="친애란">친애란?</span></h2><p>친애란 우정을 포함하여 다른 사람에 대해 가지는 서로 아끼고 의지하는 마음과 행동을 포괄적으로 지칭한다.</p>
<h2><span id="친애의-종류">친애의 종류</span></h2><h3><span id="부수적인-것에-따르는-친애">부수적인 것에 따르는 친애</span></h3><ul>
<li>상대를 그 자체로서 좋아하는 것이 아니라 어떤 좋음이나 즐거움 때문에 좋아하는 것<br>ex) 이득 등</li>
<li>상대를 더 이상 유익이나 즐거움을 주지 못할 때 사라짐<br>즉, 서로 친구가 될 수 있었던 이유가 사라지면 친애는 해체된다.<br>이러한 친애를 가진 사람은 다른 사람들과 함께 사는 일이 별로 없다.</li>
</ul>
<h3><span id="즐거움을-추구하는-친애">즐거움을 추구하는 친애</span></h3><ul>
<li>감정에 따라 살며 즐거움과 현재를 추구하는 친애</li>
<li>점은이의 친애</li>
<li>쉽게 친구가 되고 쉽게 헤어진다.</li>
<li>하루에도 몇 번씩 변하면서, 함께 시간을 보내고 같이 살기를 원한다.</li>
<li>에로스 지향적 친애</li>
</ul>
<h3><span id="덕탁월성에-따르는-친애">덕(탁월성)에 따르는 친애</span></h3><ul>
<li>덕에 있어 유사한 사람들 사이에서 성립하는 친애</li>
<li>친구를 위해 그 친구가 잘되기를 바라는 친애</li>
<li>덕은 지속적인 것이므로 이러한 친애는 지속적인 친애</li>
<li>가장 완전한 종류의 친애</li>
<li>이러한 친애는 서로에게 즐거움을 줌</li>
<li>이러한 친애는 드물다</li>
<li>이러한 친애는 시간과 사귐이 필요함</li>
</ul>
<h2><span id="친애의-특징">친애의 특징</span></h2><ol>
<li>함께 있고 함께 시간을 보내고 싶어한다.</li>
<li>서로에게 즐거움과 기쁨을 느낀다.</li>
<li>친애는 사랑 받는 것보다 사랑하는 것에서 더 잘 성립한다.</li>
</ol>
<h2><span id="행복과-친애">행복과 친애</span></h2><ul>
<li>행복은 일종의 활동인데, 활동은 생겨나는 것이지, 어떤 소유물처럼 소유되는 것은 아니다.</li>
<li>지극히 복된 사람은 즐거운 사람을 필요로 하겠지만, 유익한 사람을 필요로 하지 않는다.</li>
<li>역경에 처해 있는 사람은 자신에게 선행을 베풀어 줄 친구가 필요하고, 또 좋은 처지에 있는 사람은 자신이 잘해 줄 사람이 필요하다.</li>
<li>친구가 곁에 있다는 것 자체가 좋은 처지에 있을 때나 곤경에 처해 있을 때나 모두 즐거운 일이다.(1170a29)</li>
</ul>
<h3><span id="에피쿠로스의-우정론">에피쿠로스의 우정론</span></h3><p>행복하게 살도록 분별력을 제공하는 것 중에서 우정보다 크고 생산적이며 기쁜 것은 없다고 에피쿠로스는 말한다.<br>우정의 토대는 자기이익<br>언제나 도움을 청하는 사람도 친구가 아니며, 우정을 도움과 전혀 연결시키지 않는 사람도 친구가 아니다.<br>친구가 있으면 이롭고, 친구를 도우면 쾌락을 얻을 수 있다.<br>이로움을 얻는 것보다 이루옴을 주는 것이 더 즐겁기 때문에 우정은 욕구될 수 있다.<br>-&gt; 친구 공동체 / 에피쿠로스의 정원</p>
<h3><span id="우정에-대한-우리의-태도">우정에 대한 우리의 태도</span></h3><p>어떻게 하면 내가 좋은 친구가 될 수 있을까를 고민해라.</p>
<h2><span id="친애의-조건">친애의 조건</span></h2><ol>
<li>서로에 대한 선의를 가지고 있어야 한다.</li>
<li>상대방이 잘 되기를 바라야 한다.</li>
<li>그러한 사실을 서로가 알아야 한다.</li>
</ol>
<h1><span id="신과-행복">신과 행복</span></h1><h2><span id="종교란">종교란?</span></h2><p>인간의 문화활동의 한 형태<br>신(절대자)에 관한 인간의 믿음과 의례<br>인간이 가진 내적, 심리적 경외감, 경건의 마음</p>
<h2><span id="종교의-공통적인-내용">종교의 공통적인 내용</span></h2><h3><span id="영원의-추구">영원의 추구</span></h3><ul>
<li>죽음의 인식</li>
<li>인간의 불완전성에의 인식</li>
<li>불사</li>
</ul>
<h3><span id="지복-사상">지복 사상</span></h3><p>복을 준다고 생각을 하여 믿음<br>현실의 삶에 관한 성찰<br>삶의 규범 제시<br>(신의 말씀, 종교교리에 따른 삶)<br>마음의 안정, 행복 추구</p>
<p>기독교적 신과 ‘악’의 문제<br>아우구스티누스(Augustinus)<br>“만약 이 세상에 신이 존재한다면 악은 존재하지 않을 것이다.<br>이 세상에 악은 존재한다.<br>그러므로 이 세상에 악은 존재한다.”</p>
<p>실제 악은 없고<br>악은 선의 결핍이다.</p>
<h2><span id="아우구스티누스의-행복론">아우구스티누스의 행복론</span></h2><p>아우구스티누스는 고백록은 집필한 교부철학의 아버지라 불리며 마니교, 신플라톤주의, 키케로, 그리스도의 영향<br>“나는 의심한다. 따라서 나는 존재한다.”<br>하느님의 사랑이라는 개념을 정초하였다.</p>
<p><em>행복의 규정 - 자신이 원하는 것을 갖고 있는 사람은 모두 행복할까?</em><br>자신이 욕구한는 것을 갖고 있지 않은 사람은 행복 할 수 없지만, 자신이 원하는 것을 갖고 있는 사람이라고 모두 행복한 것은 아니다.<br><strong>행복해지려면 지속적이고 영원한 것을 가져야 한다.</strong><br>자신이 소유한 것 중 아무것도 잃지 않을 것이라고 확신하다고 해도, 사람은 그것에 만족하지 않는다.<br>우리를 끊임없이 욕구하게 만드는 것이 우리를 불행하게 만든다.</p>
<p><em>진정한 행복의 조건</em><br>진정한 행복을 위해서는 영원한 것을 소유하려는 영혼의 절제가 필요하다.<br>영혼의 절제는 인간의 자유의지와 필연의 관계를 맺음</p>
<p>영원불변의 존재이며, 인간에게 자유 의지를 부여한 것은 신이기 때문에<br><strong>진정한 행복은 오직 신의 향유에서만 가능</strong> 하다.</p>
<p>행복을 추구하려면 언제나 어느 정도의 자기포기가 필요하고, 더욱이 자기 아닌 다른 존재가 되어야 하는 고통이 따른다는 패러독스를 직시해야 한다.</p>
<p><em>행복과 사랑</em><br>인간의 의지에 힘을 부여하는 것은 사랑이며, 신으로부터 부여 받은 자유의지와 사랑이 결합되어 영혼의 운동력이 형성된다.<br>즉, <strong>행복과 불행의 문제는 자유의지에 힘을 주는 사랑이 어디를 향하느냐에 달려있다.</strong></p>
<p>선한 사랑 카리타스<br>피조물을 그 존재의 위계에 맞게 사랑하는 바른 사랑이다.</p>
<p>악한 사랑 쿠피디타스<br>위계적 분수에 어긋나는 잘못된 사랑이다.</p>
<h2><span id="신과-행복">신과 행복</span></h2><p>진정한 행복은 영원 불변한 행복이어야 하는데, 이것은 신만의 속성이다.<br>따라서, 진정한 행복은 오직 영원 불변한 신으로부터만 나오며, 신을 모시고 선하게 사는 사람이 진정 행복한 삶이다.</p>
<h2><span id="종교의-의의">종교의 의의</span></h2><p>종교는 주관적인 안녕감을 주고, 내세와 구원에 대한 믿음을 주며, 인간 삶에 관한 실존적 안녕감을 제공함으로써 어느정도 행복하게 해 준다고 할 수 있다.</p>
<p>실존주의 - 세계대전 이후 본질보다 실존이 우선시 되는 사상을 반영한다.</p>
<p><em>종교를 가진 신앙인들이 가지는 특별한 안녕감</em></p>
<ol>
<li>종교 단체에서의 봉사는 내적인 긍정감 형성시킴</li>
<li>죽음에 대해 덜 두려워하고, 심한 스트레스에 잘 대처함</li>
<li>종교적 공동체로부터 강한 사회적 지원감을 얻음</li>
</ol>
<h1><span id="정의">정의</span></h1><h2><span id="정의란">정의란?</span></h2><p>제우스가 인간에게 ‘부끄러움’과 ‘정의’를 주어 최고의 생명체가 되었다.</p>
<h2><span id="플라톤-국가의-정의">플라톤 [국가]의 정의</span></h2><ol>
<li><p>개인의 측면에서는 영혼의 세 요소가 조화를 이루는 상태<br>욕구적 부분, 기개적 부분(가슴에서 나오는 것 일종의 욱하는것), 이성적 부분</p>
</li>
<li><p>국가의 측면에서는 공동체의 세 부류가 통치자의 지도 하에 조화로운 삶을 이룬 상태<br>생산자 부류(개인의 욕구적 부분에 해당), 수호자 부류(개인의 이성적 부분에 해당), 통치자 부류(개인의 기개적 부분에 해당)</p>
</li>
</ol>
<p>지혜+용기+절제 -&gt; 정의</p>
<h2><span id="아리스토텔레스의-니코마코스윤리학의-정의-이론">아리스토텔레스의 니코마코스윤리학의 정의 이론</span></h2><p>정의란 법을 지키는 것이며, 공정한 것을 말한다.<br>정의가 완전한 것은 그 덕을 자기자신 뿐만이 아니라 타인에 대해서도 활용할 수 있게 하기 때문이다.</p>
<h2><span id="에피쿠로스의-정의-개념">에피쿠로스의 정의 개념</span></h2><p>헬레니즘의 사상적 특징<br>세계 시민주의</p>
<p>에피쿠로스에게 정의란 서로 간에 해치지 않겠다는 약속의 이행이며 원래 타당한 법과의 일치를 말한다.</p>
<h2><span id="역사적으로-규정되고-있는-정의의-개념">역사적으로 규정되고 있는 정의의 개념</span></h2><p>객관적: 법의 내용이 옳음<br>주관적 : 한 인격의 공정성<br>객관적 : 법의 개념은 인간과 인간사회가 요청하는 개념.</p>
<h2><span id="공통된-정의-개념">공통된 정의 개념</span></h2><p>같은 경우에는 똑같이 다루어야 한다.<br>-&gt; 불편부당성(훌륭한 사람이건 나쁜사람이건 죄의 경중에 따라 똑같이 처벌)<br>각자에게 적합하게 다ㄹ루어야 한다.<br>-&gt; 실적의 원리 : 주관적 죄책의 정도(획득한 만큼 돌려 준다.)</p>
<p>정의가 요구되는 조건</p>
<ol>
<li>궁핍, 갈등</li>
</ol>
<p>정의는 상반되는 이해, 이익관계에 따른 요구와 의무들이 상충할 때 문제가 됨</p>
<ol start="2">
<li>행위 능력<br>최소한 행위능력이 있는 존재인 자연적이며법률적인 인격체에 귀속되어야 한다.</li>
</ol>
<h2><span id="정의와-행복">정의와 행복</span></h2><p>사회 공동체적인 측면에서 볼 때, 다른 사회구성원과의 조화로운 삶을 위한 조건를 만족하기 위해 우리는 정의를 추구해야 한다.</p>
<h3><span id="j-rawls">J. Rawls</span></h3><p>우리 인간은 공존하기 위해 각자의 이해관계를 조절할 수 있는 도덕률이 필요하다.<br>궁극적 도덕원리는 사회적 정의 또는 공정성이다.</p>
<h1><span id="도덕과-행복">도덕과 행복</span></h1><h2><span id="도덕이란">도덕이란</span></h2><p>도덕이란 전통을 통해 확립되고 현재 용인되고 있는 공동체 행위규범의 총체<br>ex) 약속을 지키는 것, 다른 사람을 돕는 것, 다른 사람의 인격을 존중하는 것</p>
<p>도덕의 최소 개념<br>자기의 행위를 이상을 통해 인도하려는 노력<br>자기의 행동에 의하여 영향을 입게 될 각 개인, 타인에게 동등한</p>
<h2><span id="도덕에-관한-학문적-탐구로서의-윤리학">도덕에 관한 학문적 탐구로서의 윤리학</span></h2><p>윤리학의 종류</p>
<ol>
<li>규범 윤리학 : 인간 행위의 올고 그름에 대한 탐구</li>
<li>메타윤리학 : 유리학적 논의에서 사용되는 용어들을 분석하고 의미를 명료화, 도덕적 추론의 규칙과 인식방법 연구</li>
<li>응용 윤리학 : 현실세계의 구체적인 도덕 문제를 다루는 분야<br>ex) 직업 윤리, 공학윤리, 기업 윤리, 생명 윤리, 의료 윤리 …</li>
</ol>
<h3><span id="윤리학의-두-가지-원리">윤리학의 두 가지 원리</span></h3><p>공리주의적 입장<br>: 결과나 행위의 효용성을 기준.</p>
<p>의무론적 입장<br>: 도덕적 의무감이 행위의 기준</p>
<h3><span id="공리주의적-입장">공리주의적 입장</span></h3><p>보편적 행위공리주의<br>: 최대다수에게 최선의 결과를 가져다 주는 행위 선택<br>ex) 진실을 말하지 않는 것이 최선의 결과를 가져오는 상황</p>
<p>보편적 규칙공리주의<br>: 최대다수에게 최선의 결과를 가져다 주는 규칙을 고려하여 개별 행위 선택<br>ex) 만약 모든 사람이(의사가)거짓말을 한다면…</p>
<h3><span id="의무론적-입장">의무론적 입장</span></h3><p>도덕적 규범은 마땅히 따라야 할 규칙이다.<br>I.Kant - 너는 너 자신이나 다른 사람을 수단으로가 아니라 목적으로 대우하라.<br>궁극적 도덕의 원리는 타인의 인격에 대한 존중<br>타인의 자율적 의사 존중</p>
<p>덕윤리학<br>: 덕을 갖춘 사람 -&gt; 올바른 인간상</p>
<h2><span id="도덕과-행복">도덕과 행복</span></h2><p>도덕은 각 개인의 행위판단에 기여할 뿐만 아니라, 타인과의 공존의 법칙을 제공한다.</p>
<p>개인 - 행위 판단의 원리<br>사회 - 공존의 원리</p>
<p>도덕은 그 무엇보다도 개인보다는 사회에서의 행복에 직간접적으로</p>
<h1><span id="노동과-행복">노동과 행복</span></h1><h2><span id="노동이란">노동이란?</span></h2><p>노동이란 일종의 운동(몸의 움직임, 행위, 활동)이다.</p>
<p>사적 노동 개념 - 개인적 행복감에 관여<br>: 어떤 행위나 활동이 그 자체 때문이 아니라 수단적으로 이루어질 때, 즉 다른 목적을 위해 이루어질 때<br>: 행위 주체가 그 활동을 수고롭다고 느끼고, 힘들 때도 해야 할 때</p>
<h2><span id="일-노동의-어원적-의미">일, 노동의 어원적 의미</span></h2><ol>
<li>arbeit - 경작된 농지, 불어 travail - 말뚝 세개, 괴롭히다, Labor - 새로운 것을 만들어내는 일</li>
</ol>
<h2><span id="노동의-역사">노동의 역사</span></h2><p>전 인류 문명의 역사는 노동의 역사이다.<br>노동은 <strong>가치 창조의 본질적 요인</strong> 이다.</p>
<p>노동에 대한 정당한 평가가 이루어져야 한다.<br>육체적 노동의 재평가</p>
<h3><span id="고대-그리스의-노동-개념">고대 그리스의 노동 개념</span></h3><p>신체 활동을 자유시민에게는 어울리지 않는 것으로 봄. 신체의 활동은 강제를 동반하며 인간에게 관조의 여유를 빼앗기 때문.</p>
<p>아리스토텔레스 일과 덕은 서로를 배척한다.</p>
<p>키케로 - 수공업은 낮은 부류의 직업이다.<br>: 귀족주의적 노동관</p>
<h3><span id="기독교의-노동-개념">기독교의 ‘노동’ 개념</span></h3><p>신의 피조물로서 과업을 완성하기 위해서는 일, 노동은 필수적이다.<br>죄와 구원의 개념과도 연관</p>
<h3><span id="르네상스의-노동-개념">르네상스의 노동 개념</span></h3><p>귀족주의적 노동 개념 잔재<br>Homo faber(만드는, 창조하는 인간)에 대한 관심 - 수공업자, 예술가<br>조르다노 브루노 - 여가, 여유에 대립되는 ‘활동’에 가치 부여</p>
<h3><span id="근대의-노동-개념">근대의 노동 개념</span></h3><p>수공예에서 기계로의 전환에 따른 산업의 발전, 생산적 자본주의의 발달, 자본 계층과 노동자 계층의 갈등을 통한 ‘노동’개념의 이슈화</p>
<p>칼 마르크스 - ‘노동’이란 인간 삶의 창조적 근원이며 ‘삶을 생산하는 삶’이다.</p>
<p>Homo Laborans(노동하는 인간)<br>: 마르크스의 노동 개념으로 인간은 자신의 삶과 사회적 생산이라는 면에서, 불가결하지만 자신의의지와는 무관한 관계 즉, 생산관계에 들어간다.<br>생산관계의 총체는 사회의 경제적 구조를 형성하며, 이 경제적 구조는 사회의 진정한 토대로서 이 토대 위에 법률적 정치적 상부구조가 세워진다.<br>물질이 정신을 규정한다.<br>물질적 삶의 생산방식이 사회적, 정치적 및 정신적 삶의 과정을 전반적으로 조건짓는다.<br>노동은 물질적 삶의 생산을 규정하는 계기로서 가치척도이자 가치창조의 본체이다.</p>
<p>‘소외’(Entfremdung)<br>: 인간과 그의 생산물 사이의 진정한 관계를 자유로운 생산의 관계이어야 한다.<br>인간의 노동이 만든 생산물이 인간으로부터 분리되어 인간에게 낯선 존재가 되고 인간을 억압, 종속시키는 현상<br>소외의 원인을 자본주의 분석에서 찾음<br>인간 존재는 그 자체 자기목적적이며 소외되어서는 안된다.</p>
<h3><span id="현대의-노동">현대의 ‘노동’</span></h3><p>노동중심적 패러다임<br>: 취업 노동을 전제로 한 노동 중심적 삶의 방식을 근복적 삶의 방식으로 인정하는 태도.<br>취업 노동을 통해 물질적 안정을 확보하고, 자아 정체성을 형성하려 함.</p>
<p>‘노동중심적 패러다임’의 위기<br>: 자동화, 정보화에 따른 일자리 감소와 실업의 증가<br>제 4차 산업혁명의 예고</p>
<p>노동중심적 패러다임의 위기에 대한 대처<br>: 노동중심적 패러다임 탈피?</p>
<h2><span id="노동과-행복">노동과 행복</span></h2><h3><span id="소외를-지양하는-생활">소외를 지양하는 생활</span></h3><ul>
<li>‘나’를 위한 ‘노동’</li>
<li>자발적인 노동</li>
<li>노동의 즐거움과 보람을 동시에 획득하는 선택과 생활</li>
</ul>
<h3><span id="노동에-관한-비판적-접근">노동에 관한 비판적 접근</span></h3><ol>
<li>신체적 활동으로서의 노동 개념의 가치 인식<br>육체적 노동의 신성한, 가치 인식<br>수고스러움의 의미</li>
<li>노동 가치에 대한 새로운 시각<br>노동 가치에 대한 비판적 평가</li>
<li>노동 중심적 패러다임의 재고<br>나동화 등 제 4차 산업혁명에의 대비<br>노동 개념의 변화</li>
</ol>
<h1><span id="지식과-행복">지식과 행복</span></h1><h2><span id="지식이란">지식이란?</span></h2><h3><span id="플라톤이-말하는-지식의-종류">플라톤이 말하는 지식의 종류</span></h3><p>Episteme(지식, 인식)<br>Doxa(의견, 견해, 억견)</p>
<h3><span id="참된-지식이란진리">참된 지식이란?=진리?</span></h3><p>진리 대응설<br>: 어떤 것이 사실과 일치하면 진리(참)이다.</p>
<p>진리 정합설<br>: 어떤 것이 기존의 지식체계에 맞거나 모순이 아니면 진리(참)이다.</p>
<p>진리 약정설<br>: 사회구성원들이 모두 동의하는 것이, 참이라고 약속한 것이 진리이다.</p>
<h3><span id="지식의-기원">지식의 기원</span></h3><p>지식은 어떻게 얻어지는가?<br>직접 대면, 기술구에 의한 인식</p>
<p>아는 것이 힘이다.<br>정보력<br>내가 아는 정보에 의해 내가 규정된다.</p>
<h3><span id="fbacon의-우상이론">F.Bacon의 우상이론</span></h3><p>우상을 조심해야 정부의 홍수 속에서 진리를 얻을 수 있다.</p>
<p>종족의 우상<br>: 우리 인간 종족이 피할 수 없는 이성의 오류, 선입견을 가리킴, 우리는 인간의 눈으로만 세계를 보고 인간의 관점에서만 세계를 판단함</p>
<p>동굴의 우상<br>: 한 개인의 잘못된 외고집에서 기인하는 선입견, 오류</p>
<p>시장의 우상<br>: 언어에 대한 인간의 잘못된 선입견에서 오는 오류, 예컨대 진짜 사물과 그에 대한 명칭을 혼동하는 데서 오는 선입견, 오류</p>
<p>극장의 우상<br>: 전승되어 온 사상이나 교리를(그 권위 때문에)실제로 의문을 제기하지 않은 채 그대로 답습하는 데서 오는 선입견, 오류에 속지 말아라.</p>
<h2><span id="지식과-지혜">지식과 지혜</span></h2><p>이론적 지식, 실천적 지식</p>
<p>실천적 지식<br>: ~을 할 수 있음(techne)</p>
<p>정치, 사회, 문화에 대한 비판 의식<br>이론적 지식과 실천적 지식을 모두 갖추어야 지혜를 가지게 될 수 있다.</p>
<h2><span id="지식과-행복">지식과 행복</span></h2><p>에피쿠로스에게 (자연에 관한)지식<br>단편적 지식(정보 등)에서 실천적 지혜까지 살아있는 지식을 가져라!</p>
<p>생산적 지식<br>반성과 비판을 통해 얻어낸 지식<br>지속성과 안정석ㅇ을 가진 지식<br>-&gt; 전문적 능력(끊임없는 자기 개발)<br>교양과 전문적 지식 사이</p>
<h1><span id="자연과-행복">자연과 행복</span></h1><h2><span id="자연이란">자연이란?</span></h2><ol>
<li>자람, 성장</li>
<li>자연세계, 자연계</li>
<li>본성</li>
</ol>
<h3><span id="스토아학파의-자연-개념">스토아학파의 자연 개념</span></h3><p>자연의 운용 원리는 질서와 조화로 logos이다.<br>자연의 일부로서 인간은 이성적 존재<br>인간의 본성은 이성적, 합리적이다.</p>
<p>이성적, 합리적으로 생각하고 행위하는 것이 인간의 자연(본성)에 합당한 일이다.</p>
<p>본능적 욕망에 휘둘리는 것은 인간다움에서 벗어난 일이다.</p>
<h2><span id="인간과-자연세계">인간과 자연(세계)</span></h2><p>자연의 일부인 인간이지만 문명의 지배자로서 자연과 대립<br>자연의 지배자로서 인간의 모습<br>환경문제의 대두 + 4차 산업혁명</p>
<p>환경 문제<br>환경 오염, 지구온난화, 자연 파귀(인간의 문명 개발, 과학과 기술 발전, 경제적 성장으로 인해 야기됨)<br>환경문제는 불가피한 것인가?</p>
<h2><span id="환경">환경</span></h2><h3><span id="환경윤리이론의-주요-방향">환경윤리이론의 주요 방향</span></h3><p>인간중심적 윤리<br>: 오직 인간만이 도덕적 가치를 가진다.<br>인간에게는 자연계와 관련된 책임은 있을 수 있지만 자연계에 대한 직접적 책임은 없다.<br>ex) 대기오염, 수질 오염 등<br>오염된 식품과 식수는 인간의 복지에 직접적 위험을 주기 대문에 미래 세대의 인간에게 해를 끼칠 수 있기 대문에 자연을 보호하고 핵폐기물을 처리해야 한다.(인간중심적 윤리의 확장)</p>
<blockquote>
<p>인간에게 이득이 되는 것을 최고로 하고, 인간에 대한 도덕만을 고려한다.<br>이 경우 환경을 보호해야 되는 이유를 미래의 인류에 대한 책임감으로 고려한다.</p>
</blockquote>
<p>탈인간중심적 윤리<br>: 동물, 식물과 같은 자연물에도 도덕적 지위를 부여하는 입장<br>우리는 인간 이외의 다른 자연적 존재에 대해서도 직접적인 책임이 있다.</p>
<p>전체주의 윤리<br>: 개체가 아닌 개체의 집합, 즉 전체를 중심으로 윤리적 판단<br>개별생명체뿐만 아니라  종, 군집, 생태계에로 관심의 초점을 맞춤<br>무생물, 생태계 자연물들간의 관계등의 전체에도 도덕적 지위를 부여<br>생태학의 중요성<br>야생의 가치와 이념</p>
<blockquote>
<p>인간을 종으로 보고, 단지 하나하나의 개체를 넘어서 인류라는 종을 중심으로 윤리적 판단을 한다.</p>
</blockquote>
<p>근본생태주의 강령<br>: 인간과 지구상에 존재하는 모든 생명체의 번성은 본질적 가치를 지닌다. 생명체의 가치는 협의의 인간의 목적에서 나오는 유용성과 무관하다.<br>인간은 없어서는 안될 본질적 필요를 충족시키는 경우를 제외하고는 생명을 죽이면 안된다.</p>
<blockquote>
<p>인간과 동물은 같은 생명체로써 동일하다는 주의이다.<br>본질적 필요를 충족시키는 경우를 제외하고는 생명을 죽이면 안된다.</p>
</blockquote>
<h1><span id="행복의-방법">행복의 방법</span></h1><h2><span id="자아-성찰">자아 성찰</span></h2><h3><span id="독서와-사색을-통한-정적인-자기-탐구">독서와 사색을 통한 정적인 자기 탐구</span></h3><p>운동이나 문화, 예술 활동을 통한 동적인 자아에의 심취<br>(진정한)’나’와 만나기</p>
<h3><span id="거울-만들기">거울 만들기</span></h3><p>나에 관한 정확한 진단, 나의 장점과 훌륭한 점을 부각시켜줌</p>
<h3><span id="자아-능력-개발">자아 능력 개발</span></h3><p>자신이 원하는 자신의 모습 만들<br>남들이 원하는 자신의 모습은?</p>
<h3><span id="실천적-습관과-태도">실천적 습관과 태도</span></h3><p>행복은 지속적인 것<br>평상시의 긍정적 습관 형성</p>
<h3><span id="개인적인-방법">개인적인 방법</span></h3><ol>
<li>자유로운 공간</li>
</ol>
<ul>
<li>스스로 발견하는 행복의 방법</li>
<li>자신에게 만족감을 주는 활동하기</li>
</ul>
<ol start="2">
<li>자신이 주인인 생활</li>
</ol>
<ul>
<li>복합적인 면모를 지닌 자신 안에서 ‘주인’발견</li>
<li>자신의 삶은 자신이 주도하라!</li>
<li>끌려 다니는 삶에 대한 반성</li>
</ul>
<ol start="3">
<li>공존의 법칙 이해하기</li>
</ol>
<ul>
<li>나도 역시 남에게는 타인이다.</li>
<li>타인을 존중하곳 소중히 여긴다.</li>
<li>먼저 다가가기</li>
<li>의사소통 방법 연구</li>
</ul>
<ol start="4">
<li>친구 및 남과 함께 행복해지기</li>
</ol>
<ul>
<li>즐겁게 만들어라</li>
<li>규칙적으로 만나라</li>
<li>만남에 투자하라</li>
</ul>
<blockquote>
<p>자아성찰(자아탐구, 자아개발) =&gt; 공존의 법칙(타인 존중, 먼저 다가가기)을 통해서 행복해 질 수 있다.</p>
</blockquote>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/01/13/angular-에서-youtube-재생하기/" itemprop="url">
                angular 에서 youtube 재생하기
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-01-13T05:22:27.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                3 minutes read (About 382 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h2><span id="컴포넌트에-safe-pipe를-사용할-수-있도록-pipe를-만든다">컴포넌트에 safe pipe를 사용할 수 있도록 Pipe를 만든다</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Pipe, PipeTransform &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; DomSanitizer&#125; from &apos;@angular/platform-browser&apos;;</span><br><span class="line"></span><br><span class="line">@Pipe(&#123; name: &apos;safe&apos; &#125;)</span><br><span class="line">export class SafePipe implements PipeTransform &#123;</span><br><span class="line">  constructor(private sanitizer: DomSanitizer) &#123;&#125;</span><br><span class="line">  transform(url) &#123;</span><br><span class="line">    return this.sanitizer.bypassSecurityTrustResourceUrl(url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="appmodule에-safepipe를-선언해-준다">app.module에 SafePipe를 선언해 준다.</span></h2><p>생성한 pipe를 module에 포함시켜 준다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">   declarations : [</span><br><span class="line">     ...</span><br><span class="line">     SafePipe</span><br><span class="line">   ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2><span id="html-작성">html 작성</span></h2><p>iframe을 사용 할 때 src에 safe pipe를 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe width=&quot;100%&quot; height=&quot;300&quot; [src]=&quot;url | safe&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p>
<h2><span id="x-frame-options-해결하기">x-frame-options 해결하기</span></h2><p>유투브 공유하기 url을 퍼와서 재생하면 x-frame-option to ‘sameorigin’이라는 에러가 발생하게 된다.<br>여기서 X-Frame-Option이란 http response header의 한 종류로써 자신의 컨텐츠가 <frame>, <iframe> 등에서<br>렌더링이 되도록 허용하는지의 유무를 나타낸다.</iframe></p>
<p>이 옵션은 나의 컨텐츠가 다른 사이트에 무단으로 포함되는 것을 막고 다른 사이트를 통해 클릭 공격 등을 시도하는 것을 막을 수 있다.</p>
<p>즉, Youtube가 컨텐츠를 업로드 하는 시점에 x-frame-option을 설정하여 무단으로 퍼갈 수 없도록 하는 것이다.<br>때문에 Youtube에서 컨텐츠를 가져와 embed 하고 싶은 경우에는 반드시 공유=&gt;퍼가기 를 누르면 나오는 소스코드의 src 부분을<br>가져와야 한다. 이 url 에 포함된 중간의 embed 라는 문자는 해당 컨텐츠가 다른 사이트 에서도 재생 될 수 있도록 x-frame-option이 지정되어 있기에<br>퍼가는 것이 가능해 진다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/01/12/scss-시작하기/" itemprop="url">
                scss 시작하기
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-01-11T15:15:55.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                a few seconds read (About 70 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#간략한-설명">간략한 설명</a></li>
<li><a href="#기본-개념">기본 개념</a></li>
</ul>
<!-- tocstop -->
<h2><span id="간략한-설명">간략한 설명</span></h2><p>scss 란 css로 변환하기 전의 일종의 마크업 랭귀지로 컴파일러(루비 기반)에 의해 css로 변환된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install ruby</span><br><span class="line">sudo gem install sass</span><br><span class="line">sass --watch input.style.scss:output.style.css</span><br></pre></td></tr></table></figure>
<h2><span id="기본-개념">기본 개념</span></h2><p><a href="https://soooprmx.com/archives/7948" target="_blank" rel="noopener">기본 개념</a></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/01/06/시장-분석-방법론/" itemprop="url">
                시장 분석 방법론
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-01-06T03:27:41.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                8 minutes read (About 1199 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#거시-환경-분석">거시 환경 분석</a></li>
<li><a href="#미시-환경-분석">미시 환경 분석</a></li>
</ul>
<!-- tocstop -->
<h2><span id="거시-환경-분석">거시 환경 분석</span></h2><p>사업계획서를 작성하거나 혹은 마케팅 전략을 수립함에 있어 중요한 절차 중 하나는 바로 시장 분석이다.<br>시장의 정치 경제 사회적 상황을 분석하는 것은 비즈니스에 대한 직관을 심어주고 성공의 유무를 판가름 하는 핵심적인 요소이다.</p>
<p>가령 AirBnb의 경우는 사업 초기에 법적인 문제를 겪었는데, 거주지 공유 서비스가 불법 임대업에 해당한다는 국가의 규제가 있었기 때문이다.<br>하지만 AirBnb의 사업이 확장하면서 대부분의 국가에서는 자신의 아파트는 연 90일 이하로 임대할 수 있는 규정 등 다양한 완화 법규를 통과시키면서 AirBnb는 법적 대응에 맞설 수 있었다.</p>
<p>경제적인 요소에 있어서 2008년의 경제위기로 인해 많은 사람들이 여행에 적은 돈을 지출하는 현상이 나타났는데, 서비스업을 포함하여 대부분의 사람들이 더 저렴한 숙소를 원하게 되었는데, AirBnb는 공유업에 기반한 숙소를 제공하기 때문에 비교적 매우 저렴한 숙소를 공급할 수 있었기에 이러한 수요를 잘 만족시켰다.<br>만약, AirBnb가 출범할 때의 경기가 매우 호황이었고, 각종 서비스업이 각광받는 시기였다면, AirBnb의 사업성공은 그리 쉬운 일이 아니었을 수도 있다. 경제위기라는 상황에서 저렴한 숙소를 찾아다니는 고객들이 있었고, 자연스레 이런 수요를 만족시키면서 사업을 성장시킬 수 있었다. 또, 이러한 경제위기는 ‘공유 경제’라는 새로운 개념을 탄생시켰는데, 요즘 시대에는 개인이 자신의 자신을 다른 사람에게 아주 저렴한 가격으로 임대해 주는 현상이 점점 더 많이 나타나고 있으며, AirBnb는 이러한 사회적 분위기에 편승하여 빠르게 성장할 수 있었다.<br>공유경제에 기반한 많은 서비들이 아직도 새롭게 생겨나고 있으며, 그 시장은 빠르게 성장하고 있다.</p>
<p>사회적 요소에 있어서는 소셜 네트워크가 사람들의 삶에 아주 큰 영향을 미치는 현상이다. 수많은 사람들이 SNS에서 활동하며 공유경제 트렌드에 힘입어 사람들은 SNS를 통해서 수익을 창출하고 자신의 독자적인 비즈니스를 수행할 수 있기를 원했고, AirBnb는 좋은 창구가 되어 주었다. 과거 사람과 비즈니스가 구분이 되었다면 요즘 시대에는 사람 자체가 비즈니스가 되는 사회에서 살고 있다고 창립주 브라이언 체스키는 말한다.</p>
<p>기술적 요소에 있어서 스마트폰과 태블릿이라는 새로운 플랫폼이 급부상 하여 언제 어디에서든지 새로운 숙소를 예약할 수 있는 환경을 만들어 주었다.</p>
<h2><span id="미시-환경-분석">미시 환경 분석</span></h2><p><strong>_공급자의 교섭력</strong><br>플랫폼에 있어서 AirBnb는 공급자를 먼저 끌어들였으므로, 공급자들을 일종의 교섭력을 가진다.<br>공급자에게 있어서도 AirBnb는 자신의 비즈니스를 홍보할 최고의 플랫폼이기에 공급자들은 계속해서 모여들며, 자신들이 플랫폼 내의 다른 공급자들과 경쟁하며 가격을 책정하기 때문에 좋은 선순환이 일어날 수 있다.</p>
<p><strong>소비자 교섭력</strong><br>비즈니스의 성공과 평판이 고객으로 부터 나오는 만큼 고객의 권위는 막강하다. 많은 사용자들이 SNS나 포럼에서 고객경험을 공유하고 평판에 기여를 하기 때문에 고객은 아주 중요하다. 하짐나 점점 고객의 영향력은 낮아질 수 밖에 없는데 브랜드가 성장함에 따라 최고의 공급자들은 자연스럽게 AirBnb 플랫폼에 참여할 수 밖에 없고, 대부분의 사용자들도 이에 따라 플랫폼에 귀착될 수 밖에 없다.</p>
<p><strong><em>진입장벽</em></strong><br>AirBnb가 만든 진입장벽의 핵심 요인은 높은 시장 점유율을 기반으로 한 막강한 마케팅 리소스를 가진것이다.<br>last mover effect가 막강하다.</p>
<p><strong><em>경쟁자</em></strong><br>경쟁자에 대해 분석한다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/01/04/사업계획서의-작성/" itemprop="url">
                사업계획서의 작성
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-01-04T03:50:38.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                39 minutes read (About 5814 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="사업-계획서의-필요성">사업 계획서의 필요성</span></h1><p>인터넷을 기반으로 새로운 비즈니스를 시작할 예정이거나 기존 비즈니스를 인터넷 영역으로 확장하고자 한다면, 사업계획서를 작성하는 것이 중요하다.사업계획서(business plan)란 회사의 목표를 명시함은 물론 회사가 그 목표를 어떻게 달성할 것인지에 대해 정리한 문서이다. 사업계획서를 작성하는 과정을 통해 사업제안자는 사전에 생각을 하고, 달성 가능한 목표를 설정하며, 문제를 예상하고, 또 경쟁에 대응할 준비를 하게 된다. 사업계획서 자체보다는 사업계획서를 작성하는 과정이 비즈니스의 성공확률을 좌우한다.<br>일반적인 사업계획서와 마찬가지로, 인터넷 사업계획서도 필요성 및 예상되는 사업결과뿐 아니라 창업을 하고자 하는 벤처기업의 상세한 내용에 관해 기술하여야 한다. 또 전자상거래 특유의 속성을 함께 고려하여야 한다.</p>
<p>사업계획서를 필요로 하는 경우는 다음의 두 가지 유형이다.</p>
<ol>
<li>신규 벤처기업 (전자상거래 기업 창업) – 사업계획서는 대출 혹은 투자 기관에 제출됨</li>
<li>기존 오프라인 기업의 전자상거래 사업부문 – 사업계획서는 전자상거래 사업에 투자하는 후원기업에 제출됨</li>
</ol>
<h1><span id="사업계획서의-목적">사업계획서의 목적</span></h1><p>사업계획서는 제안된 사업을 실행에 옮기는데 필요한 자금을 확보하는데 그 목적이 있다. 사업계획서는 투자자나 기업후원자의 재정적 지원을 이끌어내는 것 이외에도 또 다른 목적이 있는데, 사업제안자가 철저하고 효과적인 사업분석을 실시함으로써 빈틈이 없는 치밀한 사업계획을 수립할 기회를 제공하는 것이 바로 그 것이다.</p>
<h1><span id="사업계획서의-작성">사업계획서의 작성</span></h1><h2><span id="1-요약문">1. 요약문</span></h2><p>전자상거래 <strong>사업계획서의 전체적인 내용이 작성이 되면, 1-2 페이지 분량의 요약문(executive summary)을 작성</strong> 해야 한다. 사업계획서 서두부분에 삽입되는 이 요약문은 전체 사업계획서의 핵심요지를 포함한다. 이 부분을 읽은 투자자나 관리자는 이 업체가 대략 어떠한 회사인지 알게 되며 더 상세한 내용을 보기 위해 본문을 읽게 된다. 일반적으로 요약문은 사업계획서의 <strong>개별 섹션과 관련하여 한 두 가지의 주요 포인트를 정리해</strong> 작성된다.<br>요약문의 내용은 그 것을 읽는 독자를 염두에 두고 작성되어야 한다. 만일 투자자를 위해 작성된다면, 재정적인 요구사항에 관한 중요한 정보를 담아야 할 것이다. 마찬가지로, 정보중개자, 디지털 디바이스, 매스 커스토마이즈 등과 같이 독자에게 난해한 전자상거래 전문용어나 개념은 별도의 정의를 제공하지 않는 한 사용을 피하는 것이 좋다. 가장 훌륭한 요약문은 독자에게 중요한 이슈 및 의문사항들이 무엇인지를 이해하며 이들에 대해 명료하고 직설적인 문체로 알기 쉽게 설명한 글이다.</p>
<h2><span id="2-사업-개요">2. 사업 개요</span></h2><p>독자에게 회사의 사업내용 및 목적에 대해 소개하는 섹션으로, 회사의 미션, 목표, 가치명제, 제품 및 서비스에 관한 정보를 기술하여야 한다. 회사가 어떤 활동을 하게 되며 어떻게 성공을 할 것인지에 대해 큰 그림을 제공하는 것이 목적이다. 제품과 인터넷이 서로 어떤 관련이 있으며 또 서로 보완이 되는지 설명이 돼야 한다.</p>
<p><strong><em>회사 미션</em></strong></p>
<p>미션이란 회사가 존재하는 이유를 뜻한다. 예를 들어, 삼성전자의 미션은 혁신적인 디지털 제품과 E-프로세스롤 통해 디지털 컨버전스 혁명을 주도하는 기업이 되는 것이며, LG 전자의 비전은 혁신적인 디지털 제품과 서비스로 세계 모든 고객에게 행복을 선사하는 글로벌 디지털 리더가 되는 것으로 정의되고 있다. 이 부분에서는 회사의 미션을 정의하고 이 미션의 중요성을 보여줄 수 있는 설명을 앞에서 정의한 업종과 연관시켜 한두 단락으로 제시한다. 바람직한 미션은 명확한 가치를 밝히고, 기업이 활동할 사업영역을 명시하며, 종업원들의 동기를 유발하고, 기업장래에 대한 비전을 제공하는 특징을 지닌다.</p>
<p><strong><em>가치명제</em></strong></p>
<p>고객에 대한 가치명제와 그에 대한 타당성을 기술하는 부분이다. 가치명제(value proposition)는 회사의 제품이나 서비스가 고객에게 제공하는 가치 혹은 혜택을 표현한다. 다시 말해, 왜 고객이 이 회사의 제품이나 서비스를 구매해야 하는가에 대한 답이 가치명제에 포함되는 것이다. 가치명제의 초점은 고객에 있기 때문에, 고객 관점에서 가치명제를 결정하여야 한다. 예를 들면, 가치명제는 낮은 가격(예: buy.com), 탁월한 고객서비스(amazon.com), 제품검색 비용절감(autobytel.com), 제품 커스토마이징(dell.com) 등의 가치에 기초할 수 있다. 가치명제에 관한 보다 상세한 설명은 교과서 제2장에 수록되어 있다.</p>
<p><strong><em>회사 미션</em></strong></p>
<p>미션이란 회사가 존재하는 이유를 뜻한다. 예를 들어, 삼성전자의 미션은 혁신적인 디지털 제품과 E-프로세스롤 통해 디지털 컨버전스 혁명을 주도하는 기업이 되는 것이며, LG 전자의 비전은 혁신적인 디지털 제품과 서비스로 세계 모든 고객에게 행복을 선사하는 글로벌 디지털 리더가 되는 것으로 정의되고 있다. 이 부분에서는 회사의 미션을 정의하고 이 미션의 중요성을 보여줄 수 있는 설명을 앞에서 정의한 업종과 연관시켜 한두 단락으로 제시한다. 바람직한 미션은 명확한 가치를 밝히고, 기업이 활동할 사업영역을 명시하며, 종업원들의 동기를 유발하고, 기업장래에 대한 비전을 제공하는 특징을 지닌다.</p>
<p><strong><em>제품 및 서비스</em></strong></p>
<p>가치명제가 실현가능함을 보여주기 위해 제공할 제품이나 서비스에 대해 소개하는 부문이다. 예를 들어, 기능, 디자인, 스타일, 색상 등과 같은 제품특성에 대해 서술한다. 이 회사의 제품이나 서비스가 타사의 것과 비교해 어떤 점이 다르고 독특한지 설명하여야 한다. 또 궁극적으로는 이 제품이나 서비스가 어떻게 가치명제를 뒷받침하는지 보여줄 수 있어야만 투자자에게 어필할 수가 있다.</p>
<p><strong><em>비즈니스 모델</em></strong></p>
<p>제안된 전자상거래업체가 따르게 될 비즈니스 모델에 관해 서술이 되어야 한다. 비즈니스 모델이란 회사가 존속하기 위해 비즈니스를 수행하고 수익을 창출시키는 방법을 뜻하며, 온라인 소매, 거래중개, 경매, 포털, 키워드검색 광고, 오픈콘텐츠 등이 그 예에 속한다. 투자자들은 비즈니스 모델을 통해 미래의 수익창출 및 성공의 가능성을 가늠할 수 있기 때문에, 독특한 비즈니스 모델을 신중하게 선택하는 것이 중요하다. 비즈니스 모델과 관련한 상세한 내용은 교과서의 제2장에서 수록되어 있다.</p>
<h2><span id="3-사업-타당성-검토">3. 사업 타당성 검토</span></h2><p>타당성 검토 및 분석을 필히 수행하여야 한다. 팀 프로젝트에서 제안된 비즈니스 모델을 사업화하기 위해 도입하여야 하는 정보기술에 대한 타당성이 있는지 확인하여야 하기 때문이다.</p>
<p>타당성(feasibility)이란 특정 정보기술(GPS, 웹, 휴대폰/스마트폰, 증강현실 등)을 도입하는 것이 기술적으로 또 경제적으로 타당한지를 뜻합니다. 따라서 기술적 타당성과 경제적 타당성의 두가지로 나누어 분석할 필요가 있습니다.<br>기술적 타당성은 해당 기술을 구현하는 것이 현실적으로 큰 어려움이 없이 원만하게 진행될 것인가를 뜻합니다. 반면, 경제적 타당성은 해당 기술을 도입하는 데 따른 비용이 지나치게 많이 들지 않으며, 우리 회사의 가용 자금으로 충당이 가능한지를 의미합니다.<br>이 두 가지 타당성이 존재하는 것으로 확인이 되어야만, 사업화를 추진하는 것이 의미가 있다고 할 수 있습니다. 한 예로, AR(증강현실) 기술을 휴대폰과 접목시켜 새로운 정보서비스를 제공할 사업을 구상하고 있는 기업의 경우, 현재까지 개발된 기술수준으로는 해당 기술을 구현하기 어렵거나, 혹은 해당 기술을 외부에서 구매하거나 내부적으로 개발하는데 비용이 지나치게 많이 소요될 것으로 예상될 때에는 타당성 결여로 인해 사업 아이템을 포기하고 다른 사업 아이템을 찾아봐야 합니다. 타당성 조사를 위해서는 가능하다면 해당 기술을 보유한 기업에 전화를 걸어 도입비용이나 기술수준 등에 대해 문의한다면 보다 현실적인 아이디어를 얻을 수 있을 것입니다.</p>
<h2><span id="4-시장-분석">4. 시장 분석</span></h2><p><strong><em>산업분석</em></strong></p>
<p>회사가 속한 산업 및 그 산업 내에서의 업종을 결정하고 그 업종에 대한 분석을 실시한다. 이를테면, 결정된 업종이 오픈마켓, 종합 쇼핑몰, 웹호스팅서비스, 온라인보험, 온라인여행중개, 혹은 온라인교육이라고 할 때, 그 업종에서 활동하고 있는 기존 회사들과 현 업계동향을 조사해 내용을 정리한다.</p>
<p>시장분석 섹션은 고객들이 누구인지 알고 있음을 보여주기 위한 부분이다. 타겟 고객들이 누구인지, 이 고객들이 어떠한 특성을 지니는지, 그리고 이 고객들이 왜 이 회사에서 구매할 것으로 예상되는지에 대해 기술하는 부분이다. 예를 들어, 타겟 고객이 30대 직장여성들 이라면, 이들 중 대략 몇 퍼센트가 온라인 구매 경험이 있으며, 월평균 소득이 얼마인지에 대해 관련정보를 수집할 수가 있다. 고객 베이스의 분석은 단순한 짐작보다는 인터넷 검색을 통해 통계 데이터에 의해 뒷받침될 때, 그 신뢰성이 더 높아진다. 시장분석 섹션에서는 타겟 시장을 정의하고, 매출극대화를 위해 제품이나 서비스를 어떻게 포지셔닝 할 것인지를 분석한다.<br>전자상거래 회사의 타겟시장을 선정하는데 있어, 그 범위가 적절하도록 함은 물론 시장세분화 특성을 고려하여야 한다. 시장세분화 특성으로는 인구통계적(연령, 성별, 인종, 교육, 직업, 소득), 지역적(국가, 행정구역, 도시/농촌, 모바일 근로자), 심리적(태도, 믿음, 니즈, 욕구) 및 소비자(충성도, 쇼핑빈도, 사이트 방문횟수, 온라인 구매의도) 등이 고려될 수 있다. 이들 특성들을 상세하게 묘사함으로써 타겟 시장을 기술하도록 한다.</p>
<h2><span id="5-경쟁사-분석">5. 경쟁사 분석</span></h2><p>주요 경쟁사들에 대해 철저한 분석을 함으로써 경쟁에 대응하기 위한 준비가 되어있다는 것을 보여주는 부분이다. 이를 위해, 인터넷 검색엔진을 이용해 알려진 경쟁사나 유사한 제품들이 있는지 찾아본다. 검색엔진들마다 검색기법이 다르므로, 두세 가지의 검색엔진을 사용하는 것이 좋다. 사업계획서의 독자들은 어떻게 경쟁에서 이기려고 하는지에 대해 큰 관심이 있음을 명심해야 한다.</p>
<p>경쟁사분석 섹션은 경쟁사들 및 그들의 제품이나 서비스를 검토함으로써 시장에서 경쟁사들에 비해 회사가 지니는 우위 및 열위가 무엇인지 알 수 있으며, 경쟁력을 강화하기 위한 전략을 개발하는데 도움이 되며, 또 경쟁이 회사 성공전망에 미칠 영향을 과소평가할 경우 투자자들은 경영자가 비현실적인 사업계획을 가지고 있다고 단정할 수 있다는 점에서, 매우 중요하다고 할 수 있다.<br>경쟁사 분석에서 첫 단계는 잠재적 경쟁사들을 찾아내는 것이다. 시장에서의 경쟁의 범위 및 진행패턴을 고려하면서 경쟁대상이 될 수 있는 업체들을 규명하도록 한다. 이 부분에서는 구글, 네이버, 다음과 같은 웹기반 검색엔진을 이용하면 도움이 된다.<br>다음은 경쟁사 분석이다. 선정된 경쟁사들을 대상으로, 각 기업의 상대적인 강점 및 약점 분석을 실시할 수가 있다(즉 경쟁사분석표 작성). 경쟁사 분석이 왜 중요한지 알아보자. 기업은 시장에서 자산과 핵심능력과 경쟁우위를 통해 성공을 이룬다. 성공적인 경쟁사들을 잘 살펴보면 회사성장의 원천요인들을 알 수 있으며, 이들 요인은 비즈니스 아이디어를 탐색하는데 큰 도움이 될 수 있다. 또 경쟁사들의 약점을 보면 어떤 실패를 어떻게 피해 좋은 결과를 얻을 수 있는지 학습할 수가 있다.<br>끝으로, 회사의 경쟁우위 원천요인들을 제시한다. 즉, 경쟁사들에게서 발견한 경쟁우위 원천 요인들을 바탕으로, 본 전자상거래 업체가 어떻게 경쟁력 있는 기업으로 시장에서 발돋움할 것인지 구체적인 경쟁전략을 제시할 수 있어야 한다. SWOT 분석을 통해 전략적 방향을 제시하는 방안도 고려할 수 있다.</p>
<h2><span id="6-운영">6. 운영</span></h2><p>위의 섹션들(즉, 사업개요, 시장분석 및 경쟁사분석)은 모두 전략적인 측면을 다루고 있는데 반해, 여기부터 살펴볼 섹션들은 일상적 운영 측면을 다루는 것이 특징이다. 운영계획은 향후 회사를 운영해 나가는데 관련된 다양한 이슈들을 커버한다.</p>
<p><strong><em>비즈니스 인프라</em></strong></p>
<p>비즈니스의 일상적인 운영 측면을 기술하는 섹션이다. 회사의 물리적 공간 확보, 인력 채용, 업무프로세스 개발 등 기본적인 회사 인프라의 구축 이외에도, 어떠한 시설 및 장비가 필요한가, 인터넷 전문직원을 고용할 것인가 아니면 직원을 내부적으로 훈련시킬 것인가와 같은 이슈에 대해서도 계획을 세워야 한다.</p>
<p><strong><em>경영진</em></strong></p>
<p>누가 회사를 경영할 것이며 그들의 전문지식은 어느 정도인지를 기술해 주는 섹션이다. 회사가 인터넷을 중심으로 운영이 될 것이므로, 경영진이 지닌 인터넷 전문지식의 수준과 더불어 어느 곳에서 지식을 쌓았는지를 토의하여야 한다. 또 경영진의 각기 구성원의 역할도 명시할 필요가 있다.</p>
<p><strong><em>제품 개발</em></strong></p>
<p>전자상거래 창업프로젝트의 기술적인 부분에 해당한다. 이를테면, 쇼핑몰 웹사이트를 개발하고, 결제시스템을 구현하며, 외부 협력업체와의 시스템 통합을 위한 엑스트라넷을 구축하는 것이 그 예에 속한다. 회사 자체의 웹서버를 사용할 것인지 아니면 웹호스팅업체와 계약을 체결할 것인지에 대해서도 결정해야 한다. 또 필요한 시스템을 어떤 방법으로 개발하며, 비용이 얼마나 들지 명시하도록 한다.</p>
<p><strong><em>마케팅</em></strong></p>
<p>판매하고자 하는 제품 및 서비스에 대해 잠재고객들에게 어떻게 소개할 것인지에 대해 기술한다. 근사한 웹페이지를 디자인하는 것은 그 첫 단계에 불과하다. 구축된 웹사이트에 대해 소문을 내는 것이 중요하다. 이를 위해서는, 웹 주소를 검색엔진 데이터베이스에 추가하고 발송하는 이메일 메시지마다 메시지 끝 부분에도 웹주소를 표시하는 등 다양한 효과적 방법들을 동원하여야 한다.</p>
<p><strong><em>가격체계</em></strong></p>
<p>제품 및 서비스에 대해 어떻게 가격을 결정하고 있는가? 제품이 인터넷상에서 배달 가능한 무형의 정보라면, 가격을 정당화하기 위한 가격책정 모델을 개발하여야 한다. 유사 제품을 판매하는 다른 업체들이 어떻게 요금을 부과하는지 조사하는 것도 좋은 출발점이 될 것이다.</p>
<p><strong><em>배송 및 결제</em></strong></p>
<p>제품을 어떻게 배송하며 고객의 결제는 어떻게 해결할 것인가? 이메일만으로는 결제의 안전성은 보장할 수 있으며, 암호화 기법 및 온라인 지불서비스를 고려할 필요가 있다.</p>
<h2><span id="7-재무">7. 재무</span></h2><p>이 섹션은 수익성의 예측을 보여줄 수 있으므로, 잠재적 투자자들의 큰 관심을 끌게 될 부분이다. 일반적인 사업계획서에서와 같이, 관련된 모든 재무제표들을 포함한다. 인터넷상에서 회사를 운영하는데 따른 비용절감 측면을 강조해 보여줄 필요가 있다.<br>재무제표 섹션에 포함되어야 하는 첫 번째 재무제표는 매출발생 이전 시점까지 회사 운영을 준비하기 위해 투입되어야 하는 자금지출 항목들을 명시한 초기 자금지출계획(start-up budget)이다. 그 다음으로는 회사 창업 후 3-5년간 회사의 재무상태를 예측하는 재무제표들(즉, 추정 손익계산서, 추정 대차대조표 및 현금출납표)이 제시되어야 한다.</p>
<p>초기 자금운용계획: 새 회사를 창업하는 경우, 매출을 발생시키기 전까지 회사를 창업하는데 필요한 지출항목들을 명기하는 자금지출 계획을 준비할 필요가 있다. 대부분 회사들은 사무실 임대료, 법무비용, 제품개발비, 제조장비 구입비, 차량구입비 등의 항목들이 초기 자금운용계획에 포함된다. 전자상거래 회사의 경우에는 컴퓨터, 소프트웨어, 웹사이트 개발비, 인터넷서비스 이용대금 등이 추가적으로 포함된다.<br>추정 손익계산서: 창업자가 사업아이템에 대하여 미래의 수익과 손익을 미리 분석하는 계산서를 추정 손익계산서라고 한다. 추정 손익계산서는 매출 및 이자와 같은 수입 항목들뿐만 아니라, 매출원가, 관리비, 이자지출, 세금 등과 같은 지출항목들도 포함한다. 이 재무제표에서는 이들 수입 및 지출 항목들을 근거로 하여 영업이익, 세전 이익, 순 이익과 같은 수익관련 수치들을 산출하게 된다.<br>추정 대차대조표: 추정 대차대조표는 회사의 자산, 부채, 그리고 자본금을 명기한 재무제표이다. 손익계산서가 일정 기간 동안의 재무 결과를 보여주는 반면, 대차대조표는 일정 시점에서의 회사 재정상태의 청사진을 보여준다.<br>현금흐름표: 어느 회사의 손익계산서가 이익이 난 것으로 나타나고, 또 대차대조표의 자본금이 양호한 상태라 하더라도, 회사가 실제로는 건실하지 못한 경우가 있다. 그 이유는 회사가 청구된 대금들을 결제하기 위해 즉시 사용 가능한 현금이 항상 필요하기 때문이다. 현금흐름표의 주요 목적은 일정 기간 동안 회사의 현금상태의 변동을 모니터하는 것이다. 유입되는 현금항목들과 유출되는 현금항목들을 이 현금흐름표에 모두 기록하여야 한다. 현금흐름표의 내용은 어떤 면에서는 손익계산서와 유사하다고 할 수 있지만, 수입항목들과 지출항목들이 실제로 현금변동이 있는 경우에만 기록된다는 점이 다르다고 할 수 있다.</p>
<h2><span id="8-추진-일정">8. 추진 일정</span></h2><p>제안한 내용을 현실화하기 위해 거쳐야 하는 단계들에 대해 추진일정 계획을 제시하는 부분이다. 이 일정을 개발하는데 있어, 다른 인터넷 회사들과의 대화를 통해 회사를 인터넷상에 띄우는데 얼마의 기간이 소요됐는지 알아보면 도움이 될 수 있다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2017/12/26/css-스크롤바-숨기기/" itemprop="url">
                css 스크롤바 숨기기
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2017-12-26T13:44:19.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                a few seconds read (About 5 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#element::-webkit-scrollbar &#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                        
    </div>
    
            
</article>



        
    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/page/16/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/page/18/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/">1</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/16/">16</a></li>
        
        <li><a class="pagination-link is-current" href="/page/17/">17</a></li>
        
        <li><a class="pagination-link" href="/page/18/">18</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/23/">23</a></li>
        
    </ul>
</nav>
    
    </div>
</section>

            <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 Jake.Lee 이남훈&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" href="https://github.com/frontalnh">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
                <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        //plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110077250-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-110077250-2');
</script>


    


<script src="/js/script.js"></script>

                    
                        <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
                            
</body>

</html>