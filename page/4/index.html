<!DOCTYPE html>
<html class="has-navbar-fixed-top">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Jake.Lee&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="google-site-verification" content="PgpnJMuvO-IqYWyFljnyr-tusLhJUz1VRMmECenJyHE">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">






<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="/css/style.css">
<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>

</head>

<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">Categories</a>
            
            <a class="navbar-item " href="/tags">Tags</a>
            
            <a class="navbar-item " href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" href="https://github.com/frontalnh">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

        <section class="section">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6354931397950820",
    enable_page_level_ads: true
  });
</script>

    <div class="container">
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/03/03/how-to-start-a-startup/" itemprop="url">
                How to start a startup
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-03-03T02:43:58.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                7 minutes read (About 1021 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>제품을 만들고 고객과 대화를 하는 것 외에는 하지마라.</p>
<h2><span id="사업-계획의-수립">사업 계획의 수립</span></h2><p>일단 아이디어가 어느정도 구체화 되었다면, 해당 아이디어에 대한 시장 가능성과 실제 아이디어의 실행을 위한 방법들을 수립해야 하며 크게 <strong>상황분석 =&gt; 전략 수립 =&gt; 전략 실행</strong> 의 흐름으로 이어진다.</p>
<h4><span id="시장과-경쟁자에-대한-명확한-분석을-통해-독보적인-차별점을-도출하자">시장과 경쟁자에 대한 명확한 분석을 통해 독보적인 차별점을 도출하자</span></h4><p>여기서 가장 먼저 해야 할 일은 바로 기업의 내부적 정보와 외부적 정보를 수집하는 것이다. 가령 우리 스타트업이 가장 잘하는 것은 무엇인지 또 할 수 있는것과 할 수 없는 것은 무엇인지 우리가 다른 스타트업에 비해 뛰어나게 잘하는 것과 부족한 것이 무엇인지를 냉철하게 판단해야 한다. 이를 위해서는 하고자 하는 비즈니스에 끊임없는 고민이 필요하며, 시장에 어떤 경쟁자들이 있고, 그들의 강점과 약점이 무엇인지를 명확하게 이해하는 것이 중요하다. <strong>대부분의 성공한 스타트업들은 이미 시장에 자리잡은 경쟁자가 있음에도 불구하고 명확한 차별점을 내세우고 기존 시장에 참여한 기업들이다</strong> 즉, 시장을 분석하고 내가 가장 잘 하는 강점을 무기로 삼아 시정을 침투해야하며, 이를 위한 정보의 수집은 매우 중요하다.</p>
<p>가장 간단하게는 다음과 같은 질문을 해볼 수 있다.</p>
<ol>
<li>나와 우리 팀이 가장 잘하는 것은 무엇이고 그 근거는 무엇인가?</li>
<li>이미 시장에 있는 경쟁자들이 잘하는 것은 무엇이고 우리가 그들보자 나은점이 무엇인가?</li>
<li>시장의 고객들은 기존 경쟁자들의 어떤 차별점에 반응하고, 그들의 체워지지 않은 니즈는 무엇인가?</li>
</ol>
<h4><span id="현상분석">현상분석</span></h4><p>다음으로 조사해야할 부분은 시장의 상황과 트렌드 그리고 다양한 이슈들을 말미암아 스타트업의 성공가능성과 실패 가능성을 점치는 것이다. 가령 커피를 판다고 하면 시장에 어떤 커피들이 인기를 끌고 있으며, 전체 커피 시장과 고객의 니즈는 향후 어떤 방향으로 나아갈 것인가에 대한 분석이 이것이다.</p>
<p>고객의 선호와 취향이 변모해 나가는 트렌드를 이해하고 하고자 하는 비즈니스가 그 흐름에 부합하는 지를 숙고하자.</p>
<h4><span id="비즈니스-전략의-수립">비즈니스 전략의 수립</span></h4><p>내가 시장의 다른 경쟁자들에 비해 무엇을 잘하고, 또 경쟁력을 가지지 못하는 약점을 명확하게 인지하였다면, 기업의 모든 자원을 기업이 가진 강점에 쏟아부어야 한다. 가량 다른 기업이 이미 잘하고 있고, 그들이 가진 강점의 나와 우리 팀이 아무런 근거 없이 ‘더 잘할 수 있다’ 라는 마인드 셋으로 전략을 세우는 것은 많은 스타트업이 하는 실수이다. </p>
<p>여기서 세운 전략을 기업을 운영함에 있어 잊지 말아야 할 본질이고, 나의 모든 자원을 합리적으로 분배할 근거가 되기에 이 내용을 바탕으로 말미암아 기업의 사명 선언문과  단기적 프로젝트의 목표를 규정한다.</p>
<h4><span id="구체적인-실행계획-수립">구체적인 실행계획 수립</span></h4><p>사업의 큰 정책적 방안을 수립하였다면 단기적인 실행 계획을 세운다.</p>
<p>구체적인 실행의 일정부터 예산이 허락하는 범위 내에서 짜임새 있는 예산안을 수립한다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/03/01/how-to-write-a-pitch-email/" itemprop="url">
                How To Write A Pitch Email
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-03-01T04:48:46.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/email/">email</a><span>></span><a class="article-category-link" href="/categories/email/pitch/">pitch</a><span>></span><a class="article-category-link" href="/categories/email/pitch/sales/">sales</a><span>></span><a class="article-category-link" href="/categories/email/pitch/sales/business/">business</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                5 minutes read (About 779 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h4><span id="no-cold-email">no cold email</span></h4><p>가급적으로 cold 이메일을 피하는 것은 매우 중요하다.</p>
<p>이메일 피칭은 일종의 sales 이며, 수신자는 이를 즉시 인지하게 된다.</p>
<p>때문에 부정적인 이미지를 주지 않기 위해 warm introduction 을 하는 것이 매우 중요하다.</p>
<p>가장 많이 하는 실수중 하나는 여러 명의.사람들에게 무작위 cold email 을 보내는 것이다. 이는 personalized 되지도 않았고 무작위로 copy and paste 되기 일쑤이다.</p>
<p>이는 전혀 효과적이지 않다.</p>
<p>수신자는 당신의 프로모션에 관심이 없고, 당신을 만나야 할 이유가 명확하게 5초 이내에 설득되지 않으면 당신의 이메일은 쓰레기통으로 들어갈 것이다.</p>
<h4><span id="주제문단이-가장-가장-가장-가장-중요하다">주제문단이 가장 가장 가장 가장 중요하다.</span></h4><p>다른 수많은 이메일과 독보적인 차이를 보이지 못하면 바로 삭제될 것이다</p>
<h4><span id="기본-포맷">기본 포맷</span></h4><p>첫문단에서는 간단한 인사를 건내고 그 사람의 신상정보에 대해 아는 것이 있다면 작성해라. SNS 나 링크드인에서 찾은 사람이 있다면 언급해주자.</p>
<p>두번째 문단에서는 제품에 대한 피칭을 진행한다.3~4 줄로</p>
<p>세번째 문단에서는 해당 제품이 해당 기업에 어떤 가치를 제공할지에 대해 이야기 하라 어떤 기회를 가져다주고 해당 기업을 조사하여 personalize 해야한다. 만약 가격을 제시한다면 이곳이 적당하다.</p>
<p>마지막 문단에서는 인사를 하고 전화나 이메일로 컨택을 요청한다.</p>
<h4><span id="제일-중요한-것은-진정성이다">제일 중요한 것은 진정성이다.</span></h4><p>피칭 메일을 작성하는 사람의 머릿속에 드는 가장 큰 생각은 바로 어떻게 내 제품을 사게 만들것인가이다. 하지만, 진정으로 수신자의 마음을 움직이기 위해서는 진정으로 그 사람을 이해하고 우리가 그들에게 제공할 수 있는 가치가 무엇인지를 계속 고민해야 한다.</p>
<p>만약, 메일을 쓰는 내내 그들의 입맛ㅇ르 당기게 하고, 제품만 팔고자 하는 마음을 가지고 있다면, 정말 진정성 있는 제안서가 나오기 힘들다. 특히 이런저런 이메일 피칭법을 보고 다른 피칭 메일을 참조하면서 정형화된 형식의 메일만이 나올뿐이며, 그 메일은 아마도 수신자의 마음을 움직이지는 못할 것이다. </p>
<p>피칭을 하는 과정은 내 제품을 이해하고 받는 이에게 내가 어떤 가치를 제공할 수 있는지를 고민하는 과정이지, 내 판매고를 올리기 위한 과정이 아니다.</p>
<p>내가 가진 제품의 확실한 경쟁력을 계속해서 제고하면서 진정성 있는 메일을 작성해야 할 것이다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/02/28/getting-started-with-truffle/" itemprop="url">
                Getting started with truffle
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-02-28T07:23:50.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                a few seconds read (About 7 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g truffle</span><br><span class="line">truffle init</span><br></pre></td></tr></table></figure>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/02/28/signing-and-verifying-in-ethereum/" itemprop="url">
                Signing and verifying in ethereum
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-02-28T02:31:29.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/ethereum/">ethereum</a><span>></span><a class="article-category-link" href="/categories/ethereum/blockchain/">blockchain</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                15 minutes read (About 2311 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="signing-and-verifying-in-ethereum">Signing and verifying in ethereum</span></h1><p>이더리움에서 eth 를 송금하거나 스마트 컨트랙을 부르는 등의 transaction 을 일으키기 위해서는 signing 이 필요하며, 블록체인 상에서 사용자를 인증하거나 메세지의 유효성을 검증하기 위해 signing 과 validation 이 사용된다.</p>
<p>가령, Alice 가 Bob 에게 어떤 메세지를 보내는 상황을 전제해 보자. 여기서 Bob 이 메세지를 받았다면, 인터넷 네트워크에서는 누구든지 메세지를 보낼 수 있고, 나쁜 의도를 가진 다수의 사용자들이 존재하기 때문에, 진짜 그 메세지가 Alice 로 부터 온 것인지 또, 메세지의 내용이 Alice 가 보낸 그 내용이 맞는지에 대해 의문을 품을 것이다. 이 때문에 블록체인 에서는 signing 의 개념이 존재하며 여기서 그 유효성을 검증하고자 하는 대상을 <strong>message</strong> 라고 한다.</p>
<p>그렇다면 이제 어떻게 <strong>signging</strong> 과 <strong>validation</strong> 이 진행되는 지를 알아보자. </p>
<p>먼저 위 사례에서 Alice 는 자신의 <strong>Private Key</strong> 로 해당 메세지에 서명을 한다. 이더리움에서 제공하는 web3 를 통해 다음과 같은 간략한 명령을 통해 이런 <strong>signing</strong> 이 진행되게 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.sign(message, privateKey);</span><br></pre></td></tr></table></figure>
<p> 위 에서 message 는 유효성을 검증하기 위한 메세지로 <code>String</code> 타입이다.</p>
<p>위 과정을 거치면 사용자가 서명을 한 메세지를 의미하는 <strong>Signature Object</strong> 가 나오게 되는데 그 형식은 다음과 같다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    message: 'Some data',</span><br><span class="line">    messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',</span><br><span class="line">    v: '0x1c',</span><br><span class="line">    r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',</span><br><span class="line">    s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',</span><br><span class="line">    signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f\</span><br><span class="line">    	5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위에서 알 수 있듯이 <strong>Signature</strong> 에는 사용자의 원래 메세지 뿐만 아니라 <strong>messageHash</strong> 라는 <code>&quot;\x19Ethereum Signed Message:\n&quot; + message.length + message</code> 의 양식으로 포맷팅된 후 keccak256(SHA3) 으로 해쉬된 해시값을 비롯하여 signature 를 구성하는 v, r, s 와 실제 서명인 <strong>Signature</strong> 가 포함된다. 여기서 r 과 s 는 각각 <strong>Signature의 첫 32byte 와 뒤 32byte 를 나타낸다.</strong></p>
<p>* <strong>위의 MessageHash</strong> 는 web3 가 제공하는 <strong>hashMessage(message)</strong> 함수 호출을 통해서도 얻을 수 있다.</p>
<p>위처럼 sign 을 완료했다면, 해당 <strong>Signature</strong> 를 받은 사용자는 다음과 같은 <strong>recover</strong> 함수 호출을 통해 올바른 사용자인지를 판별 할 수 있다.</p>
<p>example</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.recover(signatureObject);</span><br><span class="line">web3.eth.accounts.recover(message, signature [, preFixed]);</span><br><span class="line">web3.eth.accounts.recover(message, v, r, s [, preFixed]);</span><br><span class="line"></span><br><span class="line">web3.eth.accounts.recover(&#123;</span><br><span class="line">    messageHash: <span class="string">'0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655'</span>,</span><br><span class="line">    v: <span class="string">'0x1c'</span>,</span><br><span class="line">    r: <span class="string">'0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd'</span>,</span><br><span class="line">    s: <span class="string">'0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029'</span></span><br><span class="line">&#125;)</span><br><span class="line">&gt; <span class="string">"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// message, signature</span></span><br><span class="line">web3.eth.accounts.recover(<span class="string">'Some data'</span>, <span class="string">'0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'</span>);</span><br><span class="line">&gt; <span class="string">"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// message, v, r, s</span></span><br><span class="line">web3.eth.accounts.recover(<span class="string">'Some data'</span>, <span class="string">'0x1c'</span>, <span class="string">'0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd'</span>, <span class="string">'0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029'</span>);</span><br><span class="line">&gt; <span class="string">"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23"</span></span><br></pre></td></tr></table></figure>
<h2><span id="eip712">EIP712</span></h2><h4><span id="what-is-eip712">What is EIP712</span></h4><p>EIP 712 란 <strong>Ethereum Improvement Proposals 712</strong> 의 약어로 이더리움에서 향후 지원하게 될 다양한 제안들중 하나이다. 과거 사용자가 어떤 거래를 함에 있어 sign 을 할때에는 sign 의 대상이 되는 message 가 hash 화 되어 존재하기 때문에, 서명을 하는 사용자가 자신이 서명하는 내용에 대해 잘 알기 힘든 문제가 있었으며, 가령 유사한 해시값을 가진 피싱 사이트로 유도하여 사이닝을 유도한다던가 하는 다양한 위험에 노출되어 있었다.</p>
<p>이를 해결하기 위해 안전하고 값이 변조되지 않는 해싱을 보장하면서도 readability 를 가질 수 있는 서명방법을 고안하게 되었으며 그 제안내용이 EIP712 에 제안되었다.</p>
<p>EIP712 를 통해 사용자는 자신이 서명하는 정보에 대해 명확하게 인지할 수 있게 된다고 볼 수 있다.</p>
<p>가령, 위에서처럼 <strong>일반적인 signing의 과정에서는 sign 을 요청하는 사람이 제공하는 message값(주로 hash값) 만을 보고 사용자가 sign 을 진행하지만 EIP712 에서는 json 데이터를 보고 자신이 서명하는 데이터를 명확히 알 수 있다.</strong></p>
<p>다음은 EIP712 를 통해 수행되는 서명의 방법을 나타낸다.</p>
<p>먼저 서명을 하고자 하는 데이터의 형태를 정의하는데 이러한 <code>typed structured data</code> 를 먼저 정의하는 것으로 서명이 시작된다. 아래와 같이 서명을 하고자 하는 메세지를 json 형태로 정의를 한다. 서명자는 아래와 같은 데이터를 통해 어떤 내용에 자신이 서명을 하는지 알 수 있다.(아래의 메세지는 meta mask 등의 지갑 어플리케이션에서 파싱되어 보여지며, EIP712 는 이러한 지갑 어플리케이션에서 제공하는 기능을 말미암에 제공된다.)</p>
<p>컨트랙트 도메인 타입의 정의</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> domain = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"name"</span>, <span class="attr">type</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"version"</span>, <span class="attr">type</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"chainId"</span>, <span class="attr">type</span>: <span class="string">"uint256"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"verifyingContract"</span>, <span class="attr">type</span>: <span class="string">"address"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"salt"</span>, <span class="attr">type</span>: <span class="string">"bytes32"</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bid = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"amount"</span>, <span class="attr">type</span>: <span class="string">"uint256"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"bidder"</span>, <span class="attr">type</span>: <span class="string">"Identity"</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> identity = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"userId"</span>, <span class="attr">type</span>: <span class="string">"uint256"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"wallet"</span>, <span class="attr">type</span>: <span class="string">"address"</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">    amount: <span class="number">100</span>,</span><br><span class="line">    bidder: &#123;</span><br><span class="line">        userId: <span class="number">323</span>,</span><br><span class="line">        wallet: <span class="string">"0x3333333333333333333333333333333333333333"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>위처럼 서명하고자 하는 <strong>message</strong> 를 정의하였다면, 해당 메세지가 어떤 도메인 사업자(즉 DAPP 사업자로 이해할 수 있다) 에서부터 온 메세지인지를 나타내는 구분자인 <strong>Domain Separator</strong> 를 정의해 준다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> domainData = &#123;</span><br><span class="line">    name: <span class="string">"My amazing dApp"</span>,</span><br><span class="line">    version: <span class="string">"2"</span>,</span><br><span class="line">    chainId: <span class="built_in">parseInt</span>(web3.version.network, <span class="number">10</span>),</span><br><span class="line">    verifyingContract: <span class="string">"0x1C56346CD2A2Bf3202F771f50d3D14a367B48070"</span>,</span><br><span class="line">    salt: <span class="string">"0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a558"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>name</strong>: DAPP 혹은 Protocol 의 이름</p>
<p><strong>version</strong>: DAPP 혹은 Platform version</p>
<p><strong>chainId</strong>: 테스트 넷인지 메인넷인지 등을 구분하는 chain id 로 EIP155 에서 제안되었다.</p>
<p><strong>verifyingContract</strong>: 해당 signature 를 verify 할 스마트 컨트랙트의 주소</p>
<p><strong>salt</strong>: 32 바이트의 hard code 된 유니크한 값으로 컨트랙트와 DAPP 사이에 공유되어 다른 DAPP 과 구분되는 최후의 보루이다.</p>
<p><strong>message type 과 Domain separator 가 정의되었다면 다음과 같이 Json 형태의 data 를 만들고 이를 stringily 시켜  sign 을 요청한다. </strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    types: &#123;</span><br><span class="line">        EIP712Domain: domain,</span><br><span class="line">        Bid: bid,</span><br><span class="line">        Identity: identity,</span><br><span class="line">    &#125;,</span><br><span class="line">    domain: domainData,</span><br><span class="line">    primaryType: <span class="string">"Bid"</span>,</span><br><span class="line">    message: message</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">web3.currentProvider.sendAsync(</span><br><span class="line">&#123;</span><br><span class="line">    method: <span class="string">"eth_signTypedData_v3"</span>,</span><br><span class="line">    params: [signer, data],</span><br><span class="line">    <span class="keyword">from</span>: signer</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> signature = result.result.substring(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> r = <span class="string">"0x"</span> + signature.substring(<span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">const</span> s = <span class="string">"0x"</span> + signature.substring(<span class="number">64</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">const</span> v = <span class="built_in">parseInt</span>(signature.substring(<span class="number">128</span>, <span class="number">130</span>), <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// The signature is now comprised of r, s, and v.</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>data 내의 <code>types</code> 필드는 스마트 컨트랙트 내에서의 데이터 구조를 나타내며 반드시 <code>struct name</code> 과 정확히 일치해야한다. 또한 <code>PrimaryType</code> 은 데이터 구조에서의 최상위 자료 구조형이 무엇인지 명시한다.</p>
<h4><span id="validation-in-smart-contract">Validation in Smart contract</span></h4><p>클라이언트에서 signing 을 위해 formatting 과 hashing 을 거친 것처럼 같은 내용의 코드가 Smart Contract 에도 포함되어야 한다. 이 과정을 통해 <code>ecrecover</code> 함수를 통해 해당 서명에 사인한 account 의 address 를 알 수 있다.</p>
<p>인증을 위한 Contract 를 위해 제일 먼저 EIP712 에서 앞서 정의한 data type 을 struct 로 정의해야 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Identity &#123;</span><br><span class="line">    uint256 userId;</span><br><span class="line">    address wallet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Bid &#123;</span><br><span class="line">    uint256 amount;</span><br><span class="line">    Identity bidder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그 다음으로는 위 data structure 에 맞는 <code>type hash</code> 를 정의해야 하며 그 코드는 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string private constant IDENTITY_TYPE = &quot;Identity(uint256 userId,address wallet)&quot;;</span><br><span class="line">string private constant BID_TYPE = &quot;Bid(uint256 amount,Identity bidder)Identity(uint256 userId,address wallet)&quot;;</span><br></pre></td></tr></table></figure>
<p>여기서 comma 와 bracket 사이에 공백이 들어가지 않는것을 유념하자. 또한, parameter 의 이름과 자료형이 클라이언트의 자료형과 변수명과 완벽하게 일치해야 한다.</p>
<p>또한 다음과 같이 <code>Domain Separator</code> 도 다음과 같이 hashify 되어야 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint256 constant chainId = 1;</span><br><span class="line">address constant verifyingContract = 0x1C56346CD2A2Bf3202F771f50d3D14a367B48070;</span><br><span class="line">bytes32 constant salt = 0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a558;</span><br><span class="line">string private constant EIP712_DOMAIN = &quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)&quot;;</span><br><span class="line">bytes32 private constant DOMAIN_SEPARATOR = keccak256(abi.encode(</span><br><span class="line">    EIP712_DOMAIN_TYPEHASH,</span><br><span class="line">    keccak256(&quot;My amazing dApp&quot;),</span><br><span class="line">    keccak256(&quot;2&quot;),</span><br><span class="line">    chainId,</span><br><span class="line">    verifyingContract,</span><br><span class="line">    salt</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<p>아래와 같이 각 data 를 hashify 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function hashIdentity(Identity identity) private pure returns (bytes32) &#123;</span><br><span class="line">    return keccak256(abi.encode(</span><br><span class="line">        IDENTITY_TYPEHASH,</span><br><span class="line">        identity.userId,</span><br><span class="line">        identity.wallet</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hashBid(Bid memory bid) private pure returns (bytes32)&#123;</span><br><span class="line">    return keccak256(abi.encodePacked(</span><br><span class="line">        &quot;\\x19\\x01&quot;,</span><br><span class="line">       DOMAIN_SEPARATOR,</span><br><span class="line">       keccak256(abi.encode(</span><br><span class="line">            BID_TYPEHASH,</span><br><span class="line">            bid.amount,</span><br><span class="line">            hashIdentity(bid.bidder)</span><br><span class="line">        ))</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>마지막으로 다음과 같이 signature 를 verify 하는 함수를 작성해 준다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function verify(address signer, Bid memory bid, sigR, sigS, sigV) public pure returns (bool) &#123;</span><br><span class="line">    return signer == ecrecover(hashBid(bid), sigV, sigR, sigS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="keccak256-hashing">Keccak256 hashing</span></h2><p>이더리움에서는 SHA3 해싱을 위해 <strong>keccak256</strong> 을 사용한다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/02/25/getting-started-with-dex/" itemprop="url">
                Getting started with DEX
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-02-25T09:56:01.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/dex/">dex</a><span>></span><a class="article-category-link" href="/categories/dex/blockchain/">blockchain</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                12 minutes read (About 1868 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h2><span id="what-is-dex">What is DEX?</span></h2><p><strong>DEX</strong> 란 <strong>Decentralized Exchange</strong> 의 약어로 중간자 없이 가상화폐 지갑과 지갑 사이의 p2p 교환을 해주는 것이다.</p>
<p>DEX 에서는 <code>custody</code> 즉, 누가 거래에서의 키를 보관하는가에 대한 중대한 이슈가 있으며, DEX 는 모든 교환과정에 있어 개인이 키를 소유하고 완변하게 decentralized 되 토큰의 교환을 하는 것에 그 목적이 있다.</p>
<h2><span id="basic-procedure">Basic Procedure</span></h2><p>본 프로젝트에서 DEX 의 기본적인 프로세스는 다음과 같다.</p>
<p>먼저, 브라우저 상에서 토큰의 교환을 원하는 사용자가 <strong>매도 혹은 매수 주문</strong>을 걸면, 해당 주문정보를 EIP 712 로 서명한 서명정보와 함께 전달하면, <strong>Relayer API 를 통해 해당 기록이 off-chain 상의 orderbook 에 기록</strong>되게 된다. 그 이후, orderbook 을 조회하여 여러 주문들의 쌍을 받아와 <strong>교환이 가능한 거래쌍을 선정</strong>하여 <strong>스마트 컨트랙으로 전송</strong>한다.(즉, 하나의 taker order와 하나 이상의 maker order 들을 전달하며, 모든 주문은 서명이 완료된 주문이다. 여기서, 전송을 하는 과정에 있어 주문에 필요한 다양한 정보들을 전부 parameter 로 전달하면 gas 비 문제등 많은 문제들이 존재하기 때문에, <strong>거래에 필요한 데이터를 <code>data</code> 라는 필드로 만들어 <code>OrderParam</code> 에 포함하여 전달</strong>한다.</p>
<p>또한, <strong>위 과정을 진행함에 앞서</strong> 실제 거래의 주체가 아닌 relayer 를 통해 자금을 교환하기 때문에 플랫폼에서 만들어둔 <strong>relayer account 를 approve 하여 일정 자금에 대한 사용권한을 주어야</strong> 한다.</p>
<p>스마트 컨트랙에 전달된 인자들이 들어오면, 컨트랙은 주어진 주문 쌍을 분석하여 거래를 진행하기 위한 <code>Result</code> 들의 집합으로 나누고, 해당 주문을 <code>filled</code> 라는 <code>orderHash:amount</code> 쌍에 기록한다.</p>
<p><img src="/images/dex_process.png" alt="dex process"></p>
<h2><span id="smart-contract">Smart Contract</span></h2><h4><span id="주문의-전달">주문의 전달</span></h4><p>모든 주문은 Order Server 내의 orderbook 에 기록되고, 매칭이 가능한 조합들을 모아 스마트 컨트랙트의 <code>matchOrders</code> 를 호출하며, 그 인자는 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OrderParam memory takerOrderParam,</span><br><span class="line">OrderParam[] memory makerOrderParams,</span><br><span class="line">OrderAddressSet memory orderAddressSet</span><br></pre></td></tr></table></figure>
<p>여기서 order param 은 주문에 필요한 maker와 taker 의 요청정보이며, 그 형태는 다음과 같다.</p>
<p>OrderParam</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct OrderParam &#123;</span><br><span class="line">    address trader;</span><br><span class="line">    uint256 baseTokenAmount;</span><br><span class="line">    uint256 quoteTokenAmount;</span><br><span class="line">    uint256 gasTokenAmount;</span><br><span class="line">    bytes32 data; # 주문정보를 조합하여 32byte 로 축약, 가스비 절약 목적</span><br><span class="line">    OrderSignature signature; # EIP 712 서명</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위에서 <code>base token</code> 과 <code>quote token</code> 이 무엇인지 헷갈릴 수 있는데, <code>taker</code>가 매도 혹은 매수를 할때 기준이 되는 토큰을 <code>base token</code>이라고 한다. 즉, <code>taker</code> 가 특 정 토큰을 구매한다고 하면 그 구매의 대상이 되는 토큰을 base token 이라고 하며, 판매를 한다고 하면, 판매의 대상이 되는 그 토큰을 quote token 이라고 한다.</p>
<p>또한 여기서 <strong>OrderSignature 는 브라우저가 생성하고자 하는 주문정보를 EIP 712 로 서명한 서명정보</strong>로 추후 스마트 컨트랙트에서 해당 사용자의 주문정보를 해시하여 위 시그내처를 통해 유효성을 검증하는 과정을 거친다.</p>
<hr>
<p><strong>인증과정에서의 데이터의 흐름</strong></p>
<p>사용자의 orderParam 쌍 =&gt; param 의 data property 에서 order rebuild =&gt; EIP712 hash 를 orderParam 의 signature 로 validate</p>
<hr>
<p>* <strong><em>여기서 signature 의 목적은 무엇일까?</em></strong></p>
<p>여기서 signature 는 사용자가 본래 요청하고자 했던 주문정보가 스마트 컨트랙트에서 체결되는 시점에도 해당 사용자가 요청한 주문과 내용이 맞는지 검증하는 것이다.</p>
<p>가령, DEX 에서 두 사용자가 거래를 진행할때 다른 사용자가 특정 사용자의 계정을 스마트컨트랙에 거래를 요청하는 경우, 주문정보가 동일하더라도 주문을 작성한 유저가 요청한 주문이 아니므로 거래가 이루어 져서는 안되며, 특정 주문내용을 바꾸어서 컨트랙트에 체결을 요청하는 등 다양한 악용을 막는 역할을 수행한다.</p>
<p>* <strong><em>EIP 712 란 무엇인가?</em></strong></p>
<p>EIP 712 란 <strong>Ethereum Improvement Proposals 712</strong> 의 약어로 이더리움에서 향후 지원하게 될 다양한 제안들중 하나이다. 과거 사용자가 어떤 거래를 함에 있어 sign 을 할때에는 sign 의 대상이 되는 message 가 hash 화 되어 존재하기 때문에, 서명을 하는 사용자가 자신이 서명하는 내용에 대해 잘 알기 힘든 문제가 있었으며, 가령 유사한 해시값을 가진 피싱 사이트로 유도하여 사이닝을 유도한다던가 하는 다양한 위험에 노출되어 있었다.</p>
<p>이를 해결하기 위해 안전하고 값이 변조되지 않는 해싱을 보장하면서도 readability 를 가질 수 있는 서명방법을 고안하게 되었으며 그 제안내용이 EIP712 에 제안되었다.</p>
<p>EIP712 를 통해 사용자는 자신이 서명하는 정보에 대해 명확하게 인지할 수 있게 된다고 볼 수 있다.</p>
<p>EIP 서명의 절차에 대해 간략하게 소개하면, 먼저 서명을 하고자 하는 데이터의 형태를 정의하는데 이러한 <code>typed structured data</code> 를 먼저 정의하는 것으로 서명이 시작된다. 데이터의 정의가 완료되면, 여러 DAPP 들 사이에 구별되기 위한 <strong>domain separator</strong> 를 정하여 서명을 검증할 스마트 컨트랙트의 주소부터 version, salt 등의 데이터로 구성된다.</p>
<p>EIP 서명이 완료되면, 사용자는 signature 를 얻게 되며 추후 스마트 컨트랙트는 주문정보를 직접 해싱하여 사용자가 제공한 signature 로 validation 을 진행하여 유효성을 검증한다.</p>
<h4><span id="거래의-체결">거래의 체결</span></h4><p>matchOrders 함수가 호출되는 시점에 매칭된 오더들의 정보가 <code>filled</code> 에 <code>orderHash:filledAmount</code> 의 mapping 형태로 기록되며, 만약 주문이 체결되었다면 기존에 있던 주문들에 새로운 주문이 발생하면서 체결이 될 것이다.</p>
<p>여기서 기존에 있던 주문을 한 사용자를 <code>maker</code> 라 칭하며, 주문을 체결하는 주문을 발생시킨 사용자를 <code>taker</code> 라 명명한다.</p>
<p>또한, 거래의 특성상 <code>taker</code> 가 넣은 주문을 만족시키는데 필요한 하나 이상의 주문이 필요하게 되므로 주문이 매칭 될 때에는 하나의 <code>taker</code> 주문에 한개 이상의 <code>maker</code> 주문이 매칭된다.</p>
<h4><span id="taker-의-매도-주문">Taker 의 매도 주문</span></h4><p><code>taker</code> 의 매도주문으로 인해 주문이 체결되는 경우의 시나리오는 다음과 같으며, n개의 거래쌍이 이루어 졌다고 전제한다.</p>
<ol>
<li>maker 가 relayer 에게 만족하는 quote token 과 maker fee, maker gas fee(maker rebate fee 는 차감한다.) 를 n번 지급한다.</li>
<li><code>taker</code> 가 <code>maker</code> 에게 만족하는 base token 을 n번 지급한다.</li>
<li><code>relayer</code> 가 <code>taker</code> 에게 만족하는 quote token 중 taker gas fee 를 제하고 1회 지급한다.</li>
</ol>
<p><img src="/images/dex_taker_sell.png" alt="dex_taker_sell"></p>
<h4><span id="taker-의-매수-주문">Taker 의 매수 주문</span></h4><p><img src="/images/dex_taker_buy.png" alt="dex_taker_buy"></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/02/25/getting-started-with-solidity/" itemprop="url">
                Getting started with solidity
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-02-25T06:02:34.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                4 minutes read (About 650 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!--toc-->
<h2><span id="restricting-access">Restricting Access</span></h2><p>하나의 컨트랙트 내의 속성들은 다른 컨트랙트에서 접근 될 수 없는 것이 기본이며, <code>public</code> 키워드를 명식적으로 사용함에 따라 다른 컨트랙트에서도 접근이 가능하게 된다.</p>
<p>또다른 접근 제한자로는 <code>modifier</code> 가 있는데, 이는 특정 함수에 지정하여 해당 함수를 호출하기 전에 자격에 맞지 않으면 접근을 제한 할 수 있는 기능을 제공한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract AccessRestriction &#123;</span><br><span class="line">	modifier onlyBy(address _account)</span><br><span class="line">    &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == _account,</span><br><span class="line">            &quot;Sender not authorized.&quot;</span><br><span class="line">        );</span><br><span class="line">        // Do not forget the &quot;_;&quot;! It will</span><br><span class="line">        // be replaced by the actual function</span><br><span class="line">        // body when the modifier is used.</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="data-types">Data types</span></h2><h4><span id="memory-and-storage">memory and storage</span></h4><p>solidity 에서 memory 와 storage 를 이루는 데이터 chunk 의 크기는 32bytes 이다.</p>
<p><strong>memory</strong> 란 모든 함수 call 마다 새롭게 할당되는 임시 데이터 저장소로 이 메모리에 읽기, 쓰기 등의 작업을 수행할 때마다 가스비가 올라간다.</p>
<h4><span id="variables">variables</span></h4><p>솔리디티에서 변수는 memory address 를 가르치는 포인터이다.</p>
<h4><span id="array">array</span></h4><p>solidity 에서 array 의 첫번째 인자는 그 array 의 길이값을 저장한다.</p>
<h4><span id="bytes">Bytes</span></h4><p>solidity 에서 bytes 는 동적으로 할당되는 byte array 이며, 그 크기는 32byte 이다. 또한, solidity 에서 변수는 memory address 를 가르치는 포인터이므로 해당 포인터로 부터 32 바이트를 더해주면 실제로 해당 bytes 의 값이 저장된 주소값을 얻을 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = new bytes(32);</span><br><span class="line">add(b, 32); // b의 값이 저장된 주소값</span><br><span class="line"></span><br><span class="line">mstore(add(b, 32), x); // b=x</span><br></pre></td></tr></table></figure>
<h2><span id="events">Events</span></h2><p>Event 는 솔리디티에서 일종의 로깅의 역할을 수행한다. 이더리움 상에서 일어나는 다양한 활동들에 대한 내역을 추적하고, 사용자 데이터를 자정하기 위해 이더리움은 로그 시스템을 적용하였으며, <strong>Event</strong> 의 발생은 일종의 로그 형태로 저장된다.</p>
<p><strong>DAPP</strong> 개발자는 이더리움의 RPC 인터페이스를 통해 이러한 이벤트들을 구독할 수 있다. <strong>Topic</strong> 은 이러한 이벤트들을 찾을 수 있도록 해주며, 가령 특정 컨트랙트에서 발생한 로그들을 듣는 등의 일들을 할 수 있다.</p>
<p>여기서 각 이벤트를 정의할 때 다음과 같이 <strong>indexed</strong> 옵션을 주면, 이렇게 구독을 하는 중에 해당 속성을 읽을 수 있다. 만약 <strong>indexed</strong> 옵션을 주지 않으며, ABI 인코딩된 데이터가 내려오게 된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract ExampleContract &#123;</span><br><span class="line">    event ExampleEvent(</span><br><span class="line">        address indexed _from,</span><br><span class="line">        bytes32 indexed _id,</span><br><span class="line">        uint _value</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/02/24/getting-started-with-ethereum/" itemprop="url">
                Getting started with ethereum
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-02-24T02:13:39.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/ethereum/">ethereum</a><span>></span><a class="article-category-link" href="/categories/ethereum/blockchain/">blockchain</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                8 minutes read (About 1144 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="getting-started-with-ethereum">Getting started with ethereum</span></h1><h2><span id="kinds-of-accounts">Kinds of accounts</span></h2><p>이더리움에는 두가지 종류의 account 가 있는데, <strong>External Account</strong> 와 <strong>Contract Account</strong> 가 그것이다.</p>
<p>먼저 <strong>External Account</strong> 는 공개키 방식의 계정이며, <strong>address 역할을 하는 public key</strong> 와 <strong>nonce</strong> 로 구성이 되며, <strong>Contract Account</strong> 는 일반적인 <strong>smart contract</strong> 이다.</p>
<p>여기서 <strong>account 와 account</strong> 사이에 자금이 이동하면 그것을 <strong>transaction</strong> 이라고 말한다.</p>
<h2><span id="transaction">Transaction</span></h2><p>이더리움에서 transaction 이란 하나의 EOA 로부터 다른 account 로 전송되는 message 를 포함한 signed data packet 을 의미하며 다음과 같은 정보들을 담고 있으며, EOA 로 부터 EOA 로 가는 경우는 이더를 송금하는 것을 내포하고, 만약 수신자가 Contract Account 라면 해당 contract 가 어떤 코드를 실행하도록 trigger 하는 것이 된다.</p>
<ul>
<li>receipient</li>
<li>signature</li>
<li>value</li>
<li>data:  which can contain the message sent to a contract</li>
</ul>
<p>여기서 data 는 contract 가 실행에 필요한 정보를 들고 있으며 Contract ABI(Application Binary Interface) 에 따라 컨트랙트와 소통한다. 이 ABI 는 외부 와컨트랙트 간의 상호작용에 필요할 뿐만 아니라 contract 간의 상호작용에도 적용된다.</p>
<p>따라서 data 는 다음의 규약에 따라 인코딩 되어 사용되며 <strong>ABI(Application Binary Interface</strong> 에 따라 정의된다.</p>
<h4><span id="함수-선택자">함수 선택자</span></h4><p>data 의 함수 시그니처의 Keccak-256 (SHA-3) hash 의 첫 4바이트는 어떤 함수를 호출할지를 나타내며 function 시그니처로 부터 도출된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;0.6.0;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function bar(bytes3[2] memory) public pure &#123;&#125;</span><br><span class="line">  function baz(uint32 x, bool y) public pure returns (bool r) &#123; r = x &gt; 32 || y; &#125;</span><br><span class="line">  function sam(bytes memory, bool, uint[] memory) public pure &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 예제에서 baz 함수를 호출하고자 하는 transaction 의 data의 함수선택자는 <code>0xcdcd77c0</code> 인데 이는 method 의 id 로 ASCII format 으로 작성된 function signature 인 <code>baz(uint32,bool</code> 의 Keccak hash(sha3) 의 첫번째 4 바이트이다.</p>
<h4><span id="함수-parameter">함수 Parameter</span></h4><p>또한 해당 함수의 parameter 로 69와 true 를 제공한다면 69를 32바이트 로 패딩한 <code>0x0000000000000000000000000000000000000000000000000000000000000045</code> 가 값이 된다. <code>0x0000000000000000000000000000000000000000000000000000000000000001</code> </p>
<h4><span id="abiapplication-binary-interface">ABI(Application Binary Interface)</span></h4><p>컴퓨터 과학에서 흔히 말하는 ABI 는 <strong>두가지 종류의 binary 프로그램 모듈 사이의 인터페이스</strong>이다. 쉬운 예로는 <strong>library</strong> 와 <strong>operating</strong> 시스템의 경우가 있는데, 하나의 라이브러리는 여러 시스템 상에서 동작해야 하므로 해당 소스코드가 다양한 운영체제에서 동작하기 위해서는 약속된 인터페이스가 필요하다. 또 한 예로는 유저에 의해 실행되는 프로그램의 예가 있는데 가령 여러 운영체제에서 해당 프로그램을 실행하여도 동작하기 위해서는 이러한 ABI 가 정의되어 있어야 한다.</p>
<p>이와 같은 맥락에서 이더리움 에서의 ABI 란 특정 함수가 이더리움에서 실행되기 위한 포맷팅의 규약으로써 이해될 수 있다.</p>
<p>아래는 스마트 컨트랙트 내에서 특정 데이터를 ABI 인코딩 하는 것을 보여준다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encode(&quot;AAAA&quot;)</span><br></pre></td></tr></table></figure>
<p>위 코드는 아래와 같이 3단어로 구성된 96(32byte *3) 사이즈의 바이트 문자열을 리턴한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000000000000000000000000000000000000000000000000000000020</span><br><span class="line">0x0000000000000000000000000000000000000000000000000000000000000004</span><br><span class="line">0x4141414100000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>
<p>한 줄씩 살펴보면 먼저 첫번째 라인은 해당 문자열의 starting offset(32 in decimal) 를 32byte 문자열에 padding 한 것이며, 두번째 문자열은 인코딩 하는 데이터의 길이인 4를 32바이트 문자열에 padding 하여 나타낸다. 마지막으로 세번째 문자열은 실제 우리의 데이터인 “AAAA” 를 UTF-8 인코딩하여 32 바이트 문자열에 padding 하여 나타내어 준다.</p>
<p>위의 encoding 방식보다 다소 간편하게 인코딩을 하고 싶다면  <code>abi.encodePacked(&quot;AAAA&quot;)</code>  라는 함수를 사용할 수 있다. 이 함수는 32바이트보다 작은 문자는 그냥 해당 문자열을 바이트로 출력하고 32바이트에 padding 하지도 않는다.</p>
<p>한가지 흥미로운 사실이 있는데, <code>keccak256</code> 을 사용하여 hashing 을 할때 복수개의 인자를 전달하면 이것을 내부적으로 <code>abi.encodePacked</code> 함수로 인코딩 하여 해싱을 한다는 것이다. 현재는 복수개의 인자를 전달하면 warning 을 출력하기는 하지만, 알아두도록 하자.</p>
<p>다음은 Keccak256 에서 <code>abi.encodePacked</code> 를 사용하는 예이다. 아래의 두 hashing 은 정확히 동일한 역할을 수행한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;AAAA&quot;, &quot;BBBB&quot;, 42);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256(abi.encodePacked(&quot;AAAA&quot;, &quot;BBBB&quot;, 42));</span><br></pre></td></tr></table></figure>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/02/08/getting-started-with-nginx/" itemprop="url">
                Getting started with NGINX
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-02-08T09:10:51.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/nginx/">nginx</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                17 minutes read (About 2562 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h2><span id="what-is-nginx">What is NGINX</span></h2><p>일반적으로 webserver라 하면 http 요청이 들어오면 필요한 작업을 수행하는 서버를 의미합니다.</p>
<p>즉, 브라우저에서 읽을 수 있는 html 파일 등을 전달해 주는 역할을 합니다.</p>
<p>하지만 단순한 정적파일의 제공으로는 동적 파일 렌더링등을 수행할 수 없기 때문에 webserver는 요청을 받으면 웹서버에서 요청을 받아 그 요청을 외부 프로그램에 넘겨주면, 외부 프로그램이 프로그램 파일을 읽어 html로 반환하는 단계를 거치게 되며, 이것을 CGI 라고 합니다.</p>
<p>대표적인 CGI 로는 php fpm 등이 있습니다.</p>
<p><strong>* FAST CGI(Common Gateway Interface) 란 무엇인가?</strong></p>
<p>FastCGI는 상호 작용 프로그램을 웹 서버와 통신하기 위한 바이너리 프로토콜이다.</p>
<p>FastCGI는 초기 공용 게이트웨이 인터페이스(CGI)의 변형이다.</p>
<p>FastCGI의 주 목적은 웹 서버와 CGI 프로그램 간 통신 시 발생되는 부하를 줄임으로써 서버가 한 번에 더 많은 웹 페이지 요청을 관리할 수 있게 하는 것이다.</p>
<p><strong>* php-fpm</strong></p>
<p>nginx가 요청을 받아 php인 경우 cgi 인 php fpm에게 요청을 전달하고 거기서 php 코드를 실행한 뒤에 요청을 다시 받아온다.</p>
<h2><span id="forward-proxy-amp-reverse-proxy">Forward Proxy &amp; Reverse Proxy</span></h2><p>NGINX 는 Web Server 로써 일반적으로 기업에서 서비스를 배포할 때 reverse proxy server의 역할을 수행한다.</p>
<p>Nginx 에 대해 설명하기 전에 먼저  forward proxy 와 reverse proxy의 개념부터 설명하고자 한다.</p>
<p>먼저, <strong>forward proxy server</strong>란  사용자가 원하는 정보를 좀 더 빨리 받게 하기 위해 중간에 요청을 가로채는 것이라 볼 수 있다. 가령 target.com 이라는 주소로 어떤 정보를 받아오고 싶은 유저가 있다고 생각해 보자.</p>
<p>이 유저는 주소창에 target.com 을 입력하고 데이터를 받아올 것이며, 이 유저는 자신이 보고 있는 정보가 target.com 에서 보낸 정보라고 생각할 것이다. 하지만 대부분의 경우 유저가 받아온 정보는 실제로 target.com에 있는 정보가 아닌 중간의 프록시 서버에서 이전에 받아놓은 target.com 의 정보를 전달해 주는 것이다.</p>
<p>이러한 proxy server 는 많은 이점을 제공해 주는데, 가령 우리가 목적으로 하는 target.com 의 경우 우리의 ip 주소에 대해서는 알수가 없고, 우리가 사용하는 proxy  서버의 url 에 대해서만 알 수 있다.(하지만 대부분의 경우 browser가 우리의 정보를 제공하기 때문에 사실상은 다 알수 있다..!)</p>
<p>또한, proxy server 는 이미 알고 있는 정보에 대해서 해당 데이터를 cache 하기 때문에 추가적인 요청 없이 바로 우리에게 원하는 정보를 전달해주기 때문제 네트워크 속도의 관점에서도 더욱 빠르게 동작한다.</p>
<p><strong>NGINX</strong> 는 이러한 forward proxy 의 기능도 수행할 수 있지만, 대부분의 경우 <strong>reverse proxy</strong> 의 용도로 사용되는데, 이는 http server 의 보안 문제 해결과 로그 수집 등 여러 이점을 가지기 때문에 사용된다.</p>
<p>가령, 사용자는 proxy.com 이라는 url 로 요청을 주고 실제 서버의 위치인 target.com url 을 유저로 부터 접근을 불가능 하게 막고, 해당 서버를 VPN 에 구성함으로써 보안을 높일 수 있다.</p>
<h2><span id="how-does-it-works">How does it works?</span></h2><p>NGINX 서버는 nginx 그룹의 nginx 라는 유저로 모든 프로세스를 실행한다.</p>
<p>요청이 들어오면 nginx 는 해당 요청의 hostname 을 보고 설정된 서버들 중 어떤 서버를 사용할지 선택한다.</p>
<p>NGINX 에는 다양한 서버 설정을 할 수 있으며 이는 <code>/etc/nginx/conf.d/</code> 디렉토리에 수많은 conf 파일의 설정들 중에 어떤 서버 설정을 사용할지 결정하는데 있어 hostname 을 사용한다.</p>
<p>여기서 일치하는 hostname이 있다면 해당 설정대로 serving 하되, 만약 일치하는 hostname 이 없다면 <code>default server</code> 를 사용하며 이는 다음과 같이 server 에서 listen 하는 설정에 <code>default_server</code> 태그가 붙어있는 서버를 선택한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80 default_server;</span><br><span class="line">    server_name example.net www.example.net;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>어떤 서버로 부터 serving 할지 결정되었다면, nginx 는 url 패스를 읽어들이고 이를 location 과 비교하여 일치하는 리소스를 찾는 작업을 거치게 된다. 때문에, nginx 에는 여러개의 location 을 설정할 수 있으며, 이 중에서 가장 긴 location path를 우선적으로 선택하게 된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name localhost</span><br><span class="line">    </span><br><span class="line">    location /path &#123;</span><br><span class="line">        root /var/www/example;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="where-to-save-resources">Where to save resources</span></h3><p>서버란 특정 리소스를 제공해주는 역할을 하며, 때문에 서버가 제공할 리소스를 저장하는 공간이 필요하다.</p>
<p>nginx 는 기본적으로 <code>/usr/share/nginx</code> 디렉토리 내에 기본적이 리소스들을 보관한다.</p>
<p>하지만, 해당 디렉토리의 리소스들은 nginx 가 전역적으로 사용하기 위한 <code>50x.html</code> 과 같은 에러 페이지 리소스 등을 비롯한 nginx 어플리케이션 레벨에서의 리소스를 저장하는 공간이므로 실제 서버의 리소스는 이곳에 보관하지 않도록 한다.</p>
<p>대신, <code>/var/www/example.com/</code> 디렉토리를 컨벤션으로 사용한다.</p>
<h2><span id="basic-configuration">Basic Configuration</span></h2><p>NGINX 의 세부 설정은 /etc/nginx/nginx.conf 파일에서 관리된다.</p>
<p>하지만, 이 설정파일은 NGINX 서버 자체에 대한 설정파일로써 웹서비스를 서비스한다면 이 환경 설정은 반드시 <code>etc/nginx/conf.d/example.com.conf</code> 과 같은 파일에 설정을 해야 한다.</p>
<p><code>nginx.conf</code> 파일에서는 nginx 에서 발생하는 error 및 access log 의 저장 위치를 설정하고, 설정파일들의 위치를 명시하여 다른 설정파일을 적용하는 등, 특정 server에 종속된 것이 아니라 nginx 어플리케이션 자체의 설정을 해 준다.</p>
<p>간혹 apache 서버를 사용하던 유저들은  아파치 서버 양식인 <code>/etc/apache/sites-available</code> 와 유사하게 <code>etc/nginx/sites-available</code> 에 서버 설정을 하는 경우가 있는데 이는 좋지 않은 패턴이니 지양하도록 한다.</p>
<p>nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server_tokens       off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>기본적으로 nginx 는 <code>/etc/nginx/conf.d/default.conf</code>  에서 최초의 웹 서버 설정을 해주는데, 별도의 설정파일을 추가한 이후에는 <code>default.conf</code> 파일을 제거하거나 중복된 설정을 없애 주어야 한다. 그렇지 않으면 해당 파일이 default configuration 으로 동작하여 사용자가 한 설정을 덮어써서 설정 내용이 반영이 되지 않게 된다.</p>
<p>개발자는 다음과 같이 example.com.conf 와 같은 설정파일을 작성할 수 있으며 여러 개의 서버와 location 을 지정하고, error page 및 proxy 등 다양한 설정을 할 수 있다.</p>
<p>/etc/nginx/conf.d/example.com.conf </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    </span><br><span class="line">    error_page     500 502 503 504 /50x.html;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass localhost:80</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &apos;upgrade&apos;;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_cache_bypass $http_upgrade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /50x.html &#123;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gzip             on;</span><br><span class="line">    gzip_comp_level  3;</span><br><span class="line">    gzip_types       text/plain text/css application/javascript image/*;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="serving-static-file-and-access-to-local-file-system">Serving static file and access to local file system</span></h3><p>다음과 같이 특정 url 에 파일 시스템 경로를 mapping 함으로써 특정 url 이 정적 파일들을 서빙하게 할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location /images &#123;</span><br><span class="line">        root /var/data/images</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드는 /image 로 오는 요청을 file system 에 매핑하여 요청자가 직접 file system 경로를 통해 리소스를 받아올 수 있게 해준다. 만약 특정 파일 형태만 정적 파일 시스템에 접근하도록 하고 싶은 경우 다음과 같이 regular expression 을 통해 해결 할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location ~\.(gif|jpg|png) &#123;</span><br><span class="line">        root /var/data/images</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="reverse-proxy">Reverse Proxy</span></h3><p>NGINX 서버는 간편하게 Reverse Proxing 을 할 수 있게 해 주며, 다음과 같은 간단한 설정을 통해 reverse proxy 서버를 구축할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name   localhost default_server;</span><br><span class="line"></span><br><span class="line">    location /example1/proxy &#123;</span><br><span class="line">        proxy_pass http://naver.com;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &apos;upgrade&apos;;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_cache_bypass $http_upgrade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 예제는 <code>localhost/example1/proxy</code> 로 들어온 요청을 <code>http://naver.com/example1</code> 로 proxing 해주는 설정파일이다.</p>
<h3><span id="subdomain">Subdomain</span></h3><p>서비스를 출시할때 흔히 다음과 같은 서브 도메인 양식을 가지고 리소스에 접근할 필요가 있게 된다. </p>
<p>가령 관리자 페이지를 위한 admin.example.com 이라던가 혹은 개발서버를 위한 dev.example.com 과 같이 여러 subdomain 이 필요하게 된다. nginx 는 host name 을 인식하여 간편하게 subdomain 을 reverse proxing 해주며 다음과 같은 세팅을 통해 간편하게 이를 적용할 수 있다.</p>
<p>다음 예제는 localhost 환경에서 앞에 example1 이라는 prefix 를 주고, 이를 reverse proxing 해주는 설정파일이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name example.localhost</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        root /var/www/example2.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="ssl">SSL</span></h3><p>많은 서비스들은 http 프로토콜의 보안을 위해 https 프로토콜을 사용하며 이를 위해서는 443 port 를 통한 SSL 레벨에서의 통신이 필요하다.</p>
<p>이러한 요청을 처리하기 위해서는 다음과 같이 443 port 를 ssl 레벨에서 listen 해야 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    listen [::]:443 ssl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="gzip">GZIP</span></h3><p>NGINX 는 통신시에 데이터를 줄이기 위해 gzip 압축을 통한 리소스 압축을 제공한다.</p>
<p>이는 다음과 같은 설정을 통해 할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	...</span><br><span class="line">    gzip             on;</span><br><span class="line">    gzip_comp_level  3;</span><br><span class="line">    gzip_types       text/plain text/css application/javascript image/*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/01/29/getting-started-with-aws-cli/" itemprop="url">
                Getting started with AWS cli
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-01-29T06:45:00.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/aws-cli/">aws-cli</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                6 minutes read (About 859 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>AWS 에는 수많은 기능이 있고, 이를 실제 웹사이트에서 console 을 통해 제어하는 것은 개발자에게 매우 비효율적인 일이 아닐 수 없다. AWS 는 이렇게 사용자의 컴퓨터에서 AWS 상의 많은 기능을 제어하기 위해 AWS CLI 프로그램을 제공하며, 본 포스트에서는 AWS CLI 의 기본적인 사용법을 알아보고자 한다.</p>
<h2><span id="installation">Installation</span></h2><h3><span id="mac">Mac</span></h3><p>Mac OS 에서는 다음과 같이 pip 명령어를 통해 aws cli 를 쉽게 설치할 수 있다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install awscli</span><br></pre></td></tr></table></figure>
<h3><span id="ubuntu">Ubuntu</span></h3><h2><span id="authentication">Authentication</span></h2><p>AWS 는 현재 cli 프로그램을 사용하는 내가 어떤 유저인지 모르기 때문에 이를 AWS 에게 알려주어야 하며, 그것이 authentication 자체이다.</p>
<p>사용자의 PC에는 여러 AWS 유저들에 대한 정보를 저장할 수 있는데, AWS 는 매우 복잡한 유저 관리 체계를 가지기 때문에 이는 매우 필요한 일이다.(가령 특정 AWS 서비스의 조작을 위한 별도 Program user 를 생성하는 경우 여러 개발자가 하나의 계정을 공유하여 사용하는 것은 매우 빈번한 일이다.)</p>
<p><strong>Command 를 입력할 때 특정 사용자임을 밝히기</strong></p>
<p>아래 명령어를 통해 aws access key 와 secret key 를 등록하고 사용할 수 있다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws configure</span><br></pre></td></tr></table></figure>
<p>다음과 같은 command option 을 통해 내가 어떤 사용자인지 알리고, 미리 configure 되어있는 해당 사용자의 정보로 authentication 을 진행할 수 있다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws [<span class="built_in">command</span>] --profile 사용자이름</span><br></pre></td></tr></table></figure>
<p><strong>MFA 를 사용하는 경우의 인증</strong></p>
<p>콘솔 계정의 경우 cli 를 통한 작업을 진행할 경우 MFA 를 적용했다면 Access Deny 된다.</p>
<p>이 경우 MFA 유저를 위해 별도의 임시 인증을 거쳐야 하는데 이는 다음 명령어로 해결이 가능하다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws sts get-session-token --serial-number &lt;arn-mfa-device&gt; --token-code 126355 --profile jee</span><br></pre></td></tr></table></figure>
<p><code>arn-mfa-device</code> 는 각 AWS계정 정보에 들어가서 보안자격증명 탭에 할당된 MFA 디바이스를 보시면 알 수 있다.</p>
<p><code>token-code</code> 는 Authy와 같은 2FA 토큰 값을 입력해 주면 된다. </p>
<p>커맨드를 실행하시면 임시 Access Key가 발급되고 Access ID, Secret Access Key, Session Token을 환경변수나 credential에 profile로 등록하신후 사용하면 된다.</p>
<p>때문에, 만료시간이 있기때문에 매번 재발급받아야하는데 AWS에서는 이를 각자 Cron Tab등으로 만들어서 사용하는 것을 권장한다.</p>
<p>다음과 같이 credential 에 등록하여 사용하면 된다.</p>
<p>~/.aws/credential</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[profile name]</span><br><span class="line">AWS_ACCESS_KEY_ID = &lt;aws_access_key_id&gt;</span><br><span class="line">AWS_SECRET_ACCESS_KEY = &lt;aws_secret_access_key&gt;</span><br><span class="line">AWS_SESSION_TOKEN = &lt;asw_session_token&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="configuration">Configuration</span></h2><p>AWS 사용자 및 기타 전역 설정에 대한 정보는 /.aws 의 config 파일에 저장되어 있다.</p>
<p>해당 파일을 열어보면 다음과 같이 세팅되어 있다.</p>
<p>config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[profile user1]</span><br><span class="line">aws_access_key_id = XXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">aws_secret_access_key = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">region = ap-northeast-2</span><br><span class="line"></span><br><span class="line">[default]</span><br><span class="line">region = ap-northeast-2</span><br></pre></td></tr></table></figure>
<p>그 중에서도 유저 정보는 credentials 에 다음과 같이 저장되어 있다.</p>
<p>~/.aws/credentials</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[default]</span><br><span class="line">aws_access_key_id = XXXXXXXXXXXXXXXXXXXX</span><br><span class="line">aws_secret_access_key = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">region = ap-northeast-2</span><br><span class="line"></span><br><span class="line">[&lt;profile_name&gt;]</span><br><span class="line">aws_access_key_id = XXXXXXXXXXXXXXXXXXXX</span><br><span class="line">aws_secret_access_key = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br></pre></td></tr></table></figure>
<p>이처럼 기본 user 인 [default] 유저와 특정 유저를 나타내는 [profile user_name] 이 나뉘어 있다.</p>
<p>여기에 정의된 특정 profile 은 command line 에서 <code>--profile user1</code> 과 같이 사용될 수 있다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/01/29/getting-started-with-aws/" itemprop="url">
                Getting started with AWS
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-01-29T06:45:00.000Z" itemprop="datePublished">
                2 years ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/aws-cli/">aws cli</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                11 minutes read (About 1665 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h2><span id="route53">Route53</span></h2><p>Route53 은 AWS 가 제공하는 DNS 서비스이며, 실제 도메인을 구입하고 도메인의 routing 을 설정하고 subdomain 지정 등 많은 일을 수행할 수 있다.</p>
<p>Route 53은 도메인과 동일한 이름의 퍼블릭 호스팅 영역을 자동으로 생성한다. 퍼블릭 호스팅 영역이란 특정 도메인(예: example.com)과 그 하위 도메인(apex.example.com, acme.example.com)의 트래픽을 인터넷에서 라우팅하는 방식에 대한 정보를 담고 있는 컨테이너로, 호스팅 영역에 레코드를 생성하여 도메인 및 하위 도메인에 대한 트래픽의 라우팅 방법을 지정한다.</p>
<p>트래픽을 리소스로 라우팅하려면 호스팅 영역에 <strong>리소스 레코드 세트</strong> 라고도 하는 <em>레코드</em>를 생성해야 합니다. 각각의 레코드에는 도메인의 트래픽을 라우팅할 방법에 관한 다음과 같은 정보가 포함되어 있습니다.</p>
<p><strong>이름</strong></p>
<p>레코드의 이름은 Route 53을 사용하여 트래픽을 라우팅하려는 도메인 이름(예: example.com) 또는 하위 도메인 이름(예: <a href="http://www.example.com)과" target="_blank" rel="noopener">www.example.com)과</a> 일치합니다.</p>
<p>호스팅 영역에 있는 모든 레코드의 이름은 반드시 호스팅 영역의 이름으로 끝나야 합니다. 예를 들어 호스팅 영역의 이름이 example.com이라면 모든 레코드 이름이 example.com으로 끝나야 합니다. Route 53 콘솔은 자동으로 이 작업을 수행합니다.</p>
<p><strong>형식</strong></p>
<p>레코드 유형은 일반적으로 트래픽을 라우팅할 리소스 유형을 결정합니다. 예를 들어 트래픽을 이메일 서버로 라우팅하려면 [Type]을 [MX]로 지정합니다. IPv4 IP 주소를 가진 웹 서버로 트래픽을 라우팅하려면 [Type]을 [A]로 지정합니다.</p>
<p><strong>값</strong></p>
<p>[Value]는 [Type]과 밀접한 관련이 있습니다. [Type]을 [MX]로 지정하는 경우, [Value]에 하나 이상의 이메일 서버의 이름을 지정해야 합니다. [Type]을 [A]로 지정하는 경우, 192.0.2.136과 같은 IPv4 형식의 IP 주소를 지정해야 합니다.</p>
<p><img src="/images/image-20190328112743282.png" alt="image-20190328112743282"></p>
<p>* 출처: <a href="https://docs.aws.amazon.com/ko_kr/Route53/latest/DeveloperGuide/welcome-dns-service.html" target="_blank" rel="noopener">AWS 홈페이지</a></p>
<h2><span id="load-balancer">Load balancer</span></h2><p>Route53 에서 라우팅 된 요청을 여러 인스턴스에 분배해주는 부하 부산기이다.</p>
<p>로드 밸런서는 특정 서브도메인을 특정 타겟 그룹으로 보내도록 설정할 수 있으며, 이는 로드밸런서가 특정 프로토콜 통신을 위해 듣고 있는 포트의 rule 을 바꾸어 줌으로써 해결할 수 있다. 가령 80 번 포트 리스너에서 특정 서브 도메인을 특정 타겟 그룹으로 전달 할 수 있으며, 이때 반드시 타겟 그룹을 미리 설정해 두어야 한다.</p>
<p>타겟 그룹은 여러 인스턴스들과 특정 포트를 등록해 두는 것으로 이를 통해 로드 밸런서가 특정 타겟 그룹의 여러 인스턴스들에게 부하를 분산해서 할당한다.</p>
<h2><span id="aws-cli">AWS CLI</span></h2><p>AWS 에는 수많은 기능이 있고, 이를 실제 웹사이트에서 console 을 통해 제어하는 것은 개발자에게 매우 비효율적인 일이 아닐 수 없다. AWS 는 이렇게 사용자의 컴퓨터에서 AWS 상의 많은 기능을 제어하기 위해 AWS CLI 프로그램을 제공하며, 본 포스트에서는 AWS CLI 의 기본적인 사용법을 알아보고자 한다.</p>
<h3><span id="installation">Installation</span></h3><p>Mac OS 에서는 다음과 같이 pip 명령어를 통해 aws cli 를 쉽게 설치할 수 있다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install awscli</span><br></pre></td></tr></table></figure>
<h3><span id="authentication">Authentication</span></h3><p>AWS 는 현재 cli 프로그램을 사용하는 내가 어떤 유저인지 모르기 때문에 이를 AWS 에게 알려주어야 하며, 그것이 authentication 자체이다.</p>
<p>사용자의 PC에는 여러 AWS 유저들에 대한 정보를 저장할 수 있는데, AWS 는 매우 복잡한 유저 관리 체계를 가지기 때문에 이는 매우 필요한 일이다.(가령 특정 AWS 서비스의 조작을 위한 별도 Program user 를 생성하는 경우 여러 개발자가 하나의 계정을 공유하여 사용하는 것은 매우 빈번한 일이다.)</p>
<p><strong>Command 를 입력할 때 특정 사용자임을 밝히기</strong></p>
<p>아래 명령어를 통해 aws access key 와 secret key 를 등록하고 사용할 수 있다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws configure</span><br></pre></td></tr></table></figure>
<p>다음과 같은 command option 을 통해 내가 어떤 사용자인지 알리고, 미리 configure 되어있는 해당 사용자의 정보로 authentication 을 진행할 수 있다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws [<span class="built_in">command</span>] --profile 사용자이름</span><br></pre></td></tr></table></figure>
<p><strong>MFA 를 사용하는 경우의 인증</strong></p>
<p>콘솔 계정의 경우 cli 를 통한 작업을 진행할 경우 MFA 를 적용했다면 Access Deny 된다.</p>
<p>이 경우 MFA 유저를 위해 별도의 임시 인증을 거쳐야 하는데 이는 다음 명령어로 해결이 가능하다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws sts get-session-token --serial-number &lt;arn-mfa-device&gt; --token-code 126355 --profile jee</span><br></pre></td></tr></table></figure>
<p><code>arn-mfa-device</code> 는 각 AWS계정 정보에 들어가서 보안자격증명 탭에 할당된 MFA 디바이스를 보시면 알 수 있다.</p>
<p><code>token-code</code> 는 Authy와 같은 2FA 토큰 값을 입력해 주면 된다.</p>
<p>커맨드를 실행하시면 임시 Access Key가 발급되고 Access ID, Secret Access Key, Session Token을 환경변수나 credential에 profile로 등록하신후 사용하면 된다.</p>
<p>때문에, 만료시간이 있기때문에 매번 재발급받아야하는데 AWS에서는 이를 각자 Cron Tab등으로 만들어서 사용하는 것을 권장한다.</p>
<p>다음과 같이 credential 에 등록하여 사용하면 된다.</p>
<p>~/.aws/credential</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[profile name]</span><br><span class="line">AWS_ACCESS_KEY_ID = ~</span><br><span class="line">AWS_SECRET_ACCESS_KEY = ~</span><br><span class="line">AWS_SESSION_TOKEN = ~</span><br></pre></td></tr></table></figure>
<h3><span id="configuration">Configuration</span></h3><p>AWS 사용자 및 기타 전역 설정에 대한 정보는 /.aws 의 config 파일에 저장되어 있다.</p>
<p>해당 파일을 열어보면 다음과 같이 세팅되어 있다.</p>
<p>config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[profile user1]</span><br><span class="line">aws_access_key_id = XXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">aws_secret_access_key = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">region = ap-northeast-2</span><br><span class="line"></span><br><span class="line">[default]</span><br><span class="line">region = ap-northeast-2</span><br></pre></td></tr></table></figure>
<p>그 중에서도 유저 정보는 credentials 에 다음과 같이 저장되어 있다.</p>
<p>credentials</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[default]</span><br><span class="line">aws_access_key_id = XXXXXXXXXXXXXXXXXXXX</span><br><span class="line">aws_secret_access_key = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br></pre></td></tr></table></figure>
<p>이처럼 기본 user 인 [default] 유저와 특정 유저를 나타내는 [profile user_name] 이 나뉘어 있다.</p>
<p>여기에 정의된 특정 profile 은 command line 에서 <code>--profile user1</code> 과 같이 사용될 수 있다.</p>

                        
    </div>
    
            
</article>



        
    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/page/3/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/page/5/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/">1</a></li>
        
        <li><a class="pagination-link" href="/page/2/">2</a></li>
        
        <li><a class="pagination-link" href="/page/3/">3</a></li>
        
        <li><a class="pagination-link is-current" href="/page/4/">4</a></li>
        
        <li><a class="pagination-link" href="/page/5/">5</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/23/">23</a></li>
        
    </ul>
</nav>
    
    </div>
</section>

            <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2020 Jake.Lee 이남훈&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" href="https://github.com/frontalnh">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
                <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        //plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110077250-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-110077250-2');
</script>


    


<script src="/js/script.js"></script>

                    
                        <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
                            
</body>

</html>