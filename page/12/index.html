<!DOCTYPE html>
<html class="has-navbar-fixed-top">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Jake.Lee&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">






<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="/css/style.css">
<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>

</head>

<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">Categories</a>
            
            <a class="navbar-item " href="/tags">Tags</a>
            
            <a class="navbar-item " href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" href="https://github.com/frontalnh">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

        <section class="section">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6354931397950820",
    enable_page_level_ads: true
  });
</script>

    <div class="container">
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-트리/" itemprop="url">
                자료구조 | 트리(Tree)
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T11:28:13.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                17 minutes read (About 2475 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#트리tree란">트리(tree)란?</a></li>
<li><a href="#이진-트리">이진 트리</a><ul>
<li><a href="#이진-트리-순회">이진 트리 순회</a></li>
<li><a href="#예제">예제</a></li>
</ul>
</li>
<li><a href="#스레드-이진-트리">스레드 이진 트리</a></li>
<li><a href="#이원-탐색-트리bst-binary-search-tree">이원 탐색 트리(BST, Binary Search Tree)</a><ul>
<li><a href="#이원-탐색트리의-탐색">이원 탐색트리의 탐색</a></li>
<li><a href="#insertion-in-bst">INSERTION IN BST</a></li>
<li><a href="#deletion-in-bst">DELETION IN BST</a></li>
</ul>
</li>
<li><a href="#선택-트리">선택 트리</a><ul>
<li><a href="#승자-트리">승자 트리</a></li>
<li><a href="#패자-트리">패자 트리</a></li>
</ul>
</li>
<li><a href="#분리-집합의-표현">분리 집합의 표현</a></li>
<li><a href="#이진-트리의-개수-계산">이진 트리의 개수 계산</a></li>
<li><a href="#avl-트리">AVL 트리</a><ul>
<li><a href="#avl-트리에서의-삽입">AVL 트리에서의 삽입</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="트리tree란">트리(tree)란?</span></h1><p>트리 구조란 정보의 항목들이 가지로 연결될 수 있게 데이터가 조작되는 것이며, 가계표, 족보, 왕조의 나열 등에서 쉽게 찾아볼 수 있다.<br>가계표를 예를 들어 설명을 하면 최 상단에 조부모님이 계시고 그 아래로 아버지와 어머니, 동생 친척들이 쭉 나열이 되는데, 이러한 조직 체계를 트리를 통해 나타낼 수 있다.</p>
<p>트리 구조에서 <strong>노드</strong> 란 각 항목들을 의미하며 한 정보 아이템에서 다른 노드로 뻗어진 가지를 포함한 개념이다.<br>각 노드는 아래로 계속해서 가지를 뻗어나갈 수 있는데, <strong>한 노드에서 뻗어져 나간 가지들(서브트리)</strong> 의 수를 그 노드의 <strong>차수</strong> 라고 부른다.<br>또한, 차수가 0인 노드를 <strong>리프 혹은 단말 노드</strong> 라고 부르며, 뻗어나간 구조의 상위의 노드를 아래 노드의 <strong>부모(parent)</strong> 라 하고 아래 노드를 상위 노드의 <strong>자식(child)</strong> 이라고 부른다. 또한 한 노드에서 뻗어져 나온 병렬관계의 노드를 서로의 <strong>형제(sibling)</strong> 이라고 부른다.</p>
<p>특정 노드의 차수와 구분하여 <strong>트리의 차수</strong> 트리에 있는 노드의 최대 차수를 말한다.</p>
<h1><span id="이진-트리">이진 트리</span></h1><p>다시 가계표의 예를 들면 한 부모 밑에는 수많은 자식들이 생길 수 있으나, 컴퓨터가 이를 처리하는 시점에서 특정 부모노드 아래에 숫자를 알 수 없는 자식들이 존재하게 된다면 포인터 필드가 가변적이기에 효율적으로 메모리를 사용할 수 없다. 이 때문에 일정한 크기의 노드를 사용하기 위한 트리의 표현법이 나타나게 되었고, 한 노드가 가지만을 가지도록 만들어진 트리를 <strong>이진 트리</strong> 라고 한다.</p>
<p>제일 위의 노드(root)로 부터 2배씩 증가하며 가지들이 뻗어나와 크리스마스 트리 형태를 띄는 형태를 이진트리라고 부르며 모든 노드들이 규칙적으로 2개씩 가지를 쳐 나가 각 층의 노드가 꽉꽉 들어차면 이를 <strong>포화 이진 트리</strong> 라고 한다.<br><strong>깊이가 k인 포화 이진트리의 노드 수는 (2^k-1)개</strong> 이다.</p>
<p>컴퓨터에서는 이러한 이진트리를 메모리에 저장할 방법을 찾게 되었고 최 상단 노드부터 차례로 메모리에 저장을 하게 되면 포화 이진트리가 아닌 대부분의 이진트리에서는 메모리 중간 중간이 비게 되어 효율적인 메모리 사용에 어려움을 겪게 되었는데, 이를 해결하기 위해 열결표현 방식을 사용하여 각 노드가 다른 노드의 링크를 연결하여 포인터를 들고 있는 방식으로 저장하게 되었다.</p>
<p><strong>어떠한 트리도 이진 트리로 표현할 수 있다.</strong></p>
<p>다음은 C 언어를 이용한 이진 트리의 구현이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/*node 구조체로 *treePointer 라는 별칭 선언*/</span><br><span class="line">typedef struct node *treePointer;</span><br><span class="line">/*node 구조체를 선언한다.*/</span><br><span class="line">typedef struct node&#123;</span><br><span class="line">  char data;</span><br><span class="line">  treePointer leftChild, rightChild;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line">treePointer createNode(char newData)</span><br><span class="line">&#123;</span><br><span class="line">  treePointer newNode = (treePointer)malloc(sizeof(node));</span><br><span class="line">  newNode-&gt;leftChild = NULL;</span><br><span class="line">  newNode-&gt;rightChild = NULL;</span><br><span class="line">  newNode-&gt;data = newData;</span><br><span class="line"></span><br><span class="line">  return newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inorder(treePointer ptr)</span><br><span class="line">&#123;</span><br><span class="line">  if(ptr)&#123;</span><br><span class="line">    inorder(ptr-&gt;leftChild);</span><br><span class="line">    printf(&quot;%c&quot;, (*ptr).data);</span><br><span class="line">    inorder(ptr-&gt;rightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*추가된 노드를 출력하는 부분*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    treePointer nodeA = createNode(&apos;A&apos;);</span><br><span class="line">    treePointer nodeB = createNode(&apos;B&apos;);</span><br><span class="line">    treePointer nodeC = createNode(&apos;C&apos;);</span><br><span class="line">    treePointer nodeD = createNode(&apos;D&apos;);</span><br><span class="line">    treePointer nodeE = createNode(&apos;E&apos;);</span><br><span class="line">    treePointer nodeF = createNode(&apos;F&apos;);</span><br><span class="line">    treePointer nodeG = createNode(&apos;G&apos;);</span><br><span class="line">    treePointer nodeH = createNode(&apos;H&apos;);</span><br><span class="line"></span><br><span class="line">    (*nodeA).leftChild=nodeB;</span><br><span class="line">    (*nodeA).rightChild=nodeC;</span><br><span class="line">    (*nodeB).leftChild=nodeD;</span><br><span class="line">    (*nodeB).rightChild=nodeE;</span><br><span class="line">    (*nodeD).rightChild=nodeG;</span><br><span class="line">    (*nodeC).leftChild=nodeF;</span><br><span class="line">    (*nodeF).rightChild=nodeH;</span><br><span class="line">    inorder(nodeA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="이진-트리-순회">이진 트리 순회</span></h2><p>앞서 설명한 이진 트리를 조회하기 위해서 다양한 방법을 사용하는데, 한 노드에서 왼쪽으로 이동(L), 오른쪽으로 이동(R), 노드 방문(V) 의 순서에 따라 중위 순회, 후위 순회, 전위 순회로 구분한다.</p>
<p>먼저 <strong>전위 순회(preorder traversal)</strong> 는 이름 그대로 노드를 먼저 방문하는 경우 즉, VLR의 순서로 노드를 방문하는 경우이다.<br><strong>후위 순회(postorder traversal)</strong> 은 노드를 제일 마직막에 방문하는 경우 즉, LRV의 순서로 노드를 방문하는 경우이다.<br><strong>중위 순회</strong> 란 노드를 중간에 방문하는 경우 즉, LVR의 순서로 노드를 방문하는 경우이다.</p>
<p>중위 순회를 하는 경우를 C 코드로 나타내면 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void inorder(treePointer ptr)</span><br><span class="line">&#123;</span><br><span class="line">  if(ptr)&#123;</span><br><span class="line">    inorder(ptr-&gt;leftChild);</span><br><span class="line">    printf(&quot;%c&quot;, (*ptr).data);</span><br><span class="line">    inorder(ptr-&gt;rightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위의 코드를 살펴보면 반복법이 아닌 순환법을 이용하여 즉, 스택의 도움 없이 순회를 진행하는데 이는 스택을 이용하여 스택에 노드를 저장하고 제거하는 방식으로도 순회가 가능하다. 이러한 순회를 <strong>반복적 중위 순회</strong> 라고 하며 이를 C 코드로 구현하면 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void iterInorder(treePointer ptr)&#123;</span><br><span class="line">  int top = -1; /*스택 초기화*/</span><br><span class="line">  treePointer stack[MAX_STACK_SIZE];</span><br><span class="line">  for(;;)&#123;</span><br><span class="line">    for(;node;node=node-&gt;leftChild)</span><br><span class="line">      push(node);/*스택에 삽입*/</span><br><span class="line"></span><br><span class="line">    node=pop();/*스택에서 제거*/</span><br><span class="line">    if(!node)/*스택이 비어있는 경우 중지*/</span><br><span class="line">      break;</span><br><span class="line">    printf(&quot;%d&quot;, node-&gt;data);</span><br><span class="line">    node=node-&gt;rightChild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="예제">예제</span></h2><p>이진 트리에서 리프 노드의 수를 세는 C 함수를 작성하여라.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int totalCount=0;</span><br><span class="line">void countLeaf(treePointer ptr)&#123;</span><br><span class="line">  if(ptr&amp;&amp;(!(*ptr).leftChild)&amp;&amp;(!(*ptr).rightChild))&#123;</span><br><span class="line">    totalCount++;</span><br><span class="line">    printf(&quot;\n리프 노드: %c, count:%d\n&quot;, (*ptr).data, totalCount);</span><br><span class="line">  &#125;</span><br><span class="line">  if(ptr)&#123;</span><br><span class="line">    countLeaf((*ptr).leftChild);</span><br><span class="line">    printf(&quot;%c&quot;,(*ptr).data);</span><br><span class="line">    countLeaf((*ptr).rightChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="스레드-이진-트리">스레드 이진 트리</span></h1><p>2n개의 링크 중 n+1개가 null link 이므로 효율성이 떨어지는 문제가 생기게 되고 이를 해결하기 위해 null link에 포인터를 넣어 다른 노드의 링크를 거는 것을 <strong>스레드</strong> 라고 한다.</p>
<h1><span id="이원-탐색-트리bst-binary-search-tree">이원 탐색 트리(BST, Binary Search Tree)</span></h1><p>이원 탐색 트리는 탐색, 삽입, 삭제 연산에 있어서 지금까지 공부했던 어떤 자료 구조보다도 성능이 좋다.<br>이원 탐색트리의 모든 원소는 키를 가지고 <strong>어떤 두 원소도 동일한 키를 갖지 않으며</strong>, <strong>왼쪽 서브트리가 존재한다면 그 키들은 루트의 키보다 작고 오른쪽 서브트리가 존재한다면 루트의 키보다 크다</strong>. 또한, <strong>왼쪽과 오른쪽 서브트리도 모두 이원탐색 트리이다.</strong></p>
<h2><span id="이원-탐색트리의-탐색">이원 탐색트리의 탐색</span></h2><p>탐색은 루트부터 시작하여 루트와 키 값이 같다면 탐색은 종료된다. 탐색하고자 하는 키 값이 루트의 키보다 작다면 왼쪽 서브트리를 탐색하고 크다면 오른쪽 서브트리를 탐색한다. 왼쪽과 오른쪽 서브트리는 모두 이원탐색 트리이므로 각각을 다시 탐색하는 순환 탐색 방식을 사용한다.</p>
<p>다음은 이원 탐색 트리의 순환적 탐색을 구현한 프로그램이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">element * search(treePointer tree, int key)&#123;</span><br><span class="line">  if(!root) return NULL;</span><br><span class="line">  if(k == root-&gt;data.key) return &amp;(root-&gt;data);</span><br><span class="line">  if(k&lt;root-&gt;data.key)</span><br><span class="line">    return search(root-&gt;leftChild, k);</span><br><span class="line">  return search(root-&gt;rightChild, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>아래는 동일한 기능의 반복 함수로 구현한 프로그램이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">element* iterSearch(treePointer tree, int k)</span><br><span class="line">&#123;</span><br><span class="line">  white(tree)&#123;</span><br><span class="line">    if(k==tree-&gt;data.key) return &amp;(tree-&gt;data);</span><br><span class="line">    if(k&lt;tree-&gt;data.key)</span><br><span class="line">      tree = tree-&gt;leftChild;</span><br><span class="line">    else</span><br><span class="line">      tree = tree-&gt;rightChild;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Time Complexity: O(h)</strong></p>
<p>BST 에서의 찾는 시간은 찾고자 하는 노드의 높이만큼 분기를 수행하므로 O(h) 이다.</p>
<h2><span id="insertion-in-bst">INSERTION IN BST</span></h2><p><img src="\images\이원탐색트리에서의삽입개념도.png" alt="이원 탐색 트리에서의 삽입 개념도"></p>
<p><strong>Time Complexity: O(h)</strong></p>
<p>BST 에서의 삭제는 search 후에 단순 삽입으로 search 시의 time complexity와 같은 complexity 를 가진다.</p>
<h2><span id="deletion-in-bst">DELETION IN BST</span></h2><p><img src="\images\이진탐색트리에서의삭제개념도.png" alt="이진 탐색 트리에서의 삭제 개념도"></p>
<p><strong>Time Complexity: O(h)</strong></p>
<p>BST 에서의 삭제는 다음과 같이 진행된다.</p>
<ol>
<li>BST에서 해당 노드를 찾음</li>
<li>해당 노드를 삭제하고, maximum value in left subchild 로 대체 하거나 혹은 minimum in right subchild 로 대체한다.</li>
<li>대체된 노드에 대한 삭제를 진행한다. 이 경우 해당 노드는 차수가 0이거나 혹은 1 이므로 삭제는 매우 간편하다.</li>
</ol>
<p>위의 각 과정별로 시간 소모를 생각해 보면, 노드를 찾는데에 O(h), 삭제하고 서브 트리에서 값을 찾는데에 O(h) 삭제에 1 이므로 BST 에서 deletion 시에 time Complexity 는 O(h) 이다.</p>
<h1><span id="선택-트리">선택 트리</span></h1><h2><span id="승자-트리">승자 트리</span></h2><p>다음은 8개의 런(k=8) 을 가진 승자 트리의 개념도 입니다.</p>
<p><img src="\images\선택트리의개념도.png" alt="선택 트리의 개념도"></p>
<h2><span id="패자-트리">패자 트리</span></h2><p>다음은 위의 승자 트리에 대응하는 패자 트리의 개념도 입니다.</p>
<p><img src="\images\패자트리의개념도.png" alt="패자 트리의 개념도"></p>
<h1><span id="분리-집합의-표현">분리 집합의 표현</span></h1><h1><span id="이진-트리의-개수-계산">이진 트리의 개수 계산</span></h1><h1><span id="avl-트리">AVL 트리</span></h1><p>AVL 트리란 균형 이진 트리의 한 종류이며, 이원 탐색트리가 항상 완전 이진트리로 유지되도록 한 트리입니다.</p>
<p><strong>탐색, 삽입, 삭제 시간: O(logn)</strong></p>
<p>AVL 트리에서 각 노드는 <strong>균형 인자(balance factor)</strong> 를 가지는데, 이는 왼쪽 트리의 높이에서 오른쪽 트리의 높이를 뺀 값으로 높이의 균형도를 나타냅니다.</p>
<p><strong>balance factor = h_L - h_R</strong></p>
<p>AVL 트리에서는 어떤 서브트리 T 에서도 BF(T) 의 절대값은 1 이하입니다.</p>
<h2><span id="avl-트리에서의-삽입">AVL 트리에서의 삽입</span></h2><p><strong>LL rotation</strong></p>
<p><img src="\images\lL로테이션.png" alt="LL 로테이션"></p>
<p><strong>RR rotation</strong><br><strong>LR rotation</strong></p>
<p><img src="\images\lR로테이션.png" alt="LR 로테이션"></p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-강의-09-우선순위-큐/" itemprop="url">
                자료구조 강의 09. 우선순위 큐
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T11:07:13.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                5 minutes read (About 739 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#1-한쪽-끝과-양쪽-끝-우선순위-큐">1. 한쪽 끝과 양쪽 끝 우선순위 큐</a></li>
<li><a href="#좌향-트리">좌향 트리</a></li>
<li><a href="#이항히프b-heap">이항히프(B-Heap)</a></li>
</ul>
<!-- tocstop -->
<h1><span id="1-한쪽-끝과-양쪽-끝-우선순위-큐">1. 한쪽 끝과 양쪽 끝 우선순위 큐</span></h1><p><strong>우선순위 큐(priority queue)</strong> 는 각 원소가 연관된 우선순위를 갖고 있는 원소들의 모임이다.<br>가령 시스템의 작업 우선도를 설정해 줄 때에는 작업들을 우선 순위에 따라 분류해야 하며, 2개의 서버로 이루어진 시스템의 경우에 하나의 시스템이 사고로 인해 종료되는 경우 반대쪽 서버로 그 작업 내역들이 병합되어야 하는데 이러한 경우 우선순위 큐를 통해 두 작업 리스트를 병합해야 한다.</p>
<p>이러한 우선순위 큐 <strong>한쪽 끝 우선순위 큐</strong> 와 <strong>양쪽 끝 우선순위 큐</strong> 가 있으며, 한쪽 끝 우선순위 큐는 <strong>최대 우선순위 큐</strong> 와 <strong>최소 우선순위 큐</strong> 로 나뉜다.</p>
<p><strong>최소 우선순위 큐</strong> 에 의해 지원되는 연산은 다음과 같다.<br>SP1. 최소 우선순위를 가진 원소의 반환<br>SP2. 임의 우선순위를 가진 원소의 삽입<br>SP3. 최소 우선순위를 가진 원소의 삭제</p>
<p>이러한 우선순위 큐를 잘 표현하기 위한 고전적인 자료 구조로써 <strong>히프(heap)</strong> 를 사용한다.</p>
<p>양쪽 끝 우선순위 큐는 최소 우선순위 큐와 최대 우선순위 큐가 하나로 합해진 최소-최대 우선순위 큐이다.</p>
<p>실제 활용도 측면에서, 양쪽 끝 우선순위 큐는 네트워크 버퍼를 구현하는 데 사용되는데 네트워크 링크를 통해 전송되기를 원하는 패킷들을 가지고 있는 경우 가장 높은 우선순위를 가진 패킷이 전송되고 삭제 되는 <strong>최대 삭제</strong> 가 행해지는 반면, 네트워크 내의 다른 곳으로 부터 새로운 패킷이 도착하였는데 버퍼가 가득 차 있다면 우선 순위가 가장 낮은 패킷을 지우는 <strong>최소 삭제</strong> 가 일어나게 된다. 이처럼 작업 큐의 양쪽에서 삽입과 삭제가 가능한 큐를 양쪽 끝 우선순위 큐라고 부른다.</p>
<h1><span id="좌향-트리">좌향 트리</span></h1><p>좌향트리는 합병성 우선순위 큐의 효율적 구현을 제공한다.<br>좌향 트리의 종류에는 HBLT(Height Biased Leftist Tree)와 WBLT(Weight Biased Leftist Tree)가 있는데, 일반적으로 HBLT를 좌향트리하고 부른다.</p>
<h1><span id="이항히프b-heap">이항히프(B-Heap)</span></h1><p>좌향 트리에서 지원되는 것과 같은 기능을 수행한다. 개별적인 연산을 수행하는 데 걸리는 시간보다 우선순위 큐의 순차를 수행하는데 걸리는 시점에 관심이 있다.<br>이항 히프란 최소 트리의 집합이며, 최소 트리 가운데 최소값을 갖는 트리를 가리키는 하나의 포인터가 가르키게 된다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/컴퓨터-구조-강의-프로세서/" itemprop="url">
                컴퓨터 구조 | 프로세서
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T10:51:27.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/컴퓨터-구조-강의/">컴퓨터 구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                2 minutes read (About 302 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#파이프라이닝에-대한-개관">파이프라이닝에 대한 개관</a></li>
</ul>
<!-- tocstop -->
<p>명령어 집합 구조가 구현의 여러 가지 측면을 어떻게 결정 하는지, 또 여러가지 구현 전략이 클럭 속도와 CPI에 어떻게 영향을 미치는지 살펴볼 기회를 갖게 될 것이다.<br>명령어 종류에 관계없이 어떤 명령어 던지 처음 두 단계는 다음과 같이 동일하다.</p>
<ol>
<li>프로그램 카운터(PC)를 프로그램이 저장된 메모리로 보내어 메모리로부터 명령어를 가져온다.</li>
<li>읽은 레지스터를 선택하는 명령어 필드를 사용하여 하나 또는 두 개의 레지스터를 읽는다.</li>
</ol>
<h1><span id="파이프라이닝에-대한-개관">파이프라이닝에 대한 개관</span></h1><p>파이프라이닝이란 여러 명령어가 중첩되어 실행되는 구현기술로써 기존의 단일 사이클 구조에서는 ALU 등 여러 장치가 다른 명령어를 실행하는 동안에는 동작하지 않는 것이 효율이 매우 떨어지기에 각 명령어를 처리할 수 있는 자원이 존재한다면 이를 병렬로 실행시켜 처리량을 올리는 기술이다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/27/자료구조-강의-01-기본-개념/" itemprop="url">
                자료구조 강의 01. 기본 개념
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-27T10:29:33.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                3 minutes read (About 449 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#개요-시스템-생명-주기">개요: 시스템 생명 주기</a></li>
<li><a href="#포인터와-동적-메모리-할당">포인터와 동적 메모리 할당</a></li>
<li><a href="#알고리즘-명세">알고리즘 명세</a></li>
<li><a href="#데이터-추상화">데이터 추상화</a></li>
<li><a href="#성능-분석">성능 분석</a><ul>
<li><a href="#공간-복잡도">공간 복잡도</a></li>
<li><a href="#시간-복잡도">시간 복잡도</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="개요-시스템-생명-주기">개요: 시스템 생명 주기</span></h1><h1><span id="포인터와-동적-메모리-할당">포인터와 동적 메모리 할당</span></h1><h1><span id="알고리즘-명세">알고리즘 명세</span></h1><h1><span id="데이터-추상화">데이터 추상화</span></h1><h1><span id="성능-분석">성능 분석</span></h1><p>본 강의의 목적 중 하나는 프로그램에 대한 평가 능력을 향상시키는 것이다.<br>프로그램의 판단함에 있어서 다양한 기준이 있지만, 크게는 컴퓨터와 상관 없이 시공간의 추산에 초점을 두는 <strong>성능 분석(performance analysis)</strong> 과 컴퓨터에 의존적인 실행 시간을 얻어내는 <strong>성능 측정(performance measurement)</strong> 이 있다.</p>
<p>이번 강의 에서는 성능 측정은 배제하고 성능 분석에 초점을 두어 강의를 진행하며 성능 분석은 다음의 두 복잡도로 분석을 진행한다.</p>
<ol>
<li>공간 복잡도</li>
<li>시간 복잡도</li>
</ol>
<h2><span id="공간-복잡도">공간 복잡도</span></h2><p>공간 복잡도의 정의는 프로그램을 실행시켜 완료하는 데 필요로 하는 공간의 양으로, 실제 메모리를 차지하는 양을 나타낸다. 각 각의 변수가 얼마나 많은 메모리를 차지하는 지 등을 다루며 이러한 공간 복잡도는 <strong>고정 공간 요구</strong> 및 <strong>가변 공간 요구</strong> 로 나뉘게 된다.</p>
<p><strong><em>고정 공간 요구</em></strong><br>프로그램 입출력의 횟수나 크기에 관계없는 공간 요구를 의미한다.<br>가령 명렁어 공간, 단순 변수, 상수 고정 크기의 구조화 변수 등을 포함한다.</p>
<p><strong><em>가변 공간 요구</em></strong><br>해결하고자 하는 문제의 특정 인스턴스 I에 의존하는 크기를 가진 구조화 변수들을 위해 필요로 하는 공간이다.</p>
<h2><span id="시간-복잡도">시간 복잡도</span></h2><p>컴파일 시간과 실행 시간을 합한 것이다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/20/컴퓨터-구조-강의-02-명령어-컴퓨터-언어/" itemprop="url">
                컴퓨터 구조 | 명령어, 컴퓨터 언어
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-20T13:29:40.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/컴퓨터-구조-강의/">컴퓨터 구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                5 minutes read (About 820 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="서론">서론</span></h1><p>컴퓨터 하드웨어에게 일을 시키려면 하드웨어가 알아들을 수 있는 언어로 말을 해야하며, 컴퓨터 언어에서의 단어를 명령어 라고 하며 그 집합을 명령어 집합 이라고 한다.<br>본 강의에서는 명령어 집합의 하드웨어 표현방식 및 상위 수준 언어와의 관계를 보이며, 이를 통해 내장 프로그램의 개념을 이해한다.</p>
<h1><span id="하드웨어-연산">하드웨어 연산</span></h1><p>기본적으로 컴퓨터는 산술연산을 할 수 있으며 다음과 같은 명령어를 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add a, b, c</span><br></pre></td></tr></table></figure>
<p>위의 명령어는 b+c를 한 결과값을 a에 담는 식이다.</p>
<h1><span id="3-피연산자">3. 피연산자</span></h1><p><strong>레지스터</strong> 라고 하는 하드웨어로 직접 구현된 특수 위치 몇 곳에 있는 것만 사용할 수 있다.<br>MIPS 구조에서 이러한 <strong>레지스터의 크기는 32비트(4 byte)</strong> 이며 <strong>총 32개로 레지스터의 갯수가 제한</strong> 되어 있으며 본 강의에서는 각 레지스터 마다의 성질을 보여주기 위해 $뒤의 숫자 가령 $t0와 같은 방식으로 레지스터를 표기한다.<br>레지스터의 수가 제한된 이유는 레지스터가 아주 많아지면 전기 신호가 더 멀리까지 전달되어야 하므로 클럭 사이클이 길어지기 때문이다.</p>
<p>레지스터 안에는 변수, 명령어 등이 저장될 수 있는데,프로그래밍 언어에는 단순한 변수 이외에도 레지스터 개수보다 훨씬 많은 데이터 원소수가 있을 수 있다.<br>산술연산은 레지스터에 의해서만 실행되므로 메모리의 값을 레지스터에 옮겨오기 위해서는 이들 사이에 데이터를 주고받기 위한 명령어가 필요한데, 이를 <strong>데이터 전송 명령어</strong> 라고 한다. 메모리에서 레지스터로 데이터를 옮기는 실제 명령어는 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lw t0, 8($s3)</span><br></pre></td></tr></table></figure>
<p>한 주소블록은 32비트(즉, 4byte)를 기준으로 하기 때문에<br>위 명령은 t0에 $s3에서부터 8번째 데이터를 담는 것이다.<br>즉 실제 주소는: $s3 + 8*4byte에 위치한다.</p>
<p>레지스터 연산을 할때 상수를 더하는 경우가 있는데, 이 경우에는 상수만을 위한 명령어 addi 등을 사용한다.<br>이 경우 상수값을 메모리에서 가져오는 것이 아니라 프로세서 내에서 바로 더해 줌으로써 훨씬 빠르게 처리를 할 수 있다.</p>
<p>상수 덧셈의 예<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addi $s3, $s3, 4</span><br></pre></td></tr></table></figure></p>
<h1><span id="어셈블리어의-기계어-표현">어셈블리어의 기계어 표현</span></h1><p>레즈스터 내의 기계어 명령어 필드</p>
<p><strong>R타입</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">op</th>
<th style="text-align:left">rs</th>
<th>rt</th>
<th>rd</th>
<th>shamt</th>
<th>funct</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">연산자</td>
<td style="text-align:left">피연산자</td>
<td>피연산자2</td>
<td>목적지</td>
<td>자리이동 양</td>
<td>기능</td>
</tr>
<tr>
<td style="text-align:left">6bit</td>
<td style="text-align:left">5bit</td>
<td>5bit</td>
<td>5bit</td>
<td>5bit</td>
<td>6bit</td>
</tr>
</tbody>
</table>
<p><strong>I 타입</strong><br>| op   | rs   | rt   | constant+address |<br>|:—- |:—- | —- | —————- |<br>| 6bit | 5bit | 5bit |21bit|</p>
<h1><span id="하드웨어의-프로시저-지원">하드웨어의 프로시저 지원</span></h1><p>프로시저는 일종의 함수 역할을 하는 것으로 전달인수 레지스터4개와 반환 레지스터 2개, 복귀주소 1개로 이루어져 있다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/19/git-시작하기/" itemprop="url">
                git 시작하기
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-18T16:45:57.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/git-강의/">git 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                14 minutes read (About 2047 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!--toc-->
<h1><span id="git-시작하기">git 시작하기</span></h1><h2><span id="git-설치하기">git 설치하기</span></h2><h3><span id="git-cli-와-gui를-모두-설치한다">git cli 와 gui를 모두 설치한다</span></h3><p>이때 gui를 설치하지 않아도 되지만, 이런 경우 ssh 설정이 복잡하므로 간단하게 설치를 마쳐준다.<br>만약 ubuntu의 경우는 패키지 매니저인 apt-get을 사용하여 다음과 같이 설치한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-all</span><br></pre></td></tr></table></figure>
<h3><span id="git-home-디렉토리-변경하기">git home 디렉토리 변경하기</span></h3><p>git 아이콘을 우클릭하여 대상 뒤의 –cd-home을 없애고</p>
<p>시작위치에 원하는 위치를 넣어준다.</p>
<h2><span id="로그인-및-권한설정">로그인 및 권한설정</span></h2><p>git을 사용하기 위해 로그인 및 계정을 설정해 준다.<br>먼저, 다음과 같이 global 한 계정 정보를 설정해 준다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;YOUR_USERNAME&quot;</span><br><span class="line">git config --global user.email &quot;your_email@youremail.com&quot;</span><br><span class="line">git pull https://username:password@mygithost.com/my/repository</span><br><span class="line">git config credential.helper cache</span><br><span class="line">git config --list //설정한 내용 확인하기</span><br></pre></td></tr></table></figure>
<h3><span id="ssh-기반-인증">ssh 기반 인증</span></h3><p>만약 특정 레포지토리가 공개키 방식의 인증과정을 거치고 특정 키를 레포지토리에 등록시켜 두었다면, 해당 인증서를 통해 인증하여 레포지토리와 통신할 수 있다. 이때 여러 레포지토리들은 각각 다른 키를 사용할 수 있는데 이러한 ssh 연결 정보를 특정 레포지토리의 <code>.git/config</code> 파일에 설정해 둘 수 있으며, 그 명령어는 다음과 같다.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local --add core.sshCommand 'ssh -i ~/your_key'</span><br></pre></td></tr></table></figure>
<p>혹은 아래와 같이 직접 <code>.git/config</code> 파일을 수정할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">sshCommand = &quot;ssh -i ~/.ssh/keyfile&quot;</span><br></pre></td></tr></table></figure>
<p>w</p>
<h2><span id="원격-repo-연결하기">원격 repo 연결하기</span></h2><p>git 세팅을 완료했다면 온라인 상의 코드들을 조작하기 위해 git 서버에 연결한다.<br>git 서버에 연결하는 방법은 2가지가 있는데, 하나는 http 방식이고 다른 하나는 ssh 방식이다.</p>
<p>먼저, ssh를 활용하여 연결하기 위해서 컴퓨터의 ssh key를 생성하고, 생성된 공개키는 git에 등록한다.<br>공개키를 사용하려면 일단 공개키를 만들어야 하는데, 공개키를 만드는 방법은 모든 운영체제가 비슷하다.<br>먼저 키가 있는지부터 확인하자. 사용자의 SSH 키들은 기본적으로 사용자의 ~/.ssh 디렉토리에 저장한다.</p>
<p>리눅스 혹은 ubuntu의 경우 ssh-keygen을 통해 공개키/개인키 쌍을 생성할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>위 명령어를 통해 공개키를 생성하였으면 ~/.ssh 디렉토리에 id_rsa.pub가 생성되었을 것이다.<br>해당 공개키를 git 홈페이지의 repository의 설정에서 등록해 주면 된다.</p>
<p><a href="https://git-scm.com/book/ko/v1/Git-%EC%84%9C%EB%B2%84-SSH-%EA%B3%B5%EA%B0%9C%ED%82%A4-%EB%A7%8C%EB%93%A4%EA%B8%B0" target="_blank" rel="noopener">참조</a></p>
<p>git pull 명령을 수행하는 동중 permission denied가 되는 경우가 있는데 이는 특정 유저에게 해당 파일에 대한 변경 권한이 없는 것으로 다음과 같이 해결한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown &lt;USER&gt;.&lt;GROUP&gt; -R /home/&lt;USER&gt;/.config</span><br><span class="line">chown &lt;USER&gt;.&lt;GROUP&gt; -R /home/&lt;USER&gt;/.gitconfig</span><br></pre></td></tr></table></figure>
<p>만약 위처럼 ssh를 통해 연결이 어렵다면 pull 혹은 clone 시에 https를 기반으로 받으면 ssh 연결이 아닌 https를 통해 받을 수 있으니 시도해 보기 바란다.</p>
<h2><span id="git-명령어-모음">git 명령어 모음</span></h2><h3><span id="브랜치-생성-및-변경">브랜치 생성 및 변경</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch [브랜치명]</span><br><span class="line">git checkout [브랜치명]</span><br></pre></td></tr></table></figure>
<p>git branch [브랜치명] 명령어로 브랜치를 생성하고<br>git checkout [브랜치명] 명령어를 통해 브랜치를 변경한다.<br>여기서 checkout은 단순히 브랜치를 옮기는 것으로 지금까지의 변경내용이 바뀌지 않고 해당 브랜치로 이동하기 때문에<br>해당 브랜치에 지금의 변경내용이 전부 반영된다.</p>
<h3><span id="브랜치-삭제하기">브랜치 삭제하기</span></h3><p><code>git branch -d [branch Name]</code></p>
<h3><span id="추가된-파일-포함시키고-커밋하기">추가된 파일 포함시키고 커밋하기</span></h3><p>파일 추가<br><code>git add</code></p>
<p>커밋하기</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;메세지&quot;</span><br></pre></td></tr></table></figure>
<h3><span id="원격저장소에-사용하기">원격저장소에 사용하기</span></h3><p>업스트림(upstream) 브랜치 설정<br>로컬 저장소를 init 명령어로 생성했을땐 수동으로 업스트림 브랜치를 설정할 필요가 있다. 업스트림 브랜치란 원격 저장소와 바로 연결된 로컬 저장소를 말하며 push나 pull 명령등에서 원격 저장소 이름을 생략할 수 있게 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure>
<p>원격 저장소와 코드를 주고 받기 위해 가장 먼저 해야 할 일은 원격 저장소가 어디에 있는지를 알려주는 일이다.<br>다음과 같은 코드를 입력하기 원격저장소 origin의 위치를 등록해 준다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:hea9549/expiritAdmin.git</span><br></pre></td></tr></table></figure>
<p>밀어넣기<br><code>git push origin [branch]</code></p>
<p>강제로 밀어넣기<br><code>git push -u origin master</code></p>
<p>머지하기<br><code>git checkout master</code>를 통해 마스터로 이동한다<br><code>git merge [commit name]</code></p>
<p>풀받기<br><code>git pull [remote 저장소] [브랜치]</code></p>
<h3><span id="커밋을-되돌리기">커밋을 되돌리기</span></h3><p>이번에는 기존에 한 커밋을 되돌리는 법을 배운다.</p>
<p>먼저 커밋 내역을 확인할 수 있도록 log를 확인한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>뒤로 돌리기</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure>
<p>명령어를 통해 HEAD에 마지막으로 커밋된 내용을 뒤로 돌린다.</p>
<h3><span id="원격-브랜치-가져오기">원격 브랜치 가져오기</span></h3><p><code>git checkout -t origin/eventsource</code></p>
<h3><span id="로컬-작업-내용-버리기-혹은-저장하기">로컬 작업 내용 버리기 혹은 저장하기</span></h3><p>당신이 어떤 프로젝트에서 한 부분을 담당하고 있다고 하자. 그리고 여기에서 뭔가 작업하던 일이 있고 다른 요청이 들어와서 잠시 브랜치를 변경해야 할 일이 생겼다고 치자. 아직 완료하지 않은 일을 커밋하는 것은 좀 껄끄럽다. 이런 상황에서는 커밋하지 않고 나중에 다시 돌아와서 작업을 다시 하고 싶을 것이다. 이 문제는 git stash라는 명령으로 해결할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash // stash difference</span><br><span class="line">git stash clear // deled stased</span><br><span class="line">git stash list // list up stashed</span><br></pre></td></tr></table></figure>
<h2><span id="과거의-커밋-내용을-수정하기">과거의 커밋 내용을 수정하기</span></h2><p>open source 활동을 하거나 혹은 대규모의 프로젝트를 진행할때 겪는 가장 큰 문제는 내가 작성한 과거의 코드내용, 즉 과거의 커밋 내용을 수정하는 것이다.</p>
<p>대부분의 경우 feature 브랜치에서 많은 내용을 수정하고 중간중간 변경 사항에 대해 commit 으로 기록하기 때문에 과거의 커밋을 바꾸기 위해서는 까마득한 예전의 코드로 돌아가 그 특정 부분을 수정하고 그 뒤의 변경사항을 다시 재적용 시키는 일이 필요하다.</p>
<p>이 경우에는 <code>git rebase</code> 명령을 사용하여 해결할 수 있으며 다음과 같은 절차를 거친다.</p>
<ol>
<li><p><code>git log</code> 를 통해 나의 이전 커밋 내용을 확인한다.</p>
</li>
<li><p><code>git rebase -i HEAD~n</code> 를 통해 HEAD로 부터 얼마나 뒤 내용을 수정하고 rebase를 진행할지 정해준다. 가령 HEAD 로 부터 3 번째 커밋부터의 커밋들에 수정사항이 있다면 <code>git rebase -i HEAD~3</code> 명령어를 입력한다.</p>
</li>
<li><p>위 명령어를 입력하면 과거의 커밋들이 나타나고 커밋명 앞에 pick 이라는 키워드가 있다. 여기서 우리가 수정하기를 원하는 커밋의 pick 키워드를 e(edit) 으로 바꿔준다.</p>
</li>
<li><p>이제 git이 edit 하고자 하는 커밋으로 코드를 돌려주고 원하는 내용을 수정한 뒤에 <code>git commit --amend</code> 를 해주면 해당 커밋을 수정하여 다시 커밋하고 <code>git rebase --continue</code> 명령을 통해 뒤의 커밋들을 쭉 적용시켜 줄 수 있다.</p>
</li>
</ol>
<h2><span id="유용한-기능들">유용한 기능들</span></h2><p><strong>CLI 에서 비밀번호 저장하기</strong></p>
<p><code>git config credential.helper store</code></p>
<p><strong>변경내용 임시 저장하기</strong></p>
<p><code>git stash</code></p>
<p><strong>임시 저장내용 불러오기</strong></p>
<p><code>git stash pop</code></p>
<h2><span id="2fa-인증">2FA 인증</span></h2><p>git authentication</p>
<p>git 에서 2FA 인증을 하는 경우 personal access token을 발급받아서 해야한다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/18/how-to-write-a-service-introduction/" itemprop="url">
                How to write a service introduction
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-18T14:44:22.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
                
                    <span class="column is-narrow">
                        
                            
                                2 minutes read (About 267 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>서비스 소개서를 작성함에 있어 가장 핵심이 되는 것은 바로 청자가 원하는 것이 무엇인지를 명확하게 파악하고 그리고 우리 제품을 가능한한 알기 쉽고 직관적으로 이해 할 수 있도록 하는 것이다.</p>
<p>서비스 소개서의 시작은 고객의 관심을 사로잡을 수 있도록 상대방의 니즈 혹은 현재 하고있는 비즈니스에 명확하게 도움이 되는 포인트를 설득력있고 알기쉽게 제시한다. 이렇게 독자의 마음을 열었다면, 그 다음으로는 우리의 제품이 해당 니즈에 어떻게 도움이 되며, 아주 쉽게 우리 제품에 대해 명확한 이해가 수반되어야 한다. 이때의 기준은 독자가 우리의 서비스 소개서를 읽은 뒤에 다른 누군가에게 가서 우리의 제품에 대해 명확하게 설명할 수 있을 정도가 바람직하다.</p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/18/컴퓨터-구조-강의-01-컴퓨터-추상화-및-관련-기술/" itemprop="url">
                컴퓨터 구조 강의 01. 컴퓨터 추상화 및 관련 기술
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-18T08:31:32.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/컴퓨터-구조-강의/">컴퓨터 구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                14 minutes read (About 2048 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="서론">서론</span></h1><p>1940년 전자식 컴퓨터가 등장한 이래로 컴퓨터는 정보 혁명을 주도하며 컴퓨터와 관련 사업을 빠르게 발전시켰다.<br>스마트 가전제품 부터 슈퍼 컴퓨터 까지 삶의 다양한 분야에서 컴퓨터가 활용되고 있으며 크게 다음과 같은 세가지 응용분야에서 사용된다.</p>
<ul>
<li>개인용 컴퓨터</li>
<li>서버</li>
<li>임베디드 컴퓨터</li>
</ul>
<p>개인용 컴퓨터는 많은 사람들이 잘 알고있듯이 가정 내에 보급된 pc를 말하며, 가정 및 비즈니스에서 산업용으로도 사용되고 있다.<br>서버는 과거 대형 컴퓨터로 불리던 것의 현대적 형태로써 보통 네트워크를 통해 접근되며 소규모 비즈니스 서버 등 주로 산업에서 인터넷을 통한 서비스 공급의 목적으로 사용되고 있다.<br>가장 많이 사용되는 임베디드 컴퓨터는 한 가지 응용을 수행하거나 서로 연관된 일련의 프로그램을 실행하도록 설계된 컴퓨터로 많은 가전기기 및 제품들에 탑재되어 있다.</p>
<p>단순 컴퓨터의 출생이 가지는 의미를 넘어 컴퓨터의 영향으로 세계 IT 산업은 송두리째 뒤흔들리고 있는 분야가 있는데, 그것은 바로 <strong>개인 휴대용 기기(PMD)</strong> 와 <strong>클라우드 컴퓨팅</strong> 을 기반으로 한 <strong>sass</strong> 이다.</p>
<p>개인 휴대용 기기를 통해 사람들은 어디에서나 인터넷에 연결되어 진정한 초연결 사회로 거듭나게 되었으며, 엄청난 컴퓨팅 파워가 기반이 되어야 사용 가능했던 많은 컴퓨터 기반의 서비스들이 창고 규모의 컴퓨팅(WSC: Warehouse Scale Computing)으로 알려진 클라우드 컴퓨팅을 통해 서비스 로서의 소프트웨어(sass)로 제공되고 있다.</p>
<p><strong>본 강의는 David A. Patterson과 John L. Hennessy의 책을 토대로 공부한 내용을 정리하며, 다음과 같은 내용을 배운다.</strong></p>
<ol>
<li>상위 수준으로 작성된 프로그램이 어떻게 하드웨어로 번역되고 동작하는가?</li>
<li>소프트웨어와 하드웨어 사이의 인터페이스는 무엇이며, 소프트웨어는 어떻게 필요한 일을 하드웨어에게 지시하는가?</li>
<li>프로그램의 성능을 결정하는 요소는 무엇이며, 프로그래머는 어떻게 성능을 개선하는가?</li>
<li>성능 개선을 위해 하드웨어 설계자는 어떤 기술을 사용하는가?</li>
<li>에너지 효율성을 개선하기 위해 하드웨어 설계자는 어떤 기술을 사용할 수 있는가?</li>
<li>최근 순차처리에서 병렬처리로 넘어가는 이유는 무엇이며 결과는 어떠한가?</li>
<li>컴퓨터 구조 분야의 어떤 위대한 아이디어들이 컴퓨팅의 기초를 닦았는가?</li>
</ol>
<h1><span id="컴퓨터를-조작하는-명령어는-어떻게-작동하는가">컴퓨터를 조작하는 명령어는 어떻게 작동하는가?</span></h1><p>컴퓨터 하드웨어는 아주 단순한 명령을 실행 할 수 있도록 설계되어 있으며, 많은 현대 프로그래머들이 작성하는 복잡한 코드는 적절한 변환을 통해 컴퓨터가 알기 쉬운 언어로 번역되어 하드웨어를 동작한다. 프로그래머는 코드를 작성하면서 하드웨어의 구체적인 동작은 배제하고 프로그램을 작성이 가능한데, 이는 인간의 상위 언어인 프로그램 언어를 하드웨어와 무관하게 자유롭게 작성할 수 있도록 하는 <strong>추상화</strong> 의 일환이다.<br>즉, 프로그래머는 추상화된 언어인 상위 언어들을 사용함으로써 컴퓨터 내의 복잡한 일들을 신경쓰지 않고 더욱 정교한 시스템을 만들어 갈 수 있다.</p>
<p><strong>소프트웨어와 하드웨어의 상호작용은 다음과 같이 일어난다.</strong></p>
<p>_1. 상위 수준 언어로 코드를 작성</p>
<ol start="2">
<li>컴파일러가 상위수준 언어를 하위 언어인 어셈블리어로 변환시켜 줌</li>
<li>어셈블러가 어셈블리어를 컴퓨터가 알아들을 수 있는 이진수 체계로 변환시켜 줌_</li>
</ol>
<h2><span id="컴퓨터-구조-분야의-8가지-위대한-아이디어">컴퓨터 구조 분야의 8가지 위대한 아이디어</span></h2><ol>
<li>무어의 법칙을 고려한 설계</li>
<li>설계를 단순화하는 추상화</li>
<li>자주 생기는 일을 빠르게</li>
<li>병렬 처리</li>
<li>파이프라이닝을 통한 성능 개선</li>
<li>예측을 통한 성능 개선</li>
<li>메모리 계층구조<br>최상위 계층에는 비트당 가격이 제일 바싸지만 작고 빠른 메모리를 사용하고, 최하위 계층에는 느리지만 크고 비트당 가격이 제일 싼 메모리를 사용한다.</li>
<li>여유분을 이용한 신용도 개선</li>
</ol>
<h1><span id="컴퓨터의-구성과-기본-기능">컴퓨터의 구성과 기본 기능</span></h1><p>컴퓨터는 기본적으로 다음과 같은 5가지 항목으로 구성된다.</p>
<ol>
<li>입력 유닛</li>
<li>출력 유닛</li>
<li>메모리 유닛</li>
<li>데이터패스 유닛</li>
<li>제어 유닛</li>
</ol>
<h2><span id="출력">출력</span></h2><p>컴퓨터의 출력은 주로 그래픽 디스플레이를 통해 이루어 진다.<br>오늘날의 LCD 디스플레이는 수만개의 화상으로 이루어져 있으며, 각 화상마다 작은 트랜지스터가 배치되어 있어 전류를 정밀하게 제어하는 능동 행렬을 사용한다.<br>각 화상은 화소의 행렬로 구성되며, 이것을 비트맵이라 부르는 비트들의 행렬로 포현한다.<br>컬러 디스플레이는 각각마다 8비트씩, 모두 24비트를 사용하여 수백만 가지의 색을 표시할 수 있다.</p>
<p>그래픽을 지원하는 하드웨어의 중심이 되는 것은 비트맵을 기억하는 <strong>프레임 버퍼</strong> 라고 하는 부분이며, 스크린에 표시될 화상을 프레임 버퍼에 자장하였다가, 기억된 각 화소들의 <strong>비트 패턴을 재생 속도에 맞추어 그래픽 디스플레이로 보낸다.</strong></p>
<h2><span id="프로세서">프로세서</span></h2><p>디바이스 안에는 집적회로라 불리는 장치들이 있는데, 이는 프로그램의 지시대로 일을 하며, 데이터패스와 제어 유닛으로 나뉜다.<br>또한 프로세서 내에서 처리할 데이터를 잠깐 보관하기 위해 이를 <strong>캐시 메모리</strong> 라고 한다.</p>
<h1><span id="성능">성능</span></h1><p>컴퓨터의 성능이란 두 컴퓨터에서 같은 프로그램을 실행시키는 경우에 먼저 끝나는 쪽이 더 빠른 컴퓨터라고 할 수 있을 것이다.<br>하지만 <strong>사용하는 사람과 컴퓨터의 목적에 따라 다른 성능 척도가 필요</strong> 하다.<br>가령, 개인의 입장에서는 작업 개에서 종료까지의 시간인 <strong>응답시간</strong> 이 성능의 중요한 척도일 것이고, 데이터 센터 관리자에게는 일정 시간동안 처리하는 작업의 양인 <strong>처리량 혹은 대역폭</strong> 이 더 중요한 성능의 척도일 것이다.</p>
<h3><span id="다양한-성능-인자들">다양한 성능 인자들</span></h3><p><strong>_프로그램의 CPU 실행 시간</strong></p>
<p>프로그램의 CPU 클럭 사이클 수 * 단위 클럭 사이클 시간 = 프로그램의 CPU 클럭 사이클 수 / 클럭 속도</p>
<p><strong><em>명령어당 클럭 사이클 수(CPI)</em></strong><br>명령어 수 * 명령어당 평균 클럭 사이클 수</p>
<p><strong><em>CPU 시간</em></strong><br>명령어 개수 <em> CPI </em> 클럭 사이클 시간</p>
<p><strong><em>IPC(Instructions Per clock Cycle)</em></strong><br>클럭 사이클 당 명령어 수</p>
<p><strong><em>MIPS(Million Instructions Per Second)</em></strong><br>명령어 개수 / (실행시간*10^6)</p>
<h3><span id="예제">예제</span></h3><p>다음은 명령어당 클럭 사이클 수를 통한 성능 비교를 보여주는 표이다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">시스템 이름</th>
<th style="text-align:left">명령어 수</th>
<th>CPI</th>
<th>소요 시간</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">5</td>
<td>2</td>
<td>250ps</td>
</tr>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:left">6</td>
<td>1.2</td>
<td>500ps</td>
</tr>
</tbody>
</table>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/03/18/express의-기본-개념/" itemprop="url">
                express 시작하기
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-17T15:36:53.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/nodejs-강의/">nodejs 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                a few seconds read (About 64 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="express란">Express란?</span></h1><p>Express는 자체적인 최소한의 기능을 갖춘 라우팅 및 미들웨어 웹 프레임워크이며, Express 애플리케이션은 기본적으로 일련의 미들웨어 함수 호출이다.</p>
<h2><span id="installation">Installation</span></h2><p><code>npm install express --save</code></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/02/22/mysql-trigger의-활용/" itemprop="url">
                6. mysql trigger의 활용
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-02-22T04:20:59.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/mysql-강의/">mysql 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                2 minutes read (About 268 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="trigger의-생성과-삭제">trigger의 생성과 삭제</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER IF EXISTS `sport`.`tr_update_gameresult`;</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER `sport`.`tr_update_gameresult` BEFORE UPDATE ON sport.tb_game</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">  -- 게임이 종료 되었는지 판단</span><br><span class="line">  IF NEW.COMP_CODE = &apos;3&apos; THEN</span><br><span class="line">    SET @exception = (select EXPECATE from tb_reg_game where GAME_NO = NEW.GAME_NO);</span><br><span class="line"></span><br><span class="line">    IF @exception = NEW.VIC_CODE THEN</span><br><span class="line">      update tb_reg_game set `HIT_RESULT` = &apos;1&apos; where GAME_NO = NEW.GAME_NO;</span><br><span class="line">    ELSE</span><br><span class="line">      update tb_reg_game set `HIT_RESULT` = &apos;2&apos; where GAME_NO = NEW.GAME_NO;</span><br><span class="line">    END IF;</span><br><span class="line"></span><br><span class="line">  END IF;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<h1><span id="새로-들어온-데이터-선택자-new와-기존에-있던-데이터-선택자-old">새로 들어온 데이터 선택자 new와 기존에 있던 데이터 선택자 OLD</span></h1><p>새로 들어온 데이터를 new로 지칭하여 attribute를 뽑아서 사용할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_group set MEMBER_NUM=@memberNum where GROUP_ID = new.GM_GROUP_ID;</span><br></pre></td></tr></table></figure></p>
<h1><span id="특정-데이터-생성-혹은-삭제시에-상위-테이블의-전체-개수-인덱스-변경하기">특정 데이터 생성 혹은 삭제시에 상위 테이블의 전체 개수 인덱스 변경하기</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create trigger trx_updates_atrig</span><br><span class="line">after insert on trx_updates for each row begin</span><br><span class="line"></span><br><span class="line">&lt;!-- 트리거 동작에 필요한 변수 선언 --&gt;</span><br><span class="line">DECLARE memverNum INT;</span><br><span class="line">  &lt;!-- 변수에 값 넣는 sql --&gt;</span><br><span class="line">  set @memberNum = ( select count(*) from tb_group_member where GM_GROUP_ID=new.GM_GROUP_ID );</span><br><span class="line"></span><br><span class="line">  &lt;!-- 인덱스 변경 SQL --&gt;</span><br><span class="line">  update tb_group set MEMBER_NUM=@memberNum where GROUP_ID = new.GM_GROUP_ID;</span><br><span class="line">end//</span><br></pre></td></tr></table></figure>

                        
    </div>
    
            
</article>



        
    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/page/11/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/page/13/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/">1</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/11/">11</a></li>
        
        <li><a class="pagination-link is-current" href="/page/12/">12</a></li>
        
        <li><a class="pagination-link" href="/page/13/">13</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/21/">21</a></li>
        
    </ul>
</nav>
    
    </div>
</section>

            <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 Jake.Lee 이남훈&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" href="https://github.com/frontalnh">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
                <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        //plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110077250-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-110077250-2');
</script>


    


<script src="/js/script.js"></script>

                    
                        <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
                            
</body>

</html>