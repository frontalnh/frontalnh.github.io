<!DOCTYPE html>
<html class="has-navbar-fixed-top">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Jake.Lee&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="google-site-verification" content="PgpnJMuvO-IqYWyFljnyr-tusLhJUz1VRMmECenJyHE">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">






<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="/css/style.css">
<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>

</head>

<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">Categories</a>
            
            <a class="navbar-item " href="/tags">Tags</a>
            
            <a class="navbar-item " href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" href="https://github.com/frontalnh">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

        <section class="section">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6354931397950820",
    enable_page_level_ads: true
  });
</script>

    <div class="container">
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/24/자료구조-해시/" itemprop="url">
                자료구조 | 해시
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-24T09:53:21.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                4 minutes read (About 593 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="해시란">해시란?</span></h1><p>해시란 탐색, 삽입, 삭제를 모두 O(1) 기대 시간에 수행할 수 있도록 해 주는 기법입니다.<br>해시는 해시 테이블을 통해 구현되며 해시 테이블은 <strong>b개의 버킷</strong> 과 버킷 내에 s개의 사전쌍들로 이루어 집니다.<br>여기서 해시함수 h는 키 값을 특정 홈 주소로 사상 시키는 함수로써 주로 <strong>제산 함수</strong> 등이 사용됩니다.</p>
<p><strong>h(k) = 0 ~ (b-1)</strong></p>
<p>위 식에서 h(k)를 <strong>해시</strong> 혹은 <strong>홈 주소</strong> 라고 부릅니다.</p>
<p>이상적인 조건 하에서 모든 사전쌍들이 모두 홈 버킷에 저장됩니다.</p>
<p>이런 해시 테이블에 있는 쌍의 수를 n 개라 하고, 가능한 전체 키의 총 개수를 T라 할때</p>
<p><strong>키 밀도 = n/T</strong></p>
<p>위 식이 성립합니다.</p>
<p>이러한 해시 함수는 여러 개의 키를 하나의 버킷에 사상시키게 되기 때문에<br>h(k1) = h(k2) 가 되는 k1과 k2가 존재하게 되고 이 경우 k1과 k2를 h에 대한 동거자라고 부릅니다.</p>
<p><strong>오버플로우</strong> 란 어떤 쌍을 삽입 시 홈 버킷이 넘치는 경우를 말합니다.</p>
<h1><span id="정적-해싱">정적 해싱</span></h1><p>오버플로우 처리방법에는 <strong>개방 주소법과 체인법</strong> 이 있으며, <strong>개방 주소법</strong> 에는 <strong>선형 조사법</strong>, 이차 조사법, 재해싱, 임의 조사법이 있습니다.</p>
<h2><span id="오버플로우-처리법">오버플로우 처리법</span></h2><h3><span id="개방-주소법">개방 주소법</span></h3><p><strong>선형 조사법</strong></p>
<p><img src="\images\선형조사법개념도.png" alt="선형 조사법 개념도"></p>
<h3><span id="체인법">체인법</span></h3><p>선형 조사법을 비롯한 개방 주소법에서는 키를 탐색 할 때 서로 다른 해시 값을 가진 키들과 일일히 비교를 수행하기 때문에 효율이 매우 떨어집니다.<br>이와 달리 <strong>체인법</strong> 에서는 ht[i] 가 버킷 i에 연결된 체인들 중 첫번째 블록을 가리키고 있기 때문에, 연결된 체인 내에서만 탐색을 수행하면 되어 속도가 빠릅니다.</p>
<p><img src="\images\체인법개념도.png" alt="체인법 개념도"></p>
<h1><span id="동적-해싱">동적 해싱</span></h1><p>재조정을 한 번 할 때마다 오직 하나의 버킷만 재조정함</p>
<h2><span id="디렉터리-사용-동적-해싱">디렉터리 사용 동적 해싱</span></h2><h2><span id="디렉터리-미사용-동적-해싱">디렉터리 미사용 동적 해싱</span></h2>
                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/24/자료구조-스택과-큐/" itemprop="url">
                자료구조 | 스택과 큐
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-24T09:25:01.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                2 minutes read (About 271 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="스택을-활용한-수식의-계산">스택을 활용한 수식의 계산</span></h1><p>모든 프로그래밍 언어는 연산 순위를 결정해야한다.<br>일반적으로 실생활 에서는 x+y 와 같이 연산자를 피연산자 사이에 작성하는 <strong>중위 표기법(infix notation)</strong> 을 사용하지만, 컴퓨터의 컴파일러는 <strong>후위 표기법(postfix notation)</strong> 으로 코드를 변환하기에 컴퓨터의 연산과정을 이해하기 위해서 <strong>후기 표현법</strong> 에 대해 익숙해질 필요가 있습니다.</p>
<p><strong>후위 표기식 연산법</strong></p>
<ol>
<li>연산자를 만날때까지 피연산자를 스택에 저장</li>
<li>연산자를 만나면 연산에 필요한 만큼만 스택에서 가져와 실행하여 연산결과를 다시 스택에 저장</li>
</ol>
<p><img src="/images/후위표기식연산.png" alt="후위 표기식 연산"></p>
<p><strong>중위 표기식을 후위 표기식으로 고치는 법</strong></p>
<ol>
<li>식을 모두 괄호식으로 고침</li>
<li>연산자를 모두 해당하는 오른 괄호랑 대체</li>
<li>모들 괄호를 삭제</li>
</ol>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/24/자료구조-그래프/" itemprop="url">
                자료구조 | 그래프
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-24T07:55:15.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/자료구조-강의/">자료구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                7 minutes read (About 1108 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#그래프-추상-데이타-타입">그래프 추상 데이타 타입</a></li>
<li><a href="#그래프-표현법">그래프 표현법</a></li>
<li><a href="#그래프의-기본-연산">그래프의 기본 연산</a><ul>
<li><a href="#깊이-우선-탐색dfs">깊이 우선 탐색(DFS)</a></li>
<li><a href="#너비-우선-탐색bfs">너비 우선 탐색(BFS)</a></li>
<li><a href="#신장-트리spanning-tree">신장 트리(spanning tree)</a></li>
</ul>
</li>
<li><a href="#최소-비용-신장-트리">최소 비용 신장 트리</a><ul>
<li><a href="#kruskal-알고리즘">Kruskal 알고리즘</a></li>
<li><a href="#prim-알고리즘">Prim 알고리즘</a></li>
</ul>
</li>
<li><a href="#최단-경로와-이행적-폐쇄">최단 경로와 이행적 폐쇄</a><ul>
<li><a href="#dijkstra-알고리즘-하나의-출발점에서-모든-목표점-음이-아닌-간선-비용의-경우">Dijkstra 알고리즘, 하나의 출발점에서 모든 목표점: 음이 아닌 간선 비용의 경우</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="그래프-추상-데이타-타입">그래프 추상 데이타 타입</span></h1><p>가령 여러 지점과 그 지점들을 잊는 길들 처럼 현실 세계의 많은 문제들은 <strong>그래프</strong> 라는 개념을 통해 해결될 수 있습니다.</p>
<p>그래프 G 는 2개의 집합 V와 E로 구성됩니다. V는 공집합이 아닌 <strong>정점(Vertice)</strong> 들의 유한 집합이며, G는 정점 쌍들의 집합으로 이러한 쌍을 <strong>간선</strong> 이라 합니다. V(G) 와 E(G)는 각 각 정점과 간선들의 집합을 의미합니다. 그래프는 정점에서 특정 정점으로 가는데에 방향의 개념이 존재하는 경우와 존재하지 않는 경우로 나눌 수 있으며, 이렇게 정점에서 정점으로 이동시 방향이 있는 경우를 <strong>방향 그래프(directed graph)</strong> 라고 하며, 방향이 없는 경우 <strong>무방향 그래프(undirected graph)</strong> 라고 합니다.</p>
<p>여기서 정점에 연결된 간선의 수를 <strong>차수</strong> 라고 하며, Euler는 각 정점의 차수가 <strong>짝수</strong> 인 경우에만 임의의 정점에서 출발하여 각 간선을 단 한 번씩만 거치고 출발한 정점으로 되돌아오는 길이 있음을 보였으며, 이를 <strong>오일러 행로(Eulerian Walk)</strong> 라 부릅니다.</p>
<h1><span id="그래프-표현법">그래프 표현법</span></h1><p>무방향 그래프의 간선 <strong>(u, v)</strong><br>방향 그래프의 간선 <strong>&lt;u, v&gt;</strong></p>
<p><img src="\images\그래프의표현.png" alt="그래프의 표현"></p>
<p><img src="\images\인접리스트표현개념도.png" alt="인접 리스트 표현 개념도"></p>
<h1><span id="그래프의-기본-연산">그래프의 기본 연산</span></h1><p><img src="../images/dFS,BFS를적용하기위한그래프.png" alt="DFS, BFS 를 적용하기 위한 그래프"></p>
<h2><span id="깊이-우선-탐색dfs">깊이 우선 탐색(DFS)</span></h2><p><img src="../images/dFS개념도.png" alt="DFS 개념도"></p>
<p>위처럼 인접 리스트 표현법의 경우 간선의 횟수 만큼만 탐색이 진행되므로, O(e) 의 복잡도를 가진다.<br>하지만 인접 매트릭스 표현으로 표현한 경우 각 정점마다 다른 정점들과 비교해야 하므로 O(n^2) 의 복잡도를 가진다.</p>
<h2><span id="너비-우선-탐색bfs">너비 우선 탐색(BFS)</span></h2><p><img src="../images/bFS개념도.png" alt="BFS 개념도"></p>
<p><strong>시간 복잡도: O(n^2)</strong></p>
<h2><span id="신장-트리spanning-tree">신장 트리(spanning tree)</span></h2><p>신장 트리란 G의 간선들로만 구성되고 G의 모든 정점을 포함하는 트리를 말합니다.<br>신장 트리를 만들기 위해서는 DFS 혹은 BFS를 모두 이용할 수 있으며, DFS를 이용하여 만들어진 신장트리를 <strong>깊이 우선 신장 트리(depth first spanning tree)</strong> 라 하고, BFS를 이용하여 만들어진 신장 트리를 <strong>너비 우선 신장 트리(breath first spanning tree)</strong> 라 부릅니다.</p>
<h1><span id="최소-비용-신장-트리">최소 비용 신장 트리</span></h1><p>가중치가 부여된 무방향 그래프의 신장 트리의 비용은 신장 트리를 구성하는 간선들의 비용의 합이 됩니다. 여기서 <strong>최소 비용 신장 트리</strong> 란 최저의 비용을 갖는 신장트리를 의미합니다.</p>
<p>이 경우 다음의 조건을 만족해야 합니다.</p>
<ol>
<li>그래프 내에 있는 간선만을 사용해야 한다.</li>
<li>정확히 n-1개의 간선만을 사용해야 한다.</li>
<li>사이클을 생성하는 간선은 사용하면 안된다.</li>
</ol>
<h2><span id="kruskal-알고리즘">Kruskal 알고리즘</span></h2><p><img src="\images\kruskal알고리즘개념도.png" alt="kruskal 알고리즘 개념도"></p>
<h2><span id="prim-알고리즘">Prim 알고리즘</span></h2><p><img src="\images\prim알고리즘개념도.png" alt="prim 알고리즘 개념도"></p>
<h1><span id="최단-경로와-이행적-폐쇄">최단 경로와 이행적 폐쇄</span></h1><p>현대의 많은 지도 시스템들은 임의의 두 특정 지점 사이의 경로를 탐색하는 많은 시스템 중의 일부입니다. 경로 탐색 시스템은 일반적으로 주나 전국의 도로 시스템을 표현하기 위하여 그래프를 이용합니다. 이러한 문제에서 도시 A에서 도시 B로 가려는 운전자는 다음과 같은 사항들이 궁금할 것입니다.</p>
<ol>
<li>A로 부터 B로 가는 길이 있는가?</li>
<li>A로부터 B로 가는 길이 2갱 이상이라면, 어느 길이 최단으로 가는 길인가?</li>
</ol>
<h2><span id="dijkstra-알고리즘-하나의-출발점에서-모든-목표점-음이-아닌-간선-비용의-경우">Dijkstra 알고리즘, 하나의 출발점에서 모든 목표점: 음이 아닌 간선 비용의 경우</span></h2><p><strong>다이크스트라 알고리즘</strong></p>
<p><img src="\images\dijkstra알고리즘개념도.png" alt="dijkstra 알고리즘 개념도"></p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/23/운영체제-파일-시스템-구현/" itemprop="url">
                운영체제 | 파일 시스템 구현
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-23T00:38:29.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/운영체제-강의/">운영체제 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                3 minutes read (About 413 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#파일-시스템-구현">파일 시스템 구현</a></li>
<li><a href="#디렉터리-구현">디렉터리 구현</a><ul>
<li><a href="#선형-리스트">선형 리스트</a></li>
<li><a href="#해시-테이블">해시 테이블</a></li>
</ul>
</li>
<li><a href="#디스크-할당">디스크 할당</a><ul>
<li><a href="#연속-할당">연속 할당</a></li>
<li><a href="#연결-할당">연결 할당</a></li>
<li><a href="#색인-할당">색인 할당</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="파일-시스템-구현">파일 시스템 구현</span></h1><p>운영체제는 파일 내용에 대한 접근을 요청하는 프로세스를 위해 open()과 close() 시스템 호출을 구현합니다.<br>본 장에서는 파일 시스템 연산을 구현하는데 사용되는 구조와 연산에 대해 알아봅시다.</p>
<p>다음 그림은 파일 시스템에서 <strong>디스크</strong> 와 <strong>메모리</strong> 에 어떤 정보들이 들어있는지를 나타내 줍니다.</p>
<p><img src="..\images\파일시스템에서디스크와메모리.png" alt="파일 시스템에서 디스크와 메모리"></p>
<p><img src="..\images\계층적파일시스템구조.png" alt="계층적 파일 시스템 구조"></p>
<h1><span id="디렉터리-구현">디렉터리 구현</span></h1><h2><span id="선형-리스트">선형 리스트</span></h2><p><img src="..\images\선형리스트디렉터리개념도.png" alt="선형 리스트 디렉터리 개념도"></p>
<h2><span id="해시-테이블">해시 테이블</span></h2><p><img src="..\images\해시테이블디렉터리개념도.png" alt="해시 테이블 디렉터리 개념도"></p>
<p><img src="..\images\체인오버플로우해시테이블개념도.png" alt="체인 오버플로우 해시 테이블 개념도"></p>
<h1><span id="디스크-할당">디스크 할당</span></h1><h2><span id="연속-할당">연속 할당</span></h2><p><img src="..\images\디스크연속할당개념도.png" alt="디스크 연속 할당 개념도"></p>
<h2><span id="연결-할당">연결 할당</span></h2><p><img src="..\images\디스크연결할당개념도.png" alt="디스크 연결 할당 개념도"></p>
<p><img src="..\images\fAT개념도.png" alt="FAT 개념도"></p>
<h2><span id="색인-할당">색인 할당</span></h2><p><img src="..\images\디스크색인할당개념도.png" alt="디스크 색인 할당 개념도"></p>
<p><img src="..\images\색인블록의연결기법구성.png" alt="색인 블록의 연결 기법 구성"></p>
<p><img src="색인블록의다중단계색인.png" alt="색인 블록의 다중 단계 색인"></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/23/운영체제-파일-시스템-인터페이스/" itemprop="url">
                운영체제 | 파일 시스템 인터페이스
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-23T00:36:50.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/운영체제-강의/">운영체제 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                a few seconds read (About 80 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#디렉터리-구조">디렉터리 구조</a><ul>
<li><a href="#single-level-directory">Single Level Directory</a></li>
<li><a href="#two-level-directory">Two Level Directory</a></li>
<li><a href="#tree-structured-directory">Tree Structured Directory</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p><img src="\images\파일Open및Access개념도.png" alt="파일 open 및 access 개념도"></p>
<h1><span id="디렉터리-구조">디렉터리 구조</span></h1><h2><span id="single-level-directory">Single Level Directory</span></h2><p><img src="\images\1단계디렉터리.png" alt="1단계 디렉터리"></p>
<h2><span id="two-level-directory">Two Level Directory</span></h2><p><img src="\images\2단계디렉터리.png" alt="2단계 디렉터리"></p>
<h2><span id="tree-structured-directory">Tree Structured Directory</span></h2><p><img src="\images\트리구조디렉터리.png" alt="트리 구조 디렉터리"></p>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/19/컴퓨터-구조-amdahl의-법칙이란/" itemprop="url">
                컴퓨터 구조 | Amdahl의 법칙이란?
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-19T14:34:09.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/컴퓨터-구조-강의/">컴퓨터 구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                4 minutes read (About 572 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>컴퓨터를 설계함에 있어 위대한 아이디어인 <strong>자주 생기는 일을 빠르게(make common cae fast)</strong> 를 추구함에 있어 하드웨어 및 소프트웨어 설계자들이 필연적으로 고민하게 된느 문제 중의 하나는 “성능을 개선하려는 나의 노력이 얼마나 효과가 있는지 어떻게 평가할 수 있는가?” 이다.</p>
<p>열심히 성능을 개선하려는 노력을 했다면 그것이 얼마나 효과가 있는지 궁금해 하는 것은 당연하다.<br>이러한 질문들에 대한 정석적인 해답은 다음과 같다.</p>
<p><strong>“성능을 개선하려는 노력이 얼마나 효과가 있는지는 그 사건이 얼마나 많이 발생하는지와 관련이 있다.”</strong></p>
<p>이러한 법칙은 얼핏 보면 당연해 보이지만 많은 경우 우리에게 명확한 직관을 줄 수 있다.</p>
<p>간단한 예를 통해 <strong>Amdahl의 법칙</strong> 의 활용을 알아보자.<br>가령 프로그램의 실행 시간이 100초가 걸리는 데 그 중 80초는 곱하기 계산에 소요된다고 하자. 이 프로그램이 5배 빠르게 실행되기 위해서 곱셈 속도는 얼마나 개선되어야 하는지에 대한 문제가 있다고 하자.</p>
<p>이는 <strong>Amdahl 의 법칙</strong> 에 의해 다음과 같이 표현된다.</p>
<blockquote>
<p>개선 후 실행시간<br>= (개선에 의해 영향을 받는 실행 시간)/개선의 크기 + 영향을 받지 않는 실행 시간</p>
</blockquote>
<p>이 문제의 경우는</p>
<p>개선 후 실행시간 = 20초 = 80초 / n + (100-80)초</p>
<p>즉, 0=80초 / n</p>
<p>이라는 식을 얻을 수 있다.</p>
<p>이는 바로 곱셈의 성능을 백날 개선해 보아도 시스템의 성능을 5배로 올리는 것은 불가능 하다는 깨우침을 우리에게 준다.<br>이는 일상생활에서 수확체감의 법칙과도 연관되어 있다.</p>
<p>이처럼 Amdahl의 법칙을 통해 어떤 개선안이 전체 성능에 얼마만큼의 성능 개선을 가져다 줄 지를 예측 할 수 있다.<br>이 법칙은 CPU 성능식과 함께 잠재적 성능 개선율을 평가하는 편리한 도구이다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/17/컴퓨터-구조-risc-와-cisc-구조/" itemprop="url">
                컴퓨터 구조 | RISC 와 CISC 구조
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-17T10:41:02.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/컴퓨터-구조-강의/">컴퓨터 구조 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                5 minutes read (About 745 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <h1><span id="riscreduced-instruction-set-computer-란">RISC(Reduced Instruction Set Computer) 란?</span></h1><p>RISC 란 Reduce Instruction Set Computer 의 약자로 말 그대로 축소 명령어 세트 컴퓨터를 의미합니다.<br>여기서 명령어 세트가 축소되었다는 말은 말 그대로 명령어의 개수가 적은 것을 말합니다. 핵심적인 명령어를 기반으로 최소한의 명령어 세트를 구성함으로써 <strong>파이프라이닝</strong> 이라는 획기적인 기술을 도입할 수 있어 빠른 동작 속도와 하드웨어의 단순화와 효율화를 시킬 수 있었고, 가격 경쟁력에서도 우위를 점했습니다.</p>
<p>즉, RISC란 CISC의 길고 복잡한 명령어들을 짧고 처리가 가능한 여러개의 명령어로 체계적으로 바꾼 것입니다.</p>
<p><strong>RISC의 특징</strong></p>
<ol>
<li>적은 명령어 세트</li>
<li>간단한 명령어로 빠른 실행속도</li>
<li>고정적인 명령어 길이</li>
<li>워드, 데이터 버스 크기가 동일하고 실행 사이클도 모두 동일</li>
<li>회로 구성이 단순함</li>
<li>프로그램을 구성할 때 상대적으로 많은 명령어가 필요</li>
<li>파이프 라이닝을 사용함</li>
<li>명령어 개수가 적어서 컴파일러가 단순하게 구현됨</li>
</ol>
<h1><span id="cisccomplex-instruction-set-computer-란">CISC(Complex Instruction Set Computer) 란?</span></h1><p>연산을 처리하는 복잡한 명령어들을 수백개 이상 탑재하고 있는 프로세서입니다. CISC는 명령어 개수 증가에 따라 프로세서 내부구조가 매우 복잡해 지고, 고속으로 적동되는 플세서를 만들기 힘듭니다.</p>
<p>여기서 명령어가 복잡하다는 것의 의미는 하나의 명령어가 할 수 있는 일의 양이 RISC 대비하여 많다는 것을 의미합니다. 명령어 마다 길이가 다르고, 실행에 필요한 사이클 수도 다르기 때문에 pipelining 설계가 어려우며 한 바이트 명령어 부터 100바이트 이상되는 명령어 들도 있습니다.</p>
<p>이렇게 CISC는 RISC에 비해 성능이 많이 떨어지지만 다음과 같은 이유 때문에 아직도 쓰이고 있습니다.</p>
<p><strong>CISC의 특징</strong></p>
<ol>
<li>명령어의 개수가 많음</li>
<li>명령어 길이가 다양하며, 실행 사이클도 명령어 마다 다름</li>
<li>회로구성이 복잡함</li>
<li>프로그램을 만들 때 적은 명령어로 구현 가능</li>
<li>다양한 명령어를 사용하기 때문에 컴파일러가 복잡함</li>
</ol>
<p><strong>CISC를 사용하는 이유</strong></p>
<ol>
<li>아직 너무도 많은 프로세서가 CISC 모델로 구축되어 있고, 이것을 전부 바꾸는 것은 너무 큰 비용이 든다.</li>
<li>CISC 성능의 취약점은 RISC와 같은 파이프라인을 일부 사용하고 집적도는 더 높임으로써 부분적으로 보완이 가능하다.</li>
<li>RISC에 비해 호환성이 좋다.</li>
</ol>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/13/운영체제-프로세스-동기화/" itemprop="url">
                운영체제 | 프로세스 동기화
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-13T09:22:02.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/운영체제-강의/">운영체제 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                24 minutes read (About 3567 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <p>컴퓨터의 프로세스 중에서 <strong>협력적 프로세스</strong> 는 실행 중인 다른 프로세스의 실행에 영향을 주거나 받는 프로세스입니다. 이러한 협력적 프로세스는 <strong>논리주소 공간을 직접 공유하거나, 파일 또는 메세지를 통해서만 데이터를 공유할 수 있습니다.</strong> 이 경우 두개 이상의 프로세스가 동시에 특정 데이터에 접근하면 데이터가 비일관성을 가지게 될 수 있습니다. 본 강의에서는 이렇한 <strong>논리주소 공간을 공유하는 협력적 프로세스의 질서있는 실행을 보장하여 데이터의 일관성을 유지</strong> 하는 다양한 메커니즘을 다루어 보겠습니다.</p>
<p>두개의 프로세스가 동일한 공유된 변수에 접근하는 프로그램을 동작시킨다면 어떤 프로세스가 어떤 순서로 동작함에 따라 결과가 달라지게 됩니다. 하지만 두 프로세스가 비동기적으로 실행되는 경우 실제로 변수가 어떻게 변화하게 되는지 부정확해지는 일이 생기게 됩니다. 이런 문제는 <strong>두개의 프로세스가 동시에 같은 변수에 접근</strong> 하기 때문입니다.</p>
<p>여러 개의 프로세스가 동일한 자료를 접근하여 조작하고 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 <strong>경쟁 조건</strong> 이라고 합니다. 이를 해결하기 위해서는 한 순간에 하나의 프로세스만이 공유 변수를 조작하도록 보장해야 합니다.</p>
<h1><span id="임계영역-문제the-critical-section-problem">임계영역 문제(The Critical Section Problem)</span></h1><p>여러 개의 프로세스가 동작하는 처리기를 생각해 봅시다. 각 프로세스는 <strong>임계영역(Critical Section)</strong> 이라고 부르는 코드 부분을 가지고 있으며, 그 안에서는 다른 프로세스와 공유하는 변수를 변경하거나, 테이블을 갱신하거나 파일을 쓰거나 하는 등의 작업을 실행합니다. 각 프로세스는 자신의 임계영역으로 진입하려면 진입허가를 요청해야 한다. 이러한 요청을 구현하는 코드 부분을 <strong>진입 영역(entry section)</strong> 이라고 부르며 임계영역 뒤를 <strong>퇴출영역(exit section)</strong> 이 따라올 수 있고, 코드의 나머지 부분을 통틀어 <strong>나머지 영역</strong> 이라고 부릅니다.</p>
<p>이러한 임계영역 <strong>문제를 해결하기 위해</strong> 서는 다음의 <strong>세 가지 요구 조건</strong> 을 충족해야 합니다.</p>
<ol>
<li>상호 배제(mutual exclusion)<br>프로세스 P가 자신의 임계영역에서 실행되고 있다면, 다른 프로세스들은 그들 자신의 임계영역에서 실행될 수 없습니다.<br>즉, A라는 프로세스가 자신의 임계영역에서 실행되고 있다면, 프로세스 B는 자신의 임계영역에서 실행될 수 없습니다.</li>
<li>진행(Progress)<br>자신의 임계영역에서 실행 중인 프로세스가 없는 상태에서 자신의 임계영역으로 진입하려고 하는 프로세스가 있다면, <strong>나머지 영역에서 실행 중이지 않은 프로세스들만</strong> 임계영역으로 진입할 프로레스를 결정하는데 참여할 수 없으며, <strong>이 선택은 무한정 연기될 수 없습니다.</strong><br>가령, A, B, C 라는 프로세스가 모두 자신의 임계영역에서 실행되고 있지 않은데 프로세스 A가 자신의 임계영역으로 진입하려고 한다면, 반드시 A는 <strong>나머지 영역</strong> 에서 실행중이지 않아야 하며, <strong>유한한 시간 내에 임계영역으로 진입하고자 하는 프로세스를 선택해야 합니다.</strong></li>
<li>한정된 대기<br>프로세스가 자기의 임계영역에 진입하려는 요청을 한 뒤 그 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계영역에 진입할 수 있는 횟수에 제한이 있어야 합니다.<br>예를 들어, 프로세스 A, B, C 가 있을 때 프로세스 A가 자신의 임계영역으로 진입하려고 <strong>진입 영역</strong> 에서 요청을 한 뒤 실제로 임계영역에 진입하기 전까지는 프로세스 B, 프로세스 C 가 임계영역에서 무한히 많이 진입하도록 되어서는 안되고 몇번 진입 후에는 반드시 프로세스 A에게 진입 할 순차가 와서, 프로세스 A가 한정된 대기를 해야 합니다.</li>
</ol>
<p>운영체제에서 임계영역을 다룰 때는 두가지 상황을 고려해야 합니다.<br>바로, <strong>선점형 커널</strong> 인가 혹은 <strong>비선점형 커널</strong> 인가에 대한 문제입니다.</p>
<p><strong>선점형 커널</strong> 은 프로세스가 커널 모드에서 실행되는 동안 선점되는 것을 허용하며, <strong>비선점 커널</strong> 은 커널 모드에서 실행되는 프로세스의 선점을 허용하지 않고, 커널을 빠져나갈 때까지 또는 봉쇄될 때까지 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 실행됩니다.<br><strong>비선점형 커널</strong> 의 경우에는 커널 안에서 실행중인 프로세스가 명백하게 하나 밖에 없기 때문에 경쟁조건을 걱정하지 않아도 되지만, <strong>선점형 커널</strong> 의 경우는 그렇지 않기 때문에 경쟁 조건이 발생하지 않는 것을 보장할 수 없습니다.</p>
<p>특히, <strong>SMP(Symmetric Multi-Processing)</strong> 구조에서는 서로 다른 처리기의 두 프로세스가 동시에 커널 모드에 있을 수 있기 때문에, 선점형 커널을 설계하는 것은 특히 어렵습니다.</p>
<h1><span id="피터슨의-해결방안">피터슨의 해결방안</span></h1><p>이러한 <strong>임계영역 문제</strong> 에 대한 고전적인 소프트웨어 기반 해결책인 <strong>피터슨의 해결안</strong> 에 대해 알아봅시다.</p>
<p>피터슨의 해결안은 임계영역과 나머지 영역을 번갈아 가며 실행하는 두 개의 프로세스로 한정됩니다.<br>쉽게 말하면 두 개의 프로세스를 구현할 때 특정 변수를 인덱스 값으로 놓아 해당 변수가 <strong>임계영역</strong> 에 대한 접근의 승낙여부를 공유하는 것입니다.<br>이를 위해서 다음과 같이 두개의 데이터 항목을 공유합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int turn;</span><br><span class="line">boolean flag[2]; //프로세스가 임계영역으로 진입할 준비가 됨을 나타냅니다.</span><br></pre></td></tr></table></figure>
<p>위에서 <strong>turn 변수</strong> 는 임계영역으로 진입할 순번을 나타냅니다. 가령 turn이 i 이면 프로세스 i가 임계영역에서 실행되는 것을 나타냅니다.<br><strong>flag 변수</strong> 는 프로세스가 임계영역으로 집입할 준비가 되었다는 것을 나타냅니다. 가령 flag[i]가 true 라면 프로세스 i가 임계영역으로 들어갈 준비가 되었다는 것을 나타냅니다.</p>
<p>이렇게 동일한 변수를 공유하면 turn에 동시에 접근이 되더라도 하나의 값만을 나타내기 때문에 바로 다음에 접근한 값에 의해 덮어 씌워지게 되어 둘 중 하나의 값만이 될 것입니다.</p>
<p>위의 공유변수를 이용한 피터슨의 해결방안을 코드로 보이면 다음과 같습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">  flag[i] = TRUE;</span><br><span class="line">  turn = j;</span><br><span class="line">  while(flag[j] &amp;&amp; turn ==j)&#123;</span><br><span class="line">    임계영역 코드</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flag[i] = FALSE;</span><br><span class="line">  나머지 영역</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위 코드는 프로세스 i가 임계영역에 접근하고자 하는 코드입니다. 위에서 flag[i]를 true로 지정함으로써 프로세스 i가 임계영역에 진입하고자 하는 것을 나타냅니다. 하지만 프로세스 i는 임계영역에 진입하기에 앞서 프로세스 j에게 먼저 입계영역에 접근하고 싶으면 접근하도록 turn을 돌려 줍니다. 만약 flag[j] 가 true 즉, 프로세스 j가 임계영역에 진입하고자 했다면 먼저 진입할 수 있습니다.</p>
<h1><span id="동기화-하드웨어">동기화 하드웨어</span></h1><p>앞에서는 임계영역 문제에 대한 소프트웨어 기반의 해결책을 살펴보았다. 하지만 일반적으로 임계영역의 문제는 <strong>록(lock)</strong> 이라는 간단한 도구가 필요하다고 말할 수 있다. 경쟁 조건은 임계영역에서 록에 의해 보호함으로써 예방할 수 있습니다. 즉, 프로세스가 임계영역에 진입하기 전에 반드시 <strong>록</strong> 을 획득하도록 함으로써 임계영역 문제를 해결할 수 있습니다.</p>
<p>이를 간단히 코드로 표현하면 다음과 같습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">  록 획득</span><br><span class="line">    //임계영역</span><br><span class="line">  록 방출</span><br><span class="line">    //나머지 영역</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위처럼 임계영역에 진입하기 전에 <strong>록을 획득</strong> 하고 임계영역을 나오면서 <strong>록을 방출</strong> 하는 방식을 잘 보여주고 있습니다.</p>
<p>이러한 임계영역의 문제에 대한 해결은 단일처리기 환경 혹은 다중 처리기 환경이냐에 따라 간단하거나 복잡할 수 있습니다.<br>만약 <strong>단일 처리기 환경</strong> 이라면 임계영역 문제는 쉽게 해결될 것입니다. 공유 변수가 변경되는 동안에는 하나의 프로세스가 진행되는 것을 막는 <strong>인터럽트</strong> 의 발생을 허용하지 않는 것이지요. 이렇게 하면 공유 변수가 변경되는 동안에는 인터럽트가 발생하지 않고 해당 프로세스는 방행 없이 자신의 코드를 실행시킬 것 입니다.<br>반면, <strong>다중 처리기 환경</strong> 에서는 이것이 불가능 합니다. 다중 처리기에서 인터럽트를 막기 위해서는 모든 처리기에 인터럽트를 금지시키도록 해야 하는데 이것은 상당한 시간을 소비하기 때문이지요.</p>
<p>이러한 많은 이유들 때문에 현대의 많은 기계들은 한 워드의 내용을 검사하고 변경하거나 두 워드의 내용을 <strong>원자적으로 교환(swap)</strong> 할 수 있는, 즉 인터럽트 되지 않는 하나의 단위로서 특별한 하드웨어 명령어들을 제공합니다.</p>
<p>즉, swap을 통해 여러 처리기의 공유 변수를 원자적으로 변경시켜 <strong>록</strong> 을 획득하는 것 입니다.</p>
<h1><span id="세마포">세마포</span></h1><p>위에서 제시한 하드웨어 기반의 해결방법은 응용 프로그래머가 사용하기에는 매우 복잡하기에 이를 극복하기 위해 <strong>세마포</strong> 라고 하는 동기화 도구를 이용할 수 있습니다. 세마포 S는 정수 변수를 포함하며 초기화를 제외하고는 오직 두개의 표준 연산 acquire(), release() 로만 접근이 가능합니다.</p>
<p>이러한 세마포의 간단한 구현은 다음과 같습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">  while(value&lt;=0)&#123;</span><br><span class="line">    아무런 작업 하지 않음</span><br><span class="line">  &#125;</span><br><span class="line">  value--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">release()&#123;</span><br><span class="line">  value++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위 코드를 분석해 봅시다.<br>먼저 세마포는 임계 영역에 진입하기 위해 acquire() 를 호출합니다. 하지만 이 경우 누군가가 먼저 acquire를 호출하여 value의 값이 0보다 작다면 아무런 작업도 하지 않고 대기합니다. 그러다가 다른 세마포가 release()를 호출하여 value값을 증가시켜 주면 while 문에서 벗어나고 또 다른 acquire() 요청을 막기 위해 value를 줄여 줍니다.</p>
<p>하지만, 여기서는 치명적인 문제가 있습니다.<br>바로 while 문에서 value를 검사하면서 <strong>바쁜 대기(busy waiting)</strong> 을 하고 있는 것이죠. 한 프로세스가 임계영역에 있으면, 자신의 임계영역에 진입하려는 다른 프로세스는 진입 코드를 계속 반복 실행해야 합니다. 이러한 현상을 프로세스가 <strong>록</strong> 을 기다리면서 회전한다고 하여 spinlock이라고 부르기도 합니다.</p>
<p>어떻게 하면 이런 <strong>바쁜대기(busy waiting)</strong> 을 없앨 수 있을까요?<br>바로 바쁜 대기를 하는 대신에 자기 자신을 봉쇄시키는 방법이 있습니다. 봉쇄 연산은 프로세스를 세마포에 연관된 <strong>대기 큐</strong> 에 넣고, <strong>프로세스를 대기상태로 전환</strong> 합니다. 그 후에 제어가 CPU로 넘어가게 되고 추후 다른 프로세스가 release()연산을 실행하면 wakeup() 연산을 통해 재시작 됩니다. 이런 <strong>wakeup()</strong> 명령은 <strong>프로세스의 상태를 대기상태에서 준비완료 상태로 변경합니다.</strong> 그 뒤 wakeup 된 프로세스는 준비완료 큐에 넣어지게 됩니다.</p>
<p>이러한 block, wakeup 을 구현하기 위해 우리는 세마포를 한 개의 정수 value와 프로세스 리스트로 정의합니다. 프로세스를 기다려야 한다면 이 프로세스는 그 세마포의 프로세스 리스트에 추가됩니다. release() 연산은 프로세스 리스트에서 한 프로세스를 제거하여 그 프로세스를 깨워줍니다.</p>
<p>이를 구현한 코드는 다음과 같습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">  value--;</span><br><span class="line">  if(value&lt;0)&#123;</span><br><span class="line">    block();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">release()&#123;</span><br><span class="line">  value++;</span><br><span class="line">  if(value&lt;=0)&#123;</span><br><span class="line">    wakeup(P);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위 코드에서 block() 연산은 자기를 호출한 프로세스를 보류시키고, wakeup(P) 연산은 봉쇄된 프로세스 P의 실행을 재개시키며, 이들 두 연산은 운영체제의 기본적인 <strong>시스템 호출</strong> 로 제공됩니다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/13/학습의-방법/" itemprop="url">
                학습의 방법
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-13T06:34:20.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/학습법/">학습법</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                7 minutes read (About 1072 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#내가-배운-지식과-결합하여-새롭게-구조화-하라">내가 배운 지식과 결합하여 새롭게 구조화 하라</a></li>
<li><a href="#지식의-인출과정을-거쳐야-한다">지식의 인출과정을 거쳐야 한다.</a></li>
<li><a href="#데드라인을-설정하라">데드라인을 설정하라</a></li>
<li><a href="#예제를-풀거나-혹은-예를-들어-쉽게-설명해-보라">예제를 풀거나 혹은 예를 들어 쉽게 설명해 보라</a></li>
</ul>
<!-- tocstop -->
<p>인생의 배움의 연속이라 할 수 있다.<br>첨예한 비즈니스 세계에서 살아나가던지 혹은 엔지니어 로써 기술을 배우던지 어떤 업을 가진 사람이라도 매일 매일을 배움이 없이 살아간다면 언제든지 침몰 할 수 있으며, 그만큼 인생에서 배움이란 큰 역할을 차지한다.</p>
<p>본 글에서는 ‘학습’에 있어서의 몇가지 원칙을 제시하며 이를 통해 효과적인 학습을 할 수 있도록 하는 것에 그 목적이 있다.</p>
<h1><span id="내가-배운-지식과-결합하여-새롭게-구조화-하라">내가 배운 지식과 결합하여 새롭게 구조화 하라</span></h1><p>학습, 즉 새로운 것을 배울 때에는 내가 알고있는 개념들에 대한 구조화를 먼저 끝낸 뒤에 그 구조에서 사고를 심화시켜 지식을 확장해야 한다.</p>
<p>내가 아는것과 모르는 것이 무엇인지 또 내가 알고 있는 어떤 지식을 더 심화시키는 것인지를 명확히 이해해야 지식을 체계적이고 효과적으로 습득할 수 있다.</p>
<p>가령 로마사를 공부한다고 하자.<br>내가 로마에 대해 아는 것이 무엇이며 지금 학습하는 내용이 내가 알고 있는 부분들고 어떤 연관관계가 지어지는 지를 이해하는 것이 학습의 기초이다.</p>
<p>배움을 시작하기에 앞서 배우고자 하는 내용에 대해 내가 아는것이 무엇인지를 <strong>글 혹은 다이어 그램을 통해</strong> 체계적으로 구조화 시켜 보고 내가 배우고자 하는 내용이 여기서 어느 부분에 속하는 지를 아는 것이 학습의 첫 단추이다.</p>
<h1><span id="지식의-인출과정을-거쳐야-한다">지식의 인출과정을 거쳐야 한다.</span></h1><p>책을 보거나 혹은 강의를 듣는 등 수동적으로 지식을 두뇌에 주입하였다면 그 지식이 정말 나의 것이 되었는지 알 수 없다. 이 단계에서 계속해서 내용을 복습하는 것은 의미가 없다. 반드시 <strong>책을 덮고 혼자만의 시간을 가져 백지에 배운 내용을 스스로 떠올리고 지식을 머릿속에서 인출</strong> 하는 과정을 거쳐야 내가 아는것과 모르는 것을 정확히 알 수 있고, 또 <strong>더 오래 기억에 남게 된다.</strong></p>
<p>가능하다면 다른 사람에게 내가 배운 내용을 가르치거나 이를 다른사람에게 주기 위한 블로그 형태로 게재하는 것이 큰 도움이 될 수 있다.</p>
<p>반드시, 배운 내용을 아무 도움 없이 떠올려 보아야 한다.</p>
<p>만약 블로그를 작성한다면 먼저 대 목차를 쓴 뒤에 책이나 참고자료를 보지 않고 설명하듯이 작성해 본다.<br>이렇게 참고자료나 책을 보지 않고 머릿속에서 지식을 인출하는 과정이 매우 중요하다.</p>
<h1><span id="데드라인을-설정하라">데드라인을 설정하라</span></h1><p>공부의 시작과 끝에는 반드시 휴식시간을 두고 정해진 시간 내에 끝내도록 하여야 한다.<br>이를 통해 집중력을 올릴 수 있게 되고 특정 시간대에 특정 주제에 대해 완벽히 집중하여 번잡스러운 공부를 피할 수 있게 된다.</p>
<p>가령 새로운 정보를 습득할 때에는 공부 중에 모르는 내용이 나오게 되고 해당 부분을 선행한 뒤에 그 공부를 다시 시작하여야 할 필요가 생길때가 있을 것이다.<br>그런 경우는 선행되는 공부를 먼저 끝낸 뒤 다음 공부를 진행하여야 하는데 이것의 순서를 차곡차곡 쌓아두어야 순서에 맞추어 차근차근 효율적으로 공부를 진행할 수 있다.</p>
<h1><span id="예제를-풀거나-혹은-예를-들어-쉽게-설명해-보라">예제를 풀거나 혹은 예를 들어 쉽게 설명해 보라</span></h1><p>만약 어떤 개념을 글로만 배웠다면 이 지식을 절대 활용할 수 없다.<br>반드시 예제와 연습문제 혹은 예를 들어 설명해 봄으로써 익혀야 아는 것이 된다.</p>
<p># </p>
<hr>

                        
    </div>
    
            
</article>



        
    
        <article class="article content gallery" itemscope="" itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2018/04/13/운영체제-메인-메모리/" itemprop="url">
                운영체제 | 메인 메모리
            </a>
            
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-04-13T03:26:19.000Z" itemprop="datePublished">
                a year ago
            </time>
        </span>
        
            <span class="column is-narrow article-category">
                <i class="far fa-folder"></i>
                <a class="article-category-link" href="/categories/운영체제-강의/">운영체제 강의</a>
            </span>
            
                
                    <span class="column is-narrow">
                        
                            
                                32 minutes read (About 4770 words)
                    </span>
                    
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
                    <!-- toc -->
<ul>
<li><a href="#메모리의-기본-개념">메모리의 기본 개념</a><ul>
<li><a href="#기본적인-하드웨어-구조">기본적인 하드웨어 구조</a></li>
<li><a href="#논리-주소와-물리-주소">논리 주소와 물리 주소</a></li>
<li><a href="#동적-적재">동적 적재</a></li>
</ul>
</li>
<li><a href="#스와핑">스와핑</a></li>
<li><a href="#연속-메모리-할당">연속 메모리 할당</a><ul>
<li><a href="#단편화">단편화</a></li>
</ul>
</li>
<li><a href="#페이징">페이징</a></li>
<li><a href="#페이지-테이블의-다양한-구조">페이지 테이블의 다양한 구조</a><ul>
<li><a href="#계층적-페이징">계층적 페이징</a></li>
<li><a href="#해시된-페이지-테이블">해시된 페이지 테이블</a></li>
<li><a href="#역-페이지-테이블">역 페이지 테이블</a></li>
</ul>
</li>
<li><a href="#세그먼테이션">세그먼테이션</a></li>
</ul>
<!-- tocstop -->
<p>주 메모리에는 여러개의 프로세스가 적재되어 있고, 운영체제는 이러한 프로세스를 효율적으로 처리하기 위해 메모리를 효율적으로 관리해야할 필요가 생겼습니다. 이를 위해 두가지 알고리즘인 <strong>페이징과 세그먼트</strong> 를 다루겠습니다. 최근 디자인이 하드웨어와 운영체제를 밀접하게 통합하고 있지만 본 장에서 설명하는 알고리즘은 대부분 하드웨어 지원을 필요로 합니다.</p>
<h1><span id="메모리의-기본-개념">메모리의 기본 개념</span></h1><h2><span id="기본적인-하드웨어-구조">기본적인 하드웨어 구조</span></h2><p>메모리는 각각 주소가 할당된 일련의 워드 또는 바이트들로 구성되며 CPU는 PC(Program Counter)가 지시하는 대로 메모리로부터 다음 실행할 명령어를 가져오고, 필요한 경우 추가적인 데이터를 더 가져오거나 데이터를 메모리로 내보냅니다.</p>
<p><strong>전형적인 명령 실행은 먼저 메모리로부터 한 명령어를 가져오는 데서부터 시작되어,</strong> 그 다음 명령어를 해독하고 메모리에서 피연산자를 가져와 피연산자에 대해 명령어를 실행합니다.</p>
<p>CPU가 주 메모리에 접근하기 위해서는 많은 CPU 클록 틱 사이클이 소요되며, 이 때문에 CPU가 명령어를 실행하지 못하고 대기하는 시간이 길어집니다. 이러한 상호아은 주 메모리 접근이 빈번하게 일어나는 경우에는 큰 문제가 되며 이를 해결하기 위해 <strong>캐기</strong> 라고 부르는 메모리 버퍼를 사용합니다.</p>
<p>메모리에 많은 프로세스들이 적재되어 있는데 각각의 프로세스가 다른 프로세스가 사용하는 메모리 영역을 침범하면 큰 문제가 생길 것 입니다. 즉, 각각의 프로세스는 독립된 메모리 공간을 가지고 특정 프로세스만 접근할 수 있는 메모리 영역을 하드웨어 단에서 정해주어야 할 필요가 있습니다. 이 문제는 <strong>기준(base)과 상한(limit)이라고 불리는 두개의 레지스터들을 사용</strong> 하여 해결합니다. <strong>기준 레지스터</strong> 는 가장 작은 합법적인 물리 메모리 주소의 값을 저장하고, <strong>상한 레지스터</strong> 는 주어진 영역을 크기를 저장합니다. 이러한 <strong>기준과 상한 레지스터는 여러가지 특권 명령을 사용하는 운영체제에 의해서만 적재됩니다.</strong><br>하지만, <strong>커널 모드</strong> 에서 실행되는 운영체제는 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 어떠한 제한도 받지 않는다.</p>
<p>프로세스는 실행되기 위해 <strong>디스크에서 메모리로</strong> 이동되고, <strong>디스크에서 메모리로 들어오기를 기다리고 있는 프로세스</strong> 들은 <strong>입력 큐(input que)</strong> 를 형성합니다. 이 큐에서 하나의 프로세스를 선택하여 메모리로 적재한 후 실행합니다.</p>
<h2><span id="논리-주소와-물리-주소">논리 주소와 물리 주소</span></h2><p>CPU는 오로지 <strong>논리 주소</strong> 만을 사용하여 작동하는 반면 메모리가 취급하는 주소는 <strong>물리주소</strong> 입니다. 따라서 프로그램이 실행되기 위해서는 CPU가 다루는 <strong>논리주소가 물리주소로</strong> 변환이 되어야 하며 이것은 <strong>메모리 관리기(Memory Management Unit)</strong> 에 의해 처리됩니다.</p>
<p>이렇게 모든 논리주소와 물리주소 사이의 변환은 MMU에서 처리하며 CPU는 물리주소에 전혀 관심을 두지 않습니다. 즉, 사용자 프로그램은 실제적인 물리주소를 결코 알 수 없습니다.</p>
<h2><span id="동적-적재">동적 적재</span></h2><p>일반적으로 CPU가 프로세스를 실행하기 위해서는 프로세스 전체가 메모리에 적재되어야 했다. 하지만 <strong>동적 적재</strong> 는 프로세스의 부분만이 메모리에 적재해도 프로세스를 실행 할 수 있도록 해 준다. <strong>동적 적재에서 각 루틴은 실제로 호출되기 전까지는 메모리에 적재되지 않고 재배치 가능한 상태로 디스크에서 대기하고 있다.</strong> 이러한 동적 적재의 장점은 <strong>사용되지 않는 루틴들의 경우 절대로 미리 적재되지 않는다는 것이다.</strong></p>
<p>이러한 동적 적재는 <strong>공유 라이브러리</strong> 를 사용하는 데에 사용될 수 있으며, 주로 시스템 라이브러리에 사용된다. 만일 이 방식이 없다면 모든 프로그램들은 그들의 이진 프로그램 이미지 내에 시스템 라이브러리의 복사본 또는 적어도 참조되는 루틴의 복사본을 가지고 있어야 할 것이다. 하지만 이러한 동적 연결에서는 라이브러리를 호출하는 곳 마다 <strong>스텁(stub)</strong> 이 생기게 되고, 이 스텁은 메모리에 적재하는 라이브러리를 찾는 방법 또는 메모리에 없을 경우 라이브러리에 적재하는 방법을 알려주는 작은 코드 조각이다. <strong>스텁</strong> 은 필요한 라이브러리 루틴이 이미 메모리에 존재하는 지를 검사하고 없으면 루틴을 메모리로 적재한다.</p>
<p><strong>동적 연결</strong> 이 없었다면 새로운 라이브러리를 사용하기 위해 모든 프로그램이 새로 연결되어야 한다.</p>
<p>이러한 시스템을 <strong>공유 라이브러리</strong> 라 한다.</p>
<h1><span id="스와핑">스와핑</span></h1><p>프로세스가 메모리에서 실행되기 위해서는 메모리에 적재되어 있어야 하며 이렇게 디스크에서 메모리에 프로세스를 적재하는 것은 <strong>스와핑</strong> 이라고 한다. <strong>스와핑</strong> 은 반드시 보조 메모리가 필요하며 보통 디스크를 사용한다. CPU는 <strong>준비완료 큐</strong> 에서 프로세스를 가져와 CPU를 할당해 주며, CPU 스케줄러는 다음 프로세스를 고를 때 <strong>디스패처</strong> 를 호출한다. <strong>디스패처</strong> 는 이 큐에 있는 다음 프로세스가 메모리에 적재되어 있는지를 확인하여 없다면 디스크에서 불러들이도록 하여야 한다.</p>
<h1><span id="연속-메모리-할당">연속 메모리 할당</span></h1><p>주 메모리는 여러 사용자 프로세스를 수용해야 하며, 일반적인 메모리 할당방법 중의 하나인 <strong>연속 메모리 할당</strong> 에 대해 배워보도록 하겠습니다.<br>메모리는 일반적으로 두 개로 나누어집니다. 하나는 <strong>운영체제를 위한 것</strong> 이고 다른 하나는 <strong>사용자 프로세스를 위한 것</strong> 입니다. 운영체제는 메모리의 어느 쪽 끝에도 위치할 수 있으며, 이 결정에 영향을 미치는 중요한 요인은 인터럽트 벡터입니다.</p>
<p>보통 여러개의 프로세스가 메모리에 적재되어야 하며, <strong>입력 큐</strong> 에서 대기 중인 프로세스들에게 메모리를 어떻게 할당하는 것이 좋은가를 생각할 필요가 있습니다.<br>이번에 배울 <strong>연속 메모리 할당</strong> 에서는 프로세스는 연속된 메모리 공간을 차지하게 됩니다.</p>
<p>연속 메모리 할당에서는 여기 메모리 저기 산재해 있는 여러 크기의 자유 공간 중에서 적절한 것을 찾아 할당하게 됩니다. 만약 자유공간의 크기가 크면 두 개로 나누어 하나는 프로세스에게 할당하고 나머지 하나는 다시 자유공간으로 되돌려 줍니다. 만약 되돌려 준 자유공간이 주변의 공간과 인접해 있다면, 이 두개의 블록을 합쳐서 한개의 큰 자유 공간 블록으로 만들어 줍니다.</p>
<p>이러한 기법은 <strong>동적 메모리 할당 문제</strong> 은 특별한 예이며, 자유 공간 리스트로부터 크기 n-바이트 블록 요청을 어떻게 만족시켜 줄 수 있는지를 결정하는 문제입니다. 해결방안에는 크게 3가지 정도가 있는데, <strong>최초 적합</strong> 기법은 요청을 만족시키는 충분히 큰 첫 번째 가용공간을 할당해 주는 것이며, <strong>최적 적합</strong> 은 요청을 만족시키는 충분히 큰 공간들 중에서 제일 작은 자유 공간을 활도해 줍니다. <strong>최악 적합</strong> 은 가장 큰 가용 공간을 선택합니다.</p>
<h2><span id="단편화">단편화</span></h2><p>위의 예처럼 자유 공간을 임의의 조각으로 나누어 할당하는 방법은 두가지 형태의 <strong>단편화</strong> 를 만들어 냅니다. 단변화의 종류에는 <strong>내부 단편화</strong> 와 <strong>외부 단편화</strong> 가 있습니다. 먼저, <strong>외부 단편화</strong> 는 다음과 같이 설명할 수 있습니다. 가령 계속해서 자유 공간을 할당해 주다 보면 남은 자유공간들이 너무 작은 조각들로 여러 군대에 산재되어 있는 현상이 있을 수 있습니다. 이 모든 조각을 다 모으면 큰 자유공간이 되지만 너무 잘게 쪼게어져 있기 때문에 사용하지 못하는 공간이 되어 버립니다. 이를 해결하는 방법은 <strong>압출</strong> 을 하는 것입니다. <strong>압축</strong> 이란 이런 작은 자유 공간 조각들을 하나의 큰 조각으로 합치는 것으로 사이 사이의 프로세스가 차지하는 공간을 한쪽으로 몰아 재배치 하는 것입니다. 때문에 이 경우에는 <strong>프로세스내의 모든 주소들이 동적으로 재배치</strong> 되어야 하기 때문에 실행시간이 길어집니다. 다음으로는 <strong>내부 단편화</strong> 가 있습니다. 보통 자유 공간을 할당해 줄 때는 메모리가 분할된 크기의 정수 배로만 해주는 것이 보통이며 때문에 할당된 메모리 중 프로세스가 사용하지 않는 공간이 생길 수 있으며 이를 <strong>내부 단편화</strong> 라고 할 수 있습니다. 이러한 <strong>내부 단편화</strong> 를 줄이기 위해서는 할당해주는 메모리 조각을 최대한 작게 해 주는 것이 좋습니다.</p>
<p>이러한 다양한 단편화를 줄이기 위한 방법으로는 한 프로세스의 주소 공간을 여러 개의 동떨어진 공간으로 배정하는 것입니다. 그 대표적인 예로는 <strong>페이징과 세그먼테이션</strong> 이 있습니다.</p>
<h1><span id="페이징">페이징</span></h1><p>페이징의 기본적인 개념은 바로 논리주소 공간이 연속된 하나의 공간에 모두 모여 있어야 한다는 제약을 없애는 것입니다.</p>
<p><img src="\images\페이징의개념도.png" alt="페이징의 개념도"> </p>
<p>물리 메모리는 <strong>프레임</strong> 이라고 불리는 고정 크기의 블록으로 나누어져 있으며, 논리 메모리는 <strong>페이지</strong> 라고 불리는 고정 크기의 블록으로 나뉘어져 있습니다.<br>CPU 는 논리 메모리를 기준으로 프로그램을 처리하며 이러한 논리 주소는 <strong>페이징 하드웨어의 페이지 테이블</strong> 에 의해 물리 주소로 변환된다. 또, 모든 물리 주소는 핻아 논리 주소로 사상될 수 있다. CPU에서 나오는 모든 주소는 논리 주소로써 <strong>페이지 번호와 페이지 변위</strong> 두 개의 부분으로 나누어 진다. <strong>페이지 번호</strong> 는 <strong>페이지 테이블</strong> 에 접근할 때 사용되며, 해당 페이지 번호에 해당하는 주 메모리 내의 페이지의 기준 주소를 찾기 위해 사용되며, <strong>페이지 변위</strong> 는 해당 <strong>프레임 내에서의 변위</strong> 를 나타낸다. <strong>페이지 주소</strong> 에 <strong>페이지 변위</strong> 를 더하면 메모리 장치로 전송될 물리 주소가 된다.</p>
<p>프레임의 크기와 마찬가지로 <strong>페이지의 크기</strong> 도 하드웨어에 의해 결정된다. 만약 논리주소 공간의 크기가 2^n 이고 페이지의 크기가 2^m이면 논리 주소의 상위 m-n 비트는 페이지 번호를 나타내며, 하위 m 비트는 페이지 변위를 나타낸다.</p>
<p>페이징은 기본적으로 메모리를 정해진 페이지 사이즈로 잘라서 사용하기 때문에 <strong>외부 단편화가 발생하지 않는</strong> 대신 통산 페이지 사이즈의 반 정도의 <strong>내부 단편화</strong> 가 생기게 된다.</p>
<p>페이징의 가장 중요한 특징은 메모리에 대한 사용자가 생각하는 메모리와 실제 물리 메모리를 명확하게 분리한다는 사실이다. 그러나 실제로 프로그램은 물리 메모리 여러 곳에 프레임 단위로 산재되어 있고, 이 물리 메모리는 다양한 프로그램을 적재하고 있다. <strong>사용자가 생각하는 메모리와 실제 메모리의 차이는 주소 변환 하드웨어에 의해 가려진다.</strong></p>
<p>대부분의 운영체제는 프로세스마다 하나의 페이지 테이블을 할당합니다. 페이지 테이블을 가르키는 포인터는 다른 레지스터 값과 함께 <strong>프로세스 제어 블록(Process Control Block)</strong> 에 저장된다. 디스패처가 어떤 프로세스를 시작할 때 이 레지스터들을 다시 적재하면 페이지 테이블도 함께 사용할 수 있게 됩니다.</p>
<p>이러한 <strong>페이지 테이블</strong> 은 대부분의 경우 매우 크기 때문에 레지스터에 저장되지 못하고 <strong>주 메모리에</strong> 저장된 후 <strong>페이지 테이블 기준 레지스터(PTBR: Page Table Base Register)</strong> 로 하여금 페이지 테이블을 가르키도록 합니다. 하지만 이 경우에는 특정 정보에 접근하기 위해 두번의 메모리 접근이 필요합니다. 페이지 테이블에 접근하기 위해 한번 주 메모리에 접근하고, 얻은 주소를 통해 주 메모리에서 정보에 접근하기 위해 또 한번 접근하게 됩니다. 그래서 메모리 접근은 두 배로 느려 지며 이를 해결하기 위한 표준 방법으로 <strong>TLB(Translation Look-aside Buffers)</strong> 라고 불리는 특수한 소형 하드웨어 캐시가 사용됩니다. TLB의 각 항목은 <strong>키와 값</strong> 의 두 부분으로 구성됩니다. TLB에 페이지를 찾아달라는 요청이 들어오면 찾고자 하는 페이지를 동시에 모든 내부 키(페이지 번호)와 비교하여 해당하는 페이지 번호에 해당하는 프레임 번호를 알려줍니다. 하지만 이러한 TLB 하드웨어는 가격이 매우 비싸므로 <strong>페이지 테이블</strong> 의 일부분 밖에 들고있을 수가 없습니다. TLB에서 찾아진 페이지 번호와 프레임 번호는 TLB에 추가되어 다음 참조 시 매우 빠르게 처리할 수 있습니다. 이러한 페이지 번호는 수시로 교체되며 LRU 부터 무작위 교체까지 다양한 정책이 사용됩니다.</p>
<p>어떤 TLB는 각 항목에 <strong>ASID(Address Space IDentifiers)</strong> 를 저장하기도 하며, 이 ASID는 그 TLB 항목이 어느 프로세스에 속한 것인지를 알려주며, 이러한 ASID를 통해 TLB 안에 여러 프로세스들의 정보를 동시에 보관할 수 있게 됩니다. 여기서 페이지 번호가 TLB 에서 발견되는 확률을 <strong>적중률(hit ratio)</strong> 라고 합니다.</p>
<h1><span id="페이지-테이블의-다양한-구조">페이지 테이블의 다양한 구조</span></h1><p>각 프로세스가 필요한 페이지들은 매우 크므로 해당 프로세스의 페이지 테이블 또한 매우 커지게 됩니다. 이를 막기 위해 다양한 페이지 테이블 구조가 있는데 대표적인 테이블 구조인 <strong>계층적 페이징, 해시된 페이지 테이블, 역 페이지 테이블</strong> 에 대해 알아보겠습니다.</p>
<h2><span id="계층적-페이징">계층적 페이징</span></h2><p>계층적 페이징이란 페이지 테이블이 계층적으로 나타나는 것 입니다.<br>즉, 페이지 테이블이 두개로 나뉘어 하나의 페이지 테이블은 다음 페이지 테이블에 대한 포인터를 가지고 있게 됩니다. 이러한 계층적 페이지의 구조를 <strong>전방 사상 페이지 테이블(forward mapped page table)</strong> 이라고 합니다.</p>
<h2><span id="해시된-페이지-테이블">해시된 페이지 테이블</span></h2><p>페이지 테이블을 사이즈를 줄이기 위해서 <strong>해시된 페이지 테이블</strong> 이 도입될 수도 있습니다. 주소 공간이 32bit 보다 커지는 경우 가상 주소를 해시 값으로 사용하는 <strong>해시 페이지 테이블</strong> 을 많이 사용합니다.</p>
<h2><span id="역-페이지-테이블">역 페이지 테이블</span></h2><p>역 페이지 테이블은 일반 테이블 페이지 처럼 메모리 페이지 값에 대한 물리 페이지를 가지는 것이 아니라 특정, 물리 페이지에 대한 논리 페이지 값을 가지는 테이블 입니다. 이렇게 되면 시스템에는 <strong>단 하나의 페이지 테이블</strong> 만 존재하게 되며, 모든 물리 페이지는 특정 논리 페이지를 가르키게 됩니다. 이 경우에는 물리 프레임에 해당한느 항목만 테이블에 저장하면 되기 때문에 메모리에서 훨씬 작은 공간을 차지하게 되지만, 주소변환 시간은 더 오래 걸릴 수 있습니다.</p>
<h1><span id="세그먼테이션">세그먼테이션</span></h1><p>페이지 테이블의 가장 큰 문제는 사용자가 사용하는 메모리 공간과 실제 물리 메모리 공간이 분리되어 헷갈린 다는 점입니다.</p>
<p><strong>세그먼테이션</strong> 이란 이와 같이 메모리를 바라보는 사용자 관점을 그대로 반영합니다. 세그먼테이션에서 <strong>논리 구조 공간</strong> 은 세그먼트 들의 집합이며, 물리 메모리도 같은 원리로 세그먼테이션이 이루어집니다.</p>
<hr>

                        
    </div>
    
            
</article>



        
    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/page/10/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/page/12/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/">1</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/10/">10</a></li>
        
        <li><a class="pagination-link is-current" href="/page/11/">11</a></li>
        
        <li><a class="pagination-link" href="/page/12/">12</a></li>
        
        <li><span class="pagination-ellipsis">&hellip;</span></li>
        
        <li><a class="pagination-link" href="/page/23/">23</a></li>
        
    </ul>
</nav>
    
    </div>
</section>

            <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 Jake.Lee 이남훈&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" href="https://github.com/frontalnh">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
                <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        //plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110077250-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-110077250-2');
</script>


    


<script src="/js/script.js"></script>

                    
                        <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
                            
</body>

</html>